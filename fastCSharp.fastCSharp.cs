///本文件由程序自动生成,请不要自行修改
using System;
using fastCSharp;

namespace fastCSharp
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="values">数据指针</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为null</returns>
        private unsafe static long* IndexOf
            (long* valueFixed, int length, long value)
        {
            for (long* start = valueFixed, end = valueFixed + length; start != end; ++start)
            {
                if (*start == value) return start;
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this long[] array, long value)
        {
            if (array != null)
            {
                fixed (long* valueFixed = array)
                {
                    long* valueIndex = IndexOf(valueFixed, array.Length, value);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this long[] array, int index, int length, long value)
        {
            array.range range = new array.range(array.length(), index, length);
            if ((length = range.GetCount) != 0)
            {
                fixed (long* valueFixed = array)
                {
                    long* valueIndex = IndexOf(valueFixed + range.SkipCount, length, value);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        public static long[] getReverse(this long[] array)
        {
            return array.length() != 0 ? GetReverse(array, 0, array.Length) : array.notNull();
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        /// <returns>翻转后的新数组</returns>
        public static long[] getReverse(this long[] array, int index, int length)
        {
            array.range range = new array.range(array.length(), index, length);
            if (((range.SkipCount ^ index) | (range.GetCount ^ length)) == 0)
            {
                return GetReverse(array, index, length);
            }
            log.Default.Throw(log.exceptionType.IndexOutOfRange);
            return null;
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        /// <returns>翻转后的新数组</returns>
        private unsafe static long[] GetReverse(long[] array, int index, int length)
        {
            long[] newValues = new long[length];
            fixed (long* valueFixed = array, newValueFixed = newValues)
            {
                for (long* start = valueFixed + index, end = start + length, wirte = newValueFixed + length;
                    start != end; 
                    *--wirte = *start++) ;
            }
            return newValues;
        }
        /// <summary>
        /// 移除第一个匹配数据数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配值</param>
        /// <returns>移除数据后的数组</returns>
        public unsafe static long[] removeFirst
            (this long[] array, long value)
        {
            if (array != null)
            {
                int index = -1;
                fixed (long* valueFixed = array)
                {
                    long* valueIndex = IndexOf(valueFixed, array.Length, value);
                    if (valueIndex != null) index = (int)(valueIndex - valueFixed);
                }
                if (index != -1) return GetRemoveAt(array, index);
            }
            return nullValue<long>.Array;
        }
        /// <summary>
        /// 移动数据块
        /// </summary>
        /// <param name="array">待处理数组</param>
        /// <param name="index">原始数据位置</param>
        /// <param name="writeIndex">目标数据位置</param>
        /// <param name="count">移动数据数量</param>
        public unsafe static void move(this long[] array, int index, int writeIndex, int count)
        {
            if (count > 0)
            {
                int writeEndIndex = writeIndex + count;
                if (index >= 0 && writeEndIndex <= array.Length)
                {
                    int endIndex = index + count;
                    if (index < writeIndex && endIndex > writeIndex)
                    {
                        fixed (long* valueFixed = array)
                        {
                            for (long* write = valueFixed + writeEndIndex, end = valueFixed + endIndex, start = valueFixed + index;
                                end != start;
                                *--write = *--end) ;
                        }
                    }
                    else if (writeIndex >= 0 && endIndex <= array.Length) Array.Copy(array, index, array, writeIndex, count);
                    else log.Default.Throw(log.exceptionType.IndexOutOfRange);
                }
                else log.Default.Throw(log.exceptionType.IndexOutOfRange);
            }
            else if (count != 0) log.Default.Throw(log.exceptionType.IndexOutOfRange);
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="values">数组数据</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为null</returns>
        private unsafe static long* IndexOf
            (long* valueFixed, int length, func<long, bool> isValue)
        {
            for (long* start = valueFixed, end = valueFixed + length; start != end; ++start)
            {
                if (isValue(*start)) return start;
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this long[] array, func<long, bool> isValue)
        {
            if (array != null)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                fixed (long* valueFixed = array)
                {
                    long* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf
            (this long[] array, int index, int length, func<long, bool> isValue)
        {
            array.range range = new array.range(array.length(), index, length);
            if ((length = range.GetCount) != 0)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                fixed (long* valueFixed = array)
                {
                    long* valueIndex = IndexOf(valueFixed + range.SkipCount, length, isValue);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="index">起始位置</param>
        /// <returns>第一个匹配值,失败为default(long)</returns>
        public unsafe static long firstOrDefault
            (this long[] array, func<long, bool> isValue, int index)
        {
            if (array != null && (uint)index < (uint)array.Length)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                fixed (long* valueFixed = array)
                {
                    long* valueIndex = IndexOf(valueFixed + index, array.Length - index, isValue);
                    if (valueIndex != null) return *valueIndex;
                }
            }
            return default(long);
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public unsafe static int count
            (this long[] array, int index, int count, func<long, bool> isValue)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                int value = 0;
                fixed (long* valueFixed = array)
                {
                    for (long* start = valueFixed + index, end = start + count; start != end; ++start)
                    {
                        if (isValue(*start)) ++value;
                    }
                }
                return value;
            }
            return 0;
        }
        /// <summary>
        /// 移除第一个匹配数据数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>移除数据后的数组</returns>
        public unsafe static long[] removeFirst
            (this long[] array, func<long, bool> isValue)
        {
            if (array != null)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                int index = -1;
                fixed (long* valueFixed = array)
                {
                    long* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) index = (int)(valueIndex - valueFixed);
                }
                if (index != -1) return GetRemoveAt(array, index);
                return array;
            }
            return nullValue<long>.Array;
        }
        /// <summary>
        /// 替换数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">新值</param>
        /// <param name="isValue">数据匹配器</param>
        public unsafe static long[] replaceFirst
            (this long[] array, long value, func<long, bool> isValue)
        {
            if (array != null)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                fixed (long* valueFixed = array)
                {
                    long* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) *valueIndex = value;
                }
                return array;
            }
            return nullValue<long>.Array;
        }
        /// <summary>
        /// 转换键值对集合
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="array">键值数组</param>
        /// <param name="values">数据数组</param>
        /// <returns>键值对数组</returns>
        public unsafe static keyValue<long, valueType>[] getKeyValue<valueType>
            (this long[] array, valueType[] values)
        {
            int length = array.length();
            if (length != values.length()) log.Default.Throw(log.exceptionType.IndexOutOfRange);
            if (length != 0)
            {
                keyValue<long, valueType>[] newValues = new keyValue<long, valueType>[values.Length];
                fixed (long* valueFixed = array)
                {
                    long* readValue = valueFixed;
                    int index = 0;
                    foreach (valueType value in values)
                    {
                        newValues[index].Set(*readValue++, value);
                        ++index;
                    }
                }
                return newValues;
            }
            return nullValue<keyValue<long, valueType>>.Array;
        }
        /// <summary>
        /// 数据转换
        /// </summary>
        /// <typeparam name="valueType">数组类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public unsafe static long[] getArray<valueType>
            (this valueType[] array, func<valueType, long> getValue)
        {
            if (array.length() != 0)
            {
                if (getValue == null) log.Default.Throw(log.exceptionType.Null);
                long[] newValues = new long[array.Length];
                fixed (long* newValueFixed = newValues)
                {
                    long* writeValue = newValueFixed;
                    foreach (valueType value in array) *writeValue++ = getValue(value);
                }
                return newValues;
            }
            return nullValue<long>.Array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public unsafe static list<long> getFind
            (this long[] array, func<long, bool> isValue)
        {
            if (array.length() != 0)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                long[] newValues = new long[array.Length < sizeof(int) ? sizeof(int) : array.Length];
                fixed (long* newValueFixed = newValues, valueFixed = array)
                {
                    long* write = newValueFixed;
                    for (long* start = valueFixed, end = valueFixed + array.Length; start != end; ++start)
                    {
                        if (isValue(*start)) *write++ = *start;
                    }
                    return new list<long>(newValues, 0, (int)(write - newValueFixed), true);
                }
            }
            return null;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public unsafe static list<long> getFind
            (this long[] array, int index, int count, func<long, bool> isValue)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                long[] newValues = new long[count < sizeof(int) ? sizeof(int) : count];
                fixed (long* newValueFixed = newValues, valueFixed = array)
                {
                    long* write = newValueFixed;
                    for (long* start = valueFixed + index, end = start + count; start != end; ++start)
                    {
                        if (isValue(*start)) *write++ = *start;
                    }
                    return new list<long>(newValues, 0, (int)(write - newValueFixed), true);
                }
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public unsafe static long[] getFindArray
            (this long[] array, func<long, bool> isValue)
        {
            if (isValue == null) log.Default.Throw(log.exceptionType.Null);
            int length = array.length();
            if (length != 0)
            {
                length = (length + 7) >> 3;
                if (length <= config.pub.Default.StreamBufferLength)
                {
                    byte* data = stackalloc byte[length];
                    return GetFindArray(array, 0, array.Length, isValue, new fixedMap(data, length));
                }
                else
                {
                    byte[] data = new byte[length];
                    fixed (byte* dataFixed = data) return GetFindArray(array, 0, array.Length, isValue, new fixedMap(dataFixed));
                }
            }
            return nullValue<long>.Array;
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public unsafe static long[] getFindArray
            (this long[] array, int index, int count, func<long, bool> isValue)
        {
            if (isValue == null) log.Default.Throw(log.exceptionType.Null);
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                int length = (count + 7) >> 3;
                if (length <= config.pub.Default.StreamBufferLength)
                {
                    byte* data = stackalloc byte[length];
                    return GetFindArray(array, range.SkipCount, count, isValue, new fixedMap(data, length));
                }
                else
                {
                    byte[] data = new byte[length];
                    fixed (byte* dataFixed = data) return GetFindArray(array, range.SkipCount, count, isValue, new fixedMap(dataFixed));
                }
            }
            return nullValue<long>.Array;
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="map">匹配结果位图</param>
        /// <returns>匹配数组</returns>
        private unsafe static long[] GetFindArray
            (long[] array, int index, int count, func<long, bool> isValue, fixedMap map)
        {
            int length = 0, mapIndex = 0;
            fixed (long* valueFixed = array)
            {
                long* startFixed = valueFixed + index, end = startFixed + count;
                for (long* start = startFixed; start != end; ++start, ++mapIndex)
                {
                    if (isValue(*start))
                    {
                        ++length;
                        map.Set(mapIndex);
                    }
                }
                if (length != 0)
                {
                    long[] newValues = new long[length];
                    fixed (long* newValueFixed = newValues)
                    {
                        long* write = newValueFixed + length;
                        while (mapIndex != 0)
                        {
                            if (map.Get(--mapIndex)) *--write = startFixed[mapIndex];
                        }
                    }
                    return newValues;
                }
            }
            return nullValue<long>.Array;
        }
        /// <summary>
        /// 取子集合
        /// </summary>
        /// <typeparam name="valueType">目标数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">数据数量</param>
        /// <param name="getVlaue">目标数据获取器</param>
        /// <returns>子集合</returns>
        public unsafe static valueType[] getSub<valueType>
            (this long[] array, int index, int count, func<long, valueType> getVlaue)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                if (getVlaue == null) log.Default.Throw(log.exceptionType.Null);
                valueType[] newValues = new valueType[count];
                fixed (long* valueFixed = array)
                {
                    long* read = valueFixed + range.SkipCount;
                    for (index = 0; index != count; ++index) newValues[index] = getVlaue(*read++);
                }
                return newValues;
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 取子集合
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">数据数量</param>
        /// <param name="getVlaue">数据获取器</param>
        /// <returns>子集合</returns>
        public unsafe static long[] getSub<valueType>
            (this valueType[] array, int index, int count, func<valueType, long> getValue)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                if (getValue == null) log.Default.Throw(log.exceptionType.Null);
                long[] newValues = new long[count];
                fixed (long* newValueFixed = newValues)
                {
                    long* write = newValueFixed;
                    for (index = range.SkipCount, count = range.EndIndex; index != count; ++index) *write++ = getValue(array[index]);
                }
                return newValues;
            }
            return nullValue<long>.Array;
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        public unsafe static list<valueType> distinct<valueType>
            (this long[] array, int index, int count, func<long, valueType> getValue)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                if (getValue == null) log.Default.Throw(log.exceptionType.Null);
                list<valueType>.unsafer newValues = new list<valueType>(count).Unsafer;
                System.Collections.Generic.HashSet<long> hash
                    = new System.Collections.Generic.HashSet<long>();
                fixed (long* valueFixed = array)
                {
                    for (long* start = valueFixed + range.SkipCount, end = start + count; start != end; ++start)
                    {
                        if (!hash.Contains(*start))
                        {
                            newValues.Add(getValue(*start));
                            hash.Add(*start);
                        }
                    }
                }
                return newValues.List;
            }
            return null;
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        public unsafe static list<long> distinct<valueType>
            (this valueType[] array, func<valueType, long> getValue)
        {
            if (array != null)
            {
                if (getValue == null) log.Default.Throw(log.exceptionType.Null);
                long[] newValues = new long[array.Length];
                System.Collections.Generic.HashSet<valueType> hash = new System.Collections.Generic.HashSet<valueType>();
                fixed (long* newValueFixed = newValues)
                {
                    long* write = newValueFixed;
                    foreach (valueType value in array)
                    {
                        if (!hash.Contains(value))
                        {
                            *write++ = getValue(value);
                            hash.Add(value);
                        }
                    }
                    return new list<long>(newValues, 0, (int)(write - newValueFixed), true);
                }
            }
            return null;
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        public unsafe static list<long> distinct<valueType>
            (this valueType[] array, int index, int count, func<valueType, long> getValue)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                if (getValue == null) log.Default.Throw(log.exceptionType.Null);
                long[] newValues = new long[count];
                System.Collections.Generic.HashSet<valueType> hash = new System.Collections.Generic.HashSet<valueType>();
                valueType value;
                fixed (long* newValueFixed = newValues)
                {
                    long* write = newValueFixed;
                    for (index = range.SkipCount, count = range.EndIndex; index != count; ++index)
                    {
                        if (!hash.Contains(value = array[index]))
                        {
                            *write++ = getValue(value);
                            hash.Add(value);
                        }
                    }
                    return new list<long>(newValues, 0, (int)(write - newValueFixed), true);
                }
            }
            return null;
        }
        /// <summary>
        /// 求交集
        /// </summary>
        /// <param name="left">左侧数据</param>
        /// <param name="right">右侧数据</param>
        /// <returns>数据交集</returns>
        public unsafe static list<long> intersect(this long[] left, long[] right)
        {
            int leftLength = left.length();
            if (leftLength != 0)
            {
                int rightLength = right.length();
                if (rightLength != 0)
                {
                    long[] min = leftLength <= rightLength ? left : right, values = new long[min.Length];
                    fixed (long* valueFixed = values)
                    {
                        long* write = valueFixed;
                        staticHashSet<long> hash = new staticHashSet<long>(min);
                        foreach (long value in leftLength <= rightLength ? right : left)
                        {
                            if (hash.Contains(value)) *write++ = value;
                        }
                        return new list<long>(values, 0, (int)(write - valueFixed), true);
                    }
                }
            }
            return null;
        }
        /// <summary>
        /// 遍历foreach
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">遍历数据数量</param>
        /// <param name="method">调用函数</param>
        /// <returns>数据数组</returns>
        public unsafe static long[] each
            (this long[] array, int index, int count, action<long> method)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                if (method == null) log.Default.Throw(log.exceptionType.Null);
                fixed (long* valueFixed = array)
                {
                    for (long* start = valueFixed + index, end = start + count; start != end; method(*start++)) ;
                }
                return array;
            }
            return nullValue<long>.Array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public unsafe static bool max(this long[] array, out long value)
        {
            if (array.length() != 0)
            {
                fixed (long* valueFixed = array)
                {
                    value = *valueFixed;
                    for (long* start = valueFixed + 1, end = valueFixed + array.Length; start != end; ++start)
                    {
                        if (*start > value) value = *start;
                    }
                    return true;
                }
            }
            value = long.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public unsafe static long max(this long[] array, long nullValue)
        {
            long value;
            return max(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public unsafe static bool max(this long[] array, int index, int count, out long value)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                fixed (long* valueFixed = array)
                {
                    long* start = valueFixed + range.SkipCount;
                    value = *start;
                    for (long* end = start + count; ++start != end; )
                    {
                        if (*start > value) value = *start;
                    }
                    return true;
                }
            }
            value = long.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public unsafe static long max
            (this long[] array, int index, int count, long nullValue)
        {
            long value;
            return max(array, index, count, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>
            (this valueType[] array, func<valueType, long> getKey, out long value)
        {
            if (array.length() != 0)
            {
                value = getKey(array[0]);
                foreach (valueType nextValue in array)
                {
                    long nextKey = getKey(nextValue);
                    if (nextKey > value) value = nextKey;
                }
                return true;
            }
            value = long.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static long maxKey<valueType>
            (this valueType[] array, func<valueType, long> getKey, long nullValue)
        {
            long value;
            return maxKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>
            (this valueType[] array, int index, int count, func<valueType, long> getKey
            , out long value)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                value = getKey(array[index = range.SkipCount]);
                for (int endIndex = index + count; ++index != endIndex; )
                {
                    long nextValue = getKey(array[index]);
                    if (nextValue > value) value = nextValue;
                }
                return true;
            }
            value = long.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static long maxKey<valueType>
            (this valueType[] array, int index, int count, func<valueType, long> getKey
            , long nullValue)
        {
            long value;
            return maxKey(array, index, count, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>
            (this valueType[] array, func<valueType, long> getKey, out valueType value)
        {
            if (array.length() != 0)
            {
                value = array[0];
                long maxKey = getKey(value);
                foreach (valueType nextValue in array)
                {
                    long nextKey = getKey(nextValue);
                    if (nextKey > maxKey)
                    {
                        maxKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static valueType max<valueType>(this valueType[] array, func<valueType, long> getKey, valueType nullValue)
        {
            valueType value;
            return max(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>
            (this valueType[] array, int index, int count, func<valueType, long> getKey, out valueType value)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                value = array[index = range.SkipCount];
                long maxValue = getKey(value);
                for (int endIndex = index + count; ++index != endIndex; )
                {
                    long nextValue = getKey(array[index]);
                    if (nextValue > maxValue)
                    {
                        maxValue = nextValue;
                        value = array[index];
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static valueType max<valueType>
            (this valueType[] array, int index, int count, func<valueType, long> getKey, valueType nullValue)
        {
            valueType value;
            return max(array, index, count, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public unsafe static bool min(this long[] array, out long value)
        {
            if (array.length() != 0)
            {
                fixed (long* valueFixed = array)
                {
                    value = *valueFixed;
                    for (long* start = valueFixed + 1, end = valueFixed + array.Length; start != end; ++start)
                    {
                        if (*start < value) value = *start;
                    }
                    return true;
                }
            }
            value = long.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public unsafe static long min(this long[] array, long nullValue)
        {
            long value;
            return min(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public unsafe static bool min(this long[] array, int index, int count, out long value)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                fixed (long* valueFixed = array)
                {
                    long* start = valueFixed + range.SkipCount;
                    value = *start;
                    for (long* end = start + count; ++start != end; )
                    {
                        if (*start < value) value = *start;
                    }
                    return true;
                }
            }
            value = long.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public unsafe static long min
            (this long[] array, int index, int count, long nullValue)
        {
            long value;
            return min(array, index, count, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>
            (this valueType[] array, func<valueType, long> getKey, out long value)
        {
            if (array.length() != 0)
            {
                value = getKey(array[0]);
                foreach (valueType nextValue in array)
                {
                    long nextKey = getKey(nextValue);
                    if (nextKey < value) value = nextKey;
                }
                return true;
            }
            value = long.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static long minKey<valueType>
            (this valueType[] array, func<valueType, long> getKey, long nullValue)
        {
            long value;
            return minKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>
            (this valueType[] array, int index, int count, func<valueType, long> getKey
            , out long value)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                value = getKey(array[index = range.SkipCount]);
                for (int endIndex = index + count; ++index != endIndex; )
                {
                    long nextValue = getKey(array[index]);
                    if (nextValue < value) value = nextValue;
                }
                return true;
            }
            value = long.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static long minKey<valueType>
            (this valueType[] array, int index, int count, func<valueType, long> getKey
            , long nullValue)
        {
            long value;
            return minKey(array, index, count, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>(this valueType[] array, func<valueType, long> getKey, out valueType value)
        {
            if (array.length() != 0)
            {
                value = array[0];
                long minKey = getKey(value);
                foreach (valueType nextValue in array)
                {
                    long nextKey = getKey(nextValue);
                    if (nextKey < minKey)
                    {
                        minKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static valueType min<valueType>(this valueType[] array, func<valueType, long> getKey, valueType nullValue)
        {
            valueType value;
            return min(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>
            (this valueType[] array, int index, int count, func<valueType, long> getKey, out valueType value)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                value = array[index = range.SkipCount];
                long minValue = getKey(value);
                for (int endIndex = index + count; ++index != endIndex; )
                {
                    long nextValue = getKey(array[index]);
                    if (nextValue < minValue)
                    {
                        minValue = nextValue;
                        value = array[index];
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static valueType min<valueType>
            (this valueType[] array, int index, int count, func<valueType, long> getKey, valueType nullValue)
        {
            valueType value;
            return min(array, index, count, getKey, out value) ? value : nullValue;
        }
    }
}

namespace fastCSharp.unsafer
{
    /// <summary>
    /// 数组非安全扩展操作(请自行确保数据可靠性)
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 移动数据块
        /// </summary>
        /// <param name="array">待处理数组</param>
        /// <param name="index">原始数据位置</param>
        /// <param name="writeIndex">目标数据位置</param>
        /// <param name="count">移动数据数量</param>
        public unsafe static void Move(long[] array, int index, int writeIndex, int count)
        {
            int endIndex = index + count;
            if (index < writeIndex && endIndex > writeIndex)
            {
                fixed (long* valueFixed = array)
                {
                    for (long* write = valueFixed + writeIndex + count, start = valueFixed + index, end = valueFixed + endIndex;
                        end != start;
                        *--write = *--end) ;
                }
            }
            else Array.Copy(array, index, array, writeIndex, count);
        }
    }
}
namespace fastCSharp
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="values">数据指针</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为null</returns>
        private unsafe static uint* IndexOf
            (uint* valueFixed, int length, uint value)
        {
            for (uint* start = valueFixed, end = valueFixed + length; start != end; ++start)
            {
                if (*start == value) return start;
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this uint[] array, uint value)
        {
            if (array != null)
            {
                fixed (uint* valueFixed = array)
                {
                    uint* valueIndex = IndexOf(valueFixed, array.Length, value);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this uint[] array, int index, int length, uint value)
        {
            array.range range = new array.range(array.length(), index, length);
            if ((length = range.GetCount) != 0)
            {
                fixed (uint* valueFixed = array)
                {
                    uint* valueIndex = IndexOf(valueFixed + range.SkipCount, length, value);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        public static uint[] getReverse(this uint[] array)
        {
            return array.length() != 0 ? GetReverse(array, 0, array.Length) : array.notNull();
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        /// <returns>翻转后的新数组</returns>
        public static uint[] getReverse(this uint[] array, int index, int length)
        {
            array.range range = new array.range(array.length(), index, length);
            if (((range.SkipCount ^ index) | (range.GetCount ^ length)) == 0)
            {
                return GetReverse(array, index, length);
            }
            log.Default.Throw(log.exceptionType.IndexOutOfRange);
            return null;
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        /// <returns>翻转后的新数组</returns>
        private unsafe static uint[] GetReverse(uint[] array, int index, int length)
        {
            uint[] newValues = new uint[length];
            fixed (uint* valueFixed = array, newValueFixed = newValues)
            {
                for (uint* start = valueFixed + index, end = start + length, wirte = newValueFixed + length;
                    start != end; 
                    *--wirte = *start++) ;
            }
            return newValues;
        }
        /// <summary>
        /// 移除第一个匹配数据数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配值</param>
        /// <returns>移除数据后的数组</returns>
        public unsafe static uint[] removeFirst
            (this uint[] array, uint value)
        {
            if (array != null)
            {
                int index = -1;
                fixed (uint* valueFixed = array)
                {
                    uint* valueIndex = IndexOf(valueFixed, array.Length, value);
                    if (valueIndex != null) index = (int)(valueIndex - valueFixed);
                }
                if (index != -1) return GetRemoveAt(array, index);
            }
            return nullValue<uint>.Array;
        }
        /// <summary>
        /// 移动数据块
        /// </summary>
        /// <param name="array">待处理数组</param>
        /// <param name="index">原始数据位置</param>
        /// <param name="writeIndex">目标数据位置</param>
        /// <param name="count">移动数据数量</param>
        public unsafe static void move(this uint[] array, int index, int writeIndex, int count)
        {
            if (count > 0)
            {
                int writeEndIndex = writeIndex + count;
                if (index >= 0 && writeEndIndex <= array.Length)
                {
                    int endIndex = index + count;
                    if (index < writeIndex && endIndex > writeIndex)
                    {
                        fixed (uint* valueFixed = array)
                        {
                            for (uint* write = valueFixed + writeEndIndex, end = valueFixed + endIndex, start = valueFixed + index;
                                end != start;
                                *--write = *--end) ;
                        }
                    }
                    else if (writeIndex >= 0 && endIndex <= array.Length) Array.Copy(array, index, array, writeIndex, count);
                    else log.Default.Throw(log.exceptionType.IndexOutOfRange);
                }
                else log.Default.Throw(log.exceptionType.IndexOutOfRange);
            }
            else if (count != 0) log.Default.Throw(log.exceptionType.IndexOutOfRange);
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="values">数组数据</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为null</returns>
        private unsafe static uint* IndexOf
            (uint* valueFixed, int length, func<uint, bool> isValue)
        {
            for (uint* start = valueFixed, end = valueFixed + length; start != end; ++start)
            {
                if (isValue(*start)) return start;
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this uint[] array, func<uint, bool> isValue)
        {
            if (array != null)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                fixed (uint* valueFixed = array)
                {
                    uint* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf
            (this uint[] array, int index, int length, func<uint, bool> isValue)
        {
            array.range range = new array.range(array.length(), index, length);
            if ((length = range.GetCount) != 0)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                fixed (uint* valueFixed = array)
                {
                    uint* valueIndex = IndexOf(valueFixed + range.SkipCount, length, isValue);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="index">起始位置</param>
        /// <returns>第一个匹配值,失败为default(uint)</returns>
        public unsafe static uint firstOrDefault
            (this uint[] array, func<uint, bool> isValue, int index)
        {
            if (array != null && (uint)index < (uint)array.Length)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                fixed (uint* valueFixed = array)
                {
                    uint* valueIndex = IndexOf(valueFixed + index, array.Length - index, isValue);
                    if (valueIndex != null) return *valueIndex;
                }
            }
            return default(uint);
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public unsafe static int count
            (this uint[] array, int index, int count, func<uint, bool> isValue)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                int value = 0;
                fixed (uint* valueFixed = array)
                {
                    for (uint* start = valueFixed + index, end = start + count; start != end; ++start)
                    {
                        if (isValue(*start)) ++value;
                    }
                }
                return value;
            }
            return 0;
        }
        /// <summary>
        /// 移除第一个匹配数据数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>移除数据后的数组</returns>
        public unsafe static uint[] removeFirst
            (this uint[] array, func<uint, bool> isValue)
        {
            if (array != null)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                int index = -1;
                fixed (uint* valueFixed = array)
                {
                    uint* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) index = (int)(valueIndex - valueFixed);
                }
                if (index != -1) return GetRemoveAt(array, index);
                return array;
            }
            return nullValue<uint>.Array;
        }
        /// <summary>
        /// 替换数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">新值</param>
        /// <param name="isValue">数据匹配器</param>
        public unsafe static uint[] replaceFirst
            (this uint[] array, uint value, func<uint, bool> isValue)
        {
            if (array != null)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                fixed (uint* valueFixed = array)
                {
                    uint* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) *valueIndex = value;
                }
                return array;
            }
            return nullValue<uint>.Array;
        }
        /// <summary>
        /// 转换键值对集合
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="array">键值数组</param>
        /// <param name="values">数据数组</param>
        /// <returns>键值对数组</returns>
        public unsafe static keyValue<uint, valueType>[] getKeyValue<valueType>
            (this uint[] array, valueType[] values)
        {
            int length = array.length();
            if (length != values.length()) log.Default.Throw(log.exceptionType.IndexOutOfRange);
            if (length != 0)
            {
                keyValue<uint, valueType>[] newValues = new keyValue<uint, valueType>[values.Length];
                fixed (uint* valueFixed = array)
                {
                    uint* readValue = valueFixed;
                    int index = 0;
                    foreach (valueType value in values)
                    {
                        newValues[index].Set(*readValue++, value);
                        ++index;
                    }
                }
                return newValues;
            }
            return nullValue<keyValue<uint, valueType>>.Array;
        }
        /// <summary>
        /// 数据转换
        /// </summary>
        /// <typeparam name="valueType">数组类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public unsafe static uint[] getArray<valueType>
            (this valueType[] array, func<valueType, uint> getValue)
        {
            if (array.length() != 0)
            {
                if (getValue == null) log.Default.Throw(log.exceptionType.Null);
                uint[] newValues = new uint[array.Length];
                fixed (uint* newValueFixed = newValues)
                {
                    uint* writeValue = newValueFixed;
                    foreach (valueType value in array) *writeValue++ = getValue(value);
                }
                return newValues;
            }
            return nullValue<uint>.Array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public unsafe static list<uint> getFind
            (this uint[] array, func<uint, bool> isValue)
        {
            if (array.length() != 0)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                uint[] newValues = new uint[array.Length < sizeof(int) ? sizeof(int) : array.Length];
                fixed (uint* newValueFixed = newValues, valueFixed = array)
                {
                    uint* write = newValueFixed;
                    for (uint* start = valueFixed, end = valueFixed + array.Length; start != end; ++start)
                    {
                        if (isValue(*start)) *write++ = *start;
                    }
                    return new list<uint>(newValues, 0, (int)(write - newValueFixed), true);
                }
            }
            return null;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public unsafe static list<uint> getFind
            (this uint[] array, int index, int count, func<uint, bool> isValue)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                uint[] newValues = new uint[count < sizeof(int) ? sizeof(int) : count];
                fixed (uint* newValueFixed = newValues, valueFixed = array)
                {
                    uint* write = newValueFixed;
                    for (uint* start = valueFixed + index, end = start + count; start != end; ++start)
                    {
                        if (isValue(*start)) *write++ = *start;
                    }
                    return new list<uint>(newValues, 0, (int)(write - newValueFixed), true);
                }
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public unsafe static uint[] getFindArray
            (this uint[] array, func<uint, bool> isValue)
        {
            if (isValue == null) log.Default.Throw(log.exceptionType.Null);
            int length = array.length();
            if (length != 0)
            {
                length = (length + 7) >> 3;
                if (length <= config.pub.Default.StreamBufferLength)
                {
                    byte* data = stackalloc byte[length];
                    return GetFindArray(array, 0, array.Length, isValue, new fixedMap(data, length));
                }
                else
                {
                    byte[] data = new byte[length];
                    fixed (byte* dataFixed = data) return GetFindArray(array, 0, array.Length, isValue, new fixedMap(dataFixed));
                }
            }
            return nullValue<uint>.Array;
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public unsafe static uint[] getFindArray
            (this uint[] array, int index, int count, func<uint, bool> isValue)
        {
            if (isValue == null) log.Default.Throw(log.exceptionType.Null);
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                int length = (count + 7) >> 3;
                if (length <= config.pub.Default.StreamBufferLength)
                {
                    byte* data = stackalloc byte[length];
                    return GetFindArray(array, range.SkipCount, count, isValue, new fixedMap(data, length));
                }
                else
                {
                    byte[] data = new byte[length];
                    fixed (byte* dataFixed = data) return GetFindArray(array, range.SkipCount, count, isValue, new fixedMap(dataFixed));
                }
            }
            return nullValue<uint>.Array;
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="map">匹配结果位图</param>
        /// <returns>匹配数组</returns>
        private unsafe static uint[] GetFindArray
            (uint[] array, int index, int count, func<uint, bool> isValue, fixedMap map)
        {
            int length = 0, mapIndex = 0;
            fixed (uint* valueFixed = array)
            {
                uint* startFixed = valueFixed + index, end = startFixed + count;
                for (uint* start = startFixed; start != end; ++start, ++mapIndex)
                {
                    if (isValue(*start))
                    {
                        ++length;
                        map.Set(mapIndex);
                    }
                }
                if (length != 0)
                {
                    uint[] newValues = new uint[length];
                    fixed (uint* newValueFixed = newValues)
                    {
                        uint* write = newValueFixed + length;
                        while (mapIndex != 0)
                        {
                            if (map.Get(--mapIndex)) *--write = startFixed[mapIndex];
                        }
                    }
                    return newValues;
                }
            }
            return nullValue<uint>.Array;
        }
        /// <summary>
        /// 取子集合
        /// </summary>
        /// <typeparam name="valueType">目标数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">数据数量</param>
        /// <param name="getVlaue">目标数据获取器</param>
        /// <returns>子集合</returns>
        public unsafe static valueType[] getSub<valueType>
            (this uint[] array, int index, int count, func<uint, valueType> getVlaue)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                if (getVlaue == null) log.Default.Throw(log.exceptionType.Null);
                valueType[] newValues = new valueType[count];
                fixed (uint* valueFixed = array)
                {
                    uint* read = valueFixed + range.SkipCount;
                    for (index = 0; index != count; ++index) newValues[index] = getVlaue(*read++);
                }
                return newValues;
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 取子集合
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">数据数量</param>
        /// <param name="getVlaue">数据获取器</param>
        /// <returns>子集合</returns>
        public unsafe static uint[] getSub<valueType>
            (this valueType[] array, int index, int count, func<valueType, uint> getValue)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                if (getValue == null) log.Default.Throw(log.exceptionType.Null);
                uint[] newValues = new uint[count];
                fixed (uint* newValueFixed = newValues)
                {
                    uint* write = newValueFixed;
                    for (index = range.SkipCount, count = range.EndIndex; index != count; ++index) *write++ = getValue(array[index]);
                }
                return newValues;
            }
            return nullValue<uint>.Array;
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        public unsafe static list<valueType> distinct<valueType>
            (this uint[] array, int index, int count, func<uint, valueType> getValue)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                if (getValue == null) log.Default.Throw(log.exceptionType.Null);
                list<valueType>.unsafer newValues = new list<valueType>(count).Unsafer;
                System.Collections.Generic.HashSet<uint> hash
                    = new System.Collections.Generic.HashSet<uint>();
                fixed (uint* valueFixed = array)
                {
                    for (uint* start = valueFixed + range.SkipCount, end = start + count; start != end; ++start)
                    {
                        if (!hash.Contains(*start))
                        {
                            newValues.Add(getValue(*start));
                            hash.Add(*start);
                        }
                    }
                }
                return newValues.List;
            }
            return null;
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        public unsafe static list<uint> distinct<valueType>
            (this valueType[] array, func<valueType, uint> getValue)
        {
            if (array != null)
            {
                if (getValue == null) log.Default.Throw(log.exceptionType.Null);
                uint[] newValues = new uint[array.Length];
                System.Collections.Generic.HashSet<valueType> hash = new System.Collections.Generic.HashSet<valueType>();
                fixed (uint* newValueFixed = newValues)
                {
                    uint* write = newValueFixed;
                    foreach (valueType value in array)
                    {
                        if (!hash.Contains(value))
                        {
                            *write++ = getValue(value);
                            hash.Add(value);
                        }
                    }
                    return new list<uint>(newValues, 0, (int)(write - newValueFixed), true);
                }
            }
            return null;
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        public unsafe static list<uint> distinct<valueType>
            (this valueType[] array, int index, int count, func<valueType, uint> getValue)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                if (getValue == null) log.Default.Throw(log.exceptionType.Null);
                uint[] newValues = new uint[count];
                System.Collections.Generic.HashSet<valueType> hash = new System.Collections.Generic.HashSet<valueType>();
                valueType value;
                fixed (uint* newValueFixed = newValues)
                {
                    uint* write = newValueFixed;
                    for (index = range.SkipCount, count = range.EndIndex; index != count; ++index)
                    {
                        if (!hash.Contains(value = array[index]))
                        {
                            *write++ = getValue(value);
                            hash.Add(value);
                        }
                    }
                    return new list<uint>(newValues, 0, (int)(write - newValueFixed), true);
                }
            }
            return null;
        }
        /// <summary>
        /// 求交集
        /// </summary>
        /// <param name="left">左侧数据</param>
        /// <param name="right">右侧数据</param>
        /// <returns>数据交集</returns>
        public unsafe static list<uint> intersect(this uint[] left, uint[] right)
        {
            int leftLength = left.length();
            if (leftLength != 0)
            {
                int rightLength = right.length();
                if (rightLength != 0)
                {
                    uint[] min = leftLength <= rightLength ? left : right, values = new uint[min.Length];
                    fixed (uint* valueFixed = values)
                    {
                        uint* write = valueFixed;
                        staticHashSet<uint> hash = new staticHashSet<uint>(min);
                        foreach (uint value in leftLength <= rightLength ? right : left)
                        {
                            if (hash.Contains(value)) *write++ = value;
                        }
                        return new list<uint>(values, 0, (int)(write - valueFixed), true);
                    }
                }
            }
            return null;
        }
        /// <summary>
        /// 遍历foreach
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">遍历数据数量</param>
        /// <param name="method">调用函数</param>
        /// <returns>数据数组</returns>
        public unsafe static uint[] each
            (this uint[] array, int index, int count, action<uint> method)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                if (method == null) log.Default.Throw(log.exceptionType.Null);
                fixed (uint* valueFixed = array)
                {
                    for (uint* start = valueFixed + index, end = start + count; start != end; method(*start++)) ;
                }
                return array;
            }
            return nullValue<uint>.Array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public unsafe static bool max(this uint[] array, out uint value)
        {
            if (array.length() != 0)
            {
                fixed (uint* valueFixed = array)
                {
                    value = *valueFixed;
                    for (uint* start = valueFixed + 1, end = valueFixed + array.Length; start != end; ++start)
                    {
                        if (*start > value) value = *start;
                    }
                    return true;
                }
            }
            value = uint.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public unsafe static uint max(this uint[] array, uint nullValue)
        {
            uint value;
            return max(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public unsafe static bool max(this uint[] array, int index, int count, out uint value)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                fixed (uint* valueFixed = array)
                {
                    uint* start = valueFixed + range.SkipCount;
                    value = *start;
                    for (uint* end = start + count; ++start != end; )
                    {
                        if (*start > value) value = *start;
                    }
                    return true;
                }
            }
            value = uint.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public unsafe static uint max
            (this uint[] array, int index, int count, uint nullValue)
        {
            uint value;
            return max(array, index, count, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>
            (this valueType[] array, func<valueType, uint> getKey, out uint value)
        {
            if (array.length() != 0)
            {
                value = getKey(array[0]);
                foreach (valueType nextValue in array)
                {
                    uint nextKey = getKey(nextValue);
                    if (nextKey > value) value = nextKey;
                }
                return true;
            }
            value = uint.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static uint maxKey<valueType>
            (this valueType[] array, func<valueType, uint> getKey, uint nullValue)
        {
            uint value;
            return maxKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>
            (this valueType[] array, int index, int count, func<valueType, uint> getKey
            , out uint value)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                value = getKey(array[index = range.SkipCount]);
                for (int endIndex = index + count; ++index != endIndex; )
                {
                    uint nextValue = getKey(array[index]);
                    if (nextValue > value) value = nextValue;
                }
                return true;
            }
            value = uint.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static uint maxKey<valueType>
            (this valueType[] array, int index, int count, func<valueType, uint> getKey
            , uint nullValue)
        {
            uint value;
            return maxKey(array, index, count, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>
            (this valueType[] array, func<valueType, uint> getKey, out valueType value)
        {
            if (array.length() != 0)
            {
                value = array[0];
                uint maxKey = getKey(value);
                foreach (valueType nextValue in array)
                {
                    uint nextKey = getKey(nextValue);
                    if (nextKey > maxKey)
                    {
                        maxKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static valueType max<valueType>(this valueType[] array, func<valueType, uint> getKey, valueType nullValue)
        {
            valueType value;
            return max(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>
            (this valueType[] array, int index, int count, func<valueType, uint> getKey, out valueType value)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                value = array[index = range.SkipCount];
                uint maxValue = getKey(value);
                for (int endIndex = index + count; ++index != endIndex; )
                {
                    uint nextValue = getKey(array[index]);
                    if (nextValue > maxValue)
                    {
                        maxValue = nextValue;
                        value = array[index];
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static valueType max<valueType>
            (this valueType[] array, int index, int count, func<valueType, uint> getKey, valueType nullValue)
        {
            valueType value;
            return max(array, index, count, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public unsafe static bool min(this uint[] array, out uint value)
        {
            if (array.length() != 0)
            {
                fixed (uint* valueFixed = array)
                {
                    value = *valueFixed;
                    for (uint* start = valueFixed + 1, end = valueFixed + array.Length; start != end; ++start)
                    {
                        if (*start < value) value = *start;
                    }
                    return true;
                }
            }
            value = uint.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public unsafe static uint min(this uint[] array, uint nullValue)
        {
            uint value;
            return min(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public unsafe static bool min(this uint[] array, int index, int count, out uint value)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                fixed (uint* valueFixed = array)
                {
                    uint* start = valueFixed + range.SkipCount;
                    value = *start;
                    for (uint* end = start + count; ++start != end; )
                    {
                        if (*start < value) value = *start;
                    }
                    return true;
                }
            }
            value = uint.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public unsafe static uint min
            (this uint[] array, int index, int count, uint nullValue)
        {
            uint value;
            return min(array, index, count, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>
            (this valueType[] array, func<valueType, uint> getKey, out uint value)
        {
            if (array.length() != 0)
            {
                value = getKey(array[0]);
                foreach (valueType nextValue in array)
                {
                    uint nextKey = getKey(nextValue);
                    if (nextKey < value) value = nextKey;
                }
                return true;
            }
            value = uint.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static uint minKey<valueType>
            (this valueType[] array, func<valueType, uint> getKey, uint nullValue)
        {
            uint value;
            return minKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>
            (this valueType[] array, int index, int count, func<valueType, uint> getKey
            , out uint value)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                value = getKey(array[index = range.SkipCount]);
                for (int endIndex = index + count; ++index != endIndex; )
                {
                    uint nextValue = getKey(array[index]);
                    if (nextValue < value) value = nextValue;
                }
                return true;
            }
            value = uint.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static uint minKey<valueType>
            (this valueType[] array, int index, int count, func<valueType, uint> getKey
            , uint nullValue)
        {
            uint value;
            return minKey(array, index, count, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>(this valueType[] array, func<valueType, uint> getKey, out valueType value)
        {
            if (array.length() != 0)
            {
                value = array[0];
                uint minKey = getKey(value);
                foreach (valueType nextValue in array)
                {
                    uint nextKey = getKey(nextValue);
                    if (nextKey < minKey)
                    {
                        minKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static valueType min<valueType>(this valueType[] array, func<valueType, uint> getKey, valueType nullValue)
        {
            valueType value;
            return min(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>
            (this valueType[] array, int index, int count, func<valueType, uint> getKey, out valueType value)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                value = array[index = range.SkipCount];
                uint minValue = getKey(value);
                for (int endIndex = index + count; ++index != endIndex; )
                {
                    uint nextValue = getKey(array[index]);
                    if (nextValue < minValue)
                    {
                        minValue = nextValue;
                        value = array[index];
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static valueType min<valueType>
            (this valueType[] array, int index, int count, func<valueType, uint> getKey, valueType nullValue)
        {
            valueType value;
            return min(array, index, count, getKey, out value) ? value : nullValue;
        }
    }
}

namespace fastCSharp.unsafer
{
    /// <summary>
    /// 数组非安全扩展操作(请自行确保数据可靠性)
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 移动数据块
        /// </summary>
        /// <param name="array">待处理数组</param>
        /// <param name="index">原始数据位置</param>
        /// <param name="writeIndex">目标数据位置</param>
        /// <param name="count">移动数据数量</param>
        public unsafe static void Move(uint[] array, int index, int writeIndex, int count)
        {
            int endIndex = index + count;
            if (index < writeIndex && endIndex > writeIndex)
            {
                fixed (uint* valueFixed = array)
                {
                    for (uint* write = valueFixed + writeIndex + count, start = valueFixed + index, end = valueFixed + endIndex;
                        end != start;
                        *--write = *--end) ;
                }
            }
            else Array.Copy(array, index, array, writeIndex, count);
        }
    }
}
namespace fastCSharp
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="values">数据指针</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为null</returns>
        private unsafe static int* IndexOf
            (int* valueFixed, int length, int value)
        {
            for (int* start = valueFixed, end = valueFixed + length; start != end; ++start)
            {
                if (*start == value) return start;
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this int[] array, int value)
        {
            if (array != null)
            {
                fixed (int* valueFixed = array)
                {
                    int* valueIndex = IndexOf(valueFixed, array.Length, value);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this int[] array, int index, int length, int value)
        {
            array.range range = new array.range(array.length(), index, length);
            if ((length = range.GetCount) != 0)
            {
                fixed (int* valueFixed = array)
                {
                    int* valueIndex = IndexOf(valueFixed + range.SkipCount, length, value);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        public static int[] getReverse(this int[] array)
        {
            return array.length() != 0 ? GetReverse(array, 0, array.Length) : array.notNull();
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        /// <returns>翻转后的新数组</returns>
        public static int[] getReverse(this int[] array, int index, int length)
        {
            array.range range = new array.range(array.length(), index, length);
            if (((range.SkipCount ^ index) | (range.GetCount ^ length)) == 0)
            {
                return GetReverse(array, index, length);
            }
            log.Default.Throw(log.exceptionType.IndexOutOfRange);
            return null;
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        /// <returns>翻转后的新数组</returns>
        private unsafe static int[] GetReverse(int[] array, int index, int length)
        {
            int[] newValues = new int[length];
            fixed (int* valueFixed = array, newValueFixed = newValues)
            {
                for (int* start = valueFixed + index, end = start + length, wirte = newValueFixed + length;
                    start != end; 
                    *--wirte = *start++) ;
            }
            return newValues;
        }
        /// <summary>
        /// 移除第一个匹配数据数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配值</param>
        /// <returns>移除数据后的数组</returns>
        public unsafe static int[] removeFirst
            (this int[] array, int value)
        {
            if (array != null)
            {
                int index = -1;
                fixed (int* valueFixed = array)
                {
                    int* valueIndex = IndexOf(valueFixed, array.Length, value);
                    if (valueIndex != null) index = (int)(valueIndex - valueFixed);
                }
                if (index != -1) return GetRemoveAt(array, index);
            }
            return nullValue<int>.Array;
        }
        /// <summary>
        /// 移动数据块
        /// </summary>
        /// <param name="array">待处理数组</param>
        /// <param name="index">原始数据位置</param>
        /// <param name="writeIndex">目标数据位置</param>
        /// <param name="count">移动数据数量</param>
        public unsafe static void move(this int[] array, int index, int writeIndex, int count)
        {
            if (count > 0)
            {
                int writeEndIndex = writeIndex + count;
                if (index >= 0 && writeEndIndex <= array.Length)
                {
                    int endIndex = index + count;
                    if (index < writeIndex && endIndex > writeIndex)
                    {
                        fixed (int* valueFixed = array)
                        {
                            for (int* write = valueFixed + writeEndIndex, end = valueFixed + endIndex, start = valueFixed + index;
                                end != start;
                                *--write = *--end) ;
                        }
                    }
                    else if (writeIndex >= 0 && endIndex <= array.Length) Array.Copy(array, index, array, writeIndex, count);
                    else log.Default.Throw(log.exceptionType.IndexOutOfRange);
                }
                else log.Default.Throw(log.exceptionType.IndexOutOfRange);
            }
            else if (count != 0) log.Default.Throw(log.exceptionType.IndexOutOfRange);
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="values">数组数据</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为null</returns>
        private unsafe static int* IndexOf
            (int* valueFixed, int length, func<int, bool> isValue)
        {
            for (int* start = valueFixed, end = valueFixed + length; start != end; ++start)
            {
                if (isValue(*start)) return start;
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this int[] array, func<int, bool> isValue)
        {
            if (array != null)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                fixed (int* valueFixed = array)
                {
                    int* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf
            (this int[] array, int index, int length, func<int, bool> isValue)
        {
            array.range range = new array.range(array.length(), index, length);
            if ((length = range.GetCount) != 0)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                fixed (int* valueFixed = array)
                {
                    int* valueIndex = IndexOf(valueFixed + range.SkipCount, length, isValue);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="index">起始位置</param>
        /// <returns>第一个匹配值,失败为default(int)</returns>
        public unsafe static int firstOrDefault
            (this int[] array, func<int, bool> isValue, int index)
        {
            if (array != null && (uint)index < (uint)array.Length)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                fixed (int* valueFixed = array)
                {
                    int* valueIndex = IndexOf(valueFixed + index, array.Length - index, isValue);
                    if (valueIndex != null) return *valueIndex;
                }
            }
            return default(int);
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public unsafe static int count
            (this int[] array, int index, int count, func<int, bool> isValue)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                int value = 0;
                fixed (int* valueFixed = array)
                {
                    for (int* start = valueFixed + index, end = start + count; start != end; ++start)
                    {
                        if (isValue(*start)) ++value;
                    }
                }
                return value;
            }
            return 0;
        }
        /// <summary>
        /// 移除第一个匹配数据数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>移除数据后的数组</returns>
        public unsafe static int[] removeFirst
            (this int[] array, func<int, bool> isValue)
        {
            if (array != null)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                int index = -1;
                fixed (int* valueFixed = array)
                {
                    int* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) index = (int)(valueIndex - valueFixed);
                }
                if (index != -1) return GetRemoveAt(array, index);
                return array;
            }
            return nullValue<int>.Array;
        }
        /// <summary>
        /// 替换数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">新值</param>
        /// <param name="isValue">数据匹配器</param>
        public unsafe static int[] replaceFirst
            (this int[] array, int value, func<int, bool> isValue)
        {
            if (array != null)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                fixed (int* valueFixed = array)
                {
                    int* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) *valueIndex = value;
                }
                return array;
            }
            return nullValue<int>.Array;
        }
        /// <summary>
        /// 转换键值对集合
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="array">键值数组</param>
        /// <param name="values">数据数组</param>
        /// <returns>键值对数组</returns>
        public unsafe static keyValue<int, valueType>[] getKeyValue<valueType>
            (this int[] array, valueType[] values)
        {
            int length = array.length();
            if (length != values.length()) log.Default.Throw(log.exceptionType.IndexOutOfRange);
            if (length != 0)
            {
                keyValue<int, valueType>[] newValues = new keyValue<int, valueType>[values.Length];
                fixed (int* valueFixed = array)
                {
                    int* readValue = valueFixed;
                    int index = 0;
                    foreach (valueType value in values)
                    {
                        newValues[index].Set(*readValue++, value);
                        ++index;
                    }
                }
                return newValues;
            }
            return nullValue<keyValue<int, valueType>>.Array;
        }
        /// <summary>
        /// 数据转换
        /// </summary>
        /// <typeparam name="valueType">数组类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public unsafe static int[] getArray<valueType>
            (this valueType[] array, func<valueType, int> getValue)
        {
            if (array.length() != 0)
            {
                if (getValue == null) log.Default.Throw(log.exceptionType.Null);
                int[] newValues = new int[array.Length];
                fixed (int* newValueFixed = newValues)
                {
                    int* writeValue = newValueFixed;
                    foreach (valueType value in array) *writeValue++ = getValue(value);
                }
                return newValues;
            }
            return nullValue<int>.Array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public unsafe static list<int> getFind
            (this int[] array, func<int, bool> isValue)
        {
            if (array.length() != 0)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                int[] newValues = new int[array.Length < sizeof(int) ? sizeof(int) : array.Length];
                fixed (int* newValueFixed = newValues, valueFixed = array)
                {
                    int* write = newValueFixed;
                    for (int* start = valueFixed, end = valueFixed + array.Length; start != end; ++start)
                    {
                        if (isValue(*start)) *write++ = *start;
                    }
                    return new list<int>(newValues, 0, (int)(write - newValueFixed), true);
                }
            }
            return null;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public unsafe static list<int> getFind
            (this int[] array, int index, int count, func<int, bool> isValue)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                int[] newValues = new int[count < sizeof(int) ? sizeof(int) : count];
                fixed (int* newValueFixed = newValues, valueFixed = array)
                {
                    int* write = newValueFixed;
                    for (int* start = valueFixed + index, end = start + count; start != end; ++start)
                    {
                        if (isValue(*start)) *write++ = *start;
                    }
                    return new list<int>(newValues, 0, (int)(write - newValueFixed), true);
                }
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public unsafe static int[] getFindArray
            (this int[] array, func<int, bool> isValue)
        {
            if (isValue == null) log.Default.Throw(log.exceptionType.Null);
            int length = array.length();
            if (length != 0)
            {
                length = (length + 7) >> 3;
                if (length <= config.pub.Default.StreamBufferLength)
                {
                    byte* data = stackalloc byte[length];
                    return GetFindArray(array, 0, array.Length, isValue, new fixedMap(data, length));
                }
                else
                {
                    byte[] data = new byte[length];
                    fixed (byte* dataFixed = data) return GetFindArray(array, 0, array.Length, isValue, new fixedMap(dataFixed));
                }
            }
            return nullValue<int>.Array;
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public unsafe static int[] getFindArray
            (this int[] array, int index, int count, func<int, bool> isValue)
        {
            if (isValue == null) log.Default.Throw(log.exceptionType.Null);
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                int length = (count + 7) >> 3;
                if (length <= config.pub.Default.StreamBufferLength)
                {
                    byte* data = stackalloc byte[length];
                    return GetFindArray(array, range.SkipCount, count, isValue, new fixedMap(data, length));
                }
                else
                {
                    byte[] data = new byte[length];
                    fixed (byte* dataFixed = data) return GetFindArray(array, range.SkipCount, count, isValue, new fixedMap(dataFixed));
                }
            }
            return nullValue<int>.Array;
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="map">匹配结果位图</param>
        /// <returns>匹配数组</returns>
        private unsafe static int[] GetFindArray
            (int[] array, int index, int count, func<int, bool> isValue, fixedMap map)
        {
            int length = 0, mapIndex = 0;
            fixed (int* valueFixed = array)
            {
                int* startFixed = valueFixed + index, end = startFixed + count;
                for (int* start = startFixed; start != end; ++start, ++mapIndex)
                {
                    if (isValue(*start))
                    {
                        ++length;
                        map.Set(mapIndex);
                    }
                }
                if (length != 0)
                {
                    int[] newValues = new int[length];
                    fixed (int* newValueFixed = newValues)
                    {
                        int* write = newValueFixed + length;
                        while (mapIndex != 0)
                        {
                            if (map.Get(--mapIndex)) *--write = startFixed[mapIndex];
                        }
                    }
                    return newValues;
                }
            }
            return nullValue<int>.Array;
        }
        /// <summary>
        /// 取子集合
        /// </summary>
        /// <typeparam name="valueType">目标数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">数据数量</param>
        /// <param name="getVlaue">目标数据获取器</param>
        /// <returns>子集合</returns>
        public unsafe static valueType[] getSub<valueType>
            (this int[] array, int index, int count, func<int, valueType> getVlaue)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                if (getVlaue == null) log.Default.Throw(log.exceptionType.Null);
                valueType[] newValues = new valueType[count];
                fixed (int* valueFixed = array)
                {
                    int* read = valueFixed + range.SkipCount;
                    for (index = 0; index != count; ++index) newValues[index] = getVlaue(*read++);
                }
                return newValues;
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 取子集合
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">数据数量</param>
        /// <param name="getVlaue">数据获取器</param>
        /// <returns>子集合</returns>
        public unsafe static int[] getSub<valueType>
            (this valueType[] array, int index, int count, func<valueType, int> getValue)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                if (getValue == null) log.Default.Throw(log.exceptionType.Null);
                int[] newValues = new int[count];
                fixed (int* newValueFixed = newValues)
                {
                    int* write = newValueFixed;
                    for (index = range.SkipCount, count = range.EndIndex; index != count; ++index) *write++ = getValue(array[index]);
                }
                return newValues;
            }
            return nullValue<int>.Array;
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        public unsafe static list<valueType> distinct<valueType>
            (this int[] array, int index, int count, func<int, valueType> getValue)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                if (getValue == null) log.Default.Throw(log.exceptionType.Null);
                list<valueType>.unsafer newValues = new list<valueType>(count).Unsafer;
                System.Collections.Generic.HashSet<int> hash
                    = new System.Collections.Generic.HashSet<int>();
                fixed (int* valueFixed = array)
                {
                    for (int* start = valueFixed + range.SkipCount, end = start + count; start != end; ++start)
                    {
                        if (!hash.Contains(*start))
                        {
                            newValues.Add(getValue(*start));
                            hash.Add(*start);
                        }
                    }
                }
                return newValues.List;
            }
            return null;
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        public unsafe static list<int> distinct<valueType>
            (this valueType[] array, func<valueType, int> getValue)
        {
            if (array != null)
            {
                if (getValue == null) log.Default.Throw(log.exceptionType.Null);
                int[] newValues = new int[array.Length];
                System.Collections.Generic.HashSet<valueType> hash = new System.Collections.Generic.HashSet<valueType>();
                fixed (int* newValueFixed = newValues)
                {
                    int* write = newValueFixed;
                    foreach (valueType value in array)
                    {
                        if (!hash.Contains(value))
                        {
                            *write++ = getValue(value);
                            hash.Add(value);
                        }
                    }
                    return new list<int>(newValues, 0, (int)(write - newValueFixed), true);
                }
            }
            return null;
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        public unsafe static list<int> distinct<valueType>
            (this valueType[] array, int index, int count, func<valueType, int> getValue)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                if (getValue == null) log.Default.Throw(log.exceptionType.Null);
                int[] newValues = new int[count];
                System.Collections.Generic.HashSet<valueType> hash = new System.Collections.Generic.HashSet<valueType>();
                valueType value;
                fixed (int* newValueFixed = newValues)
                {
                    int* write = newValueFixed;
                    for (index = range.SkipCount, count = range.EndIndex; index != count; ++index)
                    {
                        if (!hash.Contains(value = array[index]))
                        {
                            *write++ = getValue(value);
                            hash.Add(value);
                        }
                    }
                    return new list<int>(newValues, 0, (int)(write - newValueFixed), true);
                }
            }
            return null;
        }
        /// <summary>
        /// 求交集
        /// </summary>
        /// <param name="left">左侧数据</param>
        /// <param name="right">右侧数据</param>
        /// <returns>数据交集</returns>
        public unsafe static list<int> intersect(this int[] left, int[] right)
        {
            int leftLength = left.length();
            if (leftLength != 0)
            {
                int rightLength = right.length();
                if (rightLength != 0)
                {
                    int[] min = leftLength <= rightLength ? left : right, values = new int[min.Length];
                    fixed (int* valueFixed = values)
                    {
                        int* write = valueFixed;
                        staticHashSet<int> hash = new staticHashSet<int>(min);
                        foreach (int value in leftLength <= rightLength ? right : left)
                        {
                            if (hash.Contains(value)) *write++ = value;
                        }
                        return new list<int>(values, 0, (int)(write - valueFixed), true);
                    }
                }
            }
            return null;
        }
        /// <summary>
        /// 遍历foreach
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">遍历数据数量</param>
        /// <param name="method">调用函数</param>
        /// <returns>数据数组</returns>
        public unsafe static int[] each
            (this int[] array, int index, int count, action<int> method)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                if (method == null) log.Default.Throw(log.exceptionType.Null);
                fixed (int* valueFixed = array)
                {
                    for (int* start = valueFixed + index, end = start + count; start != end; method(*start++)) ;
                }
                return array;
            }
            return nullValue<int>.Array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public unsafe static bool max(this int[] array, out int value)
        {
            if (array.length() != 0)
            {
                fixed (int* valueFixed = array)
                {
                    value = *valueFixed;
                    for (int* start = valueFixed + 1, end = valueFixed + array.Length; start != end; ++start)
                    {
                        if (*start > value) value = *start;
                    }
                    return true;
                }
            }
            value = int.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public unsafe static int max(this int[] array, int nullValue)
        {
            int value;
            return max(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public unsafe static bool max(this int[] array, int index, int count, out int value)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                fixed (int* valueFixed = array)
                {
                    int* start = valueFixed + range.SkipCount;
                    value = *start;
                    for (int* end = start + count; ++start != end; )
                    {
                        if (*start > value) value = *start;
                    }
                    return true;
                }
            }
            value = int.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public unsafe static int max
            (this int[] array, int index, int count, int nullValue)
        {
            int value;
            return max(array, index, count, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>
            (this valueType[] array, func<valueType, int> getKey, out int value)
        {
            if (array.length() != 0)
            {
                value = getKey(array[0]);
                foreach (valueType nextValue in array)
                {
                    int nextKey = getKey(nextValue);
                    if (nextKey > value) value = nextKey;
                }
                return true;
            }
            value = int.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static int maxKey<valueType>
            (this valueType[] array, func<valueType, int> getKey, int nullValue)
        {
            int value;
            return maxKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>
            (this valueType[] array, int index, int count, func<valueType, int> getKey
            , out int value)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                value = getKey(array[index = range.SkipCount]);
                for (int endIndex = index + count; ++index != endIndex; )
                {
                    int nextValue = getKey(array[index]);
                    if (nextValue > value) value = nextValue;
                }
                return true;
            }
            value = int.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static int maxKey<valueType>
            (this valueType[] array, int index, int count, func<valueType, int> getKey
            , int nullValue)
        {
            int value;
            return maxKey(array, index, count, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>
            (this valueType[] array, func<valueType, int> getKey, out valueType value)
        {
            if (array.length() != 0)
            {
                value = array[0];
                int maxKey = getKey(value);
                foreach (valueType nextValue in array)
                {
                    int nextKey = getKey(nextValue);
                    if (nextKey > maxKey)
                    {
                        maxKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static valueType max<valueType>(this valueType[] array, func<valueType, int> getKey, valueType nullValue)
        {
            valueType value;
            return max(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>
            (this valueType[] array, int index, int count, func<valueType, int> getKey, out valueType value)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                value = array[index = range.SkipCount];
                int maxValue = getKey(value);
                for (int endIndex = index + count; ++index != endIndex; )
                {
                    int nextValue = getKey(array[index]);
                    if (nextValue > maxValue)
                    {
                        maxValue = nextValue;
                        value = array[index];
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static valueType max<valueType>
            (this valueType[] array, int index, int count, func<valueType, int> getKey, valueType nullValue)
        {
            valueType value;
            return max(array, index, count, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public unsafe static bool min(this int[] array, out int value)
        {
            if (array.length() != 0)
            {
                fixed (int* valueFixed = array)
                {
                    value = *valueFixed;
                    for (int* start = valueFixed + 1, end = valueFixed + array.Length; start != end; ++start)
                    {
                        if (*start < value) value = *start;
                    }
                    return true;
                }
            }
            value = int.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public unsafe static int min(this int[] array, int nullValue)
        {
            int value;
            return min(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public unsafe static bool min(this int[] array, int index, int count, out int value)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                fixed (int* valueFixed = array)
                {
                    int* start = valueFixed + range.SkipCount;
                    value = *start;
                    for (int* end = start + count; ++start != end; )
                    {
                        if (*start < value) value = *start;
                    }
                    return true;
                }
            }
            value = int.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public unsafe static int min
            (this int[] array, int index, int count, int nullValue)
        {
            int value;
            return min(array, index, count, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>
            (this valueType[] array, func<valueType, int> getKey, out int value)
        {
            if (array.length() != 0)
            {
                value = getKey(array[0]);
                foreach (valueType nextValue in array)
                {
                    int nextKey = getKey(nextValue);
                    if (nextKey < value) value = nextKey;
                }
                return true;
            }
            value = int.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static int minKey<valueType>
            (this valueType[] array, func<valueType, int> getKey, int nullValue)
        {
            int value;
            return minKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>
            (this valueType[] array, int index, int count, func<valueType, int> getKey
            , out int value)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                value = getKey(array[index = range.SkipCount]);
                for (int endIndex = index + count; ++index != endIndex; )
                {
                    int nextValue = getKey(array[index]);
                    if (nextValue < value) value = nextValue;
                }
                return true;
            }
            value = int.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static int minKey<valueType>
            (this valueType[] array, int index, int count, func<valueType, int> getKey
            , int nullValue)
        {
            int value;
            return minKey(array, index, count, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>(this valueType[] array, func<valueType, int> getKey, out valueType value)
        {
            if (array.length() != 0)
            {
                value = array[0];
                int minKey = getKey(value);
                foreach (valueType nextValue in array)
                {
                    int nextKey = getKey(nextValue);
                    if (nextKey < minKey)
                    {
                        minKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static valueType min<valueType>(this valueType[] array, func<valueType, int> getKey, valueType nullValue)
        {
            valueType value;
            return min(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>
            (this valueType[] array, int index, int count, func<valueType, int> getKey, out valueType value)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                value = array[index = range.SkipCount];
                int minValue = getKey(value);
                for (int endIndex = index + count; ++index != endIndex; )
                {
                    int nextValue = getKey(array[index]);
                    if (nextValue < minValue)
                    {
                        minValue = nextValue;
                        value = array[index];
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static valueType min<valueType>
            (this valueType[] array, int index, int count, func<valueType, int> getKey, valueType nullValue)
        {
            valueType value;
            return min(array, index, count, getKey, out value) ? value : nullValue;
        }
    }
}

namespace fastCSharp.unsafer
{
    /// <summary>
    /// 数组非安全扩展操作(请自行确保数据可靠性)
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 移动数据块
        /// </summary>
        /// <param name="array">待处理数组</param>
        /// <param name="index">原始数据位置</param>
        /// <param name="writeIndex">目标数据位置</param>
        /// <param name="count">移动数据数量</param>
        public unsafe static void Move(int[] array, int index, int writeIndex, int count)
        {
            int endIndex = index + count;
            if (index < writeIndex && endIndex > writeIndex)
            {
                fixed (int* valueFixed = array)
                {
                    for (int* write = valueFixed + writeIndex + count, start = valueFixed + index, end = valueFixed + endIndex;
                        end != start;
                        *--write = *--end) ;
                }
            }
            else Array.Copy(array, index, array, writeIndex, count);
        }
    }
}
namespace fastCSharp
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="values">数据指针</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为null</returns>
        private unsafe static ushort* IndexOf
            (ushort* valueFixed, int length, ushort value)
        {
            for (ushort* start = valueFixed, end = valueFixed + length; start != end; ++start)
            {
                if (*start == value) return start;
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this ushort[] array, ushort value)
        {
            if (array != null)
            {
                fixed (ushort* valueFixed = array)
                {
                    ushort* valueIndex = IndexOf(valueFixed, array.Length, value);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this ushort[] array, int index, int length, ushort value)
        {
            array.range range = new array.range(array.length(), index, length);
            if ((length = range.GetCount) != 0)
            {
                fixed (ushort* valueFixed = array)
                {
                    ushort* valueIndex = IndexOf(valueFixed + range.SkipCount, length, value);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        public static ushort[] getReverse(this ushort[] array)
        {
            return array.length() != 0 ? GetReverse(array, 0, array.Length) : array.notNull();
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        /// <returns>翻转后的新数组</returns>
        public static ushort[] getReverse(this ushort[] array, int index, int length)
        {
            array.range range = new array.range(array.length(), index, length);
            if (((range.SkipCount ^ index) | (range.GetCount ^ length)) == 0)
            {
                return GetReverse(array, index, length);
            }
            log.Default.Throw(log.exceptionType.IndexOutOfRange);
            return null;
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        /// <returns>翻转后的新数组</returns>
        private unsafe static ushort[] GetReverse(ushort[] array, int index, int length)
        {
            ushort[] newValues = new ushort[length];
            fixed (ushort* valueFixed = array, newValueFixed = newValues)
            {
                for (ushort* start = valueFixed + index, end = start + length, wirte = newValueFixed + length;
                    start != end; 
                    *--wirte = *start++) ;
            }
            return newValues;
        }
        /// <summary>
        /// 移除第一个匹配数据数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配值</param>
        /// <returns>移除数据后的数组</returns>
        public unsafe static ushort[] removeFirst
            (this ushort[] array, ushort value)
        {
            if (array != null)
            {
                int index = -1;
                fixed (ushort* valueFixed = array)
                {
                    ushort* valueIndex = IndexOf(valueFixed, array.Length, value);
                    if (valueIndex != null) index = (int)(valueIndex - valueFixed);
                }
                if (index != -1) return GetRemoveAt(array, index);
            }
            return nullValue<ushort>.Array;
        }
        /// <summary>
        /// 移动数据块
        /// </summary>
        /// <param name="array">待处理数组</param>
        /// <param name="index">原始数据位置</param>
        /// <param name="writeIndex">目标数据位置</param>
        /// <param name="count">移动数据数量</param>
        public unsafe static void move(this ushort[] array, int index, int writeIndex, int count)
        {
            if (count > 0)
            {
                int writeEndIndex = writeIndex + count;
                if (index >= 0 && writeEndIndex <= array.Length)
                {
                    int endIndex = index + count;
                    if (index < writeIndex && endIndex > writeIndex)
                    {
                        fixed (ushort* valueFixed = array)
                        {
                            for (ushort* write = valueFixed + writeEndIndex, end = valueFixed + endIndex, start = valueFixed + index;
                                end != start;
                                *--write = *--end) ;
                        }
                    }
                    else if (writeIndex >= 0 && endIndex <= array.Length) Array.Copy(array, index, array, writeIndex, count);
                    else log.Default.Throw(log.exceptionType.IndexOutOfRange);
                }
                else log.Default.Throw(log.exceptionType.IndexOutOfRange);
            }
            else if (count != 0) log.Default.Throw(log.exceptionType.IndexOutOfRange);
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="values">数组数据</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为null</returns>
        private unsafe static ushort* IndexOf
            (ushort* valueFixed, int length, func<ushort, bool> isValue)
        {
            for (ushort* start = valueFixed, end = valueFixed + length; start != end; ++start)
            {
                if (isValue(*start)) return start;
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this ushort[] array, func<ushort, bool> isValue)
        {
            if (array != null)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                fixed (ushort* valueFixed = array)
                {
                    ushort* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf
            (this ushort[] array, int index, int length, func<ushort, bool> isValue)
        {
            array.range range = new array.range(array.length(), index, length);
            if ((length = range.GetCount) != 0)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                fixed (ushort* valueFixed = array)
                {
                    ushort* valueIndex = IndexOf(valueFixed + range.SkipCount, length, isValue);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="index">起始位置</param>
        /// <returns>第一个匹配值,失败为default(ushort)</returns>
        public unsafe static ushort firstOrDefault
            (this ushort[] array, func<ushort, bool> isValue, int index)
        {
            if (array != null && (uint)index < (uint)array.Length)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                fixed (ushort* valueFixed = array)
                {
                    ushort* valueIndex = IndexOf(valueFixed + index, array.Length - index, isValue);
                    if (valueIndex != null) return *valueIndex;
                }
            }
            return default(ushort);
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public unsafe static int count
            (this ushort[] array, int index, int count, func<ushort, bool> isValue)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                int value = 0;
                fixed (ushort* valueFixed = array)
                {
                    for (ushort* start = valueFixed + index, end = start + count; start != end; ++start)
                    {
                        if (isValue(*start)) ++value;
                    }
                }
                return value;
            }
            return 0;
        }
        /// <summary>
        /// 移除第一个匹配数据数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>移除数据后的数组</returns>
        public unsafe static ushort[] removeFirst
            (this ushort[] array, func<ushort, bool> isValue)
        {
            if (array != null)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                int index = -1;
                fixed (ushort* valueFixed = array)
                {
                    ushort* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) index = (int)(valueIndex - valueFixed);
                }
                if (index != -1) return GetRemoveAt(array, index);
                return array;
            }
            return nullValue<ushort>.Array;
        }
        /// <summary>
        /// 替换数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">新值</param>
        /// <param name="isValue">数据匹配器</param>
        public unsafe static ushort[] replaceFirst
            (this ushort[] array, ushort value, func<ushort, bool> isValue)
        {
            if (array != null)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                fixed (ushort* valueFixed = array)
                {
                    ushort* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) *valueIndex = value;
                }
                return array;
            }
            return nullValue<ushort>.Array;
        }
        /// <summary>
        /// 转换键值对集合
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="array">键值数组</param>
        /// <param name="values">数据数组</param>
        /// <returns>键值对数组</returns>
        public unsafe static keyValue<ushort, valueType>[] getKeyValue<valueType>
            (this ushort[] array, valueType[] values)
        {
            int length = array.length();
            if (length != values.length()) log.Default.Throw(log.exceptionType.IndexOutOfRange);
            if (length != 0)
            {
                keyValue<ushort, valueType>[] newValues = new keyValue<ushort, valueType>[values.Length];
                fixed (ushort* valueFixed = array)
                {
                    ushort* readValue = valueFixed;
                    int index = 0;
                    foreach (valueType value in values)
                    {
                        newValues[index].Set(*readValue++, value);
                        ++index;
                    }
                }
                return newValues;
            }
            return nullValue<keyValue<ushort, valueType>>.Array;
        }
        /// <summary>
        /// 数据转换
        /// </summary>
        /// <typeparam name="valueType">数组类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public unsafe static ushort[] getArray<valueType>
            (this valueType[] array, func<valueType, ushort> getValue)
        {
            if (array.length() != 0)
            {
                if (getValue == null) log.Default.Throw(log.exceptionType.Null);
                ushort[] newValues = new ushort[array.Length];
                fixed (ushort* newValueFixed = newValues)
                {
                    ushort* writeValue = newValueFixed;
                    foreach (valueType value in array) *writeValue++ = getValue(value);
                }
                return newValues;
            }
            return nullValue<ushort>.Array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public unsafe static list<ushort> getFind
            (this ushort[] array, func<ushort, bool> isValue)
        {
            if (array.length() != 0)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                ushort[] newValues = new ushort[array.Length < sizeof(int) ? sizeof(int) : array.Length];
                fixed (ushort* newValueFixed = newValues, valueFixed = array)
                {
                    ushort* write = newValueFixed;
                    for (ushort* start = valueFixed, end = valueFixed + array.Length; start != end; ++start)
                    {
                        if (isValue(*start)) *write++ = *start;
                    }
                    return new list<ushort>(newValues, 0, (int)(write - newValueFixed), true);
                }
            }
            return null;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public unsafe static list<ushort> getFind
            (this ushort[] array, int index, int count, func<ushort, bool> isValue)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                ushort[] newValues = new ushort[count < sizeof(int) ? sizeof(int) : count];
                fixed (ushort* newValueFixed = newValues, valueFixed = array)
                {
                    ushort* write = newValueFixed;
                    for (ushort* start = valueFixed + index, end = start + count; start != end; ++start)
                    {
                        if (isValue(*start)) *write++ = *start;
                    }
                    return new list<ushort>(newValues, 0, (int)(write - newValueFixed), true);
                }
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public unsafe static ushort[] getFindArray
            (this ushort[] array, func<ushort, bool> isValue)
        {
            if (isValue == null) log.Default.Throw(log.exceptionType.Null);
            int length = array.length();
            if (length != 0)
            {
                length = (length + 7) >> 3;
                if (length <= config.pub.Default.StreamBufferLength)
                {
                    byte* data = stackalloc byte[length];
                    return GetFindArray(array, 0, array.Length, isValue, new fixedMap(data, length));
                }
                else
                {
                    byte[] data = new byte[length];
                    fixed (byte* dataFixed = data) return GetFindArray(array, 0, array.Length, isValue, new fixedMap(dataFixed));
                }
            }
            return nullValue<ushort>.Array;
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public unsafe static ushort[] getFindArray
            (this ushort[] array, int index, int count, func<ushort, bool> isValue)
        {
            if (isValue == null) log.Default.Throw(log.exceptionType.Null);
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                int length = (count + 7) >> 3;
                if (length <= config.pub.Default.StreamBufferLength)
                {
                    byte* data = stackalloc byte[length];
                    return GetFindArray(array, range.SkipCount, count, isValue, new fixedMap(data, length));
                }
                else
                {
                    byte[] data = new byte[length];
                    fixed (byte* dataFixed = data) return GetFindArray(array, range.SkipCount, count, isValue, new fixedMap(dataFixed));
                }
            }
            return nullValue<ushort>.Array;
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="map">匹配结果位图</param>
        /// <returns>匹配数组</returns>
        private unsafe static ushort[] GetFindArray
            (ushort[] array, int index, int count, func<ushort, bool> isValue, fixedMap map)
        {
            int length = 0, mapIndex = 0;
            fixed (ushort* valueFixed = array)
            {
                ushort* startFixed = valueFixed + index, end = startFixed + count;
                for (ushort* start = startFixed; start != end; ++start, ++mapIndex)
                {
                    if (isValue(*start))
                    {
                        ++length;
                        map.Set(mapIndex);
                    }
                }
                if (length != 0)
                {
                    ushort[] newValues = new ushort[length];
                    fixed (ushort* newValueFixed = newValues)
                    {
                        ushort* write = newValueFixed + length;
                        while (mapIndex != 0)
                        {
                            if (map.Get(--mapIndex)) *--write = startFixed[mapIndex];
                        }
                    }
                    return newValues;
                }
            }
            return nullValue<ushort>.Array;
        }
        /// <summary>
        /// 取子集合
        /// </summary>
        /// <typeparam name="valueType">目标数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">数据数量</param>
        /// <param name="getVlaue">目标数据获取器</param>
        /// <returns>子集合</returns>
        public unsafe static valueType[] getSub<valueType>
            (this ushort[] array, int index, int count, func<ushort, valueType> getVlaue)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                if (getVlaue == null) log.Default.Throw(log.exceptionType.Null);
                valueType[] newValues = new valueType[count];
                fixed (ushort* valueFixed = array)
                {
                    ushort* read = valueFixed + range.SkipCount;
                    for (index = 0; index != count; ++index) newValues[index] = getVlaue(*read++);
                }
                return newValues;
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 取子集合
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">数据数量</param>
        /// <param name="getVlaue">数据获取器</param>
        /// <returns>子集合</returns>
        public unsafe static ushort[] getSub<valueType>
            (this valueType[] array, int index, int count, func<valueType, ushort> getValue)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                if (getValue == null) log.Default.Throw(log.exceptionType.Null);
                ushort[] newValues = new ushort[count];
                fixed (ushort* newValueFixed = newValues)
                {
                    ushort* write = newValueFixed;
                    for (index = range.SkipCount, count = range.EndIndex; index != count; ++index) *write++ = getValue(array[index]);
                }
                return newValues;
            }
            return nullValue<ushort>.Array;
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        public unsafe static list<valueType> distinct<valueType>
            (this ushort[] array, int index, int count, func<ushort, valueType> getValue)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                if (getValue == null) log.Default.Throw(log.exceptionType.Null);
                list<valueType>.unsafer newValues = new list<valueType>(count).Unsafer;
                System.Collections.Generic.HashSet<ushort> hash
                    = new System.Collections.Generic.HashSet<ushort>();
                fixed (ushort* valueFixed = array)
                {
                    for (ushort* start = valueFixed + range.SkipCount, end = start + count; start != end; ++start)
                    {
                        if (!hash.Contains(*start))
                        {
                            newValues.Add(getValue(*start));
                            hash.Add(*start);
                        }
                    }
                }
                return newValues.List;
            }
            return null;
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        public unsafe static list<ushort> distinct<valueType>
            (this valueType[] array, func<valueType, ushort> getValue)
        {
            if (array != null)
            {
                if (getValue == null) log.Default.Throw(log.exceptionType.Null);
                ushort[] newValues = new ushort[array.Length];
                System.Collections.Generic.HashSet<valueType> hash = new System.Collections.Generic.HashSet<valueType>();
                fixed (ushort* newValueFixed = newValues)
                {
                    ushort* write = newValueFixed;
                    foreach (valueType value in array)
                    {
                        if (!hash.Contains(value))
                        {
                            *write++ = getValue(value);
                            hash.Add(value);
                        }
                    }
                    return new list<ushort>(newValues, 0, (int)(write - newValueFixed), true);
                }
            }
            return null;
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        public unsafe static list<ushort> distinct<valueType>
            (this valueType[] array, int index, int count, func<valueType, ushort> getValue)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                if (getValue == null) log.Default.Throw(log.exceptionType.Null);
                ushort[] newValues = new ushort[count];
                System.Collections.Generic.HashSet<valueType> hash = new System.Collections.Generic.HashSet<valueType>();
                valueType value;
                fixed (ushort* newValueFixed = newValues)
                {
                    ushort* write = newValueFixed;
                    for (index = range.SkipCount, count = range.EndIndex; index != count; ++index)
                    {
                        if (!hash.Contains(value = array[index]))
                        {
                            *write++ = getValue(value);
                            hash.Add(value);
                        }
                    }
                    return new list<ushort>(newValues, 0, (int)(write - newValueFixed), true);
                }
            }
            return null;
        }
        /// <summary>
        /// 求交集
        /// </summary>
        /// <param name="left">左侧数据</param>
        /// <param name="right">右侧数据</param>
        /// <returns>数据交集</returns>
        public unsafe static list<ushort> intersect(this ushort[] left, ushort[] right)
        {
            int leftLength = left.length();
            if (leftLength != 0)
            {
                int rightLength = right.length();
                if (rightLength != 0)
                {
                    ushort[] min = leftLength <= rightLength ? left : right, values = new ushort[min.Length];
                    fixed (ushort* valueFixed = values)
                    {
                        ushort* write = valueFixed;
                        staticHashSet<ushort> hash = new staticHashSet<ushort>(min);
                        foreach (ushort value in leftLength <= rightLength ? right : left)
                        {
                            if (hash.Contains(value)) *write++ = value;
                        }
                        return new list<ushort>(values, 0, (int)(write - valueFixed), true);
                    }
                }
            }
            return null;
        }
        /// <summary>
        /// 遍历foreach
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">遍历数据数量</param>
        /// <param name="method">调用函数</param>
        /// <returns>数据数组</returns>
        public unsafe static ushort[] each
            (this ushort[] array, int index, int count, action<ushort> method)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                if (method == null) log.Default.Throw(log.exceptionType.Null);
                fixed (ushort* valueFixed = array)
                {
                    for (ushort* start = valueFixed + index, end = start + count; start != end; method(*start++)) ;
                }
                return array;
            }
            return nullValue<ushort>.Array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public unsafe static bool max(this ushort[] array, out ushort value)
        {
            if (array.length() != 0)
            {
                fixed (ushort* valueFixed = array)
                {
                    value = *valueFixed;
                    for (ushort* start = valueFixed + 1, end = valueFixed + array.Length; start != end; ++start)
                    {
                        if (*start > value) value = *start;
                    }
                    return true;
                }
            }
            value = ushort.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public unsafe static ushort max(this ushort[] array, ushort nullValue)
        {
            ushort value;
            return max(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public unsafe static bool max(this ushort[] array, int index, int count, out ushort value)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                fixed (ushort* valueFixed = array)
                {
                    ushort* start = valueFixed + range.SkipCount;
                    value = *start;
                    for (ushort* end = start + count; ++start != end; )
                    {
                        if (*start > value) value = *start;
                    }
                    return true;
                }
            }
            value = ushort.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public unsafe static ushort max
            (this ushort[] array, int index, int count, ushort nullValue)
        {
            ushort value;
            return max(array, index, count, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>
            (this valueType[] array, func<valueType, ushort> getKey, out ushort value)
        {
            if (array.length() != 0)
            {
                value = getKey(array[0]);
                foreach (valueType nextValue in array)
                {
                    ushort nextKey = getKey(nextValue);
                    if (nextKey > value) value = nextKey;
                }
                return true;
            }
            value = ushort.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static ushort maxKey<valueType>
            (this valueType[] array, func<valueType, ushort> getKey, ushort nullValue)
        {
            ushort value;
            return maxKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>
            (this valueType[] array, int index, int count, func<valueType, ushort> getKey
            , out ushort value)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                value = getKey(array[index = range.SkipCount]);
                for (int endIndex = index + count; ++index != endIndex; )
                {
                    ushort nextValue = getKey(array[index]);
                    if (nextValue > value) value = nextValue;
                }
                return true;
            }
            value = ushort.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static ushort maxKey<valueType>
            (this valueType[] array, int index, int count, func<valueType, ushort> getKey
            , ushort nullValue)
        {
            ushort value;
            return maxKey(array, index, count, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>
            (this valueType[] array, func<valueType, ushort> getKey, out valueType value)
        {
            if (array.length() != 0)
            {
                value = array[0];
                ushort maxKey = getKey(value);
                foreach (valueType nextValue in array)
                {
                    ushort nextKey = getKey(nextValue);
                    if (nextKey > maxKey)
                    {
                        maxKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static valueType max<valueType>(this valueType[] array, func<valueType, ushort> getKey, valueType nullValue)
        {
            valueType value;
            return max(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>
            (this valueType[] array, int index, int count, func<valueType, ushort> getKey, out valueType value)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                value = array[index = range.SkipCount];
                ushort maxValue = getKey(value);
                for (int endIndex = index + count; ++index != endIndex; )
                {
                    ushort nextValue = getKey(array[index]);
                    if (nextValue > maxValue)
                    {
                        maxValue = nextValue;
                        value = array[index];
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static valueType max<valueType>
            (this valueType[] array, int index, int count, func<valueType, ushort> getKey, valueType nullValue)
        {
            valueType value;
            return max(array, index, count, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public unsafe static bool min(this ushort[] array, out ushort value)
        {
            if (array.length() != 0)
            {
                fixed (ushort* valueFixed = array)
                {
                    value = *valueFixed;
                    for (ushort* start = valueFixed + 1, end = valueFixed + array.Length; start != end; ++start)
                    {
                        if (*start < value) value = *start;
                    }
                    return true;
                }
            }
            value = ushort.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public unsafe static ushort min(this ushort[] array, ushort nullValue)
        {
            ushort value;
            return min(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public unsafe static bool min(this ushort[] array, int index, int count, out ushort value)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                fixed (ushort* valueFixed = array)
                {
                    ushort* start = valueFixed + range.SkipCount;
                    value = *start;
                    for (ushort* end = start + count; ++start != end; )
                    {
                        if (*start < value) value = *start;
                    }
                    return true;
                }
            }
            value = ushort.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public unsafe static ushort min
            (this ushort[] array, int index, int count, ushort nullValue)
        {
            ushort value;
            return min(array, index, count, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>
            (this valueType[] array, func<valueType, ushort> getKey, out ushort value)
        {
            if (array.length() != 0)
            {
                value = getKey(array[0]);
                foreach (valueType nextValue in array)
                {
                    ushort nextKey = getKey(nextValue);
                    if (nextKey < value) value = nextKey;
                }
                return true;
            }
            value = ushort.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static ushort minKey<valueType>
            (this valueType[] array, func<valueType, ushort> getKey, ushort nullValue)
        {
            ushort value;
            return minKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>
            (this valueType[] array, int index, int count, func<valueType, ushort> getKey
            , out ushort value)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                value = getKey(array[index = range.SkipCount]);
                for (int endIndex = index + count; ++index != endIndex; )
                {
                    ushort nextValue = getKey(array[index]);
                    if (nextValue < value) value = nextValue;
                }
                return true;
            }
            value = ushort.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static ushort minKey<valueType>
            (this valueType[] array, int index, int count, func<valueType, ushort> getKey
            , ushort nullValue)
        {
            ushort value;
            return minKey(array, index, count, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>(this valueType[] array, func<valueType, ushort> getKey, out valueType value)
        {
            if (array.length() != 0)
            {
                value = array[0];
                ushort minKey = getKey(value);
                foreach (valueType nextValue in array)
                {
                    ushort nextKey = getKey(nextValue);
                    if (nextKey < minKey)
                    {
                        minKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static valueType min<valueType>(this valueType[] array, func<valueType, ushort> getKey, valueType nullValue)
        {
            valueType value;
            return min(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>
            (this valueType[] array, int index, int count, func<valueType, ushort> getKey, out valueType value)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                value = array[index = range.SkipCount];
                ushort minValue = getKey(value);
                for (int endIndex = index + count; ++index != endIndex; )
                {
                    ushort nextValue = getKey(array[index]);
                    if (nextValue < minValue)
                    {
                        minValue = nextValue;
                        value = array[index];
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static valueType min<valueType>
            (this valueType[] array, int index, int count, func<valueType, ushort> getKey, valueType nullValue)
        {
            valueType value;
            return min(array, index, count, getKey, out value) ? value : nullValue;
        }
    }
}

namespace fastCSharp.unsafer
{
    /// <summary>
    /// 数组非安全扩展操作(请自行确保数据可靠性)
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 移动数据块
        /// </summary>
        /// <param name="array">待处理数组</param>
        /// <param name="index">原始数据位置</param>
        /// <param name="writeIndex">目标数据位置</param>
        /// <param name="count">移动数据数量</param>
        public unsafe static void Move(ushort[] array, int index, int writeIndex, int count)
        {
            int endIndex = index + count;
            if (index < writeIndex && endIndex > writeIndex)
            {
                fixed (ushort* valueFixed = array)
                {
                    for (ushort* write = valueFixed + writeIndex + count, start = valueFixed + index, end = valueFixed + endIndex;
                        end != start;
                        *--write = *--end) ;
                }
            }
            else Array.Copy(array, index, array, writeIndex, count);
        }
    }
}
namespace fastCSharp
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="values">数据指针</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为null</returns>
        private unsafe static short* IndexOf
            (short* valueFixed, int length, short value)
        {
            for (short* start = valueFixed, end = valueFixed + length; start != end; ++start)
            {
                if (*start == value) return start;
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this short[] array, short value)
        {
            if (array != null)
            {
                fixed (short* valueFixed = array)
                {
                    short* valueIndex = IndexOf(valueFixed, array.Length, value);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this short[] array, int index, int length, short value)
        {
            array.range range = new array.range(array.length(), index, length);
            if ((length = range.GetCount) != 0)
            {
                fixed (short* valueFixed = array)
                {
                    short* valueIndex = IndexOf(valueFixed + range.SkipCount, length, value);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        public static short[] getReverse(this short[] array)
        {
            return array.length() != 0 ? GetReverse(array, 0, array.Length) : array.notNull();
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        /// <returns>翻转后的新数组</returns>
        public static short[] getReverse(this short[] array, int index, int length)
        {
            array.range range = new array.range(array.length(), index, length);
            if (((range.SkipCount ^ index) | (range.GetCount ^ length)) == 0)
            {
                return GetReverse(array, index, length);
            }
            log.Default.Throw(log.exceptionType.IndexOutOfRange);
            return null;
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        /// <returns>翻转后的新数组</returns>
        private unsafe static short[] GetReverse(short[] array, int index, int length)
        {
            short[] newValues = new short[length];
            fixed (short* valueFixed = array, newValueFixed = newValues)
            {
                for (short* start = valueFixed + index, end = start + length, wirte = newValueFixed + length;
                    start != end; 
                    *--wirte = *start++) ;
            }
            return newValues;
        }
        /// <summary>
        /// 移除第一个匹配数据数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配值</param>
        /// <returns>移除数据后的数组</returns>
        public unsafe static short[] removeFirst
            (this short[] array, short value)
        {
            if (array != null)
            {
                int index = -1;
                fixed (short* valueFixed = array)
                {
                    short* valueIndex = IndexOf(valueFixed, array.Length, value);
                    if (valueIndex != null) index = (int)(valueIndex - valueFixed);
                }
                if (index != -1) return GetRemoveAt(array, index);
            }
            return nullValue<short>.Array;
        }
        /// <summary>
        /// 移动数据块
        /// </summary>
        /// <param name="array">待处理数组</param>
        /// <param name="index">原始数据位置</param>
        /// <param name="writeIndex">目标数据位置</param>
        /// <param name="count">移动数据数量</param>
        public unsafe static void move(this short[] array, int index, int writeIndex, int count)
        {
            if (count > 0)
            {
                int writeEndIndex = writeIndex + count;
                if (index >= 0 && writeEndIndex <= array.Length)
                {
                    int endIndex = index + count;
                    if (index < writeIndex && endIndex > writeIndex)
                    {
                        fixed (short* valueFixed = array)
                        {
                            for (short* write = valueFixed + writeEndIndex, end = valueFixed + endIndex, start = valueFixed + index;
                                end != start;
                                *--write = *--end) ;
                        }
                    }
                    else if (writeIndex >= 0 && endIndex <= array.Length) Array.Copy(array, index, array, writeIndex, count);
                    else log.Default.Throw(log.exceptionType.IndexOutOfRange);
                }
                else log.Default.Throw(log.exceptionType.IndexOutOfRange);
            }
            else if (count != 0) log.Default.Throw(log.exceptionType.IndexOutOfRange);
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="values">数组数据</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为null</returns>
        private unsafe static short* IndexOf
            (short* valueFixed, int length, func<short, bool> isValue)
        {
            for (short* start = valueFixed, end = valueFixed + length; start != end; ++start)
            {
                if (isValue(*start)) return start;
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this short[] array, func<short, bool> isValue)
        {
            if (array != null)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                fixed (short* valueFixed = array)
                {
                    short* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf
            (this short[] array, int index, int length, func<short, bool> isValue)
        {
            array.range range = new array.range(array.length(), index, length);
            if ((length = range.GetCount) != 0)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                fixed (short* valueFixed = array)
                {
                    short* valueIndex = IndexOf(valueFixed + range.SkipCount, length, isValue);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="index">起始位置</param>
        /// <returns>第一个匹配值,失败为default(short)</returns>
        public unsafe static short firstOrDefault
            (this short[] array, func<short, bool> isValue, int index)
        {
            if (array != null && (uint)index < (uint)array.Length)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                fixed (short* valueFixed = array)
                {
                    short* valueIndex = IndexOf(valueFixed + index, array.Length - index, isValue);
                    if (valueIndex != null) return *valueIndex;
                }
            }
            return default(short);
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public unsafe static int count
            (this short[] array, int index, int count, func<short, bool> isValue)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                int value = 0;
                fixed (short* valueFixed = array)
                {
                    for (short* start = valueFixed + index, end = start + count; start != end; ++start)
                    {
                        if (isValue(*start)) ++value;
                    }
                }
                return value;
            }
            return 0;
        }
        /// <summary>
        /// 移除第一个匹配数据数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>移除数据后的数组</returns>
        public unsafe static short[] removeFirst
            (this short[] array, func<short, bool> isValue)
        {
            if (array != null)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                int index = -1;
                fixed (short* valueFixed = array)
                {
                    short* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) index = (int)(valueIndex - valueFixed);
                }
                if (index != -1) return GetRemoveAt(array, index);
                return array;
            }
            return nullValue<short>.Array;
        }
        /// <summary>
        /// 替换数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">新值</param>
        /// <param name="isValue">数据匹配器</param>
        public unsafe static short[] replaceFirst
            (this short[] array, short value, func<short, bool> isValue)
        {
            if (array != null)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                fixed (short* valueFixed = array)
                {
                    short* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) *valueIndex = value;
                }
                return array;
            }
            return nullValue<short>.Array;
        }
        /// <summary>
        /// 转换键值对集合
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="array">键值数组</param>
        /// <param name="values">数据数组</param>
        /// <returns>键值对数组</returns>
        public unsafe static keyValue<short, valueType>[] getKeyValue<valueType>
            (this short[] array, valueType[] values)
        {
            int length = array.length();
            if (length != values.length()) log.Default.Throw(log.exceptionType.IndexOutOfRange);
            if (length != 0)
            {
                keyValue<short, valueType>[] newValues = new keyValue<short, valueType>[values.Length];
                fixed (short* valueFixed = array)
                {
                    short* readValue = valueFixed;
                    int index = 0;
                    foreach (valueType value in values)
                    {
                        newValues[index].Set(*readValue++, value);
                        ++index;
                    }
                }
                return newValues;
            }
            return nullValue<keyValue<short, valueType>>.Array;
        }
        /// <summary>
        /// 数据转换
        /// </summary>
        /// <typeparam name="valueType">数组类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public unsafe static short[] getArray<valueType>
            (this valueType[] array, func<valueType, short> getValue)
        {
            if (array.length() != 0)
            {
                if (getValue == null) log.Default.Throw(log.exceptionType.Null);
                short[] newValues = new short[array.Length];
                fixed (short* newValueFixed = newValues)
                {
                    short* writeValue = newValueFixed;
                    foreach (valueType value in array) *writeValue++ = getValue(value);
                }
                return newValues;
            }
            return nullValue<short>.Array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public unsafe static list<short> getFind
            (this short[] array, func<short, bool> isValue)
        {
            if (array.length() != 0)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                short[] newValues = new short[array.Length < sizeof(int) ? sizeof(int) : array.Length];
                fixed (short* newValueFixed = newValues, valueFixed = array)
                {
                    short* write = newValueFixed;
                    for (short* start = valueFixed, end = valueFixed + array.Length; start != end; ++start)
                    {
                        if (isValue(*start)) *write++ = *start;
                    }
                    return new list<short>(newValues, 0, (int)(write - newValueFixed), true);
                }
            }
            return null;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public unsafe static list<short> getFind
            (this short[] array, int index, int count, func<short, bool> isValue)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                short[] newValues = new short[count < sizeof(int) ? sizeof(int) : count];
                fixed (short* newValueFixed = newValues, valueFixed = array)
                {
                    short* write = newValueFixed;
                    for (short* start = valueFixed + index, end = start + count; start != end; ++start)
                    {
                        if (isValue(*start)) *write++ = *start;
                    }
                    return new list<short>(newValues, 0, (int)(write - newValueFixed), true);
                }
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public unsafe static short[] getFindArray
            (this short[] array, func<short, bool> isValue)
        {
            if (isValue == null) log.Default.Throw(log.exceptionType.Null);
            int length = array.length();
            if (length != 0)
            {
                length = (length + 7) >> 3;
                if (length <= config.pub.Default.StreamBufferLength)
                {
                    byte* data = stackalloc byte[length];
                    return GetFindArray(array, 0, array.Length, isValue, new fixedMap(data, length));
                }
                else
                {
                    byte[] data = new byte[length];
                    fixed (byte* dataFixed = data) return GetFindArray(array, 0, array.Length, isValue, new fixedMap(dataFixed));
                }
            }
            return nullValue<short>.Array;
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public unsafe static short[] getFindArray
            (this short[] array, int index, int count, func<short, bool> isValue)
        {
            if (isValue == null) log.Default.Throw(log.exceptionType.Null);
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                int length = (count + 7) >> 3;
                if (length <= config.pub.Default.StreamBufferLength)
                {
                    byte* data = stackalloc byte[length];
                    return GetFindArray(array, range.SkipCount, count, isValue, new fixedMap(data, length));
                }
                else
                {
                    byte[] data = new byte[length];
                    fixed (byte* dataFixed = data) return GetFindArray(array, range.SkipCount, count, isValue, new fixedMap(dataFixed));
                }
            }
            return nullValue<short>.Array;
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="map">匹配结果位图</param>
        /// <returns>匹配数组</returns>
        private unsafe static short[] GetFindArray
            (short[] array, int index, int count, func<short, bool> isValue, fixedMap map)
        {
            int length = 0, mapIndex = 0;
            fixed (short* valueFixed = array)
            {
                short* startFixed = valueFixed + index, end = startFixed + count;
                for (short* start = startFixed; start != end; ++start, ++mapIndex)
                {
                    if (isValue(*start))
                    {
                        ++length;
                        map.Set(mapIndex);
                    }
                }
                if (length != 0)
                {
                    short[] newValues = new short[length];
                    fixed (short* newValueFixed = newValues)
                    {
                        short* write = newValueFixed + length;
                        while (mapIndex != 0)
                        {
                            if (map.Get(--mapIndex)) *--write = startFixed[mapIndex];
                        }
                    }
                    return newValues;
                }
            }
            return nullValue<short>.Array;
        }
        /// <summary>
        /// 取子集合
        /// </summary>
        /// <typeparam name="valueType">目标数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">数据数量</param>
        /// <param name="getVlaue">目标数据获取器</param>
        /// <returns>子集合</returns>
        public unsafe static valueType[] getSub<valueType>
            (this short[] array, int index, int count, func<short, valueType> getVlaue)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                if (getVlaue == null) log.Default.Throw(log.exceptionType.Null);
                valueType[] newValues = new valueType[count];
                fixed (short* valueFixed = array)
                {
                    short* read = valueFixed + range.SkipCount;
                    for (index = 0; index != count; ++index) newValues[index] = getVlaue(*read++);
                }
                return newValues;
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 取子集合
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">数据数量</param>
        /// <param name="getVlaue">数据获取器</param>
        /// <returns>子集合</returns>
        public unsafe static short[] getSub<valueType>
            (this valueType[] array, int index, int count, func<valueType, short> getValue)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                if (getValue == null) log.Default.Throw(log.exceptionType.Null);
                short[] newValues = new short[count];
                fixed (short* newValueFixed = newValues)
                {
                    short* write = newValueFixed;
                    for (index = range.SkipCount, count = range.EndIndex; index != count; ++index) *write++ = getValue(array[index]);
                }
                return newValues;
            }
            return nullValue<short>.Array;
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        public unsafe static list<valueType> distinct<valueType>
            (this short[] array, int index, int count, func<short, valueType> getValue)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                if (getValue == null) log.Default.Throw(log.exceptionType.Null);
                list<valueType>.unsafer newValues = new list<valueType>(count).Unsafer;
                System.Collections.Generic.HashSet<short> hash
                    = new System.Collections.Generic.HashSet<short>();
                fixed (short* valueFixed = array)
                {
                    for (short* start = valueFixed + range.SkipCount, end = start + count; start != end; ++start)
                    {
                        if (!hash.Contains(*start))
                        {
                            newValues.Add(getValue(*start));
                            hash.Add(*start);
                        }
                    }
                }
                return newValues.List;
            }
            return null;
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        public unsafe static list<short> distinct<valueType>
            (this valueType[] array, func<valueType, short> getValue)
        {
            if (array != null)
            {
                if (getValue == null) log.Default.Throw(log.exceptionType.Null);
                short[] newValues = new short[array.Length];
                System.Collections.Generic.HashSet<valueType> hash = new System.Collections.Generic.HashSet<valueType>();
                fixed (short* newValueFixed = newValues)
                {
                    short* write = newValueFixed;
                    foreach (valueType value in array)
                    {
                        if (!hash.Contains(value))
                        {
                            *write++ = getValue(value);
                            hash.Add(value);
                        }
                    }
                    return new list<short>(newValues, 0, (int)(write - newValueFixed), true);
                }
            }
            return null;
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        public unsafe static list<short> distinct<valueType>
            (this valueType[] array, int index, int count, func<valueType, short> getValue)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                if (getValue == null) log.Default.Throw(log.exceptionType.Null);
                short[] newValues = new short[count];
                System.Collections.Generic.HashSet<valueType> hash = new System.Collections.Generic.HashSet<valueType>();
                valueType value;
                fixed (short* newValueFixed = newValues)
                {
                    short* write = newValueFixed;
                    for (index = range.SkipCount, count = range.EndIndex; index != count; ++index)
                    {
                        if (!hash.Contains(value = array[index]))
                        {
                            *write++ = getValue(value);
                            hash.Add(value);
                        }
                    }
                    return new list<short>(newValues, 0, (int)(write - newValueFixed), true);
                }
            }
            return null;
        }
        /// <summary>
        /// 求交集
        /// </summary>
        /// <param name="left">左侧数据</param>
        /// <param name="right">右侧数据</param>
        /// <returns>数据交集</returns>
        public unsafe static list<short> intersect(this short[] left, short[] right)
        {
            int leftLength = left.length();
            if (leftLength != 0)
            {
                int rightLength = right.length();
                if (rightLength != 0)
                {
                    short[] min = leftLength <= rightLength ? left : right, values = new short[min.Length];
                    fixed (short* valueFixed = values)
                    {
                        short* write = valueFixed;
                        staticHashSet<short> hash = new staticHashSet<short>(min);
                        foreach (short value in leftLength <= rightLength ? right : left)
                        {
                            if (hash.Contains(value)) *write++ = value;
                        }
                        return new list<short>(values, 0, (int)(write - valueFixed), true);
                    }
                }
            }
            return null;
        }
        /// <summary>
        /// 遍历foreach
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">遍历数据数量</param>
        /// <param name="method">调用函数</param>
        /// <returns>数据数组</returns>
        public unsafe static short[] each
            (this short[] array, int index, int count, action<short> method)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                if (method == null) log.Default.Throw(log.exceptionType.Null);
                fixed (short* valueFixed = array)
                {
                    for (short* start = valueFixed + index, end = start + count; start != end; method(*start++)) ;
                }
                return array;
            }
            return nullValue<short>.Array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public unsafe static bool max(this short[] array, out short value)
        {
            if (array.length() != 0)
            {
                fixed (short* valueFixed = array)
                {
                    value = *valueFixed;
                    for (short* start = valueFixed + 1, end = valueFixed + array.Length; start != end; ++start)
                    {
                        if (*start > value) value = *start;
                    }
                    return true;
                }
            }
            value = short.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public unsafe static short max(this short[] array, short nullValue)
        {
            short value;
            return max(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public unsafe static bool max(this short[] array, int index, int count, out short value)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                fixed (short* valueFixed = array)
                {
                    short* start = valueFixed + range.SkipCount;
                    value = *start;
                    for (short* end = start + count; ++start != end; )
                    {
                        if (*start > value) value = *start;
                    }
                    return true;
                }
            }
            value = short.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public unsafe static short max
            (this short[] array, int index, int count, short nullValue)
        {
            short value;
            return max(array, index, count, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>
            (this valueType[] array, func<valueType, short> getKey, out short value)
        {
            if (array.length() != 0)
            {
                value = getKey(array[0]);
                foreach (valueType nextValue in array)
                {
                    short nextKey = getKey(nextValue);
                    if (nextKey > value) value = nextKey;
                }
                return true;
            }
            value = short.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static short maxKey<valueType>
            (this valueType[] array, func<valueType, short> getKey, short nullValue)
        {
            short value;
            return maxKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>
            (this valueType[] array, int index, int count, func<valueType, short> getKey
            , out short value)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                value = getKey(array[index = range.SkipCount]);
                for (int endIndex = index + count; ++index != endIndex; )
                {
                    short nextValue = getKey(array[index]);
                    if (nextValue > value) value = nextValue;
                }
                return true;
            }
            value = short.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static short maxKey<valueType>
            (this valueType[] array, int index, int count, func<valueType, short> getKey
            , short nullValue)
        {
            short value;
            return maxKey(array, index, count, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>
            (this valueType[] array, func<valueType, short> getKey, out valueType value)
        {
            if (array.length() != 0)
            {
                value = array[0];
                short maxKey = getKey(value);
                foreach (valueType nextValue in array)
                {
                    short nextKey = getKey(nextValue);
                    if (nextKey > maxKey)
                    {
                        maxKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static valueType max<valueType>(this valueType[] array, func<valueType, short> getKey, valueType nullValue)
        {
            valueType value;
            return max(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>
            (this valueType[] array, int index, int count, func<valueType, short> getKey, out valueType value)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                value = array[index = range.SkipCount];
                short maxValue = getKey(value);
                for (int endIndex = index + count; ++index != endIndex; )
                {
                    short nextValue = getKey(array[index]);
                    if (nextValue > maxValue)
                    {
                        maxValue = nextValue;
                        value = array[index];
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static valueType max<valueType>
            (this valueType[] array, int index, int count, func<valueType, short> getKey, valueType nullValue)
        {
            valueType value;
            return max(array, index, count, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public unsafe static bool min(this short[] array, out short value)
        {
            if (array.length() != 0)
            {
                fixed (short* valueFixed = array)
                {
                    value = *valueFixed;
                    for (short* start = valueFixed + 1, end = valueFixed + array.Length; start != end; ++start)
                    {
                        if (*start < value) value = *start;
                    }
                    return true;
                }
            }
            value = short.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public unsafe static short min(this short[] array, short nullValue)
        {
            short value;
            return min(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public unsafe static bool min(this short[] array, int index, int count, out short value)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                fixed (short* valueFixed = array)
                {
                    short* start = valueFixed + range.SkipCount;
                    value = *start;
                    for (short* end = start + count; ++start != end; )
                    {
                        if (*start < value) value = *start;
                    }
                    return true;
                }
            }
            value = short.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public unsafe static short min
            (this short[] array, int index, int count, short nullValue)
        {
            short value;
            return min(array, index, count, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>
            (this valueType[] array, func<valueType, short> getKey, out short value)
        {
            if (array.length() != 0)
            {
                value = getKey(array[0]);
                foreach (valueType nextValue in array)
                {
                    short nextKey = getKey(nextValue);
                    if (nextKey < value) value = nextKey;
                }
                return true;
            }
            value = short.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static short minKey<valueType>
            (this valueType[] array, func<valueType, short> getKey, short nullValue)
        {
            short value;
            return minKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>
            (this valueType[] array, int index, int count, func<valueType, short> getKey
            , out short value)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                value = getKey(array[index = range.SkipCount]);
                for (int endIndex = index + count; ++index != endIndex; )
                {
                    short nextValue = getKey(array[index]);
                    if (nextValue < value) value = nextValue;
                }
                return true;
            }
            value = short.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static short minKey<valueType>
            (this valueType[] array, int index, int count, func<valueType, short> getKey
            , short nullValue)
        {
            short value;
            return minKey(array, index, count, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>(this valueType[] array, func<valueType, short> getKey, out valueType value)
        {
            if (array.length() != 0)
            {
                value = array[0];
                short minKey = getKey(value);
                foreach (valueType nextValue in array)
                {
                    short nextKey = getKey(nextValue);
                    if (nextKey < minKey)
                    {
                        minKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static valueType min<valueType>(this valueType[] array, func<valueType, short> getKey, valueType nullValue)
        {
            valueType value;
            return min(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>
            (this valueType[] array, int index, int count, func<valueType, short> getKey, out valueType value)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                value = array[index = range.SkipCount];
                short minValue = getKey(value);
                for (int endIndex = index + count; ++index != endIndex; )
                {
                    short nextValue = getKey(array[index]);
                    if (nextValue < minValue)
                    {
                        minValue = nextValue;
                        value = array[index];
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static valueType min<valueType>
            (this valueType[] array, int index, int count, func<valueType, short> getKey, valueType nullValue)
        {
            valueType value;
            return min(array, index, count, getKey, out value) ? value : nullValue;
        }
    }
}

namespace fastCSharp.unsafer
{
    /// <summary>
    /// 数组非安全扩展操作(请自行确保数据可靠性)
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 移动数据块
        /// </summary>
        /// <param name="array">待处理数组</param>
        /// <param name="index">原始数据位置</param>
        /// <param name="writeIndex">目标数据位置</param>
        /// <param name="count">移动数据数量</param>
        public unsafe static void Move(short[] array, int index, int writeIndex, int count)
        {
            int endIndex = index + count;
            if (index < writeIndex && endIndex > writeIndex)
            {
                fixed (short* valueFixed = array)
                {
                    for (short* write = valueFixed + writeIndex + count, start = valueFixed + index, end = valueFixed + endIndex;
                        end != start;
                        *--write = *--end) ;
                }
            }
            else Array.Copy(array, index, array, writeIndex, count);
        }
    }
}
namespace fastCSharp
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="values">数据指针</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为null</returns>
        private unsafe static byte* IndexOf
            (byte* valueFixed, int length, byte value)
        {
            for (byte* start = valueFixed, end = valueFixed + length; start != end; ++start)
            {
                if (*start == value) return start;
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this byte[] array, byte value)
        {
            if (array != null)
            {
                fixed (byte* valueFixed = array)
                {
                    byte* valueIndex = IndexOf(valueFixed, array.Length, value);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this byte[] array, int index, int length, byte value)
        {
            array.range range = new array.range(array.length(), index, length);
            if ((length = range.GetCount) != 0)
            {
                fixed (byte* valueFixed = array)
                {
                    byte* valueIndex = IndexOf(valueFixed + range.SkipCount, length, value);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        public static byte[] getReverse(this byte[] array)
        {
            return array.length() != 0 ? GetReverse(array, 0, array.Length) : array.notNull();
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        /// <returns>翻转后的新数组</returns>
        public static byte[] getReverse(this byte[] array, int index, int length)
        {
            array.range range = new array.range(array.length(), index, length);
            if (((range.SkipCount ^ index) | (range.GetCount ^ length)) == 0)
            {
                return GetReverse(array, index, length);
            }
            log.Default.Throw(log.exceptionType.IndexOutOfRange);
            return null;
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        /// <returns>翻转后的新数组</returns>
        private unsafe static byte[] GetReverse(byte[] array, int index, int length)
        {
            byte[] newValues = new byte[length];
            fixed (byte* valueFixed = array, newValueFixed = newValues)
            {
                for (byte* start = valueFixed + index, end = start + length, wirte = newValueFixed + length;
                    start != end; 
                    *--wirte = *start++) ;
            }
            return newValues;
        }
        /// <summary>
        /// 移除第一个匹配数据数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配值</param>
        /// <returns>移除数据后的数组</returns>
        public unsafe static byte[] removeFirst
            (this byte[] array, byte value)
        {
            if (array != null)
            {
                int index = -1;
                fixed (byte* valueFixed = array)
                {
                    byte* valueIndex = IndexOf(valueFixed, array.Length, value);
                    if (valueIndex != null) index = (int)(valueIndex - valueFixed);
                }
                if (index != -1) return GetRemoveAt(array, index);
            }
            return nullValue<byte>.Array;
        }
        /// <summary>
        /// 移动数据块
        /// </summary>
        /// <param name="array">待处理数组</param>
        /// <param name="index">原始数据位置</param>
        /// <param name="writeIndex">目标数据位置</param>
        /// <param name="count">移动数据数量</param>
        public unsafe static void move(this byte[] array, int index, int writeIndex, int count)
        {
            if (count > 0)
            {
                int writeEndIndex = writeIndex + count;
                if (index >= 0 && writeEndIndex <= array.Length)
                {
                    int endIndex = index + count;
                    if (index < writeIndex && endIndex > writeIndex)
                    {
                        fixed (byte* valueFixed = array)
                        {
                            for (byte* write = valueFixed + writeEndIndex, end = valueFixed + endIndex, start = valueFixed + index;
                                end != start;
                                *--write = *--end) ;
                        }
                    }
                    else if (writeIndex >= 0 && endIndex <= array.Length) Array.Copy(array, index, array, writeIndex, count);
                    else log.Default.Throw(log.exceptionType.IndexOutOfRange);
                }
                else log.Default.Throw(log.exceptionType.IndexOutOfRange);
            }
            else if (count != 0) log.Default.Throw(log.exceptionType.IndexOutOfRange);
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="values">数组数据</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为null</returns>
        private unsafe static byte* IndexOf
            (byte* valueFixed, int length, func<byte, bool> isValue)
        {
            for (byte* start = valueFixed, end = valueFixed + length; start != end; ++start)
            {
                if (isValue(*start)) return start;
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this byte[] array, func<byte, bool> isValue)
        {
            if (array != null)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                fixed (byte* valueFixed = array)
                {
                    byte* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf
            (this byte[] array, int index, int length, func<byte, bool> isValue)
        {
            array.range range = new array.range(array.length(), index, length);
            if ((length = range.GetCount) != 0)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                fixed (byte* valueFixed = array)
                {
                    byte* valueIndex = IndexOf(valueFixed + range.SkipCount, length, isValue);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="index">起始位置</param>
        /// <returns>第一个匹配值,失败为default(byte)</returns>
        public unsafe static byte firstOrDefault
            (this byte[] array, func<byte, bool> isValue, int index)
        {
            if (array != null && (uint)index < (uint)array.Length)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                fixed (byte* valueFixed = array)
                {
                    byte* valueIndex = IndexOf(valueFixed + index, array.Length - index, isValue);
                    if (valueIndex != null) return *valueIndex;
                }
            }
            return default(byte);
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public unsafe static int count
            (this byte[] array, int index, int count, func<byte, bool> isValue)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                int value = 0;
                fixed (byte* valueFixed = array)
                {
                    for (byte* start = valueFixed + index, end = start + count; start != end; ++start)
                    {
                        if (isValue(*start)) ++value;
                    }
                }
                return value;
            }
            return 0;
        }
        /// <summary>
        /// 移除第一个匹配数据数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>移除数据后的数组</returns>
        public unsafe static byte[] removeFirst
            (this byte[] array, func<byte, bool> isValue)
        {
            if (array != null)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                int index = -1;
                fixed (byte* valueFixed = array)
                {
                    byte* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) index = (int)(valueIndex - valueFixed);
                }
                if (index != -1) return GetRemoveAt(array, index);
                return array;
            }
            return nullValue<byte>.Array;
        }
        /// <summary>
        /// 替换数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">新值</param>
        /// <param name="isValue">数据匹配器</param>
        public unsafe static byte[] replaceFirst
            (this byte[] array, byte value, func<byte, bool> isValue)
        {
            if (array != null)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                fixed (byte* valueFixed = array)
                {
                    byte* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) *valueIndex = value;
                }
                return array;
            }
            return nullValue<byte>.Array;
        }
        /// <summary>
        /// 转换键值对集合
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="array">键值数组</param>
        /// <param name="values">数据数组</param>
        /// <returns>键值对数组</returns>
        public unsafe static keyValue<byte, valueType>[] getKeyValue<valueType>
            (this byte[] array, valueType[] values)
        {
            int length = array.length();
            if (length != values.length()) log.Default.Throw(log.exceptionType.IndexOutOfRange);
            if (length != 0)
            {
                keyValue<byte, valueType>[] newValues = new keyValue<byte, valueType>[values.Length];
                fixed (byte* valueFixed = array)
                {
                    byte* readValue = valueFixed;
                    int index = 0;
                    foreach (valueType value in values)
                    {
                        newValues[index].Set(*readValue++, value);
                        ++index;
                    }
                }
                return newValues;
            }
            return nullValue<keyValue<byte, valueType>>.Array;
        }
        /// <summary>
        /// 数据转换
        /// </summary>
        /// <typeparam name="valueType">数组类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public unsafe static byte[] getArray<valueType>
            (this valueType[] array, func<valueType, byte> getValue)
        {
            if (array.length() != 0)
            {
                if (getValue == null) log.Default.Throw(log.exceptionType.Null);
                byte[] newValues = new byte[array.Length];
                fixed (byte* newValueFixed = newValues)
                {
                    byte* writeValue = newValueFixed;
                    foreach (valueType value in array) *writeValue++ = getValue(value);
                }
                return newValues;
            }
            return nullValue<byte>.Array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public unsafe static list<byte> getFind
            (this byte[] array, func<byte, bool> isValue)
        {
            if (array.length() != 0)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                byte[] newValues = new byte[array.Length < sizeof(int) ? sizeof(int) : array.Length];
                fixed (byte* newValueFixed = newValues, valueFixed = array)
                {
                    byte* write = newValueFixed;
                    for (byte* start = valueFixed, end = valueFixed + array.Length; start != end; ++start)
                    {
                        if (isValue(*start)) *write++ = *start;
                    }
                    return new list<byte>(newValues, 0, (int)(write - newValueFixed), true);
                }
            }
            return null;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public unsafe static list<byte> getFind
            (this byte[] array, int index, int count, func<byte, bool> isValue)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                byte[] newValues = new byte[count < sizeof(int) ? sizeof(int) : count];
                fixed (byte* newValueFixed = newValues, valueFixed = array)
                {
                    byte* write = newValueFixed;
                    for (byte* start = valueFixed + index, end = start + count; start != end; ++start)
                    {
                        if (isValue(*start)) *write++ = *start;
                    }
                    return new list<byte>(newValues, 0, (int)(write - newValueFixed), true);
                }
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public unsafe static byte[] getFindArray
            (this byte[] array, func<byte, bool> isValue)
        {
            if (isValue == null) log.Default.Throw(log.exceptionType.Null);
            int length = array.length();
            if (length != 0)
            {
                length = (length + 7) >> 3;
                if (length <= config.pub.Default.StreamBufferLength)
                {
                    byte* data = stackalloc byte[length];
                    return GetFindArray(array, 0, array.Length, isValue, new fixedMap(data, length));
                }
                else
                {
                    byte[] data = new byte[length];
                    fixed (byte* dataFixed = data) return GetFindArray(array, 0, array.Length, isValue, new fixedMap(dataFixed));
                }
            }
            return nullValue<byte>.Array;
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public unsafe static byte[] getFindArray
            (this byte[] array, int index, int count, func<byte, bool> isValue)
        {
            if (isValue == null) log.Default.Throw(log.exceptionType.Null);
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                int length = (count + 7) >> 3;
                if (length <= config.pub.Default.StreamBufferLength)
                {
                    byte* data = stackalloc byte[length];
                    return GetFindArray(array, range.SkipCount, count, isValue, new fixedMap(data, length));
                }
                else
                {
                    byte[] data = new byte[length];
                    fixed (byte* dataFixed = data) return GetFindArray(array, range.SkipCount, count, isValue, new fixedMap(dataFixed));
                }
            }
            return nullValue<byte>.Array;
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="map">匹配结果位图</param>
        /// <returns>匹配数组</returns>
        private unsafe static byte[] GetFindArray
            (byte[] array, int index, int count, func<byte, bool> isValue, fixedMap map)
        {
            int length = 0, mapIndex = 0;
            fixed (byte* valueFixed = array)
            {
                byte* startFixed = valueFixed + index, end = startFixed + count;
                for (byte* start = startFixed; start != end; ++start, ++mapIndex)
                {
                    if (isValue(*start))
                    {
                        ++length;
                        map.Set(mapIndex);
                    }
                }
                if (length != 0)
                {
                    byte[] newValues = new byte[length];
                    fixed (byte* newValueFixed = newValues)
                    {
                        byte* write = newValueFixed + length;
                        while (mapIndex != 0)
                        {
                            if (map.Get(--mapIndex)) *--write = startFixed[mapIndex];
                        }
                    }
                    return newValues;
                }
            }
            return nullValue<byte>.Array;
        }
        /// <summary>
        /// 取子集合
        /// </summary>
        /// <typeparam name="valueType">目标数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">数据数量</param>
        /// <param name="getVlaue">目标数据获取器</param>
        /// <returns>子集合</returns>
        public unsafe static valueType[] getSub<valueType>
            (this byte[] array, int index, int count, func<byte, valueType> getVlaue)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                if (getVlaue == null) log.Default.Throw(log.exceptionType.Null);
                valueType[] newValues = new valueType[count];
                fixed (byte* valueFixed = array)
                {
                    byte* read = valueFixed + range.SkipCount;
                    for (index = 0; index != count; ++index) newValues[index] = getVlaue(*read++);
                }
                return newValues;
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 取子集合
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">数据数量</param>
        /// <param name="getVlaue">数据获取器</param>
        /// <returns>子集合</returns>
        public unsafe static byte[] getSub<valueType>
            (this valueType[] array, int index, int count, func<valueType, byte> getValue)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                if (getValue == null) log.Default.Throw(log.exceptionType.Null);
                byte[] newValues = new byte[count];
                fixed (byte* newValueFixed = newValues)
                {
                    byte* write = newValueFixed;
                    for (index = range.SkipCount, count = range.EndIndex; index != count; ++index) *write++ = getValue(array[index]);
                }
                return newValues;
            }
            return nullValue<byte>.Array;
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        public unsafe static list<valueType> distinct<valueType>
            (this byte[] array, int index, int count, func<byte, valueType> getValue)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                if (getValue == null) log.Default.Throw(log.exceptionType.Null);
                list<valueType>.unsafer newValues = new list<valueType>(count).Unsafer;
                System.Collections.Generic.HashSet<byte> hash
                    = new System.Collections.Generic.HashSet<byte>();
                fixed (byte* valueFixed = array)
                {
                    for (byte* start = valueFixed + range.SkipCount, end = start + count; start != end; ++start)
                    {
                        if (!hash.Contains(*start))
                        {
                            newValues.Add(getValue(*start));
                            hash.Add(*start);
                        }
                    }
                }
                return newValues.List;
            }
            return null;
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        public unsafe static list<byte> distinct<valueType>
            (this valueType[] array, func<valueType, byte> getValue)
        {
            if (array != null)
            {
                if (getValue == null) log.Default.Throw(log.exceptionType.Null);
                byte[] newValues = new byte[array.Length];
                System.Collections.Generic.HashSet<valueType> hash = new System.Collections.Generic.HashSet<valueType>();
                fixed (byte* newValueFixed = newValues)
                {
                    byte* write = newValueFixed;
                    foreach (valueType value in array)
                    {
                        if (!hash.Contains(value))
                        {
                            *write++ = getValue(value);
                            hash.Add(value);
                        }
                    }
                    return new list<byte>(newValues, 0, (int)(write - newValueFixed), true);
                }
            }
            return null;
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        public unsafe static list<byte> distinct<valueType>
            (this valueType[] array, int index, int count, func<valueType, byte> getValue)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                if (getValue == null) log.Default.Throw(log.exceptionType.Null);
                byte[] newValues = new byte[count];
                System.Collections.Generic.HashSet<valueType> hash = new System.Collections.Generic.HashSet<valueType>();
                valueType value;
                fixed (byte* newValueFixed = newValues)
                {
                    byte* write = newValueFixed;
                    for (index = range.SkipCount, count = range.EndIndex; index != count; ++index)
                    {
                        if (!hash.Contains(value = array[index]))
                        {
                            *write++ = getValue(value);
                            hash.Add(value);
                        }
                    }
                    return new list<byte>(newValues, 0, (int)(write - newValueFixed), true);
                }
            }
            return null;
        }
        /// <summary>
        /// 求交集
        /// </summary>
        /// <param name="left">左侧数据</param>
        /// <param name="right">右侧数据</param>
        /// <returns>数据交集</returns>
        public unsafe static list<byte> intersect(this byte[] left, byte[] right)
        {
            int leftLength = left.length();
            if (leftLength != 0)
            {
                int rightLength = right.length();
                if (rightLength != 0)
                {
                    byte[] min = leftLength <= rightLength ? left : right, values = new byte[min.Length];
                    fixed (byte* valueFixed = values)
                    {
                        byte* write = valueFixed;
                        staticHashSet<byte> hash = new staticHashSet<byte>(min);
                        foreach (byte value in leftLength <= rightLength ? right : left)
                        {
                            if (hash.Contains(value)) *write++ = value;
                        }
                        return new list<byte>(values, 0, (int)(write - valueFixed), true);
                    }
                }
            }
            return null;
        }
        /// <summary>
        /// 遍历foreach
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">遍历数据数量</param>
        /// <param name="method">调用函数</param>
        /// <returns>数据数组</returns>
        public unsafe static byte[] each
            (this byte[] array, int index, int count, action<byte> method)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                if (method == null) log.Default.Throw(log.exceptionType.Null);
                fixed (byte* valueFixed = array)
                {
                    for (byte* start = valueFixed + index, end = start + count; start != end; method(*start++)) ;
                }
                return array;
            }
            return nullValue<byte>.Array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public unsafe static bool max(this byte[] array, out byte value)
        {
            if (array.length() != 0)
            {
                fixed (byte* valueFixed = array)
                {
                    value = *valueFixed;
                    for (byte* start = valueFixed + 1, end = valueFixed + array.Length; start != end; ++start)
                    {
                        if (*start > value) value = *start;
                    }
                    return true;
                }
            }
            value = byte.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public unsafe static byte max(this byte[] array, byte nullValue)
        {
            byte value;
            return max(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public unsafe static bool max(this byte[] array, int index, int count, out byte value)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                fixed (byte* valueFixed = array)
                {
                    byte* start = valueFixed + range.SkipCount;
                    value = *start;
                    for (byte* end = start + count; ++start != end; )
                    {
                        if (*start > value) value = *start;
                    }
                    return true;
                }
            }
            value = byte.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public unsafe static byte max
            (this byte[] array, int index, int count, byte nullValue)
        {
            byte value;
            return max(array, index, count, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>
            (this valueType[] array, func<valueType, byte> getKey, out byte value)
        {
            if (array.length() != 0)
            {
                value = getKey(array[0]);
                foreach (valueType nextValue in array)
                {
                    byte nextKey = getKey(nextValue);
                    if (nextKey > value) value = nextKey;
                }
                return true;
            }
            value = byte.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static byte maxKey<valueType>
            (this valueType[] array, func<valueType, byte> getKey, byte nullValue)
        {
            byte value;
            return maxKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>
            (this valueType[] array, int index, int count, func<valueType, byte> getKey
            , out byte value)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                value = getKey(array[index = range.SkipCount]);
                for (int endIndex = index + count; ++index != endIndex; )
                {
                    byte nextValue = getKey(array[index]);
                    if (nextValue > value) value = nextValue;
                }
                return true;
            }
            value = byte.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static byte maxKey<valueType>
            (this valueType[] array, int index, int count, func<valueType, byte> getKey
            , byte nullValue)
        {
            byte value;
            return maxKey(array, index, count, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>
            (this valueType[] array, func<valueType, byte> getKey, out valueType value)
        {
            if (array.length() != 0)
            {
                value = array[0];
                byte maxKey = getKey(value);
                foreach (valueType nextValue in array)
                {
                    byte nextKey = getKey(nextValue);
                    if (nextKey > maxKey)
                    {
                        maxKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static valueType max<valueType>(this valueType[] array, func<valueType, byte> getKey, valueType nullValue)
        {
            valueType value;
            return max(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>
            (this valueType[] array, int index, int count, func<valueType, byte> getKey, out valueType value)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                value = array[index = range.SkipCount];
                byte maxValue = getKey(value);
                for (int endIndex = index + count; ++index != endIndex; )
                {
                    byte nextValue = getKey(array[index]);
                    if (nextValue > maxValue)
                    {
                        maxValue = nextValue;
                        value = array[index];
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static valueType max<valueType>
            (this valueType[] array, int index, int count, func<valueType, byte> getKey, valueType nullValue)
        {
            valueType value;
            return max(array, index, count, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public unsafe static bool min(this byte[] array, out byte value)
        {
            if (array.length() != 0)
            {
                fixed (byte* valueFixed = array)
                {
                    value = *valueFixed;
                    for (byte* start = valueFixed + 1, end = valueFixed + array.Length; start != end; ++start)
                    {
                        if (*start < value) value = *start;
                    }
                    return true;
                }
            }
            value = byte.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public unsafe static byte min(this byte[] array, byte nullValue)
        {
            byte value;
            return min(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public unsafe static bool min(this byte[] array, int index, int count, out byte value)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                fixed (byte* valueFixed = array)
                {
                    byte* start = valueFixed + range.SkipCount;
                    value = *start;
                    for (byte* end = start + count; ++start != end; )
                    {
                        if (*start < value) value = *start;
                    }
                    return true;
                }
            }
            value = byte.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public unsafe static byte min
            (this byte[] array, int index, int count, byte nullValue)
        {
            byte value;
            return min(array, index, count, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>
            (this valueType[] array, func<valueType, byte> getKey, out byte value)
        {
            if (array.length() != 0)
            {
                value = getKey(array[0]);
                foreach (valueType nextValue in array)
                {
                    byte nextKey = getKey(nextValue);
                    if (nextKey < value) value = nextKey;
                }
                return true;
            }
            value = byte.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static byte minKey<valueType>
            (this valueType[] array, func<valueType, byte> getKey, byte nullValue)
        {
            byte value;
            return minKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>
            (this valueType[] array, int index, int count, func<valueType, byte> getKey
            , out byte value)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                value = getKey(array[index = range.SkipCount]);
                for (int endIndex = index + count; ++index != endIndex; )
                {
                    byte nextValue = getKey(array[index]);
                    if (nextValue < value) value = nextValue;
                }
                return true;
            }
            value = byte.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static byte minKey<valueType>
            (this valueType[] array, int index, int count, func<valueType, byte> getKey
            , byte nullValue)
        {
            byte value;
            return minKey(array, index, count, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>(this valueType[] array, func<valueType, byte> getKey, out valueType value)
        {
            if (array.length() != 0)
            {
                value = array[0];
                byte minKey = getKey(value);
                foreach (valueType nextValue in array)
                {
                    byte nextKey = getKey(nextValue);
                    if (nextKey < minKey)
                    {
                        minKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static valueType min<valueType>(this valueType[] array, func<valueType, byte> getKey, valueType nullValue)
        {
            valueType value;
            return min(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>
            (this valueType[] array, int index, int count, func<valueType, byte> getKey, out valueType value)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                value = array[index = range.SkipCount];
                byte minValue = getKey(value);
                for (int endIndex = index + count; ++index != endIndex; )
                {
                    byte nextValue = getKey(array[index]);
                    if (nextValue < minValue)
                    {
                        minValue = nextValue;
                        value = array[index];
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static valueType min<valueType>
            (this valueType[] array, int index, int count, func<valueType, byte> getKey, valueType nullValue)
        {
            valueType value;
            return min(array, index, count, getKey, out value) ? value : nullValue;
        }
    }
}

namespace fastCSharp.unsafer
{
    /// <summary>
    /// 数组非安全扩展操作(请自行确保数据可靠性)
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 移动数据块
        /// </summary>
        /// <param name="array">待处理数组</param>
        /// <param name="index">原始数据位置</param>
        /// <param name="writeIndex">目标数据位置</param>
        /// <param name="count">移动数据数量</param>
        public unsafe static void Move(byte[] array, int index, int writeIndex, int count)
        {
            int endIndex = index + count;
            if (index < writeIndex && endIndex > writeIndex)
            {
                fixed (byte* valueFixed = array)
                {
                    for (byte* write = valueFixed + writeIndex + count, start = valueFixed + index, end = valueFixed + endIndex;
                        end != start;
                        *--write = *--end) ;
                }
            }
            else Array.Copy(array, index, array, writeIndex, count);
        }
    }
}
namespace fastCSharp
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="values">数据指针</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为null</returns>
        private unsafe static sbyte* IndexOf
            (sbyte* valueFixed, int length, sbyte value)
        {
            for (sbyte* start = valueFixed, end = valueFixed + length; start != end; ++start)
            {
                if (*start == value) return start;
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this sbyte[] array, sbyte value)
        {
            if (array != null)
            {
                fixed (sbyte* valueFixed = array)
                {
                    sbyte* valueIndex = IndexOf(valueFixed, array.Length, value);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this sbyte[] array, int index, int length, sbyte value)
        {
            array.range range = new array.range(array.length(), index, length);
            if ((length = range.GetCount) != 0)
            {
                fixed (sbyte* valueFixed = array)
                {
                    sbyte* valueIndex = IndexOf(valueFixed + range.SkipCount, length, value);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        public static sbyte[] getReverse(this sbyte[] array)
        {
            return array.length() != 0 ? GetReverse(array, 0, array.Length) : array.notNull();
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        /// <returns>翻转后的新数组</returns>
        public static sbyte[] getReverse(this sbyte[] array, int index, int length)
        {
            array.range range = new array.range(array.length(), index, length);
            if (((range.SkipCount ^ index) | (range.GetCount ^ length)) == 0)
            {
                return GetReverse(array, index, length);
            }
            log.Default.Throw(log.exceptionType.IndexOutOfRange);
            return null;
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        /// <returns>翻转后的新数组</returns>
        private unsafe static sbyte[] GetReverse(sbyte[] array, int index, int length)
        {
            sbyte[] newValues = new sbyte[length];
            fixed (sbyte* valueFixed = array, newValueFixed = newValues)
            {
                for (sbyte* start = valueFixed + index, end = start + length, wirte = newValueFixed + length;
                    start != end; 
                    *--wirte = *start++) ;
            }
            return newValues;
        }
        /// <summary>
        /// 移除第一个匹配数据数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配值</param>
        /// <returns>移除数据后的数组</returns>
        public unsafe static sbyte[] removeFirst
            (this sbyte[] array, sbyte value)
        {
            if (array != null)
            {
                int index = -1;
                fixed (sbyte* valueFixed = array)
                {
                    sbyte* valueIndex = IndexOf(valueFixed, array.Length, value);
                    if (valueIndex != null) index = (int)(valueIndex - valueFixed);
                }
                if (index != -1) return GetRemoveAt(array, index);
            }
            return nullValue<sbyte>.Array;
        }
        /// <summary>
        /// 移动数据块
        /// </summary>
        /// <param name="array">待处理数组</param>
        /// <param name="index">原始数据位置</param>
        /// <param name="writeIndex">目标数据位置</param>
        /// <param name="count">移动数据数量</param>
        public unsafe static void move(this sbyte[] array, int index, int writeIndex, int count)
        {
            if (count > 0)
            {
                int writeEndIndex = writeIndex + count;
                if (index >= 0 && writeEndIndex <= array.Length)
                {
                    int endIndex = index + count;
                    if (index < writeIndex && endIndex > writeIndex)
                    {
                        fixed (sbyte* valueFixed = array)
                        {
                            for (sbyte* write = valueFixed + writeEndIndex, end = valueFixed + endIndex, start = valueFixed + index;
                                end != start;
                                *--write = *--end) ;
                        }
                    }
                    else if (writeIndex >= 0 && endIndex <= array.Length) Array.Copy(array, index, array, writeIndex, count);
                    else log.Default.Throw(log.exceptionType.IndexOutOfRange);
                }
                else log.Default.Throw(log.exceptionType.IndexOutOfRange);
            }
            else if (count != 0) log.Default.Throw(log.exceptionType.IndexOutOfRange);
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="values">数组数据</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为null</returns>
        private unsafe static sbyte* IndexOf
            (sbyte* valueFixed, int length, func<sbyte, bool> isValue)
        {
            for (sbyte* start = valueFixed, end = valueFixed + length; start != end; ++start)
            {
                if (isValue(*start)) return start;
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this sbyte[] array, func<sbyte, bool> isValue)
        {
            if (array != null)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                fixed (sbyte* valueFixed = array)
                {
                    sbyte* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf
            (this sbyte[] array, int index, int length, func<sbyte, bool> isValue)
        {
            array.range range = new array.range(array.length(), index, length);
            if ((length = range.GetCount) != 0)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                fixed (sbyte* valueFixed = array)
                {
                    sbyte* valueIndex = IndexOf(valueFixed + range.SkipCount, length, isValue);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="index">起始位置</param>
        /// <returns>第一个匹配值,失败为default(sbyte)</returns>
        public unsafe static sbyte firstOrDefault
            (this sbyte[] array, func<sbyte, bool> isValue, int index)
        {
            if (array != null && (uint)index < (uint)array.Length)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                fixed (sbyte* valueFixed = array)
                {
                    sbyte* valueIndex = IndexOf(valueFixed + index, array.Length - index, isValue);
                    if (valueIndex != null) return *valueIndex;
                }
            }
            return default(sbyte);
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public unsafe static int count
            (this sbyte[] array, int index, int count, func<sbyte, bool> isValue)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                int value = 0;
                fixed (sbyte* valueFixed = array)
                {
                    for (sbyte* start = valueFixed + index, end = start + count; start != end; ++start)
                    {
                        if (isValue(*start)) ++value;
                    }
                }
                return value;
            }
            return 0;
        }
        /// <summary>
        /// 移除第一个匹配数据数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>移除数据后的数组</returns>
        public unsafe static sbyte[] removeFirst
            (this sbyte[] array, func<sbyte, bool> isValue)
        {
            if (array != null)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                int index = -1;
                fixed (sbyte* valueFixed = array)
                {
                    sbyte* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) index = (int)(valueIndex - valueFixed);
                }
                if (index != -1) return GetRemoveAt(array, index);
                return array;
            }
            return nullValue<sbyte>.Array;
        }
        /// <summary>
        /// 替换数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">新值</param>
        /// <param name="isValue">数据匹配器</param>
        public unsafe static sbyte[] replaceFirst
            (this sbyte[] array, sbyte value, func<sbyte, bool> isValue)
        {
            if (array != null)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                fixed (sbyte* valueFixed = array)
                {
                    sbyte* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) *valueIndex = value;
                }
                return array;
            }
            return nullValue<sbyte>.Array;
        }
        /// <summary>
        /// 转换键值对集合
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="array">键值数组</param>
        /// <param name="values">数据数组</param>
        /// <returns>键值对数组</returns>
        public unsafe static keyValue<sbyte, valueType>[] getKeyValue<valueType>
            (this sbyte[] array, valueType[] values)
        {
            int length = array.length();
            if (length != values.length()) log.Default.Throw(log.exceptionType.IndexOutOfRange);
            if (length != 0)
            {
                keyValue<sbyte, valueType>[] newValues = new keyValue<sbyte, valueType>[values.Length];
                fixed (sbyte* valueFixed = array)
                {
                    sbyte* readValue = valueFixed;
                    int index = 0;
                    foreach (valueType value in values)
                    {
                        newValues[index].Set(*readValue++, value);
                        ++index;
                    }
                }
                return newValues;
            }
            return nullValue<keyValue<sbyte, valueType>>.Array;
        }
        /// <summary>
        /// 数据转换
        /// </summary>
        /// <typeparam name="valueType">数组类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public unsafe static sbyte[] getArray<valueType>
            (this valueType[] array, func<valueType, sbyte> getValue)
        {
            if (array.length() != 0)
            {
                if (getValue == null) log.Default.Throw(log.exceptionType.Null);
                sbyte[] newValues = new sbyte[array.Length];
                fixed (sbyte* newValueFixed = newValues)
                {
                    sbyte* writeValue = newValueFixed;
                    foreach (valueType value in array) *writeValue++ = getValue(value);
                }
                return newValues;
            }
            return nullValue<sbyte>.Array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public unsafe static list<sbyte> getFind
            (this sbyte[] array, func<sbyte, bool> isValue)
        {
            if (array.length() != 0)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                sbyte[] newValues = new sbyte[array.Length < sizeof(int) ? sizeof(int) : array.Length];
                fixed (sbyte* newValueFixed = newValues, valueFixed = array)
                {
                    sbyte* write = newValueFixed;
                    for (sbyte* start = valueFixed, end = valueFixed + array.Length; start != end; ++start)
                    {
                        if (isValue(*start)) *write++ = *start;
                    }
                    return new list<sbyte>(newValues, 0, (int)(write - newValueFixed), true);
                }
            }
            return null;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public unsafe static list<sbyte> getFind
            (this sbyte[] array, int index, int count, func<sbyte, bool> isValue)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                sbyte[] newValues = new sbyte[count < sizeof(int) ? sizeof(int) : count];
                fixed (sbyte* newValueFixed = newValues, valueFixed = array)
                {
                    sbyte* write = newValueFixed;
                    for (sbyte* start = valueFixed + index, end = start + count; start != end; ++start)
                    {
                        if (isValue(*start)) *write++ = *start;
                    }
                    return new list<sbyte>(newValues, 0, (int)(write - newValueFixed), true);
                }
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public unsafe static sbyte[] getFindArray
            (this sbyte[] array, func<sbyte, bool> isValue)
        {
            if (isValue == null) log.Default.Throw(log.exceptionType.Null);
            int length = array.length();
            if (length != 0)
            {
                length = (length + 7) >> 3;
                if (length <= config.pub.Default.StreamBufferLength)
                {
                    byte* data = stackalloc byte[length];
                    return GetFindArray(array, 0, array.Length, isValue, new fixedMap(data, length));
                }
                else
                {
                    byte[] data = new byte[length];
                    fixed (byte* dataFixed = data) return GetFindArray(array, 0, array.Length, isValue, new fixedMap(dataFixed));
                }
            }
            return nullValue<sbyte>.Array;
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public unsafe static sbyte[] getFindArray
            (this sbyte[] array, int index, int count, func<sbyte, bool> isValue)
        {
            if (isValue == null) log.Default.Throw(log.exceptionType.Null);
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                int length = (count + 7) >> 3;
                if (length <= config.pub.Default.StreamBufferLength)
                {
                    byte* data = stackalloc byte[length];
                    return GetFindArray(array, range.SkipCount, count, isValue, new fixedMap(data, length));
                }
                else
                {
                    byte[] data = new byte[length];
                    fixed (byte* dataFixed = data) return GetFindArray(array, range.SkipCount, count, isValue, new fixedMap(dataFixed));
                }
            }
            return nullValue<sbyte>.Array;
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="map">匹配结果位图</param>
        /// <returns>匹配数组</returns>
        private unsafe static sbyte[] GetFindArray
            (sbyte[] array, int index, int count, func<sbyte, bool> isValue, fixedMap map)
        {
            int length = 0, mapIndex = 0;
            fixed (sbyte* valueFixed = array)
            {
                sbyte* startFixed = valueFixed + index, end = startFixed + count;
                for (sbyte* start = startFixed; start != end; ++start, ++mapIndex)
                {
                    if (isValue(*start))
                    {
                        ++length;
                        map.Set(mapIndex);
                    }
                }
                if (length != 0)
                {
                    sbyte[] newValues = new sbyte[length];
                    fixed (sbyte* newValueFixed = newValues)
                    {
                        sbyte* write = newValueFixed + length;
                        while (mapIndex != 0)
                        {
                            if (map.Get(--mapIndex)) *--write = startFixed[mapIndex];
                        }
                    }
                    return newValues;
                }
            }
            return nullValue<sbyte>.Array;
        }
        /// <summary>
        /// 取子集合
        /// </summary>
        /// <typeparam name="valueType">目标数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">数据数量</param>
        /// <param name="getVlaue">目标数据获取器</param>
        /// <returns>子集合</returns>
        public unsafe static valueType[] getSub<valueType>
            (this sbyte[] array, int index, int count, func<sbyte, valueType> getVlaue)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                if (getVlaue == null) log.Default.Throw(log.exceptionType.Null);
                valueType[] newValues = new valueType[count];
                fixed (sbyte* valueFixed = array)
                {
                    sbyte* read = valueFixed + range.SkipCount;
                    for (index = 0; index != count; ++index) newValues[index] = getVlaue(*read++);
                }
                return newValues;
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 取子集合
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">数据数量</param>
        /// <param name="getVlaue">数据获取器</param>
        /// <returns>子集合</returns>
        public unsafe static sbyte[] getSub<valueType>
            (this valueType[] array, int index, int count, func<valueType, sbyte> getValue)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                if (getValue == null) log.Default.Throw(log.exceptionType.Null);
                sbyte[] newValues = new sbyte[count];
                fixed (sbyte* newValueFixed = newValues)
                {
                    sbyte* write = newValueFixed;
                    for (index = range.SkipCount, count = range.EndIndex; index != count; ++index) *write++ = getValue(array[index]);
                }
                return newValues;
            }
            return nullValue<sbyte>.Array;
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        public unsafe static list<valueType> distinct<valueType>
            (this sbyte[] array, int index, int count, func<sbyte, valueType> getValue)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                if (getValue == null) log.Default.Throw(log.exceptionType.Null);
                list<valueType>.unsafer newValues = new list<valueType>(count).Unsafer;
                System.Collections.Generic.HashSet<sbyte> hash
                    = new System.Collections.Generic.HashSet<sbyte>();
                fixed (sbyte* valueFixed = array)
                {
                    for (sbyte* start = valueFixed + range.SkipCount, end = start + count; start != end; ++start)
                    {
                        if (!hash.Contains(*start))
                        {
                            newValues.Add(getValue(*start));
                            hash.Add(*start);
                        }
                    }
                }
                return newValues.List;
            }
            return null;
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        public unsafe static list<sbyte> distinct<valueType>
            (this valueType[] array, func<valueType, sbyte> getValue)
        {
            if (array != null)
            {
                if (getValue == null) log.Default.Throw(log.exceptionType.Null);
                sbyte[] newValues = new sbyte[array.Length];
                System.Collections.Generic.HashSet<valueType> hash = new System.Collections.Generic.HashSet<valueType>();
                fixed (sbyte* newValueFixed = newValues)
                {
                    sbyte* write = newValueFixed;
                    foreach (valueType value in array)
                    {
                        if (!hash.Contains(value))
                        {
                            *write++ = getValue(value);
                            hash.Add(value);
                        }
                    }
                    return new list<sbyte>(newValues, 0, (int)(write - newValueFixed), true);
                }
            }
            return null;
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        public unsafe static list<sbyte> distinct<valueType>
            (this valueType[] array, int index, int count, func<valueType, sbyte> getValue)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                if (getValue == null) log.Default.Throw(log.exceptionType.Null);
                sbyte[] newValues = new sbyte[count];
                System.Collections.Generic.HashSet<valueType> hash = new System.Collections.Generic.HashSet<valueType>();
                valueType value;
                fixed (sbyte* newValueFixed = newValues)
                {
                    sbyte* write = newValueFixed;
                    for (index = range.SkipCount, count = range.EndIndex; index != count; ++index)
                    {
                        if (!hash.Contains(value = array[index]))
                        {
                            *write++ = getValue(value);
                            hash.Add(value);
                        }
                    }
                    return new list<sbyte>(newValues, 0, (int)(write - newValueFixed), true);
                }
            }
            return null;
        }
        /// <summary>
        /// 求交集
        /// </summary>
        /// <param name="left">左侧数据</param>
        /// <param name="right">右侧数据</param>
        /// <returns>数据交集</returns>
        public unsafe static list<sbyte> intersect(this sbyte[] left, sbyte[] right)
        {
            int leftLength = left.length();
            if (leftLength != 0)
            {
                int rightLength = right.length();
                if (rightLength != 0)
                {
                    sbyte[] min = leftLength <= rightLength ? left : right, values = new sbyte[min.Length];
                    fixed (sbyte* valueFixed = values)
                    {
                        sbyte* write = valueFixed;
                        staticHashSet<sbyte> hash = new staticHashSet<sbyte>(min);
                        foreach (sbyte value in leftLength <= rightLength ? right : left)
                        {
                            if (hash.Contains(value)) *write++ = value;
                        }
                        return new list<sbyte>(values, 0, (int)(write - valueFixed), true);
                    }
                }
            }
            return null;
        }
        /// <summary>
        /// 遍历foreach
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">遍历数据数量</param>
        /// <param name="method">调用函数</param>
        /// <returns>数据数组</returns>
        public unsafe static sbyte[] each
            (this sbyte[] array, int index, int count, action<sbyte> method)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                if (method == null) log.Default.Throw(log.exceptionType.Null);
                fixed (sbyte* valueFixed = array)
                {
                    for (sbyte* start = valueFixed + index, end = start + count; start != end; method(*start++)) ;
                }
                return array;
            }
            return nullValue<sbyte>.Array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public unsafe static bool max(this sbyte[] array, out sbyte value)
        {
            if (array.length() != 0)
            {
                fixed (sbyte* valueFixed = array)
                {
                    value = *valueFixed;
                    for (sbyte* start = valueFixed + 1, end = valueFixed + array.Length; start != end; ++start)
                    {
                        if (*start > value) value = *start;
                    }
                    return true;
                }
            }
            value = sbyte.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public unsafe static sbyte max(this sbyte[] array, sbyte nullValue)
        {
            sbyte value;
            return max(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public unsafe static bool max(this sbyte[] array, int index, int count, out sbyte value)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                fixed (sbyte* valueFixed = array)
                {
                    sbyte* start = valueFixed + range.SkipCount;
                    value = *start;
                    for (sbyte* end = start + count; ++start != end; )
                    {
                        if (*start > value) value = *start;
                    }
                    return true;
                }
            }
            value = sbyte.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public unsafe static sbyte max
            (this sbyte[] array, int index, int count, sbyte nullValue)
        {
            sbyte value;
            return max(array, index, count, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>
            (this valueType[] array, func<valueType, sbyte> getKey, out sbyte value)
        {
            if (array.length() != 0)
            {
                value = getKey(array[0]);
                foreach (valueType nextValue in array)
                {
                    sbyte nextKey = getKey(nextValue);
                    if (nextKey > value) value = nextKey;
                }
                return true;
            }
            value = sbyte.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static sbyte maxKey<valueType>
            (this valueType[] array, func<valueType, sbyte> getKey, sbyte nullValue)
        {
            sbyte value;
            return maxKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>
            (this valueType[] array, int index, int count, func<valueType, sbyte> getKey
            , out sbyte value)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                value = getKey(array[index = range.SkipCount]);
                for (int endIndex = index + count; ++index != endIndex; )
                {
                    sbyte nextValue = getKey(array[index]);
                    if (nextValue > value) value = nextValue;
                }
                return true;
            }
            value = sbyte.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static sbyte maxKey<valueType>
            (this valueType[] array, int index, int count, func<valueType, sbyte> getKey
            , sbyte nullValue)
        {
            sbyte value;
            return maxKey(array, index, count, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>
            (this valueType[] array, func<valueType, sbyte> getKey, out valueType value)
        {
            if (array.length() != 0)
            {
                value = array[0];
                sbyte maxKey = getKey(value);
                foreach (valueType nextValue in array)
                {
                    sbyte nextKey = getKey(nextValue);
                    if (nextKey > maxKey)
                    {
                        maxKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static valueType max<valueType>(this valueType[] array, func<valueType, sbyte> getKey, valueType nullValue)
        {
            valueType value;
            return max(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>
            (this valueType[] array, int index, int count, func<valueType, sbyte> getKey, out valueType value)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                value = array[index = range.SkipCount];
                sbyte maxValue = getKey(value);
                for (int endIndex = index + count; ++index != endIndex; )
                {
                    sbyte nextValue = getKey(array[index]);
                    if (nextValue > maxValue)
                    {
                        maxValue = nextValue;
                        value = array[index];
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static valueType max<valueType>
            (this valueType[] array, int index, int count, func<valueType, sbyte> getKey, valueType nullValue)
        {
            valueType value;
            return max(array, index, count, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public unsafe static bool min(this sbyte[] array, out sbyte value)
        {
            if (array.length() != 0)
            {
                fixed (sbyte* valueFixed = array)
                {
                    value = *valueFixed;
                    for (sbyte* start = valueFixed + 1, end = valueFixed + array.Length; start != end; ++start)
                    {
                        if (*start < value) value = *start;
                    }
                    return true;
                }
            }
            value = sbyte.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public unsafe static sbyte min(this sbyte[] array, sbyte nullValue)
        {
            sbyte value;
            return min(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public unsafe static bool min(this sbyte[] array, int index, int count, out sbyte value)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                fixed (sbyte* valueFixed = array)
                {
                    sbyte* start = valueFixed + range.SkipCount;
                    value = *start;
                    for (sbyte* end = start + count; ++start != end; )
                    {
                        if (*start < value) value = *start;
                    }
                    return true;
                }
            }
            value = sbyte.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public unsafe static sbyte min
            (this sbyte[] array, int index, int count, sbyte nullValue)
        {
            sbyte value;
            return min(array, index, count, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>
            (this valueType[] array, func<valueType, sbyte> getKey, out sbyte value)
        {
            if (array.length() != 0)
            {
                value = getKey(array[0]);
                foreach (valueType nextValue in array)
                {
                    sbyte nextKey = getKey(nextValue);
                    if (nextKey < value) value = nextKey;
                }
                return true;
            }
            value = sbyte.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static sbyte minKey<valueType>
            (this valueType[] array, func<valueType, sbyte> getKey, sbyte nullValue)
        {
            sbyte value;
            return minKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>
            (this valueType[] array, int index, int count, func<valueType, sbyte> getKey
            , out sbyte value)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                value = getKey(array[index = range.SkipCount]);
                for (int endIndex = index + count; ++index != endIndex; )
                {
                    sbyte nextValue = getKey(array[index]);
                    if (nextValue < value) value = nextValue;
                }
                return true;
            }
            value = sbyte.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static sbyte minKey<valueType>
            (this valueType[] array, int index, int count, func<valueType, sbyte> getKey
            , sbyte nullValue)
        {
            sbyte value;
            return minKey(array, index, count, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>(this valueType[] array, func<valueType, sbyte> getKey, out valueType value)
        {
            if (array.length() != 0)
            {
                value = array[0];
                sbyte minKey = getKey(value);
                foreach (valueType nextValue in array)
                {
                    sbyte nextKey = getKey(nextValue);
                    if (nextKey < minKey)
                    {
                        minKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static valueType min<valueType>(this valueType[] array, func<valueType, sbyte> getKey, valueType nullValue)
        {
            valueType value;
            return min(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>
            (this valueType[] array, int index, int count, func<valueType, sbyte> getKey, out valueType value)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                value = array[index = range.SkipCount];
                sbyte minValue = getKey(value);
                for (int endIndex = index + count; ++index != endIndex; )
                {
                    sbyte nextValue = getKey(array[index]);
                    if (nextValue < minValue)
                    {
                        minValue = nextValue;
                        value = array[index];
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static valueType min<valueType>
            (this valueType[] array, int index, int count, func<valueType, sbyte> getKey, valueType nullValue)
        {
            valueType value;
            return min(array, index, count, getKey, out value) ? value : nullValue;
        }
    }
}

namespace fastCSharp.unsafer
{
    /// <summary>
    /// 数组非安全扩展操作(请自行确保数据可靠性)
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 移动数据块
        /// </summary>
        /// <param name="array">待处理数组</param>
        /// <param name="index">原始数据位置</param>
        /// <param name="writeIndex">目标数据位置</param>
        /// <param name="count">移动数据数量</param>
        public unsafe static void Move(sbyte[] array, int index, int writeIndex, int count)
        {
            int endIndex = index + count;
            if (index < writeIndex && endIndex > writeIndex)
            {
                fixed (sbyte* valueFixed = array)
                {
                    for (sbyte* write = valueFixed + writeIndex + count, start = valueFixed + index, end = valueFixed + endIndex;
                        end != start;
                        *--write = *--end) ;
                }
            }
            else Array.Copy(array, index, array, writeIndex, count);
        }
    }
}
namespace fastCSharp
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="values">数据指针</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为null</returns>
        private unsafe static double* IndexOf
            (double* valueFixed, int length, double value)
        {
            for (double* start = valueFixed, end = valueFixed + length; start != end; ++start)
            {
                if (*start == value) return start;
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this double[] array, double value)
        {
            if (array != null)
            {
                fixed (double* valueFixed = array)
                {
                    double* valueIndex = IndexOf(valueFixed, array.Length, value);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this double[] array, int index, int length, double value)
        {
            array.range range = new array.range(array.length(), index, length);
            if ((length = range.GetCount) != 0)
            {
                fixed (double* valueFixed = array)
                {
                    double* valueIndex = IndexOf(valueFixed + range.SkipCount, length, value);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        public static double[] getReverse(this double[] array)
        {
            return array.length() != 0 ? GetReverse(array, 0, array.Length) : array.notNull();
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        /// <returns>翻转后的新数组</returns>
        public static double[] getReverse(this double[] array, int index, int length)
        {
            array.range range = new array.range(array.length(), index, length);
            if (((range.SkipCount ^ index) | (range.GetCount ^ length)) == 0)
            {
                return GetReverse(array, index, length);
            }
            log.Default.Throw(log.exceptionType.IndexOutOfRange);
            return null;
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        /// <returns>翻转后的新数组</returns>
        private unsafe static double[] GetReverse(double[] array, int index, int length)
        {
            double[] newValues = new double[length];
            fixed (double* valueFixed = array, newValueFixed = newValues)
            {
                for (double* start = valueFixed + index, end = start + length, wirte = newValueFixed + length;
                    start != end; 
                    *--wirte = *start++) ;
            }
            return newValues;
        }
        /// <summary>
        /// 移除第一个匹配数据数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配值</param>
        /// <returns>移除数据后的数组</returns>
        public unsafe static double[] removeFirst
            (this double[] array, double value)
        {
            if (array != null)
            {
                int index = -1;
                fixed (double* valueFixed = array)
                {
                    double* valueIndex = IndexOf(valueFixed, array.Length, value);
                    if (valueIndex != null) index = (int)(valueIndex - valueFixed);
                }
                if (index != -1) return GetRemoveAt(array, index);
            }
            return nullValue<double>.Array;
        }
        /// <summary>
        /// 移动数据块
        /// </summary>
        /// <param name="array">待处理数组</param>
        /// <param name="index">原始数据位置</param>
        /// <param name="writeIndex">目标数据位置</param>
        /// <param name="count">移动数据数量</param>
        public unsafe static void move(this double[] array, int index, int writeIndex, int count)
        {
            if (count > 0)
            {
                int writeEndIndex = writeIndex + count;
                if (index >= 0 && writeEndIndex <= array.Length)
                {
                    int endIndex = index + count;
                    if (index < writeIndex && endIndex > writeIndex)
                    {
                        fixed (double* valueFixed = array)
                        {
                            for (double* write = valueFixed + writeEndIndex, end = valueFixed + endIndex, start = valueFixed + index;
                                end != start;
                                *--write = *--end) ;
                        }
                    }
                    else if (writeIndex >= 0 && endIndex <= array.Length) Array.Copy(array, index, array, writeIndex, count);
                    else log.Default.Throw(log.exceptionType.IndexOutOfRange);
                }
                else log.Default.Throw(log.exceptionType.IndexOutOfRange);
            }
            else if (count != 0) log.Default.Throw(log.exceptionType.IndexOutOfRange);
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="values">数组数据</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为null</returns>
        private unsafe static double* IndexOf
            (double* valueFixed, int length, func<double, bool> isValue)
        {
            for (double* start = valueFixed, end = valueFixed + length; start != end; ++start)
            {
                if (isValue(*start)) return start;
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this double[] array, func<double, bool> isValue)
        {
            if (array != null)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                fixed (double* valueFixed = array)
                {
                    double* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf
            (this double[] array, int index, int length, func<double, bool> isValue)
        {
            array.range range = new array.range(array.length(), index, length);
            if ((length = range.GetCount) != 0)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                fixed (double* valueFixed = array)
                {
                    double* valueIndex = IndexOf(valueFixed + range.SkipCount, length, isValue);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="index">起始位置</param>
        /// <returns>第一个匹配值,失败为default(double)</returns>
        public unsafe static double firstOrDefault
            (this double[] array, func<double, bool> isValue, int index)
        {
            if (array != null && (uint)index < (uint)array.Length)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                fixed (double* valueFixed = array)
                {
                    double* valueIndex = IndexOf(valueFixed + index, array.Length - index, isValue);
                    if (valueIndex != null) return *valueIndex;
                }
            }
            return default(double);
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public unsafe static int count
            (this double[] array, int index, int count, func<double, bool> isValue)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                int value = 0;
                fixed (double* valueFixed = array)
                {
                    for (double* start = valueFixed + index, end = start + count; start != end; ++start)
                    {
                        if (isValue(*start)) ++value;
                    }
                }
                return value;
            }
            return 0;
        }
        /// <summary>
        /// 移除第一个匹配数据数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>移除数据后的数组</returns>
        public unsafe static double[] removeFirst
            (this double[] array, func<double, bool> isValue)
        {
            if (array != null)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                int index = -1;
                fixed (double* valueFixed = array)
                {
                    double* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) index = (int)(valueIndex - valueFixed);
                }
                if (index != -1) return GetRemoveAt(array, index);
                return array;
            }
            return nullValue<double>.Array;
        }
        /// <summary>
        /// 替换数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">新值</param>
        /// <param name="isValue">数据匹配器</param>
        public unsafe static double[] replaceFirst
            (this double[] array, double value, func<double, bool> isValue)
        {
            if (array != null)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                fixed (double* valueFixed = array)
                {
                    double* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) *valueIndex = value;
                }
                return array;
            }
            return nullValue<double>.Array;
        }
        /// <summary>
        /// 转换键值对集合
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="array">键值数组</param>
        /// <param name="values">数据数组</param>
        /// <returns>键值对数组</returns>
        public unsafe static keyValue<double, valueType>[] getKeyValue<valueType>
            (this double[] array, valueType[] values)
        {
            int length = array.length();
            if (length != values.length()) log.Default.Throw(log.exceptionType.IndexOutOfRange);
            if (length != 0)
            {
                keyValue<double, valueType>[] newValues = new keyValue<double, valueType>[values.Length];
                fixed (double* valueFixed = array)
                {
                    double* readValue = valueFixed;
                    int index = 0;
                    foreach (valueType value in values)
                    {
                        newValues[index].Set(*readValue++, value);
                        ++index;
                    }
                }
                return newValues;
            }
            return nullValue<keyValue<double, valueType>>.Array;
        }
        /// <summary>
        /// 数据转换
        /// </summary>
        /// <typeparam name="valueType">数组类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public unsafe static double[] getArray<valueType>
            (this valueType[] array, func<valueType, double> getValue)
        {
            if (array.length() != 0)
            {
                if (getValue == null) log.Default.Throw(log.exceptionType.Null);
                double[] newValues = new double[array.Length];
                fixed (double* newValueFixed = newValues)
                {
                    double* writeValue = newValueFixed;
                    foreach (valueType value in array) *writeValue++ = getValue(value);
                }
                return newValues;
            }
            return nullValue<double>.Array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public unsafe static list<double> getFind
            (this double[] array, func<double, bool> isValue)
        {
            if (array.length() != 0)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                double[] newValues = new double[array.Length < sizeof(int) ? sizeof(int) : array.Length];
                fixed (double* newValueFixed = newValues, valueFixed = array)
                {
                    double* write = newValueFixed;
                    for (double* start = valueFixed, end = valueFixed + array.Length; start != end; ++start)
                    {
                        if (isValue(*start)) *write++ = *start;
                    }
                    return new list<double>(newValues, 0, (int)(write - newValueFixed), true);
                }
            }
            return null;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public unsafe static list<double> getFind
            (this double[] array, int index, int count, func<double, bool> isValue)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                double[] newValues = new double[count < sizeof(int) ? sizeof(int) : count];
                fixed (double* newValueFixed = newValues, valueFixed = array)
                {
                    double* write = newValueFixed;
                    for (double* start = valueFixed + index, end = start + count; start != end; ++start)
                    {
                        if (isValue(*start)) *write++ = *start;
                    }
                    return new list<double>(newValues, 0, (int)(write - newValueFixed), true);
                }
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public unsafe static double[] getFindArray
            (this double[] array, func<double, bool> isValue)
        {
            if (isValue == null) log.Default.Throw(log.exceptionType.Null);
            int length = array.length();
            if (length != 0)
            {
                length = (length + 7) >> 3;
                if (length <= config.pub.Default.StreamBufferLength)
                {
                    byte* data = stackalloc byte[length];
                    return GetFindArray(array, 0, array.Length, isValue, new fixedMap(data, length));
                }
                else
                {
                    byte[] data = new byte[length];
                    fixed (byte* dataFixed = data) return GetFindArray(array, 0, array.Length, isValue, new fixedMap(dataFixed));
                }
            }
            return nullValue<double>.Array;
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public unsafe static double[] getFindArray
            (this double[] array, int index, int count, func<double, bool> isValue)
        {
            if (isValue == null) log.Default.Throw(log.exceptionType.Null);
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                int length = (count + 7) >> 3;
                if (length <= config.pub.Default.StreamBufferLength)
                {
                    byte* data = stackalloc byte[length];
                    return GetFindArray(array, range.SkipCount, count, isValue, new fixedMap(data, length));
                }
                else
                {
                    byte[] data = new byte[length];
                    fixed (byte* dataFixed = data) return GetFindArray(array, range.SkipCount, count, isValue, new fixedMap(dataFixed));
                }
            }
            return nullValue<double>.Array;
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="map">匹配结果位图</param>
        /// <returns>匹配数组</returns>
        private unsafe static double[] GetFindArray
            (double[] array, int index, int count, func<double, bool> isValue, fixedMap map)
        {
            int length = 0, mapIndex = 0;
            fixed (double* valueFixed = array)
            {
                double* startFixed = valueFixed + index, end = startFixed + count;
                for (double* start = startFixed; start != end; ++start, ++mapIndex)
                {
                    if (isValue(*start))
                    {
                        ++length;
                        map.Set(mapIndex);
                    }
                }
                if (length != 0)
                {
                    double[] newValues = new double[length];
                    fixed (double* newValueFixed = newValues)
                    {
                        double* write = newValueFixed + length;
                        while (mapIndex != 0)
                        {
                            if (map.Get(--mapIndex)) *--write = startFixed[mapIndex];
                        }
                    }
                    return newValues;
                }
            }
            return nullValue<double>.Array;
        }
        /// <summary>
        /// 取子集合
        /// </summary>
        /// <typeparam name="valueType">目标数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">数据数量</param>
        /// <param name="getVlaue">目标数据获取器</param>
        /// <returns>子集合</returns>
        public unsafe static valueType[] getSub<valueType>
            (this double[] array, int index, int count, func<double, valueType> getVlaue)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                if (getVlaue == null) log.Default.Throw(log.exceptionType.Null);
                valueType[] newValues = new valueType[count];
                fixed (double* valueFixed = array)
                {
                    double* read = valueFixed + range.SkipCount;
                    for (index = 0; index != count; ++index) newValues[index] = getVlaue(*read++);
                }
                return newValues;
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 取子集合
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">数据数量</param>
        /// <param name="getVlaue">数据获取器</param>
        /// <returns>子集合</returns>
        public unsafe static double[] getSub<valueType>
            (this valueType[] array, int index, int count, func<valueType, double> getValue)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                if (getValue == null) log.Default.Throw(log.exceptionType.Null);
                double[] newValues = new double[count];
                fixed (double* newValueFixed = newValues)
                {
                    double* write = newValueFixed;
                    for (index = range.SkipCount, count = range.EndIndex; index != count; ++index) *write++ = getValue(array[index]);
                }
                return newValues;
            }
            return nullValue<double>.Array;
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        public unsafe static list<valueType> distinct<valueType>
            (this double[] array, int index, int count, func<double, valueType> getValue)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                if (getValue == null) log.Default.Throw(log.exceptionType.Null);
                list<valueType>.unsafer newValues = new list<valueType>(count).Unsafer;
                System.Collections.Generic.HashSet<double> hash
                    = new System.Collections.Generic.HashSet<double>();
                fixed (double* valueFixed = array)
                {
                    for (double* start = valueFixed + range.SkipCount, end = start + count; start != end; ++start)
                    {
                        if (!hash.Contains(*start))
                        {
                            newValues.Add(getValue(*start));
                            hash.Add(*start);
                        }
                    }
                }
                return newValues.List;
            }
            return null;
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        public unsafe static list<double> distinct<valueType>
            (this valueType[] array, func<valueType, double> getValue)
        {
            if (array != null)
            {
                if (getValue == null) log.Default.Throw(log.exceptionType.Null);
                double[] newValues = new double[array.Length];
                System.Collections.Generic.HashSet<valueType> hash = new System.Collections.Generic.HashSet<valueType>();
                fixed (double* newValueFixed = newValues)
                {
                    double* write = newValueFixed;
                    foreach (valueType value in array)
                    {
                        if (!hash.Contains(value))
                        {
                            *write++ = getValue(value);
                            hash.Add(value);
                        }
                    }
                    return new list<double>(newValues, 0, (int)(write - newValueFixed), true);
                }
            }
            return null;
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        public unsafe static list<double> distinct<valueType>
            (this valueType[] array, int index, int count, func<valueType, double> getValue)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                if (getValue == null) log.Default.Throw(log.exceptionType.Null);
                double[] newValues = new double[count];
                System.Collections.Generic.HashSet<valueType> hash = new System.Collections.Generic.HashSet<valueType>();
                valueType value;
                fixed (double* newValueFixed = newValues)
                {
                    double* write = newValueFixed;
                    for (index = range.SkipCount, count = range.EndIndex; index != count; ++index)
                    {
                        if (!hash.Contains(value = array[index]))
                        {
                            *write++ = getValue(value);
                            hash.Add(value);
                        }
                    }
                    return new list<double>(newValues, 0, (int)(write - newValueFixed), true);
                }
            }
            return null;
        }
        /// <summary>
        /// 求交集
        /// </summary>
        /// <param name="left">左侧数据</param>
        /// <param name="right">右侧数据</param>
        /// <returns>数据交集</returns>
        public unsafe static list<double> intersect(this double[] left, double[] right)
        {
            int leftLength = left.length();
            if (leftLength != 0)
            {
                int rightLength = right.length();
                if (rightLength != 0)
                {
                    double[] min = leftLength <= rightLength ? left : right, values = new double[min.Length];
                    fixed (double* valueFixed = values)
                    {
                        double* write = valueFixed;
                        staticHashSet<double> hash = new staticHashSet<double>(min);
                        foreach (double value in leftLength <= rightLength ? right : left)
                        {
                            if (hash.Contains(value)) *write++ = value;
                        }
                        return new list<double>(values, 0, (int)(write - valueFixed), true);
                    }
                }
            }
            return null;
        }
        /// <summary>
        /// 遍历foreach
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">遍历数据数量</param>
        /// <param name="method">调用函数</param>
        /// <returns>数据数组</returns>
        public unsafe static double[] each
            (this double[] array, int index, int count, action<double> method)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                if (method == null) log.Default.Throw(log.exceptionType.Null);
                fixed (double* valueFixed = array)
                {
                    for (double* start = valueFixed + index, end = start + count; start != end; method(*start++)) ;
                }
                return array;
            }
            return nullValue<double>.Array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public unsafe static bool max(this double[] array, out double value)
        {
            if (array.length() != 0)
            {
                fixed (double* valueFixed = array)
                {
                    value = *valueFixed;
                    for (double* start = valueFixed + 1, end = valueFixed + array.Length; start != end; ++start)
                    {
                        if (*start > value) value = *start;
                    }
                    return true;
                }
            }
            value = double.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public unsafe static double max(this double[] array, double nullValue)
        {
            double value;
            return max(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public unsafe static bool max(this double[] array, int index, int count, out double value)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                fixed (double* valueFixed = array)
                {
                    double* start = valueFixed + range.SkipCount;
                    value = *start;
                    for (double* end = start + count; ++start != end; )
                    {
                        if (*start > value) value = *start;
                    }
                    return true;
                }
            }
            value = double.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public unsafe static double max
            (this double[] array, int index, int count, double nullValue)
        {
            double value;
            return max(array, index, count, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>
            (this valueType[] array, func<valueType, double> getKey, out double value)
        {
            if (array.length() != 0)
            {
                value = getKey(array[0]);
                foreach (valueType nextValue in array)
                {
                    double nextKey = getKey(nextValue);
                    if (nextKey > value) value = nextKey;
                }
                return true;
            }
            value = double.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static double maxKey<valueType>
            (this valueType[] array, func<valueType, double> getKey, double nullValue)
        {
            double value;
            return maxKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>
            (this valueType[] array, int index, int count, func<valueType, double> getKey
            , out double value)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                value = getKey(array[index = range.SkipCount]);
                for (int endIndex = index + count; ++index != endIndex; )
                {
                    double nextValue = getKey(array[index]);
                    if (nextValue > value) value = nextValue;
                }
                return true;
            }
            value = double.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static double maxKey<valueType>
            (this valueType[] array, int index, int count, func<valueType, double> getKey
            , double nullValue)
        {
            double value;
            return maxKey(array, index, count, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>
            (this valueType[] array, func<valueType, double> getKey, out valueType value)
        {
            if (array.length() != 0)
            {
                value = array[0];
                double maxKey = getKey(value);
                foreach (valueType nextValue in array)
                {
                    double nextKey = getKey(nextValue);
                    if (nextKey > maxKey)
                    {
                        maxKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static valueType max<valueType>(this valueType[] array, func<valueType, double> getKey, valueType nullValue)
        {
            valueType value;
            return max(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>
            (this valueType[] array, int index, int count, func<valueType, double> getKey, out valueType value)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                value = array[index = range.SkipCount];
                double maxValue = getKey(value);
                for (int endIndex = index + count; ++index != endIndex; )
                {
                    double nextValue = getKey(array[index]);
                    if (nextValue > maxValue)
                    {
                        maxValue = nextValue;
                        value = array[index];
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static valueType max<valueType>
            (this valueType[] array, int index, int count, func<valueType, double> getKey, valueType nullValue)
        {
            valueType value;
            return max(array, index, count, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public unsafe static bool min(this double[] array, out double value)
        {
            if (array.length() != 0)
            {
                fixed (double* valueFixed = array)
                {
                    value = *valueFixed;
                    for (double* start = valueFixed + 1, end = valueFixed + array.Length; start != end; ++start)
                    {
                        if (*start < value) value = *start;
                    }
                    return true;
                }
            }
            value = double.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public unsafe static double min(this double[] array, double nullValue)
        {
            double value;
            return min(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public unsafe static bool min(this double[] array, int index, int count, out double value)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                fixed (double* valueFixed = array)
                {
                    double* start = valueFixed + range.SkipCount;
                    value = *start;
                    for (double* end = start + count; ++start != end; )
                    {
                        if (*start < value) value = *start;
                    }
                    return true;
                }
            }
            value = double.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public unsafe static double min
            (this double[] array, int index, int count, double nullValue)
        {
            double value;
            return min(array, index, count, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>
            (this valueType[] array, func<valueType, double> getKey, out double value)
        {
            if (array.length() != 0)
            {
                value = getKey(array[0]);
                foreach (valueType nextValue in array)
                {
                    double nextKey = getKey(nextValue);
                    if (nextKey < value) value = nextKey;
                }
                return true;
            }
            value = double.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static double minKey<valueType>
            (this valueType[] array, func<valueType, double> getKey, double nullValue)
        {
            double value;
            return minKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>
            (this valueType[] array, int index, int count, func<valueType, double> getKey
            , out double value)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                value = getKey(array[index = range.SkipCount]);
                for (int endIndex = index + count; ++index != endIndex; )
                {
                    double nextValue = getKey(array[index]);
                    if (nextValue < value) value = nextValue;
                }
                return true;
            }
            value = double.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static double minKey<valueType>
            (this valueType[] array, int index, int count, func<valueType, double> getKey
            , double nullValue)
        {
            double value;
            return minKey(array, index, count, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>(this valueType[] array, func<valueType, double> getKey, out valueType value)
        {
            if (array.length() != 0)
            {
                value = array[0];
                double minKey = getKey(value);
                foreach (valueType nextValue in array)
                {
                    double nextKey = getKey(nextValue);
                    if (nextKey < minKey)
                    {
                        minKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static valueType min<valueType>(this valueType[] array, func<valueType, double> getKey, valueType nullValue)
        {
            valueType value;
            return min(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>
            (this valueType[] array, int index, int count, func<valueType, double> getKey, out valueType value)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                value = array[index = range.SkipCount];
                double minValue = getKey(value);
                for (int endIndex = index + count; ++index != endIndex; )
                {
                    double nextValue = getKey(array[index]);
                    if (nextValue < minValue)
                    {
                        minValue = nextValue;
                        value = array[index];
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static valueType min<valueType>
            (this valueType[] array, int index, int count, func<valueType, double> getKey, valueType nullValue)
        {
            valueType value;
            return min(array, index, count, getKey, out value) ? value : nullValue;
        }
    }
}

namespace fastCSharp.unsafer
{
    /// <summary>
    /// 数组非安全扩展操作(请自行确保数据可靠性)
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 移动数据块
        /// </summary>
        /// <param name="array">待处理数组</param>
        /// <param name="index">原始数据位置</param>
        /// <param name="writeIndex">目标数据位置</param>
        /// <param name="count">移动数据数量</param>
        public unsafe static void Move(double[] array, int index, int writeIndex, int count)
        {
            int endIndex = index + count;
            if (index < writeIndex && endIndex > writeIndex)
            {
                fixed (double* valueFixed = array)
                {
                    for (double* write = valueFixed + writeIndex + count, start = valueFixed + index, end = valueFixed + endIndex;
                        end != start;
                        *--write = *--end) ;
                }
            }
            else Array.Copy(array, index, array, writeIndex, count);
        }
    }
}
namespace fastCSharp
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="values">数据指针</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为null</returns>
        private unsafe static float* IndexOf
            (float* valueFixed, int length, float value)
        {
            for (float* start = valueFixed, end = valueFixed + length; start != end; ++start)
            {
                if (*start == value) return start;
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this float[] array, float value)
        {
            if (array != null)
            {
                fixed (float* valueFixed = array)
                {
                    float* valueIndex = IndexOf(valueFixed, array.Length, value);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this float[] array, int index, int length, float value)
        {
            array.range range = new array.range(array.length(), index, length);
            if ((length = range.GetCount) != 0)
            {
                fixed (float* valueFixed = array)
                {
                    float* valueIndex = IndexOf(valueFixed + range.SkipCount, length, value);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        public static float[] getReverse(this float[] array)
        {
            return array.length() != 0 ? GetReverse(array, 0, array.Length) : array.notNull();
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        /// <returns>翻转后的新数组</returns>
        public static float[] getReverse(this float[] array, int index, int length)
        {
            array.range range = new array.range(array.length(), index, length);
            if (((range.SkipCount ^ index) | (range.GetCount ^ length)) == 0)
            {
                return GetReverse(array, index, length);
            }
            log.Default.Throw(log.exceptionType.IndexOutOfRange);
            return null;
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        /// <returns>翻转后的新数组</returns>
        private unsafe static float[] GetReverse(float[] array, int index, int length)
        {
            float[] newValues = new float[length];
            fixed (float* valueFixed = array, newValueFixed = newValues)
            {
                for (float* start = valueFixed + index, end = start + length, wirte = newValueFixed + length;
                    start != end; 
                    *--wirte = *start++) ;
            }
            return newValues;
        }
        /// <summary>
        /// 移除第一个匹配数据数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配值</param>
        /// <returns>移除数据后的数组</returns>
        public unsafe static float[] removeFirst
            (this float[] array, float value)
        {
            if (array != null)
            {
                int index = -1;
                fixed (float* valueFixed = array)
                {
                    float* valueIndex = IndexOf(valueFixed, array.Length, value);
                    if (valueIndex != null) index = (int)(valueIndex - valueFixed);
                }
                if (index != -1) return GetRemoveAt(array, index);
            }
            return nullValue<float>.Array;
        }
        /// <summary>
        /// 移动数据块
        /// </summary>
        /// <param name="array">待处理数组</param>
        /// <param name="index">原始数据位置</param>
        /// <param name="writeIndex">目标数据位置</param>
        /// <param name="count">移动数据数量</param>
        public unsafe static void move(this float[] array, int index, int writeIndex, int count)
        {
            if (count > 0)
            {
                int writeEndIndex = writeIndex + count;
                if (index >= 0 && writeEndIndex <= array.Length)
                {
                    int endIndex = index + count;
                    if (index < writeIndex && endIndex > writeIndex)
                    {
                        fixed (float* valueFixed = array)
                        {
                            for (float* write = valueFixed + writeEndIndex, end = valueFixed + endIndex, start = valueFixed + index;
                                end != start;
                                *--write = *--end) ;
                        }
                    }
                    else if (writeIndex >= 0 && endIndex <= array.Length) Array.Copy(array, index, array, writeIndex, count);
                    else log.Default.Throw(log.exceptionType.IndexOutOfRange);
                }
                else log.Default.Throw(log.exceptionType.IndexOutOfRange);
            }
            else if (count != 0) log.Default.Throw(log.exceptionType.IndexOutOfRange);
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="values">数组数据</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为null</returns>
        private unsafe static float* IndexOf
            (float* valueFixed, int length, func<float, bool> isValue)
        {
            for (float* start = valueFixed, end = valueFixed + length; start != end; ++start)
            {
                if (isValue(*start)) return start;
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this float[] array, func<float, bool> isValue)
        {
            if (array != null)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                fixed (float* valueFixed = array)
                {
                    float* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf
            (this float[] array, int index, int length, func<float, bool> isValue)
        {
            array.range range = new array.range(array.length(), index, length);
            if ((length = range.GetCount) != 0)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                fixed (float* valueFixed = array)
                {
                    float* valueIndex = IndexOf(valueFixed + range.SkipCount, length, isValue);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="index">起始位置</param>
        /// <returns>第一个匹配值,失败为default(float)</returns>
        public unsafe static float firstOrDefault
            (this float[] array, func<float, bool> isValue, int index)
        {
            if (array != null && (uint)index < (uint)array.Length)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                fixed (float* valueFixed = array)
                {
                    float* valueIndex = IndexOf(valueFixed + index, array.Length - index, isValue);
                    if (valueIndex != null) return *valueIndex;
                }
            }
            return default(float);
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public unsafe static int count
            (this float[] array, int index, int count, func<float, bool> isValue)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                int value = 0;
                fixed (float* valueFixed = array)
                {
                    for (float* start = valueFixed + index, end = start + count; start != end; ++start)
                    {
                        if (isValue(*start)) ++value;
                    }
                }
                return value;
            }
            return 0;
        }
        /// <summary>
        /// 移除第一个匹配数据数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>移除数据后的数组</returns>
        public unsafe static float[] removeFirst
            (this float[] array, func<float, bool> isValue)
        {
            if (array != null)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                int index = -1;
                fixed (float* valueFixed = array)
                {
                    float* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) index = (int)(valueIndex - valueFixed);
                }
                if (index != -1) return GetRemoveAt(array, index);
                return array;
            }
            return nullValue<float>.Array;
        }
        /// <summary>
        /// 替换数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">新值</param>
        /// <param name="isValue">数据匹配器</param>
        public unsafe static float[] replaceFirst
            (this float[] array, float value, func<float, bool> isValue)
        {
            if (array != null)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                fixed (float* valueFixed = array)
                {
                    float* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) *valueIndex = value;
                }
                return array;
            }
            return nullValue<float>.Array;
        }
        /// <summary>
        /// 转换键值对集合
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="array">键值数组</param>
        /// <param name="values">数据数组</param>
        /// <returns>键值对数组</returns>
        public unsafe static keyValue<float, valueType>[] getKeyValue<valueType>
            (this float[] array, valueType[] values)
        {
            int length = array.length();
            if (length != values.length()) log.Default.Throw(log.exceptionType.IndexOutOfRange);
            if (length != 0)
            {
                keyValue<float, valueType>[] newValues = new keyValue<float, valueType>[values.Length];
                fixed (float* valueFixed = array)
                {
                    float* readValue = valueFixed;
                    int index = 0;
                    foreach (valueType value in values)
                    {
                        newValues[index].Set(*readValue++, value);
                        ++index;
                    }
                }
                return newValues;
            }
            return nullValue<keyValue<float, valueType>>.Array;
        }
        /// <summary>
        /// 数据转换
        /// </summary>
        /// <typeparam name="valueType">数组类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public unsafe static float[] getArray<valueType>
            (this valueType[] array, func<valueType, float> getValue)
        {
            if (array.length() != 0)
            {
                if (getValue == null) log.Default.Throw(log.exceptionType.Null);
                float[] newValues = new float[array.Length];
                fixed (float* newValueFixed = newValues)
                {
                    float* writeValue = newValueFixed;
                    foreach (valueType value in array) *writeValue++ = getValue(value);
                }
                return newValues;
            }
            return nullValue<float>.Array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public unsafe static list<float> getFind
            (this float[] array, func<float, bool> isValue)
        {
            if (array.length() != 0)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                float[] newValues = new float[array.Length < sizeof(int) ? sizeof(int) : array.Length];
                fixed (float* newValueFixed = newValues, valueFixed = array)
                {
                    float* write = newValueFixed;
                    for (float* start = valueFixed, end = valueFixed + array.Length; start != end; ++start)
                    {
                        if (isValue(*start)) *write++ = *start;
                    }
                    return new list<float>(newValues, 0, (int)(write - newValueFixed), true);
                }
            }
            return null;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public unsafe static list<float> getFind
            (this float[] array, int index, int count, func<float, bool> isValue)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                float[] newValues = new float[count < sizeof(int) ? sizeof(int) : count];
                fixed (float* newValueFixed = newValues, valueFixed = array)
                {
                    float* write = newValueFixed;
                    for (float* start = valueFixed + index, end = start + count; start != end; ++start)
                    {
                        if (isValue(*start)) *write++ = *start;
                    }
                    return new list<float>(newValues, 0, (int)(write - newValueFixed), true);
                }
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public unsafe static float[] getFindArray
            (this float[] array, func<float, bool> isValue)
        {
            if (isValue == null) log.Default.Throw(log.exceptionType.Null);
            int length = array.length();
            if (length != 0)
            {
                length = (length + 7) >> 3;
                if (length <= config.pub.Default.StreamBufferLength)
                {
                    byte* data = stackalloc byte[length];
                    return GetFindArray(array, 0, array.Length, isValue, new fixedMap(data, length));
                }
                else
                {
                    byte[] data = new byte[length];
                    fixed (byte* dataFixed = data) return GetFindArray(array, 0, array.Length, isValue, new fixedMap(dataFixed));
                }
            }
            return nullValue<float>.Array;
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public unsafe static float[] getFindArray
            (this float[] array, int index, int count, func<float, bool> isValue)
        {
            if (isValue == null) log.Default.Throw(log.exceptionType.Null);
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                int length = (count + 7) >> 3;
                if (length <= config.pub.Default.StreamBufferLength)
                {
                    byte* data = stackalloc byte[length];
                    return GetFindArray(array, range.SkipCount, count, isValue, new fixedMap(data, length));
                }
                else
                {
                    byte[] data = new byte[length];
                    fixed (byte* dataFixed = data) return GetFindArray(array, range.SkipCount, count, isValue, new fixedMap(dataFixed));
                }
            }
            return nullValue<float>.Array;
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="map">匹配结果位图</param>
        /// <returns>匹配数组</returns>
        private unsafe static float[] GetFindArray
            (float[] array, int index, int count, func<float, bool> isValue, fixedMap map)
        {
            int length = 0, mapIndex = 0;
            fixed (float* valueFixed = array)
            {
                float* startFixed = valueFixed + index, end = startFixed + count;
                for (float* start = startFixed; start != end; ++start, ++mapIndex)
                {
                    if (isValue(*start))
                    {
                        ++length;
                        map.Set(mapIndex);
                    }
                }
                if (length != 0)
                {
                    float[] newValues = new float[length];
                    fixed (float* newValueFixed = newValues)
                    {
                        float* write = newValueFixed + length;
                        while (mapIndex != 0)
                        {
                            if (map.Get(--mapIndex)) *--write = startFixed[mapIndex];
                        }
                    }
                    return newValues;
                }
            }
            return nullValue<float>.Array;
        }
        /// <summary>
        /// 取子集合
        /// </summary>
        /// <typeparam name="valueType">目标数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">数据数量</param>
        /// <param name="getVlaue">目标数据获取器</param>
        /// <returns>子集合</returns>
        public unsafe static valueType[] getSub<valueType>
            (this float[] array, int index, int count, func<float, valueType> getVlaue)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                if (getVlaue == null) log.Default.Throw(log.exceptionType.Null);
                valueType[] newValues = new valueType[count];
                fixed (float* valueFixed = array)
                {
                    float* read = valueFixed + range.SkipCount;
                    for (index = 0; index != count; ++index) newValues[index] = getVlaue(*read++);
                }
                return newValues;
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 取子集合
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">数据数量</param>
        /// <param name="getVlaue">数据获取器</param>
        /// <returns>子集合</returns>
        public unsafe static float[] getSub<valueType>
            (this valueType[] array, int index, int count, func<valueType, float> getValue)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                if (getValue == null) log.Default.Throw(log.exceptionType.Null);
                float[] newValues = new float[count];
                fixed (float* newValueFixed = newValues)
                {
                    float* write = newValueFixed;
                    for (index = range.SkipCount, count = range.EndIndex; index != count; ++index) *write++ = getValue(array[index]);
                }
                return newValues;
            }
            return nullValue<float>.Array;
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        public unsafe static list<valueType> distinct<valueType>
            (this float[] array, int index, int count, func<float, valueType> getValue)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                if (getValue == null) log.Default.Throw(log.exceptionType.Null);
                list<valueType>.unsafer newValues = new list<valueType>(count).Unsafer;
                System.Collections.Generic.HashSet<float> hash
                    = new System.Collections.Generic.HashSet<float>();
                fixed (float* valueFixed = array)
                {
                    for (float* start = valueFixed + range.SkipCount, end = start + count; start != end; ++start)
                    {
                        if (!hash.Contains(*start))
                        {
                            newValues.Add(getValue(*start));
                            hash.Add(*start);
                        }
                    }
                }
                return newValues.List;
            }
            return null;
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        public unsafe static list<float> distinct<valueType>
            (this valueType[] array, func<valueType, float> getValue)
        {
            if (array != null)
            {
                if (getValue == null) log.Default.Throw(log.exceptionType.Null);
                float[] newValues = new float[array.Length];
                System.Collections.Generic.HashSet<valueType> hash = new System.Collections.Generic.HashSet<valueType>();
                fixed (float* newValueFixed = newValues)
                {
                    float* write = newValueFixed;
                    foreach (valueType value in array)
                    {
                        if (!hash.Contains(value))
                        {
                            *write++ = getValue(value);
                            hash.Add(value);
                        }
                    }
                    return new list<float>(newValues, 0, (int)(write - newValueFixed), true);
                }
            }
            return null;
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        public unsafe static list<float> distinct<valueType>
            (this valueType[] array, int index, int count, func<valueType, float> getValue)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                if (getValue == null) log.Default.Throw(log.exceptionType.Null);
                float[] newValues = new float[count];
                System.Collections.Generic.HashSet<valueType> hash = new System.Collections.Generic.HashSet<valueType>();
                valueType value;
                fixed (float* newValueFixed = newValues)
                {
                    float* write = newValueFixed;
                    for (index = range.SkipCount, count = range.EndIndex; index != count; ++index)
                    {
                        if (!hash.Contains(value = array[index]))
                        {
                            *write++ = getValue(value);
                            hash.Add(value);
                        }
                    }
                    return new list<float>(newValues, 0, (int)(write - newValueFixed), true);
                }
            }
            return null;
        }
        /// <summary>
        /// 求交集
        /// </summary>
        /// <param name="left">左侧数据</param>
        /// <param name="right">右侧数据</param>
        /// <returns>数据交集</returns>
        public unsafe static list<float> intersect(this float[] left, float[] right)
        {
            int leftLength = left.length();
            if (leftLength != 0)
            {
                int rightLength = right.length();
                if (rightLength != 0)
                {
                    float[] min = leftLength <= rightLength ? left : right, values = new float[min.Length];
                    fixed (float* valueFixed = values)
                    {
                        float* write = valueFixed;
                        staticHashSet<float> hash = new staticHashSet<float>(min);
                        foreach (float value in leftLength <= rightLength ? right : left)
                        {
                            if (hash.Contains(value)) *write++ = value;
                        }
                        return new list<float>(values, 0, (int)(write - valueFixed), true);
                    }
                }
            }
            return null;
        }
        /// <summary>
        /// 遍历foreach
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">遍历数据数量</param>
        /// <param name="method">调用函数</param>
        /// <returns>数据数组</returns>
        public unsafe static float[] each
            (this float[] array, int index, int count, action<float> method)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                if (method == null) log.Default.Throw(log.exceptionType.Null);
                fixed (float* valueFixed = array)
                {
                    for (float* start = valueFixed + index, end = start + count; start != end; method(*start++)) ;
                }
                return array;
            }
            return nullValue<float>.Array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public unsafe static bool max(this float[] array, out float value)
        {
            if (array.length() != 0)
            {
                fixed (float* valueFixed = array)
                {
                    value = *valueFixed;
                    for (float* start = valueFixed + 1, end = valueFixed + array.Length; start != end; ++start)
                    {
                        if (*start > value) value = *start;
                    }
                    return true;
                }
            }
            value = float.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public unsafe static float max(this float[] array, float nullValue)
        {
            float value;
            return max(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public unsafe static bool max(this float[] array, int index, int count, out float value)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                fixed (float* valueFixed = array)
                {
                    float* start = valueFixed + range.SkipCount;
                    value = *start;
                    for (float* end = start + count; ++start != end; )
                    {
                        if (*start > value) value = *start;
                    }
                    return true;
                }
            }
            value = float.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public unsafe static float max
            (this float[] array, int index, int count, float nullValue)
        {
            float value;
            return max(array, index, count, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>
            (this valueType[] array, func<valueType, float> getKey, out float value)
        {
            if (array.length() != 0)
            {
                value = getKey(array[0]);
                foreach (valueType nextValue in array)
                {
                    float nextKey = getKey(nextValue);
                    if (nextKey > value) value = nextKey;
                }
                return true;
            }
            value = float.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static float maxKey<valueType>
            (this valueType[] array, func<valueType, float> getKey, float nullValue)
        {
            float value;
            return maxKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>
            (this valueType[] array, int index, int count, func<valueType, float> getKey
            , out float value)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                value = getKey(array[index = range.SkipCount]);
                for (int endIndex = index + count; ++index != endIndex; )
                {
                    float nextValue = getKey(array[index]);
                    if (nextValue > value) value = nextValue;
                }
                return true;
            }
            value = float.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static float maxKey<valueType>
            (this valueType[] array, int index, int count, func<valueType, float> getKey
            , float nullValue)
        {
            float value;
            return maxKey(array, index, count, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>
            (this valueType[] array, func<valueType, float> getKey, out valueType value)
        {
            if (array.length() != 0)
            {
                value = array[0];
                float maxKey = getKey(value);
                foreach (valueType nextValue in array)
                {
                    float nextKey = getKey(nextValue);
                    if (nextKey > maxKey)
                    {
                        maxKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static valueType max<valueType>(this valueType[] array, func<valueType, float> getKey, valueType nullValue)
        {
            valueType value;
            return max(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>
            (this valueType[] array, int index, int count, func<valueType, float> getKey, out valueType value)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                value = array[index = range.SkipCount];
                float maxValue = getKey(value);
                for (int endIndex = index + count; ++index != endIndex; )
                {
                    float nextValue = getKey(array[index]);
                    if (nextValue > maxValue)
                    {
                        maxValue = nextValue;
                        value = array[index];
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static valueType max<valueType>
            (this valueType[] array, int index, int count, func<valueType, float> getKey, valueType nullValue)
        {
            valueType value;
            return max(array, index, count, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public unsafe static bool min(this float[] array, out float value)
        {
            if (array.length() != 0)
            {
                fixed (float* valueFixed = array)
                {
                    value = *valueFixed;
                    for (float* start = valueFixed + 1, end = valueFixed + array.Length; start != end; ++start)
                    {
                        if (*start < value) value = *start;
                    }
                    return true;
                }
            }
            value = float.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public unsafe static float min(this float[] array, float nullValue)
        {
            float value;
            return min(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public unsafe static bool min(this float[] array, int index, int count, out float value)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                fixed (float* valueFixed = array)
                {
                    float* start = valueFixed + range.SkipCount;
                    value = *start;
                    for (float* end = start + count; ++start != end; )
                    {
                        if (*start < value) value = *start;
                    }
                    return true;
                }
            }
            value = float.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public unsafe static float min
            (this float[] array, int index, int count, float nullValue)
        {
            float value;
            return min(array, index, count, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>
            (this valueType[] array, func<valueType, float> getKey, out float value)
        {
            if (array.length() != 0)
            {
                value = getKey(array[0]);
                foreach (valueType nextValue in array)
                {
                    float nextKey = getKey(nextValue);
                    if (nextKey < value) value = nextKey;
                }
                return true;
            }
            value = float.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static float minKey<valueType>
            (this valueType[] array, func<valueType, float> getKey, float nullValue)
        {
            float value;
            return minKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>
            (this valueType[] array, int index, int count, func<valueType, float> getKey
            , out float value)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                value = getKey(array[index = range.SkipCount]);
                for (int endIndex = index + count; ++index != endIndex; )
                {
                    float nextValue = getKey(array[index]);
                    if (nextValue < value) value = nextValue;
                }
                return true;
            }
            value = float.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static float minKey<valueType>
            (this valueType[] array, int index, int count, func<valueType, float> getKey
            , float nullValue)
        {
            float value;
            return minKey(array, index, count, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>(this valueType[] array, func<valueType, float> getKey, out valueType value)
        {
            if (array.length() != 0)
            {
                value = array[0];
                float minKey = getKey(value);
                foreach (valueType nextValue in array)
                {
                    float nextKey = getKey(nextValue);
                    if (nextKey < minKey)
                    {
                        minKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static valueType min<valueType>(this valueType[] array, func<valueType, float> getKey, valueType nullValue)
        {
            valueType value;
            return min(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>
            (this valueType[] array, int index, int count, func<valueType, float> getKey, out valueType value)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                value = array[index = range.SkipCount];
                float minValue = getKey(value);
                for (int endIndex = index + count; ++index != endIndex; )
                {
                    float nextValue = getKey(array[index]);
                    if (nextValue < minValue)
                    {
                        minValue = nextValue;
                        value = array[index];
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static valueType min<valueType>
            (this valueType[] array, int index, int count, func<valueType, float> getKey, valueType nullValue)
        {
            valueType value;
            return min(array, index, count, getKey, out value) ? value : nullValue;
        }
    }
}

namespace fastCSharp.unsafer
{
    /// <summary>
    /// 数组非安全扩展操作(请自行确保数据可靠性)
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 移动数据块
        /// </summary>
        /// <param name="array">待处理数组</param>
        /// <param name="index">原始数据位置</param>
        /// <param name="writeIndex">目标数据位置</param>
        /// <param name="count">移动数据数量</param>
        public unsafe static void Move(float[] array, int index, int writeIndex, int count)
        {
            int endIndex = index + count;
            if (index < writeIndex && endIndex > writeIndex)
            {
                fixed (float* valueFixed = array)
                {
                    for (float* write = valueFixed + writeIndex + count, start = valueFixed + index, end = valueFixed + endIndex;
                        end != start;
                        *--write = *--end) ;
                }
            }
            else Array.Copy(array, index, array, writeIndex, count);
        }
    }
}
namespace fastCSharp
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="values">数据指针</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为null</returns>
        private unsafe static DateTime* IndexOf
            (DateTime* valueFixed, int length, DateTime value)
        {
            for (DateTime* start = valueFixed, end = valueFixed + length; start != end; ++start)
            {
                if (*start == value) return start;
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this DateTime[] array, DateTime value)
        {
            if (array != null)
            {
                fixed (DateTime* valueFixed = array)
                {
                    DateTime* valueIndex = IndexOf(valueFixed, array.Length, value);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this DateTime[] array, int index, int length, DateTime value)
        {
            array.range range = new array.range(array.length(), index, length);
            if ((length = range.GetCount) != 0)
            {
                fixed (DateTime* valueFixed = array)
                {
                    DateTime* valueIndex = IndexOf(valueFixed + range.SkipCount, length, value);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        public static DateTime[] getReverse(this DateTime[] array)
        {
            return array.length() != 0 ? GetReverse(array, 0, array.Length) : array.notNull();
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        /// <returns>翻转后的新数组</returns>
        public static DateTime[] getReverse(this DateTime[] array, int index, int length)
        {
            array.range range = new array.range(array.length(), index, length);
            if (((range.SkipCount ^ index) | (range.GetCount ^ length)) == 0)
            {
                return GetReverse(array, index, length);
            }
            log.Default.Throw(log.exceptionType.IndexOutOfRange);
            return null;
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        /// <returns>翻转后的新数组</returns>
        private unsafe static DateTime[] GetReverse(DateTime[] array, int index, int length)
        {
            DateTime[] newValues = new DateTime[length];
            fixed (DateTime* valueFixed = array, newValueFixed = newValues)
            {
                for (DateTime* start = valueFixed + index, end = start + length, wirte = newValueFixed + length;
                    start != end; 
                    *--wirte = *start++) ;
            }
            return newValues;
        }
        /// <summary>
        /// 移除第一个匹配数据数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配值</param>
        /// <returns>移除数据后的数组</returns>
        public unsafe static DateTime[] removeFirst
            (this DateTime[] array, DateTime value)
        {
            if (array != null)
            {
                int index = -1;
                fixed (DateTime* valueFixed = array)
                {
                    DateTime* valueIndex = IndexOf(valueFixed, array.Length, value);
                    if (valueIndex != null) index = (int)(valueIndex - valueFixed);
                }
                if (index != -1) return GetRemoveAt(array, index);
            }
            return nullValue<DateTime>.Array;
        }
        /// <summary>
        /// 移动数据块
        /// </summary>
        /// <param name="array">待处理数组</param>
        /// <param name="index">原始数据位置</param>
        /// <param name="writeIndex">目标数据位置</param>
        /// <param name="count">移动数据数量</param>
        public unsafe static void move(this DateTime[] array, int index, int writeIndex, int count)
        {
            if (count > 0)
            {
                int writeEndIndex = writeIndex + count;
                if (index >= 0 && writeEndIndex <= array.Length)
                {
                    int endIndex = index + count;
                    if (index < writeIndex && endIndex > writeIndex)
                    {
                        fixed (DateTime* valueFixed = array)
                        {
                            for (DateTime* write = valueFixed + writeEndIndex, end = valueFixed + endIndex, start = valueFixed + index;
                                end != start;
                                *--write = *--end) ;
                        }
                    }
                    else if (writeIndex >= 0 && endIndex <= array.Length) Array.Copy(array, index, array, writeIndex, count);
                    else log.Default.Throw(log.exceptionType.IndexOutOfRange);
                }
                else log.Default.Throw(log.exceptionType.IndexOutOfRange);
            }
            else if (count != 0) log.Default.Throw(log.exceptionType.IndexOutOfRange);
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="values">数组数据</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为null</returns>
        private unsafe static DateTime* IndexOf
            (DateTime* valueFixed, int length, func<DateTime, bool> isValue)
        {
            for (DateTime* start = valueFixed, end = valueFixed + length; start != end; ++start)
            {
                if (isValue(*start)) return start;
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this DateTime[] array, func<DateTime, bool> isValue)
        {
            if (array != null)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                fixed (DateTime* valueFixed = array)
                {
                    DateTime* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf
            (this DateTime[] array, int index, int length, func<DateTime, bool> isValue)
        {
            array.range range = new array.range(array.length(), index, length);
            if ((length = range.GetCount) != 0)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                fixed (DateTime* valueFixed = array)
                {
                    DateTime* valueIndex = IndexOf(valueFixed + range.SkipCount, length, isValue);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="index">起始位置</param>
        /// <returns>第一个匹配值,失败为default(DateTime)</returns>
        public unsafe static DateTime firstOrDefault
            (this DateTime[] array, func<DateTime, bool> isValue, int index)
        {
            if (array != null && (uint)index < (uint)array.Length)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                fixed (DateTime* valueFixed = array)
                {
                    DateTime* valueIndex = IndexOf(valueFixed + index, array.Length - index, isValue);
                    if (valueIndex != null) return *valueIndex;
                }
            }
            return default(DateTime);
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public unsafe static int count
            (this DateTime[] array, int index, int count, func<DateTime, bool> isValue)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                int value = 0;
                fixed (DateTime* valueFixed = array)
                {
                    for (DateTime* start = valueFixed + index, end = start + count; start != end; ++start)
                    {
                        if (isValue(*start)) ++value;
                    }
                }
                return value;
            }
            return 0;
        }
        /// <summary>
        /// 移除第一个匹配数据数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>移除数据后的数组</returns>
        public unsafe static DateTime[] removeFirst
            (this DateTime[] array, func<DateTime, bool> isValue)
        {
            if (array != null)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                int index = -1;
                fixed (DateTime* valueFixed = array)
                {
                    DateTime* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) index = (int)(valueIndex - valueFixed);
                }
                if (index != -1) return GetRemoveAt(array, index);
                return array;
            }
            return nullValue<DateTime>.Array;
        }
        /// <summary>
        /// 替换数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">新值</param>
        /// <param name="isValue">数据匹配器</param>
        public unsafe static DateTime[] replaceFirst
            (this DateTime[] array, DateTime value, func<DateTime, bool> isValue)
        {
            if (array != null)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                fixed (DateTime* valueFixed = array)
                {
                    DateTime* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) *valueIndex = value;
                }
                return array;
            }
            return nullValue<DateTime>.Array;
        }
        /// <summary>
        /// 转换键值对集合
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="array">键值数组</param>
        /// <param name="values">数据数组</param>
        /// <returns>键值对数组</returns>
        public unsafe static keyValue<DateTime, valueType>[] getKeyValue<valueType>
            (this DateTime[] array, valueType[] values)
        {
            int length = array.length();
            if (length != values.length()) log.Default.Throw(log.exceptionType.IndexOutOfRange);
            if (length != 0)
            {
                keyValue<DateTime, valueType>[] newValues = new keyValue<DateTime, valueType>[values.Length];
                fixed (DateTime* valueFixed = array)
                {
                    DateTime* readValue = valueFixed;
                    int index = 0;
                    foreach (valueType value in values)
                    {
                        newValues[index].Set(*readValue++, value);
                        ++index;
                    }
                }
                return newValues;
            }
            return nullValue<keyValue<DateTime, valueType>>.Array;
        }
        /// <summary>
        /// 数据转换
        /// </summary>
        /// <typeparam name="valueType">数组类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public unsafe static DateTime[] getArray<valueType>
            (this valueType[] array, func<valueType, DateTime> getValue)
        {
            if (array.length() != 0)
            {
                if (getValue == null) log.Default.Throw(log.exceptionType.Null);
                DateTime[] newValues = new DateTime[array.Length];
                fixed (DateTime* newValueFixed = newValues)
                {
                    DateTime* writeValue = newValueFixed;
                    foreach (valueType value in array) *writeValue++ = getValue(value);
                }
                return newValues;
            }
            return nullValue<DateTime>.Array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public unsafe static list<DateTime> getFind
            (this DateTime[] array, func<DateTime, bool> isValue)
        {
            if (array.length() != 0)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                DateTime[] newValues = new DateTime[array.Length < sizeof(int) ? sizeof(int) : array.Length];
                fixed (DateTime* newValueFixed = newValues, valueFixed = array)
                {
                    DateTime* write = newValueFixed;
                    for (DateTime* start = valueFixed, end = valueFixed + array.Length; start != end; ++start)
                    {
                        if (isValue(*start)) *write++ = *start;
                    }
                    return new list<DateTime>(newValues, 0, (int)(write - newValueFixed), true);
                }
            }
            return null;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public unsafe static list<DateTime> getFind
            (this DateTime[] array, int index, int count, func<DateTime, bool> isValue)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                DateTime[] newValues = new DateTime[count < sizeof(int) ? sizeof(int) : count];
                fixed (DateTime* newValueFixed = newValues, valueFixed = array)
                {
                    DateTime* write = newValueFixed;
                    for (DateTime* start = valueFixed + index, end = start + count; start != end; ++start)
                    {
                        if (isValue(*start)) *write++ = *start;
                    }
                    return new list<DateTime>(newValues, 0, (int)(write - newValueFixed), true);
                }
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public unsafe static DateTime[] getFindArray
            (this DateTime[] array, func<DateTime, bool> isValue)
        {
            if (isValue == null) log.Default.Throw(log.exceptionType.Null);
            int length = array.length();
            if (length != 0)
            {
                length = (length + 7) >> 3;
                if (length <= config.pub.Default.StreamBufferLength)
                {
                    byte* data = stackalloc byte[length];
                    return GetFindArray(array, 0, array.Length, isValue, new fixedMap(data, length));
                }
                else
                {
                    byte[] data = new byte[length];
                    fixed (byte* dataFixed = data) return GetFindArray(array, 0, array.Length, isValue, new fixedMap(dataFixed));
                }
            }
            return nullValue<DateTime>.Array;
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public unsafe static DateTime[] getFindArray
            (this DateTime[] array, int index, int count, func<DateTime, bool> isValue)
        {
            if (isValue == null) log.Default.Throw(log.exceptionType.Null);
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                int length = (count + 7) >> 3;
                if (length <= config.pub.Default.StreamBufferLength)
                {
                    byte* data = stackalloc byte[length];
                    return GetFindArray(array, range.SkipCount, count, isValue, new fixedMap(data, length));
                }
                else
                {
                    byte[] data = new byte[length];
                    fixed (byte* dataFixed = data) return GetFindArray(array, range.SkipCount, count, isValue, new fixedMap(dataFixed));
                }
            }
            return nullValue<DateTime>.Array;
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="map">匹配结果位图</param>
        /// <returns>匹配数组</returns>
        private unsafe static DateTime[] GetFindArray
            (DateTime[] array, int index, int count, func<DateTime, bool> isValue, fixedMap map)
        {
            int length = 0, mapIndex = 0;
            fixed (DateTime* valueFixed = array)
            {
                DateTime* startFixed = valueFixed + index, end = startFixed + count;
                for (DateTime* start = startFixed; start != end; ++start, ++mapIndex)
                {
                    if (isValue(*start))
                    {
                        ++length;
                        map.Set(mapIndex);
                    }
                }
                if (length != 0)
                {
                    DateTime[] newValues = new DateTime[length];
                    fixed (DateTime* newValueFixed = newValues)
                    {
                        DateTime* write = newValueFixed + length;
                        while (mapIndex != 0)
                        {
                            if (map.Get(--mapIndex)) *--write = startFixed[mapIndex];
                        }
                    }
                    return newValues;
                }
            }
            return nullValue<DateTime>.Array;
        }
        /// <summary>
        /// 取子集合
        /// </summary>
        /// <typeparam name="valueType">目标数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">数据数量</param>
        /// <param name="getVlaue">目标数据获取器</param>
        /// <returns>子集合</returns>
        public unsafe static valueType[] getSub<valueType>
            (this DateTime[] array, int index, int count, func<DateTime, valueType> getVlaue)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                if (getVlaue == null) log.Default.Throw(log.exceptionType.Null);
                valueType[] newValues = new valueType[count];
                fixed (DateTime* valueFixed = array)
                {
                    DateTime* read = valueFixed + range.SkipCount;
                    for (index = 0; index != count; ++index) newValues[index] = getVlaue(*read++);
                }
                return newValues;
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 取子集合
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">数据数量</param>
        /// <param name="getVlaue">数据获取器</param>
        /// <returns>子集合</returns>
        public unsafe static DateTime[] getSub<valueType>
            (this valueType[] array, int index, int count, func<valueType, DateTime> getValue)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                if (getValue == null) log.Default.Throw(log.exceptionType.Null);
                DateTime[] newValues = new DateTime[count];
                fixed (DateTime* newValueFixed = newValues)
                {
                    DateTime* write = newValueFixed;
                    for (index = range.SkipCount, count = range.EndIndex; index != count; ++index) *write++ = getValue(array[index]);
                }
                return newValues;
            }
            return nullValue<DateTime>.Array;
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        public unsafe static list<valueType> distinct<valueType>
            (this DateTime[] array, int index, int count, func<DateTime, valueType> getValue)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                if (getValue == null) log.Default.Throw(log.exceptionType.Null);
                list<valueType>.unsafer newValues = new list<valueType>(count).Unsafer;
                System.Collections.Generic.HashSet<DateTime> hash
                    = new System.Collections.Generic.HashSet<DateTime>();
                fixed (DateTime* valueFixed = array)
                {
                    for (DateTime* start = valueFixed + range.SkipCount, end = start + count; start != end; ++start)
                    {
                        if (!hash.Contains(*start))
                        {
                            newValues.Add(getValue(*start));
                            hash.Add(*start);
                        }
                    }
                }
                return newValues.List;
            }
            return null;
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        public unsafe static list<DateTime> distinct<valueType>
            (this valueType[] array, func<valueType, DateTime> getValue)
        {
            if (array != null)
            {
                if (getValue == null) log.Default.Throw(log.exceptionType.Null);
                DateTime[] newValues = new DateTime[array.Length];
                System.Collections.Generic.HashSet<valueType> hash = new System.Collections.Generic.HashSet<valueType>();
                fixed (DateTime* newValueFixed = newValues)
                {
                    DateTime* write = newValueFixed;
                    foreach (valueType value in array)
                    {
                        if (!hash.Contains(value))
                        {
                            *write++ = getValue(value);
                            hash.Add(value);
                        }
                    }
                    return new list<DateTime>(newValues, 0, (int)(write - newValueFixed), true);
                }
            }
            return null;
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        public unsafe static list<DateTime> distinct<valueType>
            (this valueType[] array, int index, int count, func<valueType, DateTime> getValue)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                if (getValue == null) log.Default.Throw(log.exceptionType.Null);
                DateTime[] newValues = new DateTime[count];
                System.Collections.Generic.HashSet<valueType> hash = new System.Collections.Generic.HashSet<valueType>();
                valueType value;
                fixed (DateTime* newValueFixed = newValues)
                {
                    DateTime* write = newValueFixed;
                    for (index = range.SkipCount, count = range.EndIndex; index != count; ++index)
                    {
                        if (!hash.Contains(value = array[index]))
                        {
                            *write++ = getValue(value);
                            hash.Add(value);
                        }
                    }
                    return new list<DateTime>(newValues, 0, (int)(write - newValueFixed), true);
                }
            }
            return null;
        }
        /// <summary>
        /// 求交集
        /// </summary>
        /// <param name="left">左侧数据</param>
        /// <param name="right">右侧数据</param>
        /// <returns>数据交集</returns>
        public unsafe static list<DateTime> intersect(this DateTime[] left, DateTime[] right)
        {
            int leftLength = left.length();
            if (leftLength != 0)
            {
                int rightLength = right.length();
                if (rightLength != 0)
                {
                    DateTime[] min = leftLength <= rightLength ? left : right, values = new DateTime[min.Length];
                    fixed (DateTime* valueFixed = values)
                    {
                        DateTime* write = valueFixed;
                        staticHashSet<DateTime> hash = new staticHashSet<DateTime>(min);
                        foreach (DateTime value in leftLength <= rightLength ? right : left)
                        {
                            if (hash.Contains(value)) *write++ = value;
                        }
                        return new list<DateTime>(values, 0, (int)(write - valueFixed), true);
                    }
                }
            }
            return null;
        }
        /// <summary>
        /// 遍历foreach
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">遍历数据数量</param>
        /// <param name="method">调用函数</param>
        /// <returns>数据数组</returns>
        public unsafe static DateTime[] each
            (this DateTime[] array, int index, int count, action<DateTime> method)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                if (method == null) log.Default.Throw(log.exceptionType.Null);
                fixed (DateTime* valueFixed = array)
                {
                    for (DateTime* start = valueFixed + index, end = start + count; start != end; method(*start++)) ;
                }
                return array;
            }
            return nullValue<DateTime>.Array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public unsafe static bool max(this DateTime[] array, out DateTime value)
        {
            if (array.length() != 0)
            {
                fixed (DateTime* valueFixed = array)
                {
                    value = *valueFixed;
                    for (DateTime* start = valueFixed + 1, end = valueFixed + array.Length; start != end; ++start)
                    {
                        if (*start > value) value = *start;
                    }
                    return true;
                }
            }
            value = DateTime.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public unsafe static DateTime max(this DateTime[] array, DateTime nullValue)
        {
            DateTime value;
            return max(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public unsafe static bool max(this DateTime[] array, int index, int count, out DateTime value)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                fixed (DateTime* valueFixed = array)
                {
                    DateTime* start = valueFixed + range.SkipCount;
                    value = *start;
                    for (DateTime* end = start + count; ++start != end; )
                    {
                        if (*start > value) value = *start;
                    }
                    return true;
                }
            }
            value = DateTime.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public unsafe static DateTime max
            (this DateTime[] array, int index, int count, DateTime nullValue)
        {
            DateTime value;
            return max(array, index, count, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>
            (this valueType[] array, func<valueType, DateTime> getKey, out DateTime value)
        {
            if (array.length() != 0)
            {
                value = getKey(array[0]);
                foreach (valueType nextValue in array)
                {
                    DateTime nextKey = getKey(nextValue);
                    if (nextKey > value) value = nextKey;
                }
                return true;
            }
            value = DateTime.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static DateTime maxKey<valueType>
            (this valueType[] array, func<valueType, DateTime> getKey, DateTime nullValue)
        {
            DateTime value;
            return maxKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>
            (this valueType[] array, int index, int count, func<valueType, DateTime> getKey
            , out DateTime value)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                value = getKey(array[index = range.SkipCount]);
                for (int endIndex = index + count; ++index != endIndex; )
                {
                    DateTime nextValue = getKey(array[index]);
                    if (nextValue > value) value = nextValue;
                }
                return true;
            }
            value = DateTime.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static DateTime maxKey<valueType>
            (this valueType[] array, int index, int count, func<valueType, DateTime> getKey
            , DateTime nullValue)
        {
            DateTime value;
            return maxKey(array, index, count, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>
            (this valueType[] array, func<valueType, DateTime> getKey, out valueType value)
        {
            if (array.length() != 0)
            {
                value = array[0];
                DateTime maxKey = getKey(value);
                foreach (valueType nextValue in array)
                {
                    DateTime nextKey = getKey(nextValue);
                    if (nextKey > maxKey)
                    {
                        maxKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static valueType max<valueType>(this valueType[] array, func<valueType, DateTime> getKey, valueType nullValue)
        {
            valueType value;
            return max(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>
            (this valueType[] array, int index, int count, func<valueType, DateTime> getKey, out valueType value)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                value = array[index = range.SkipCount];
                DateTime maxValue = getKey(value);
                for (int endIndex = index + count; ++index != endIndex; )
                {
                    DateTime nextValue = getKey(array[index]);
                    if (nextValue > maxValue)
                    {
                        maxValue = nextValue;
                        value = array[index];
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static valueType max<valueType>
            (this valueType[] array, int index, int count, func<valueType, DateTime> getKey, valueType nullValue)
        {
            valueType value;
            return max(array, index, count, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public unsafe static bool min(this DateTime[] array, out DateTime value)
        {
            if (array.length() != 0)
            {
                fixed (DateTime* valueFixed = array)
                {
                    value = *valueFixed;
                    for (DateTime* start = valueFixed + 1, end = valueFixed + array.Length; start != end; ++start)
                    {
                        if (*start < value) value = *start;
                    }
                    return true;
                }
            }
            value = DateTime.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public unsafe static DateTime min(this DateTime[] array, DateTime nullValue)
        {
            DateTime value;
            return min(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public unsafe static bool min(this DateTime[] array, int index, int count, out DateTime value)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                fixed (DateTime* valueFixed = array)
                {
                    DateTime* start = valueFixed + range.SkipCount;
                    value = *start;
                    for (DateTime* end = start + count; ++start != end; )
                    {
                        if (*start < value) value = *start;
                    }
                    return true;
                }
            }
            value = DateTime.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public unsafe static DateTime min
            (this DateTime[] array, int index, int count, DateTime nullValue)
        {
            DateTime value;
            return min(array, index, count, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>
            (this valueType[] array, func<valueType, DateTime> getKey, out DateTime value)
        {
            if (array.length() != 0)
            {
                value = getKey(array[0]);
                foreach (valueType nextValue in array)
                {
                    DateTime nextKey = getKey(nextValue);
                    if (nextKey < value) value = nextKey;
                }
                return true;
            }
            value = DateTime.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static DateTime minKey<valueType>
            (this valueType[] array, func<valueType, DateTime> getKey, DateTime nullValue)
        {
            DateTime value;
            return minKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>
            (this valueType[] array, int index, int count, func<valueType, DateTime> getKey
            , out DateTime value)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                value = getKey(array[index = range.SkipCount]);
                for (int endIndex = index + count; ++index != endIndex; )
                {
                    DateTime nextValue = getKey(array[index]);
                    if (nextValue < value) value = nextValue;
                }
                return true;
            }
            value = DateTime.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static DateTime minKey<valueType>
            (this valueType[] array, int index, int count, func<valueType, DateTime> getKey
            , DateTime nullValue)
        {
            DateTime value;
            return minKey(array, index, count, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>(this valueType[] array, func<valueType, DateTime> getKey, out valueType value)
        {
            if (array.length() != 0)
            {
                value = array[0];
                DateTime minKey = getKey(value);
                foreach (valueType nextValue in array)
                {
                    DateTime nextKey = getKey(nextValue);
                    if (nextKey < minKey)
                    {
                        minKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static valueType min<valueType>(this valueType[] array, func<valueType, DateTime> getKey, valueType nullValue)
        {
            valueType value;
            return min(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>
            (this valueType[] array, int index, int count, func<valueType, DateTime> getKey, out valueType value)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                value = array[index = range.SkipCount];
                DateTime minValue = getKey(value);
                for (int endIndex = index + count; ++index != endIndex; )
                {
                    DateTime nextValue = getKey(array[index]);
                    if (nextValue < minValue)
                    {
                        minValue = nextValue;
                        value = array[index];
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static valueType min<valueType>
            (this valueType[] array, int index, int count, func<valueType, DateTime> getKey, valueType nullValue)
        {
            valueType value;
            return min(array, index, count, getKey, out value) ? value : nullValue;
        }
    }
}

namespace fastCSharp.unsafer
{
    /// <summary>
    /// 数组非安全扩展操作(请自行确保数据可靠性)
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 移动数据块
        /// </summary>
        /// <param name="array">待处理数组</param>
        /// <param name="index">原始数据位置</param>
        /// <param name="writeIndex">目标数据位置</param>
        /// <param name="count">移动数据数量</param>
        public unsafe static void Move(DateTime[] array, int index, int writeIndex, int count)
        {
            int endIndex = index + count;
            if (index < writeIndex && endIndex > writeIndex)
            {
                fixed (DateTime* valueFixed = array)
                {
                    for (DateTime* write = valueFixed + writeIndex + count, start = valueFixed + index, end = valueFixed + endIndex;
                        end != start;
                        *--write = *--end) ;
                }
            }
            else Array.Copy(array, index, array, writeIndex, count);
        }
    }
}
namespace fastCSharp
{
    /// <summary>
    /// 集合相关扩展
    /// </summary>
    public static partial class iCollection
    {
        /// <summary>
        /// 根据集合内容返回数组
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>数组</returns>
        public unsafe static long[] getArray
            (this System.Collections.Generic.ICollection<long> values)
        {
            if (values.count() != 0)
            {
                long[] newValues = new long[values.Count];
                fixed (long* newValueFixed = newValues)
                {
                    long* write = newValueFixed;
                    foreach (long value in values) *write++ = value;
                }
                return newValues;
            }
            return nullValue<long>.Array;
        }
        /// <summary>
        /// 根据集合内容返回数组
        /// </summary>
        /// <typeparam name="valueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>数组</returns>
        public unsafe static long[] getArray<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, long> getValue)
        {
            if (values.count() != 0)
            {
                if (getValue == null) log.Default.Throw(log.exceptionType.Null);
                long[] newValues = new long[values.Count];
                fixed (long* newValueFixed = newValues)
                {
                    long* write = newValueFixed;
                    foreach (valueType value in values) *write++ = getValue(value);
                }
                return newValues;
            }
            return nullValue<long>.Array;
        }
        /// <summary>
        /// 根据集合内容返回单向列表
        /// </summary>
        /// <typeparam name="valueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>单向列表</returns>
        public static list<long> getList<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, long> getValue)
        {
            return values != null ? new list<long>(getArray(values, getValue), true) : null;
        }
        /// <summary>
        /// 根据集合内容返回单向列表
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>单向列表</returns>
        public static list<long> getList(this System.Collections.Generic.ICollection<long> values)
        {
            return values != null ? new list<long>(getArray(values), true) : null;
        }
        /// <summary>
        /// 根据集合内容返回双向列表
        /// </summary>
        /// <typeparam name="valueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>双向列表</returns>
        public static collection<long> getCollection<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, long> getValue)
        {
            return values != null ? new collection<long>(getArray(values, getValue), true) : null;
        }
        /// <summary>
        /// 根据集合内容返回双向列表
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>双向列表</returns>
        public static collection<long> getCollection
            (this System.Collections.Generic.ICollection<long> values)
        {
            return values != null ? new collection<long>(getArray(values), true) : null;
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public unsafe static list<long> getFind
            (this System.Collections.Generic.ICollection<long> values, func<long, bool> isValue)
        {
            if (values.count() != 0)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                long[] newValues = new long[values.Count];
                fixed (long* newValueFixed = newValues)
                {
                    long* write = newValueFixed;
                    foreach (long value in values)
                    {
                        if (isValue(value)) *write++ = value;
                    }
                    return new list<long>(newValues, 0, (int)(write - newValueFixed), true);
                }
            }
            return null;
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public unsafe static list<long> getFind
            (this System.Collections.ICollection values, func<long, bool> isValue)
        {
            if (values != null)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                long[] newValues = new long[values.Count];
                fixed (long* newValueFixed = newValues)
                {
                    long* write = newValueFixed;
                    foreach (long value in values)
                    {
                        if (isValue(value)) *write++ = value;
                    }
                    return new list<long>(newValues, 0, (int)(write - newValueFixed), true);
                }
            }
            return null;
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public static long[] getFindArray
            (this System.Collections.Generic.ICollection<long> values, func<long, bool> isValue)
        {
            return values.getFind(isValue).toArray();
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public static long[] getFindArray
            (this System.Collections.ICollection values, func<long, bool> isValue)
        {
            return values.getFind(isValue).toArray();
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max
            (this System.Collections.Generic.ICollection<long> values, out long value)
        {
            if (values.count() != 0)
            {
                value = long.MinValue;
                foreach (long nextValue in values)
                {
                    if (nextValue > value) value = nextValue;
                }
                return true;
            }
            value = long.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static long max
            (this System.Collections.Generic.ICollection<long> values, long nullValue)
        {
            long value;
            return max(values, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, long> getKey
            , out valueType value)
        {
            if (values.count() != 0)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                value = default(valueType);
                int count = -1;
                long key = long.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        long nextKey = getKey(nextValue);
                        if (nextKey > key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static valueType max<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, long> getKey
            , valueType nullValue)
        {
            valueType value;
            return max(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="key">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, long> getKey
            , out long key)
        {
            if (values.count() != 0)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                valueType value = default(valueType);
                int count = -1;
                key = long.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        long nextKey = getKey(nextValue);
                        if (nextKey > key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                return true;
            }
            key = default(long);
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static long maxKey<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, long> getKey
            , long nullValue)
        {
            long value;
            return maxKey(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min
            (this System.Collections.Generic.ICollection<long> values, out long value)
        {
            if (values.count() != 0)
            {
                value = long.MinValue;
                foreach (long nextValue in values)
                {
                    if (nextValue < value) value = nextValue;
                }
                return true;
            }
            value = long.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static long min
            (this System.Collections.Generic.ICollection<long> values, long nullValue)
        {
            long value;
            return min(values, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, long> getKey
            , out valueType value)
        {
            if (values.count() != 0)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                value = default(valueType);
                int count = -1;
                long key = long.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        long nextKey = getKey(nextValue);
                        if (nextKey < key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static valueType min<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, long> getKey
            , valueType nullValue)
        {
            valueType value;
            return min(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="key">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, long> getKey
            , out long key)
        {
            if (values.count() != 0)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                valueType value = default(valueType);
                int count = -1;
                key = long.MaxValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        long nextKey = getKey(nextValue);
                        if (nextKey < key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                return true;
            }
            key = default(long);
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static long minKey<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, long> getKey
            , long nullValue)
        {
            long value;
            return minKey(values, getKey, out value) ? value : nullValue;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 集合相关扩展
    /// </summary>
    public static partial class iCollection
    {
        /// <summary>
        /// 根据集合内容返回数组
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>数组</returns>
        public unsafe static uint[] getArray
            (this System.Collections.Generic.ICollection<uint> values)
        {
            if (values.count() != 0)
            {
                uint[] newValues = new uint[values.Count];
                fixed (uint* newValueFixed = newValues)
                {
                    uint* write = newValueFixed;
                    foreach (uint value in values) *write++ = value;
                }
                return newValues;
            }
            return nullValue<uint>.Array;
        }
        /// <summary>
        /// 根据集合内容返回数组
        /// </summary>
        /// <typeparam name="valueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>数组</returns>
        public unsafe static uint[] getArray<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, uint> getValue)
        {
            if (values.count() != 0)
            {
                if (getValue == null) log.Default.Throw(log.exceptionType.Null);
                uint[] newValues = new uint[values.Count];
                fixed (uint* newValueFixed = newValues)
                {
                    uint* write = newValueFixed;
                    foreach (valueType value in values) *write++ = getValue(value);
                }
                return newValues;
            }
            return nullValue<uint>.Array;
        }
        /// <summary>
        /// 根据集合内容返回单向列表
        /// </summary>
        /// <typeparam name="valueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>单向列表</returns>
        public static list<uint> getList<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, uint> getValue)
        {
            return values != null ? new list<uint>(getArray(values, getValue), true) : null;
        }
        /// <summary>
        /// 根据集合内容返回单向列表
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>单向列表</returns>
        public static list<uint> getList(this System.Collections.Generic.ICollection<uint> values)
        {
            return values != null ? new list<uint>(getArray(values), true) : null;
        }
        /// <summary>
        /// 根据集合内容返回双向列表
        /// </summary>
        /// <typeparam name="valueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>双向列表</returns>
        public static collection<uint> getCollection<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, uint> getValue)
        {
            return values != null ? new collection<uint>(getArray(values, getValue), true) : null;
        }
        /// <summary>
        /// 根据集合内容返回双向列表
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>双向列表</returns>
        public static collection<uint> getCollection
            (this System.Collections.Generic.ICollection<uint> values)
        {
            return values != null ? new collection<uint>(getArray(values), true) : null;
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public unsafe static list<uint> getFind
            (this System.Collections.Generic.ICollection<uint> values, func<uint, bool> isValue)
        {
            if (values.count() != 0)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                uint[] newValues = new uint[values.Count];
                fixed (uint* newValueFixed = newValues)
                {
                    uint* write = newValueFixed;
                    foreach (uint value in values)
                    {
                        if (isValue(value)) *write++ = value;
                    }
                    return new list<uint>(newValues, 0, (int)(write - newValueFixed), true);
                }
            }
            return null;
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public unsafe static list<uint> getFind
            (this System.Collections.ICollection values, func<uint, bool> isValue)
        {
            if (values != null)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                uint[] newValues = new uint[values.Count];
                fixed (uint* newValueFixed = newValues)
                {
                    uint* write = newValueFixed;
                    foreach (uint value in values)
                    {
                        if (isValue(value)) *write++ = value;
                    }
                    return new list<uint>(newValues, 0, (int)(write - newValueFixed), true);
                }
            }
            return null;
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public static uint[] getFindArray
            (this System.Collections.Generic.ICollection<uint> values, func<uint, bool> isValue)
        {
            return values.getFind(isValue).toArray();
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public static uint[] getFindArray
            (this System.Collections.ICollection values, func<uint, bool> isValue)
        {
            return values.getFind(isValue).toArray();
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max
            (this System.Collections.Generic.ICollection<uint> values, out uint value)
        {
            if (values.count() != 0)
            {
                value = uint.MinValue;
                foreach (uint nextValue in values)
                {
                    if (nextValue > value) value = nextValue;
                }
                return true;
            }
            value = uint.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static uint max
            (this System.Collections.Generic.ICollection<uint> values, uint nullValue)
        {
            uint value;
            return max(values, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, uint> getKey
            , out valueType value)
        {
            if (values.count() != 0)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                value = default(valueType);
                int count = -1;
                uint key = uint.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        uint nextKey = getKey(nextValue);
                        if (nextKey > key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static valueType max<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, uint> getKey
            , valueType nullValue)
        {
            valueType value;
            return max(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="key">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, uint> getKey
            , out uint key)
        {
            if (values.count() != 0)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                valueType value = default(valueType);
                int count = -1;
                key = uint.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        uint nextKey = getKey(nextValue);
                        if (nextKey > key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                return true;
            }
            key = default(uint);
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static uint maxKey<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, uint> getKey
            , uint nullValue)
        {
            uint value;
            return maxKey(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min
            (this System.Collections.Generic.ICollection<uint> values, out uint value)
        {
            if (values.count() != 0)
            {
                value = uint.MinValue;
                foreach (uint nextValue in values)
                {
                    if (nextValue < value) value = nextValue;
                }
                return true;
            }
            value = uint.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static uint min
            (this System.Collections.Generic.ICollection<uint> values, uint nullValue)
        {
            uint value;
            return min(values, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, uint> getKey
            , out valueType value)
        {
            if (values.count() != 0)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                value = default(valueType);
                int count = -1;
                uint key = uint.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        uint nextKey = getKey(nextValue);
                        if (nextKey < key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static valueType min<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, uint> getKey
            , valueType nullValue)
        {
            valueType value;
            return min(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="key">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, uint> getKey
            , out uint key)
        {
            if (values.count() != 0)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                valueType value = default(valueType);
                int count = -1;
                key = uint.MaxValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        uint nextKey = getKey(nextValue);
                        if (nextKey < key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                return true;
            }
            key = default(uint);
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static uint minKey<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, uint> getKey
            , uint nullValue)
        {
            uint value;
            return minKey(values, getKey, out value) ? value : nullValue;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 集合相关扩展
    /// </summary>
    public static partial class iCollection
    {
        /// <summary>
        /// 根据集合内容返回数组
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>数组</returns>
        public unsafe static int[] getArray
            (this System.Collections.Generic.ICollection<int> values)
        {
            if (values.count() != 0)
            {
                int[] newValues = new int[values.Count];
                fixed (int* newValueFixed = newValues)
                {
                    int* write = newValueFixed;
                    foreach (int value in values) *write++ = value;
                }
                return newValues;
            }
            return nullValue<int>.Array;
        }
        /// <summary>
        /// 根据集合内容返回数组
        /// </summary>
        /// <typeparam name="valueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>数组</returns>
        public unsafe static int[] getArray<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, int> getValue)
        {
            if (values.count() != 0)
            {
                if (getValue == null) log.Default.Throw(log.exceptionType.Null);
                int[] newValues = new int[values.Count];
                fixed (int* newValueFixed = newValues)
                {
                    int* write = newValueFixed;
                    foreach (valueType value in values) *write++ = getValue(value);
                }
                return newValues;
            }
            return nullValue<int>.Array;
        }
        /// <summary>
        /// 根据集合内容返回单向列表
        /// </summary>
        /// <typeparam name="valueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>单向列表</returns>
        public static list<int> getList<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, int> getValue)
        {
            return values != null ? new list<int>(getArray(values, getValue), true) : null;
        }
        /// <summary>
        /// 根据集合内容返回单向列表
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>单向列表</returns>
        public static list<int> getList(this System.Collections.Generic.ICollection<int> values)
        {
            return values != null ? new list<int>(getArray(values), true) : null;
        }
        /// <summary>
        /// 根据集合内容返回双向列表
        /// </summary>
        /// <typeparam name="valueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>双向列表</returns>
        public static collection<int> getCollection<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, int> getValue)
        {
            return values != null ? new collection<int>(getArray(values, getValue), true) : null;
        }
        /// <summary>
        /// 根据集合内容返回双向列表
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>双向列表</returns>
        public static collection<int> getCollection
            (this System.Collections.Generic.ICollection<int> values)
        {
            return values != null ? new collection<int>(getArray(values), true) : null;
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public unsafe static list<int> getFind
            (this System.Collections.Generic.ICollection<int> values, func<int, bool> isValue)
        {
            if (values.count() != 0)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                int[] newValues = new int[values.Count];
                fixed (int* newValueFixed = newValues)
                {
                    int* write = newValueFixed;
                    foreach (int value in values)
                    {
                        if (isValue(value)) *write++ = value;
                    }
                    return new list<int>(newValues, 0, (int)(write - newValueFixed), true);
                }
            }
            return null;
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public unsafe static list<int> getFind
            (this System.Collections.ICollection values, func<int, bool> isValue)
        {
            if (values != null)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                int[] newValues = new int[values.Count];
                fixed (int* newValueFixed = newValues)
                {
                    int* write = newValueFixed;
                    foreach (int value in values)
                    {
                        if (isValue(value)) *write++ = value;
                    }
                    return new list<int>(newValues, 0, (int)(write - newValueFixed), true);
                }
            }
            return null;
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public static int[] getFindArray
            (this System.Collections.Generic.ICollection<int> values, func<int, bool> isValue)
        {
            return values.getFind(isValue).toArray();
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public static int[] getFindArray
            (this System.Collections.ICollection values, func<int, bool> isValue)
        {
            return values.getFind(isValue).toArray();
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max
            (this System.Collections.Generic.ICollection<int> values, out int value)
        {
            if (values.count() != 0)
            {
                value = int.MinValue;
                foreach (int nextValue in values)
                {
                    if (nextValue > value) value = nextValue;
                }
                return true;
            }
            value = int.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static int max
            (this System.Collections.Generic.ICollection<int> values, int nullValue)
        {
            int value;
            return max(values, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, int> getKey
            , out valueType value)
        {
            if (values.count() != 0)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                value = default(valueType);
                int count = -1;
                int key = int.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        int nextKey = getKey(nextValue);
                        if (nextKey > key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static valueType max<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, int> getKey
            , valueType nullValue)
        {
            valueType value;
            return max(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="key">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, int> getKey
            , out int key)
        {
            if (values.count() != 0)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                valueType value = default(valueType);
                int count = -1;
                key = int.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        int nextKey = getKey(nextValue);
                        if (nextKey > key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                return true;
            }
            key = default(int);
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static int maxKey<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, int> getKey
            , int nullValue)
        {
            int value;
            return maxKey(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min
            (this System.Collections.Generic.ICollection<int> values, out int value)
        {
            if (values.count() != 0)
            {
                value = int.MinValue;
                foreach (int nextValue in values)
                {
                    if (nextValue < value) value = nextValue;
                }
                return true;
            }
            value = int.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static int min
            (this System.Collections.Generic.ICollection<int> values, int nullValue)
        {
            int value;
            return min(values, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, int> getKey
            , out valueType value)
        {
            if (values.count() != 0)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                value = default(valueType);
                int count = -1;
                int key = int.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        int nextKey = getKey(nextValue);
                        if (nextKey < key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static valueType min<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, int> getKey
            , valueType nullValue)
        {
            valueType value;
            return min(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="key">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, int> getKey
            , out int key)
        {
            if (values.count() != 0)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                valueType value = default(valueType);
                int count = -1;
                key = int.MaxValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        int nextKey = getKey(nextValue);
                        if (nextKey < key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                return true;
            }
            key = default(int);
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static int minKey<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, int> getKey
            , int nullValue)
        {
            int value;
            return minKey(values, getKey, out value) ? value : nullValue;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 集合相关扩展
    /// </summary>
    public static partial class iCollection
    {
        /// <summary>
        /// 根据集合内容返回数组
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>数组</returns>
        public unsafe static ushort[] getArray
            (this System.Collections.Generic.ICollection<ushort> values)
        {
            if (values.count() != 0)
            {
                ushort[] newValues = new ushort[values.Count];
                fixed (ushort* newValueFixed = newValues)
                {
                    ushort* write = newValueFixed;
                    foreach (ushort value in values) *write++ = value;
                }
                return newValues;
            }
            return nullValue<ushort>.Array;
        }
        /// <summary>
        /// 根据集合内容返回数组
        /// </summary>
        /// <typeparam name="valueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>数组</returns>
        public unsafe static ushort[] getArray<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, ushort> getValue)
        {
            if (values.count() != 0)
            {
                if (getValue == null) log.Default.Throw(log.exceptionType.Null);
                ushort[] newValues = new ushort[values.Count];
                fixed (ushort* newValueFixed = newValues)
                {
                    ushort* write = newValueFixed;
                    foreach (valueType value in values) *write++ = getValue(value);
                }
                return newValues;
            }
            return nullValue<ushort>.Array;
        }
        /// <summary>
        /// 根据集合内容返回单向列表
        /// </summary>
        /// <typeparam name="valueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>单向列表</returns>
        public static list<ushort> getList<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, ushort> getValue)
        {
            return values != null ? new list<ushort>(getArray(values, getValue), true) : null;
        }
        /// <summary>
        /// 根据集合内容返回单向列表
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>单向列表</returns>
        public static list<ushort> getList(this System.Collections.Generic.ICollection<ushort> values)
        {
            return values != null ? new list<ushort>(getArray(values), true) : null;
        }
        /// <summary>
        /// 根据集合内容返回双向列表
        /// </summary>
        /// <typeparam name="valueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>双向列表</returns>
        public static collection<ushort> getCollection<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, ushort> getValue)
        {
            return values != null ? new collection<ushort>(getArray(values, getValue), true) : null;
        }
        /// <summary>
        /// 根据集合内容返回双向列表
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>双向列表</returns>
        public static collection<ushort> getCollection
            (this System.Collections.Generic.ICollection<ushort> values)
        {
            return values != null ? new collection<ushort>(getArray(values), true) : null;
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public unsafe static list<ushort> getFind
            (this System.Collections.Generic.ICollection<ushort> values, func<ushort, bool> isValue)
        {
            if (values.count() != 0)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                ushort[] newValues = new ushort[values.Count];
                fixed (ushort* newValueFixed = newValues)
                {
                    ushort* write = newValueFixed;
                    foreach (ushort value in values)
                    {
                        if (isValue(value)) *write++ = value;
                    }
                    return new list<ushort>(newValues, 0, (int)(write - newValueFixed), true);
                }
            }
            return null;
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public unsafe static list<ushort> getFind
            (this System.Collections.ICollection values, func<ushort, bool> isValue)
        {
            if (values != null)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                ushort[] newValues = new ushort[values.Count];
                fixed (ushort* newValueFixed = newValues)
                {
                    ushort* write = newValueFixed;
                    foreach (ushort value in values)
                    {
                        if (isValue(value)) *write++ = value;
                    }
                    return new list<ushort>(newValues, 0, (int)(write - newValueFixed), true);
                }
            }
            return null;
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public static ushort[] getFindArray
            (this System.Collections.Generic.ICollection<ushort> values, func<ushort, bool> isValue)
        {
            return values.getFind(isValue).toArray();
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public static ushort[] getFindArray
            (this System.Collections.ICollection values, func<ushort, bool> isValue)
        {
            return values.getFind(isValue).toArray();
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max
            (this System.Collections.Generic.ICollection<ushort> values, out ushort value)
        {
            if (values.count() != 0)
            {
                value = ushort.MinValue;
                foreach (ushort nextValue in values)
                {
                    if (nextValue > value) value = nextValue;
                }
                return true;
            }
            value = ushort.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static ushort max
            (this System.Collections.Generic.ICollection<ushort> values, ushort nullValue)
        {
            ushort value;
            return max(values, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, ushort> getKey
            , out valueType value)
        {
            if (values.count() != 0)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                value = default(valueType);
                int count = -1;
                ushort key = ushort.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        ushort nextKey = getKey(nextValue);
                        if (nextKey > key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static valueType max<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, ushort> getKey
            , valueType nullValue)
        {
            valueType value;
            return max(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="key">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, ushort> getKey
            , out ushort key)
        {
            if (values.count() != 0)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                valueType value = default(valueType);
                int count = -1;
                key = ushort.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        ushort nextKey = getKey(nextValue);
                        if (nextKey > key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                return true;
            }
            key = default(ushort);
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static ushort maxKey<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, ushort> getKey
            , ushort nullValue)
        {
            ushort value;
            return maxKey(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min
            (this System.Collections.Generic.ICollection<ushort> values, out ushort value)
        {
            if (values.count() != 0)
            {
                value = ushort.MinValue;
                foreach (ushort nextValue in values)
                {
                    if (nextValue < value) value = nextValue;
                }
                return true;
            }
            value = ushort.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static ushort min
            (this System.Collections.Generic.ICollection<ushort> values, ushort nullValue)
        {
            ushort value;
            return min(values, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, ushort> getKey
            , out valueType value)
        {
            if (values.count() != 0)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                value = default(valueType);
                int count = -1;
                ushort key = ushort.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        ushort nextKey = getKey(nextValue);
                        if (nextKey < key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static valueType min<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, ushort> getKey
            , valueType nullValue)
        {
            valueType value;
            return min(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="key">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, ushort> getKey
            , out ushort key)
        {
            if (values.count() != 0)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                valueType value = default(valueType);
                int count = -1;
                key = ushort.MaxValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        ushort nextKey = getKey(nextValue);
                        if (nextKey < key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                return true;
            }
            key = default(ushort);
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static ushort minKey<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, ushort> getKey
            , ushort nullValue)
        {
            ushort value;
            return minKey(values, getKey, out value) ? value : nullValue;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 集合相关扩展
    /// </summary>
    public static partial class iCollection
    {
        /// <summary>
        /// 根据集合内容返回数组
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>数组</returns>
        public unsafe static short[] getArray
            (this System.Collections.Generic.ICollection<short> values)
        {
            if (values.count() != 0)
            {
                short[] newValues = new short[values.Count];
                fixed (short* newValueFixed = newValues)
                {
                    short* write = newValueFixed;
                    foreach (short value in values) *write++ = value;
                }
                return newValues;
            }
            return nullValue<short>.Array;
        }
        /// <summary>
        /// 根据集合内容返回数组
        /// </summary>
        /// <typeparam name="valueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>数组</returns>
        public unsafe static short[] getArray<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, short> getValue)
        {
            if (values.count() != 0)
            {
                if (getValue == null) log.Default.Throw(log.exceptionType.Null);
                short[] newValues = new short[values.Count];
                fixed (short* newValueFixed = newValues)
                {
                    short* write = newValueFixed;
                    foreach (valueType value in values) *write++ = getValue(value);
                }
                return newValues;
            }
            return nullValue<short>.Array;
        }
        /// <summary>
        /// 根据集合内容返回单向列表
        /// </summary>
        /// <typeparam name="valueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>单向列表</returns>
        public static list<short> getList<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, short> getValue)
        {
            return values != null ? new list<short>(getArray(values, getValue), true) : null;
        }
        /// <summary>
        /// 根据集合内容返回单向列表
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>单向列表</returns>
        public static list<short> getList(this System.Collections.Generic.ICollection<short> values)
        {
            return values != null ? new list<short>(getArray(values), true) : null;
        }
        /// <summary>
        /// 根据集合内容返回双向列表
        /// </summary>
        /// <typeparam name="valueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>双向列表</returns>
        public static collection<short> getCollection<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, short> getValue)
        {
            return values != null ? new collection<short>(getArray(values, getValue), true) : null;
        }
        /// <summary>
        /// 根据集合内容返回双向列表
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>双向列表</returns>
        public static collection<short> getCollection
            (this System.Collections.Generic.ICollection<short> values)
        {
            return values != null ? new collection<short>(getArray(values), true) : null;
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public unsafe static list<short> getFind
            (this System.Collections.Generic.ICollection<short> values, func<short, bool> isValue)
        {
            if (values.count() != 0)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                short[] newValues = new short[values.Count];
                fixed (short* newValueFixed = newValues)
                {
                    short* write = newValueFixed;
                    foreach (short value in values)
                    {
                        if (isValue(value)) *write++ = value;
                    }
                    return new list<short>(newValues, 0, (int)(write - newValueFixed), true);
                }
            }
            return null;
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public unsafe static list<short> getFind
            (this System.Collections.ICollection values, func<short, bool> isValue)
        {
            if (values != null)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                short[] newValues = new short[values.Count];
                fixed (short* newValueFixed = newValues)
                {
                    short* write = newValueFixed;
                    foreach (short value in values)
                    {
                        if (isValue(value)) *write++ = value;
                    }
                    return new list<short>(newValues, 0, (int)(write - newValueFixed), true);
                }
            }
            return null;
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public static short[] getFindArray
            (this System.Collections.Generic.ICollection<short> values, func<short, bool> isValue)
        {
            return values.getFind(isValue).toArray();
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public static short[] getFindArray
            (this System.Collections.ICollection values, func<short, bool> isValue)
        {
            return values.getFind(isValue).toArray();
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max
            (this System.Collections.Generic.ICollection<short> values, out short value)
        {
            if (values.count() != 0)
            {
                value = short.MinValue;
                foreach (short nextValue in values)
                {
                    if (nextValue > value) value = nextValue;
                }
                return true;
            }
            value = short.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static short max
            (this System.Collections.Generic.ICollection<short> values, short nullValue)
        {
            short value;
            return max(values, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, short> getKey
            , out valueType value)
        {
            if (values.count() != 0)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                value = default(valueType);
                int count = -1;
                short key = short.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        short nextKey = getKey(nextValue);
                        if (nextKey > key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static valueType max<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, short> getKey
            , valueType nullValue)
        {
            valueType value;
            return max(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="key">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, short> getKey
            , out short key)
        {
            if (values.count() != 0)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                valueType value = default(valueType);
                int count = -1;
                key = short.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        short nextKey = getKey(nextValue);
                        if (nextKey > key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                return true;
            }
            key = default(short);
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static short maxKey<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, short> getKey
            , short nullValue)
        {
            short value;
            return maxKey(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min
            (this System.Collections.Generic.ICollection<short> values, out short value)
        {
            if (values.count() != 0)
            {
                value = short.MinValue;
                foreach (short nextValue in values)
                {
                    if (nextValue < value) value = nextValue;
                }
                return true;
            }
            value = short.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static short min
            (this System.Collections.Generic.ICollection<short> values, short nullValue)
        {
            short value;
            return min(values, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, short> getKey
            , out valueType value)
        {
            if (values.count() != 0)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                value = default(valueType);
                int count = -1;
                short key = short.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        short nextKey = getKey(nextValue);
                        if (nextKey < key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static valueType min<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, short> getKey
            , valueType nullValue)
        {
            valueType value;
            return min(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="key">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, short> getKey
            , out short key)
        {
            if (values.count() != 0)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                valueType value = default(valueType);
                int count = -1;
                key = short.MaxValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        short nextKey = getKey(nextValue);
                        if (nextKey < key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                return true;
            }
            key = default(short);
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static short minKey<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, short> getKey
            , short nullValue)
        {
            short value;
            return minKey(values, getKey, out value) ? value : nullValue;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 集合相关扩展
    /// </summary>
    public static partial class iCollection
    {
        /// <summary>
        /// 根据集合内容返回数组
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>数组</returns>
        public unsafe static byte[] getArray
            (this System.Collections.Generic.ICollection<byte> values)
        {
            if (values.count() != 0)
            {
                byte[] newValues = new byte[values.Count];
                fixed (byte* newValueFixed = newValues)
                {
                    byte* write = newValueFixed;
                    foreach (byte value in values) *write++ = value;
                }
                return newValues;
            }
            return nullValue<byte>.Array;
        }
        /// <summary>
        /// 根据集合内容返回数组
        /// </summary>
        /// <typeparam name="valueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>数组</returns>
        public unsafe static byte[] getArray<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, byte> getValue)
        {
            if (values.count() != 0)
            {
                if (getValue == null) log.Default.Throw(log.exceptionType.Null);
                byte[] newValues = new byte[values.Count];
                fixed (byte* newValueFixed = newValues)
                {
                    byte* write = newValueFixed;
                    foreach (valueType value in values) *write++ = getValue(value);
                }
                return newValues;
            }
            return nullValue<byte>.Array;
        }
        /// <summary>
        /// 根据集合内容返回单向列表
        /// </summary>
        /// <typeparam name="valueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>单向列表</returns>
        public static list<byte> getList<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, byte> getValue)
        {
            return values != null ? new list<byte>(getArray(values, getValue), true) : null;
        }
        /// <summary>
        /// 根据集合内容返回单向列表
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>单向列表</returns>
        public static list<byte> getList(this System.Collections.Generic.ICollection<byte> values)
        {
            return values != null ? new list<byte>(getArray(values), true) : null;
        }
        /// <summary>
        /// 根据集合内容返回双向列表
        /// </summary>
        /// <typeparam name="valueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>双向列表</returns>
        public static collection<byte> getCollection<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, byte> getValue)
        {
            return values != null ? new collection<byte>(getArray(values, getValue), true) : null;
        }
        /// <summary>
        /// 根据集合内容返回双向列表
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>双向列表</returns>
        public static collection<byte> getCollection
            (this System.Collections.Generic.ICollection<byte> values)
        {
            return values != null ? new collection<byte>(getArray(values), true) : null;
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public unsafe static list<byte> getFind
            (this System.Collections.Generic.ICollection<byte> values, func<byte, bool> isValue)
        {
            if (values.count() != 0)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                byte[] newValues = new byte[values.Count];
                fixed (byte* newValueFixed = newValues)
                {
                    byte* write = newValueFixed;
                    foreach (byte value in values)
                    {
                        if (isValue(value)) *write++ = value;
                    }
                    return new list<byte>(newValues, 0, (int)(write - newValueFixed), true);
                }
            }
            return null;
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public unsafe static list<byte> getFind
            (this System.Collections.ICollection values, func<byte, bool> isValue)
        {
            if (values != null)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                byte[] newValues = new byte[values.Count];
                fixed (byte* newValueFixed = newValues)
                {
                    byte* write = newValueFixed;
                    foreach (byte value in values)
                    {
                        if (isValue(value)) *write++ = value;
                    }
                    return new list<byte>(newValues, 0, (int)(write - newValueFixed), true);
                }
            }
            return null;
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public static byte[] getFindArray
            (this System.Collections.Generic.ICollection<byte> values, func<byte, bool> isValue)
        {
            return values.getFind(isValue).toArray();
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public static byte[] getFindArray
            (this System.Collections.ICollection values, func<byte, bool> isValue)
        {
            return values.getFind(isValue).toArray();
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max
            (this System.Collections.Generic.ICollection<byte> values, out byte value)
        {
            if (values.count() != 0)
            {
                value = byte.MinValue;
                foreach (byte nextValue in values)
                {
                    if (nextValue > value) value = nextValue;
                }
                return true;
            }
            value = byte.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static byte max
            (this System.Collections.Generic.ICollection<byte> values, byte nullValue)
        {
            byte value;
            return max(values, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, byte> getKey
            , out valueType value)
        {
            if (values.count() != 0)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                value = default(valueType);
                int count = -1;
                byte key = byte.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        byte nextKey = getKey(nextValue);
                        if (nextKey > key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static valueType max<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, byte> getKey
            , valueType nullValue)
        {
            valueType value;
            return max(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="key">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, byte> getKey
            , out byte key)
        {
            if (values.count() != 0)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                valueType value = default(valueType);
                int count = -1;
                key = byte.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        byte nextKey = getKey(nextValue);
                        if (nextKey > key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                return true;
            }
            key = default(byte);
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static byte maxKey<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, byte> getKey
            , byte nullValue)
        {
            byte value;
            return maxKey(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min
            (this System.Collections.Generic.ICollection<byte> values, out byte value)
        {
            if (values.count() != 0)
            {
                value = byte.MinValue;
                foreach (byte nextValue in values)
                {
                    if (nextValue < value) value = nextValue;
                }
                return true;
            }
            value = byte.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static byte min
            (this System.Collections.Generic.ICollection<byte> values, byte nullValue)
        {
            byte value;
            return min(values, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, byte> getKey
            , out valueType value)
        {
            if (values.count() != 0)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                value = default(valueType);
                int count = -1;
                byte key = byte.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        byte nextKey = getKey(nextValue);
                        if (nextKey < key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static valueType min<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, byte> getKey
            , valueType nullValue)
        {
            valueType value;
            return min(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="key">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, byte> getKey
            , out byte key)
        {
            if (values.count() != 0)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                valueType value = default(valueType);
                int count = -1;
                key = byte.MaxValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        byte nextKey = getKey(nextValue);
                        if (nextKey < key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                return true;
            }
            key = default(byte);
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static byte minKey<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, byte> getKey
            , byte nullValue)
        {
            byte value;
            return minKey(values, getKey, out value) ? value : nullValue;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 集合相关扩展
    /// </summary>
    public static partial class iCollection
    {
        /// <summary>
        /// 根据集合内容返回数组
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>数组</returns>
        public unsafe static sbyte[] getArray
            (this System.Collections.Generic.ICollection<sbyte> values)
        {
            if (values.count() != 0)
            {
                sbyte[] newValues = new sbyte[values.Count];
                fixed (sbyte* newValueFixed = newValues)
                {
                    sbyte* write = newValueFixed;
                    foreach (sbyte value in values) *write++ = value;
                }
                return newValues;
            }
            return nullValue<sbyte>.Array;
        }
        /// <summary>
        /// 根据集合内容返回数组
        /// </summary>
        /// <typeparam name="valueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>数组</returns>
        public unsafe static sbyte[] getArray<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, sbyte> getValue)
        {
            if (values.count() != 0)
            {
                if (getValue == null) log.Default.Throw(log.exceptionType.Null);
                sbyte[] newValues = new sbyte[values.Count];
                fixed (sbyte* newValueFixed = newValues)
                {
                    sbyte* write = newValueFixed;
                    foreach (valueType value in values) *write++ = getValue(value);
                }
                return newValues;
            }
            return nullValue<sbyte>.Array;
        }
        /// <summary>
        /// 根据集合内容返回单向列表
        /// </summary>
        /// <typeparam name="valueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>单向列表</returns>
        public static list<sbyte> getList<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, sbyte> getValue)
        {
            return values != null ? new list<sbyte>(getArray(values, getValue), true) : null;
        }
        /// <summary>
        /// 根据集合内容返回单向列表
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>单向列表</returns>
        public static list<sbyte> getList(this System.Collections.Generic.ICollection<sbyte> values)
        {
            return values != null ? new list<sbyte>(getArray(values), true) : null;
        }
        /// <summary>
        /// 根据集合内容返回双向列表
        /// </summary>
        /// <typeparam name="valueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>双向列表</returns>
        public static collection<sbyte> getCollection<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, sbyte> getValue)
        {
            return values != null ? new collection<sbyte>(getArray(values, getValue), true) : null;
        }
        /// <summary>
        /// 根据集合内容返回双向列表
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>双向列表</returns>
        public static collection<sbyte> getCollection
            (this System.Collections.Generic.ICollection<sbyte> values)
        {
            return values != null ? new collection<sbyte>(getArray(values), true) : null;
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public unsafe static list<sbyte> getFind
            (this System.Collections.Generic.ICollection<sbyte> values, func<sbyte, bool> isValue)
        {
            if (values.count() != 0)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                sbyte[] newValues = new sbyte[values.Count];
                fixed (sbyte* newValueFixed = newValues)
                {
                    sbyte* write = newValueFixed;
                    foreach (sbyte value in values)
                    {
                        if (isValue(value)) *write++ = value;
                    }
                    return new list<sbyte>(newValues, 0, (int)(write - newValueFixed), true);
                }
            }
            return null;
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public unsafe static list<sbyte> getFind
            (this System.Collections.ICollection values, func<sbyte, bool> isValue)
        {
            if (values != null)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                sbyte[] newValues = new sbyte[values.Count];
                fixed (sbyte* newValueFixed = newValues)
                {
                    sbyte* write = newValueFixed;
                    foreach (sbyte value in values)
                    {
                        if (isValue(value)) *write++ = value;
                    }
                    return new list<sbyte>(newValues, 0, (int)(write - newValueFixed), true);
                }
            }
            return null;
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public static sbyte[] getFindArray
            (this System.Collections.Generic.ICollection<sbyte> values, func<sbyte, bool> isValue)
        {
            return values.getFind(isValue).toArray();
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public static sbyte[] getFindArray
            (this System.Collections.ICollection values, func<sbyte, bool> isValue)
        {
            return values.getFind(isValue).toArray();
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max
            (this System.Collections.Generic.ICollection<sbyte> values, out sbyte value)
        {
            if (values.count() != 0)
            {
                value = sbyte.MinValue;
                foreach (sbyte nextValue in values)
                {
                    if (nextValue > value) value = nextValue;
                }
                return true;
            }
            value = sbyte.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static sbyte max
            (this System.Collections.Generic.ICollection<sbyte> values, sbyte nullValue)
        {
            sbyte value;
            return max(values, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, sbyte> getKey
            , out valueType value)
        {
            if (values.count() != 0)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                value = default(valueType);
                int count = -1;
                sbyte key = sbyte.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        sbyte nextKey = getKey(nextValue);
                        if (nextKey > key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static valueType max<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, sbyte> getKey
            , valueType nullValue)
        {
            valueType value;
            return max(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="key">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, sbyte> getKey
            , out sbyte key)
        {
            if (values.count() != 0)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                valueType value = default(valueType);
                int count = -1;
                key = sbyte.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        sbyte nextKey = getKey(nextValue);
                        if (nextKey > key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                return true;
            }
            key = default(sbyte);
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static sbyte maxKey<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, sbyte> getKey
            , sbyte nullValue)
        {
            sbyte value;
            return maxKey(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min
            (this System.Collections.Generic.ICollection<sbyte> values, out sbyte value)
        {
            if (values.count() != 0)
            {
                value = sbyte.MinValue;
                foreach (sbyte nextValue in values)
                {
                    if (nextValue < value) value = nextValue;
                }
                return true;
            }
            value = sbyte.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static sbyte min
            (this System.Collections.Generic.ICollection<sbyte> values, sbyte nullValue)
        {
            sbyte value;
            return min(values, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, sbyte> getKey
            , out valueType value)
        {
            if (values.count() != 0)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                value = default(valueType);
                int count = -1;
                sbyte key = sbyte.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        sbyte nextKey = getKey(nextValue);
                        if (nextKey < key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static valueType min<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, sbyte> getKey
            , valueType nullValue)
        {
            valueType value;
            return min(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="key">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, sbyte> getKey
            , out sbyte key)
        {
            if (values.count() != 0)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                valueType value = default(valueType);
                int count = -1;
                key = sbyte.MaxValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        sbyte nextKey = getKey(nextValue);
                        if (nextKey < key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                return true;
            }
            key = default(sbyte);
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static sbyte minKey<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, sbyte> getKey
            , sbyte nullValue)
        {
            sbyte value;
            return minKey(values, getKey, out value) ? value : nullValue;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 集合相关扩展
    /// </summary>
    public static partial class iCollection
    {
        /// <summary>
        /// 根据集合内容返回数组
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>数组</returns>
        public unsafe static double[] getArray
            (this System.Collections.Generic.ICollection<double> values)
        {
            if (values.count() != 0)
            {
                double[] newValues = new double[values.Count];
                fixed (double* newValueFixed = newValues)
                {
                    double* write = newValueFixed;
                    foreach (double value in values) *write++ = value;
                }
                return newValues;
            }
            return nullValue<double>.Array;
        }
        /// <summary>
        /// 根据集合内容返回数组
        /// </summary>
        /// <typeparam name="valueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>数组</returns>
        public unsafe static double[] getArray<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, double> getValue)
        {
            if (values.count() != 0)
            {
                if (getValue == null) log.Default.Throw(log.exceptionType.Null);
                double[] newValues = new double[values.Count];
                fixed (double* newValueFixed = newValues)
                {
                    double* write = newValueFixed;
                    foreach (valueType value in values) *write++ = getValue(value);
                }
                return newValues;
            }
            return nullValue<double>.Array;
        }
        /// <summary>
        /// 根据集合内容返回单向列表
        /// </summary>
        /// <typeparam name="valueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>单向列表</returns>
        public static list<double> getList<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, double> getValue)
        {
            return values != null ? new list<double>(getArray(values, getValue), true) : null;
        }
        /// <summary>
        /// 根据集合内容返回单向列表
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>单向列表</returns>
        public static list<double> getList(this System.Collections.Generic.ICollection<double> values)
        {
            return values != null ? new list<double>(getArray(values), true) : null;
        }
        /// <summary>
        /// 根据集合内容返回双向列表
        /// </summary>
        /// <typeparam name="valueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>双向列表</returns>
        public static collection<double> getCollection<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, double> getValue)
        {
            return values != null ? new collection<double>(getArray(values, getValue), true) : null;
        }
        /// <summary>
        /// 根据集合内容返回双向列表
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>双向列表</returns>
        public static collection<double> getCollection
            (this System.Collections.Generic.ICollection<double> values)
        {
            return values != null ? new collection<double>(getArray(values), true) : null;
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public unsafe static list<double> getFind
            (this System.Collections.Generic.ICollection<double> values, func<double, bool> isValue)
        {
            if (values.count() != 0)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                double[] newValues = new double[values.Count];
                fixed (double* newValueFixed = newValues)
                {
                    double* write = newValueFixed;
                    foreach (double value in values)
                    {
                        if (isValue(value)) *write++ = value;
                    }
                    return new list<double>(newValues, 0, (int)(write - newValueFixed), true);
                }
            }
            return null;
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public unsafe static list<double> getFind
            (this System.Collections.ICollection values, func<double, bool> isValue)
        {
            if (values != null)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                double[] newValues = new double[values.Count];
                fixed (double* newValueFixed = newValues)
                {
                    double* write = newValueFixed;
                    foreach (double value in values)
                    {
                        if (isValue(value)) *write++ = value;
                    }
                    return new list<double>(newValues, 0, (int)(write - newValueFixed), true);
                }
            }
            return null;
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public static double[] getFindArray
            (this System.Collections.Generic.ICollection<double> values, func<double, bool> isValue)
        {
            return values.getFind(isValue).toArray();
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public static double[] getFindArray
            (this System.Collections.ICollection values, func<double, bool> isValue)
        {
            return values.getFind(isValue).toArray();
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max
            (this System.Collections.Generic.ICollection<double> values, out double value)
        {
            if (values.count() != 0)
            {
                value = double.MinValue;
                foreach (double nextValue in values)
                {
                    if (nextValue > value) value = nextValue;
                }
                return true;
            }
            value = double.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static double max
            (this System.Collections.Generic.ICollection<double> values, double nullValue)
        {
            double value;
            return max(values, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, double> getKey
            , out valueType value)
        {
            if (values.count() != 0)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                value = default(valueType);
                int count = -1;
                double key = double.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        double nextKey = getKey(nextValue);
                        if (nextKey > key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static valueType max<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, double> getKey
            , valueType nullValue)
        {
            valueType value;
            return max(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="key">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, double> getKey
            , out double key)
        {
            if (values.count() != 0)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                valueType value = default(valueType);
                int count = -1;
                key = double.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        double nextKey = getKey(nextValue);
                        if (nextKey > key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                return true;
            }
            key = default(double);
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static double maxKey<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, double> getKey
            , double nullValue)
        {
            double value;
            return maxKey(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min
            (this System.Collections.Generic.ICollection<double> values, out double value)
        {
            if (values.count() != 0)
            {
                value = double.MinValue;
                foreach (double nextValue in values)
                {
                    if (nextValue < value) value = nextValue;
                }
                return true;
            }
            value = double.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static double min
            (this System.Collections.Generic.ICollection<double> values, double nullValue)
        {
            double value;
            return min(values, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, double> getKey
            , out valueType value)
        {
            if (values.count() != 0)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                value = default(valueType);
                int count = -1;
                double key = double.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        double nextKey = getKey(nextValue);
                        if (nextKey < key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static valueType min<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, double> getKey
            , valueType nullValue)
        {
            valueType value;
            return min(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="key">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, double> getKey
            , out double key)
        {
            if (values.count() != 0)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                valueType value = default(valueType);
                int count = -1;
                key = double.MaxValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        double nextKey = getKey(nextValue);
                        if (nextKey < key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                return true;
            }
            key = default(double);
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static double minKey<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, double> getKey
            , double nullValue)
        {
            double value;
            return minKey(values, getKey, out value) ? value : nullValue;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 集合相关扩展
    /// </summary>
    public static partial class iCollection
    {
        /// <summary>
        /// 根据集合内容返回数组
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>数组</returns>
        public unsafe static float[] getArray
            (this System.Collections.Generic.ICollection<float> values)
        {
            if (values.count() != 0)
            {
                float[] newValues = new float[values.Count];
                fixed (float* newValueFixed = newValues)
                {
                    float* write = newValueFixed;
                    foreach (float value in values) *write++ = value;
                }
                return newValues;
            }
            return nullValue<float>.Array;
        }
        /// <summary>
        /// 根据集合内容返回数组
        /// </summary>
        /// <typeparam name="valueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>数组</returns>
        public unsafe static float[] getArray<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, float> getValue)
        {
            if (values.count() != 0)
            {
                if (getValue == null) log.Default.Throw(log.exceptionType.Null);
                float[] newValues = new float[values.Count];
                fixed (float* newValueFixed = newValues)
                {
                    float* write = newValueFixed;
                    foreach (valueType value in values) *write++ = getValue(value);
                }
                return newValues;
            }
            return nullValue<float>.Array;
        }
        /// <summary>
        /// 根据集合内容返回单向列表
        /// </summary>
        /// <typeparam name="valueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>单向列表</returns>
        public static list<float> getList<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, float> getValue)
        {
            return values != null ? new list<float>(getArray(values, getValue), true) : null;
        }
        /// <summary>
        /// 根据集合内容返回单向列表
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>单向列表</returns>
        public static list<float> getList(this System.Collections.Generic.ICollection<float> values)
        {
            return values != null ? new list<float>(getArray(values), true) : null;
        }
        /// <summary>
        /// 根据集合内容返回双向列表
        /// </summary>
        /// <typeparam name="valueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>双向列表</returns>
        public static collection<float> getCollection<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, float> getValue)
        {
            return values != null ? new collection<float>(getArray(values, getValue), true) : null;
        }
        /// <summary>
        /// 根据集合内容返回双向列表
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>双向列表</returns>
        public static collection<float> getCollection
            (this System.Collections.Generic.ICollection<float> values)
        {
            return values != null ? new collection<float>(getArray(values), true) : null;
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public unsafe static list<float> getFind
            (this System.Collections.Generic.ICollection<float> values, func<float, bool> isValue)
        {
            if (values.count() != 0)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                float[] newValues = new float[values.Count];
                fixed (float* newValueFixed = newValues)
                {
                    float* write = newValueFixed;
                    foreach (float value in values)
                    {
                        if (isValue(value)) *write++ = value;
                    }
                    return new list<float>(newValues, 0, (int)(write - newValueFixed), true);
                }
            }
            return null;
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public unsafe static list<float> getFind
            (this System.Collections.ICollection values, func<float, bool> isValue)
        {
            if (values != null)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                float[] newValues = new float[values.Count];
                fixed (float* newValueFixed = newValues)
                {
                    float* write = newValueFixed;
                    foreach (float value in values)
                    {
                        if (isValue(value)) *write++ = value;
                    }
                    return new list<float>(newValues, 0, (int)(write - newValueFixed), true);
                }
            }
            return null;
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public static float[] getFindArray
            (this System.Collections.Generic.ICollection<float> values, func<float, bool> isValue)
        {
            return values.getFind(isValue).toArray();
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public static float[] getFindArray
            (this System.Collections.ICollection values, func<float, bool> isValue)
        {
            return values.getFind(isValue).toArray();
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max
            (this System.Collections.Generic.ICollection<float> values, out float value)
        {
            if (values.count() != 0)
            {
                value = float.MinValue;
                foreach (float nextValue in values)
                {
                    if (nextValue > value) value = nextValue;
                }
                return true;
            }
            value = float.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static float max
            (this System.Collections.Generic.ICollection<float> values, float nullValue)
        {
            float value;
            return max(values, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, float> getKey
            , out valueType value)
        {
            if (values.count() != 0)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                value = default(valueType);
                int count = -1;
                float key = float.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        float nextKey = getKey(nextValue);
                        if (nextKey > key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static valueType max<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, float> getKey
            , valueType nullValue)
        {
            valueType value;
            return max(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="key">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, float> getKey
            , out float key)
        {
            if (values.count() != 0)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                valueType value = default(valueType);
                int count = -1;
                key = float.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        float nextKey = getKey(nextValue);
                        if (nextKey > key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                return true;
            }
            key = default(float);
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static float maxKey<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, float> getKey
            , float nullValue)
        {
            float value;
            return maxKey(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min
            (this System.Collections.Generic.ICollection<float> values, out float value)
        {
            if (values.count() != 0)
            {
                value = float.MinValue;
                foreach (float nextValue in values)
                {
                    if (nextValue < value) value = nextValue;
                }
                return true;
            }
            value = float.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static float min
            (this System.Collections.Generic.ICollection<float> values, float nullValue)
        {
            float value;
            return min(values, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, float> getKey
            , out valueType value)
        {
            if (values.count() != 0)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                value = default(valueType);
                int count = -1;
                float key = float.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        float nextKey = getKey(nextValue);
                        if (nextKey < key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static valueType min<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, float> getKey
            , valueType nullValue)
        {
            valueType value;
            return min(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="key">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, float> getKey
            , out float key)
        {
            if (values.count() != 0)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                valueType value = default(valueType);
                int count = -1;
                key = float.MaxValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        float nextKey = getKey(nextValue);
                        if (nextKey < key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                return true;
            }
            key = default(float);
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static float minKey<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, float> getKey
            , float nullValue)
        {
            float value;
            return minKey(values, getKey, out value) ? value : nullValue;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 集合相关扩展
    /// </summary>
    public static partial class iCollection
    {
        /// <summary>
        /// 根据集合内容返回数组
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>数组</returns>
        public unsafe static DateTime[] getArray
            (this System.Collections.Generic.ICollection<DateTime> values)
        {
            if (values.count() != 0)
            {
                DateTime[] newValues = new DateTime[values.Count];
                fixed (DateTime* newValueFixed = newValues)
                {
                    DateTime* write = newValueFixed;
                    foreach (DateTime value in values) *write++ = value;
                }
                return newValues;
            }
            return nullValue<DateTime>.Array;
        }
        /// <summary>
        /// 根据集合内容返回数组
        /// </summary>
        /// <typeparam name="valueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>数组</returns>
        public unsafe static DateTime[] getArray<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, DateTime> getValue)
        {
            if (values.count() != 0)
            {
                if (getValue == null) log.Default.Throw(log.exceptionType.Null);
                DateTime[] newValues = new DateTime[values.Count];
                fixed (DateTime* newValueFixed = newValues)
                {
                    DateTime* write = newValueFixed;
                    foreach (valueType value in values) *write++ = getValue(value);
                }
                return newValues;
            }
            return nullValue<DateTime>.Array;
        }
        /// <summary>
        /// 根据集合内容返回单向列表
        /// </summary>
        /// <typeparam name="valueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>单向列表</returns>
        public static list<DateTime> getList<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, DateTime> getValue)
        {
            return values != null ? new list<DateTime>(getArray(values, getValue), true) : null;
        }
        /// <summary>
        /// 根据集合内容返回单向列表
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>单向列表</returns>
        public static list<DateTime> getList(this System.Collections.Generic.ICollection<DateTime> values)
        {
            return values != null ? new list<DateTime>(getArray(values), true) : null;
        }
        /// <summary>
        /// 根据集合内容返回双向列表
        /// </summary>
        /// <typeparam name="valueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>双向列表</returns>
        public static collection<DateTime> getCollection<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, DateTime> getValue)
        {
            return values != null ? new collection<DateTime>(getArray(values, getValue), true) : null;
        }
        /// <summary>
        /// 根据集合内容返回双向列表
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>双向列表</returns>
        public static collection<DateTime> getCollection
            (this System.Collections.Generic.ICollection<DateTime> values)
        {
            return values != null ? new collection<DateTime>(getArray(values), true) : null;
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public unsafe static list<DateTime> getFind
            (this System.Collections.Generic.ICollection<DateTime> values, func<DateTime, bool> isValue)
        {
            if (values.count() != 0)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                DateTime[] newValues = new DateTime[values.Count];
                fixed (DateTime* newValueFixed = newValues)
                {
                    DateTime* write = newValueFixed;
                    foreach (DateTime value in values)
                    {
                        if (isValue(value)) *write++ = value;
                    }
                    return new list<DateTime>(newValues, 0, (int)(write - newValueFixed), true);
                }
            }
            return null;
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public unsafe static list<DateTime> getFind
            (this System.Collections.ICollection values, func<DateTime, bool> isValue)
        {
            if (values != null)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                DateTime[] newValues = new DateTime[values.Count];
                fixed (DateTime* newValueFixed = newValues)
                {
                    DateTime* write = newValueFixed;
                    foreach (DateTime value in values)
                    {
                        if (isValue(value)) *write++ = value;
                    }
                    return new list<DateTime>(newValues, 0, (int)(write - newValueFixed), true);
                }
            }
            return null;
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public static DateTime[] getFindArray
            (this System.Collections.Generic.ICollection<DateTime> values, func<DateTime, bool> isValue)
        {
            return values.getFind(isValue).toArray();
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public static DateTime[] getFindArray
            (this System.Collections.ICollection values, func<DateTime, bool> isValue)
        {
            return values.getFind(isValue).toArray();
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max
            (this System.Collections.Generic.ICollection<DateTime> values, out DateTime value)
        {
            if (values.count() != 0)
            {
                value = DateTime.MinValue;
                foreach (DateTime nextValue in values)
                {
                    if (nextValue > value) value = nextValue;
                }
                return true;
            }
            value = DateTime.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static DateTime max
            (this System.Collections.Generic.ICollection<DateTime> values, DateTime nullValue)
        {
            DateTime value;
            return max(values, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, DateTime> getKey
            , out valueType value)
        {
            if (values.count() != 0)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                value = default(valueType);
                int count = -1;
                DateTime key = DateTime.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        DateTime nextKey = getKey(nextValue);
                        if (nextKey > key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static valueType max<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, DateTime> getKey
            , valueType nullValue)
        {
            valueType value;
            return max(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="key">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, DateTime> getKey
            , out DateTime key)
        {
            if (values.count() != 0)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                valueType value = default(valueType);
                int count = -1;
                key = DateTime.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        DateTime nextKey = getKey(nextValue);
                        if (nextKey > key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                return true;
            }
            key = default(DateTime);
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static DateTime maxKey<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, DateTime> getKey
            , DateTime nullValue)
        {
            DateTime value;
            return maxKey(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min
            (this System.Collections.Generic.ICollection<DateTime> values, out DateTime value)
        {
            if (values.count() != 0)
            {
                value = DateTime.MinValue;
                foreach (DateTime nextValue in values)
                {
                    if (nextValue < value) value = nextValue;
                }
                return true;
            }
            value = DateTime.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static DateTime min
            (this System.Collections.Generic.ICollection<DateTime> values, DateTime nullValue)
        {
            DateTime value;
            return min(values, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, DateTime> getKey
            , out valueType value)
        {
            if (values.count() != 0)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                value = default(valueType);
                int count = -1;
                DateTime key = DateTime.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        DateTime nextKey = getKey(nextValue);
                        if (nextKey < key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static valueType min<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, DateTime> getKey
            , valueType nullValue)
        {
            valueType value;
            return min(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="key">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, DateTime> getKey
            , out DateTime key)
        {
            if (values.count() != 0)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                valueType value = default(valueType);
                int count = -1;
                key = DateTime.MaxValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        DateTime nextKey = getKey(nextValue);
                        if (nextKey < key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                return true;
            }
            key = default(DateTime);
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static DateTime minKey<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, func<valueType, DateTime> getKey
            , DateTime nullValue)
        {
            DateTime value;
            return minKey(values, getKey, out value) ? value : nullValue;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 可枚举相关扩展
    /// </summary>
    public static partial class iEnumerable
    {
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max
            (this System.Collections.Generic.IEnumerable<long> values, out long value)
        {
            if (values != null)
            {
                bool isValue = false;
                value = long.MinValue;
                foreach (long nextValue in values)
                {
                    if (nextValue > value) value = nextValue;
                    isValue = true;
                }
                if (isValue) return true;
            }
            value = long.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static long max
            (this System.Collections.Generic.IEnumerable<long> values, long nullValue)
        {
            long value;
            return max(values, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, long> getKey
            , out valueType value)
        {
            value = default(valueType);
            if (values != null)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                int count = -1;
                long key = long.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        long nextKey = getKey(nextValue);
                        if (nextKey > key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                if (count != -1) return true;
            }
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static valueType max<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, long> getKey
            , valueType nullValue)
        {
            valueType value;
            return max(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, long> getKey
            , out long value)
        {
            if (values != null)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                int count = -1;
                value = long.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) value = getKey(nextValue);
                    else
                    {
                        long nextKey = getKey(nextValue);
                        if (nextKey > value) value = nextKey;
                    }
                }
                if (count != -1) return true;
            }
            value = long.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static long maxKey<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, long> getKey
            , long nullValue)
        {
            long value;
            return maxKey(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min
            (this System.Collections.Generic.IEnumerable<long> values, out long value)
        {
            if (values != null)
            {
                bool isValue = false;
                value = long.MinValue;
                foreach (long nextValue in values)
                {
                    if (nextValue < value) value = nextValue;
                    isValue = true;
                }
                if (isValue) return true;
            }
            value = long.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static long min
            (this System.Collections.Generic.IEnumerable<long> values, long nullValue)
        {
            long value;
            return min(values, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, long> getKey
            , out valueType value)
        {
            value = default(valueType);
            if (values != null)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                int count = -1;
                long key = long.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        long nextKey = getKey(nextValue);
                        if (nextKey < key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                if (count != -1) return true;
            }
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static valueType min<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, long> getKey
            , valueType nullValue)
        {
            valueType value;
            return min(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, long> getKey
            , out long value)
        {
            if (values != null)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                int count = -1;
                value = long.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) value = getKey(nextValue);
                    else
                    {
                        long nextKey = getKey(nextValue);
                        if (nextKey < value) value = nextKey;
                    }
                }
                if (count != -1) return true;
            }
            value = long.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static long minKey<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, long> getKey
            , long nullValue)
        {
            long value;
            return minKey(values, getKey, out value) ? value : nullValue;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 可枚举相关扩展
    /// </summary>
    public static partial class iEnumerable
    {
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max
            (this System.Collections.Generic.IEnumerable<uint> values, out uint value)
        {
            if (values != null)
            {
                bool isValue = false;
                value = uint.MinValue;
                foreach (uint nextValue in values)
                {
                    if (nextValue > value) value = nextValue;
                    isValue = true;
                }
                if (isValue) return true;
            }
            value = uint.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static uint max
            (this System.Collections.Generic.IEnumerable<uint> values, uint nullValue)
        {
            uint value;
            return max(values, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, uint> getKey
            , out valueType value)
        {
            value = default(valueType);
            if (values != null)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                int count = -1;
                uint key = uint.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        uint nextKey = getKey(nextValue);
                        if (nextKey > key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                if (count != -1) return true;
            }
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static valueType max<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, uint> getKey
            , valueType nullValue)
        {
            valueType value;
            return max(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, uint> getKey
            , out uint value)
        {
            if (values != null)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                int count = -1;
                value = uint.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) value = getKey(nextValue);
                    else
                    {
                        uint nextKey = getKey(nextValue);
                        if (nextKey > value) value = nextKey;
                    }
                }
                if (count != -1) return true;
            }
            value = uint.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static uint maxKey<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, uint> getKey
            , uint nullValue)
        {
            uint value;
            return maxKey(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min
            (this System.Collections.Generic.IEnumerable<uint> values, out uint value)
        {
            if (values != null)
            {
                bool isValue = false;
                value = uint.MinValue;
                foreach (uint nextValue in values)
                {
                    if (nextValue < value) value = nextValue;
                    isValue = true;
                }
                if (isValue) return true;
            }
            value = uint.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static uint min
            (this System.Collections.Generic.IEnumerable<uint> values, uint nullValue)
        {
            uint value;
            return min(values, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, uint> getKey
            , out valueType value)
        {
            value = default(valueType);
            if (values != null)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                int count = -1;
                uint key = uint.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        uint nextKey = getKey(nextValue);
                        if (nextKey < key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                if (count != -1) return true;
            }
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static valueType min<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, uint> getKey
            , valueType nullValue)
        {
            valueType value;
            return min(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, uint> getKey
            , out uint value)
        {
            if (values != null)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                int count = -1;
                value = uint.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) value = getKey(nextValue);
                    else
                    {
                        uint nextKey = getKey(nextValue);
                        if (nextKey < value) value = nextKey;
                    }
                }
                if (count != -1) return true;
            }
            value = uint.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static uint minKey<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, uint> getKey
            , uint nullValue)
        {
            uint value;
            return minKey(values, getKey, out value) ? value : nullValue;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 可枚举相关扩展
    /// </summary>
    public static partial class iEnumerable
    {
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max
            (this System.Collections.Generic.IEnumerable<int> values, out int value)
        {
            if (values != null)
            {
                bool isValue = false;
                value = int.MinValue;
                foreach (int nextValue in values)
                {
                    if (nextValue > value) value = nextValue;
                    isValue = true;
                }
                if (isValue) return true;
            }
            value = int.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static int max
            (this System.Collections.Generic.IEnumerable<int> values, int nullValue)
        {
            int value;
            return max(values, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, int> getKey
            , out valueType value)
        {
            value = default(valueType);
            if (values != null)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                int count = -1;
                int key = int.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        int nextKey = getKey(nextValue);
                        if (nextKey > key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                if (count != -1) return true;
            }
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static valueType max<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, int> getKey
            , valueType nullValue)
        {
            valueType value;
            return max(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, int> getKey
            , out int value)
        {
            if (values != null)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                int count = -1;
                value = int.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) value = getKey(nextValue);
                    else
                    {
                        int nextKey = getKey(nextValue);
                        if (nextKey > value) value = nextKey;
                    }
                }
                if (count != -1) return true;
            }
            value = int.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static int maxKey<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, int> getKey
            , int nullValue)
        {
            int value;
            return maxKey(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min
            (this System.Collections.Generic.IEnumerable<int> values, out int value)
        {
            if (values != null)
            {
                bool isValue = false;
                value = int.MinValue;
                foreach (int nextValue in values)
                {
                    if (nextValue < value) value = nextValue;
                    isValue = true;
                }
                if (isValue) return true;
            }
            value = int.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static int min
            (this System.Collections.Generic.IEnumerable<int> values, int nullValue)
        {
            int value;
            return min(values, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, int> getKey
            , out valueType value)
        {
            value = default(valueType);
            if (values != null)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                int count = -1;
                int key = int.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        int nextKey = getKey(nextValue);
                        if (nextKey < key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                if (count != -1) return true;
            }
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static valueType min<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, int> getKey
            , valueType nullValue)
        {
            valueType value;
            return min(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, int> getKey
            , out int value)
        {
            if (values != null)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                int count = -1;
                value = int.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) value = getKey(nextValue);
                    else
                    {
                        int nextKey = getKey(nextValue);
                        if (nextKey < value) value = nextKey;
                    }
                }
                if (count != -1) return true;
            }
            value = int.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static int minKey<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, int> getKey
            , int nullValue)
        {
            int value;
            return minKey(values, getKey, out value) ? value : nullValue;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 可枚举相关扩展
    /// </summary>
    public static partial class iEnumerable
    {
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max
            (this System.Collections.Generic.IEnumerable<ushort> values, out ushort value)
        {
            if (values != null)
            {
                bool isValue = false;
                value = ushort.MinValue;
                foreach (ushort nextValue in values)
                {
                    if (nextValue > value) value = nextValue;
                    isValue = true;
                }
                if (isValue) return true;
            }
            value = ushort.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static ushort max
            (this System.Collections.Generic.IEnumerable<ushort> values, ushort nullValue)
        {
            ushort value;
            return max(values, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, ushort> getKey
            , out valueType value)
        {
            value = default(valueType);
            if (values != null)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                int count = -1;
                ushort key = ushort.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        ushort nextKey = getKey(nextValue);
                        if (nextKey > key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                if (count != -1) return true;
            }
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static valueType max<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, ushort> getKey
            , valueType nullValue)
        {
            valueType value;
            return max(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, ushort> getKey
            , out ushort value)
        {
            if (values != null)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                int count = -1;
                value = ushort.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) value = getKey(nextValue);
                    else
                    {
                        ushort nextKey = getKey(nextValue);
                        if (nextKey > value) value = nextKey;
                    }
                }
                if (count != -1) return true;
            }
            value = ushort.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static ushort maxKey<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, ushort> getKey
            , ushort nullValue)
        {
            ushort value;
            return maxKey(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min
            (this System.Collections.Generic.IEnumerable<ushort> values, out ushort value)
        {
            if (values != null)
            {
                bool isValue = false;
                value = ushort.MinValue;
                foreach (ushort nextValue in values)
                {
                    if (nextValue < value) value = nextValue;
                    isValue = true;
                }
                if (isValue) return true;
            }
            value = ushort.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static ushort min
            (this System.Collections.Generic.IEnumerable<ushort> values, ushort nullValue)
        {
            ushort value;
            return min(values, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, ushort> getKey
            , out valueType value)
        {
            value = default(valueType);
            if (values != null)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                int count = -1;
                ushort key = ushort.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        ushort nextKey = getKey(nextValue);
                        if (nextKey < key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                if (count != -1) return true;
            }
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static valueType min<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, ushort> getKey
            , valueType nullValue)
        {
            valueType value;
            return min(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, ushort> getKey
            , out ushort value)
        {
            if (values != null)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                int count = -1;
                value = ushort.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) value = getKey(nextValue);
                    else
                    {
                        ushort nextKey = getKey(nextValue);
                        if (nextKey < value) value = nextKey;
                    }
                }
                if (count != -1) return true;
            }
            value = ushort.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static ushort minKey<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, ushort> getKey
            , ushort nullValue)
        {
            ushort value;
            return minKey(values, getKey, out value) ? value : nullValue;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 可枚举相关扩展
    /// </summary>
    public static partial class iEnumerable
    {
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max
            (this System.Collections.Generic.IEnumerable<short> values, out short value)
        {
            if (values != null)
            {
                bool isValue = false;
                value = short.MinValue;
                foreach (short nextValue in values)
                {
                    if (nextValue > value) value = nextValue;
                    isValue = true;
                }
                if (isValue) return true;
            }
            value = short.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static short max
            (this System.Collections.Generic.IEnumerable<short> values, short nullValue)
        {
            short value;
            return max(values, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, short> getKey
            , out valueType value)
        {
            value = default(valueType);
            if (values != null)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                int count = -1;
                short key = short.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        short nextKey = getKey(nextValue);
                        if (nextKey > key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                if (count != -1) return true;
            }
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static valueType max<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, short> getKey
            , valueType nullValue)
        {
            valueType value;
            return max(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, short> getKey
            , out short value)
        {
            if (values != null)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                int count = -1;
                value = short.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) value = getKey(nextValue);
                    else
                    {
                        short nextKey = getKey(nextValue);
                        if (nextKey > value) value = nextKey;
                    }
                }
                if (count != -1) return true;
            }
            value = short.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static short maxKey<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, short> getKey
            , short nullValue)
        {
            short value;
            return maxKey(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min
            (this System.Collections.Generic.IEnumerable<short> values, out short value)
        {
            if (values != null)
            {
                bool isValue = false;
                value = short.MinValue;
                foreach (short nextValue in values)
                {
                    if (nextValue < value) value = nextValue;
                    isValue = true;
                }
                if (isValue) return true;
            }
            value = short.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static short min
            (this System.Collections.Generic.IEnumerable<short> values, short nullValue)
        {
            short value;
            return min(values, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, short> getKey
            , out valueType value)
        {
            value = default(valueType);
            if (values != null)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                int count = -1;
                short key = short.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        short nextKey = getKey(nextValue);
                        if (nextKey < key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                if (count != -1) return true;
            }
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static valueType min<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, short> getKey
            , valueType nullValue)
        {
            valueType value;
            return min(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, short> getKey
            , out short value)
        {
            if (values != null)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                int count = -1;
                value = short.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) value = getKey(nextValue);
                    else
                    {
                        short nextKey = getKey(nextValue);
                        if (nextKey < value) value = nextKey;
                    }
                }
                if (count != -1) return true;
            }
            value = short.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static short minKey<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, short> getKey
            , short nullValue)
        {
            short value;
            return minKey(values, getKey, out value) ? value : nullValue;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 可枚举相关扩展
    /// </summary>
    public static partial class iEnumerable
    {
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max
            (this System.Collections.Generic.IEnumerable<byte> values, out byte value)
        {
            if (values != null)
            {
                bool isValue = false;
                value = byte.MinValue;
                foreach (byte nextValue in values)
                {
                    if (nextValue > value) value = nextValue;
                    isValue = true;
                }
                if (isValue) return true;
            }
            value = byte.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static byte max
            (this System.Collections.Generic.IEnumerable<byte> values, byte nullValue)
        {
            byte value;
            return max(values, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, byte> getKey
            , out valueType value)
        {
            value = default(valueType);
            if (values != null)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                int count = -1;
                byte key = byte.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        byte nextKey = getKey(nextValue);
                        if (nextKey > key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                if (count != -1) return true;
            }
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static valueType max<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, byte> getKey
            , valueType nullValue)
        {
            valueType value;
            return max(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, byte> getKey
            , out byte value)
        {
            if (values != null)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                int count = -1;
                value = byte.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) value = getKey(nextValue);
                    else
                    {
                        byte nextKey = getKey(nextValue);
                        if (nextKey > value) value = nextKey;
                    }
                }
                if (count != -1) return true;
            }
            value = byte.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static byte maxKey<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, byte> getKey
            , byte nullValue)
        {
            byte value;
            return maxKey(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min
            (this System.Collections.Generic.IEnumerable<byte> values, out byte value)
        {
            if (values != null)
            {
                bool isValue = false;
                value = byte.MinValue;
                foreach (byte nextValue in values)
                {
                    if (nextValue < value) value = nextValue;
                    isValue = true;
                }
                if (isValue) return true;
            }
            value = byte.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static byte min
            (this System.Collections.Generic.IEnumerable<byte> values, byte nullValue)
        {
            byte value;
            return min(values, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, byte> getKey
            , out valueType value)
        {
            value = default(valueType);
            if (values != null)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                int count = -1;
                byte key = byte.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        byte nextKey = getKey(nextValue);
                        if (nextKey < key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                if (count != -1) return true;
            }
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static valueType min<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, byte> getKey
            , valueType nullValue)
        {
            valueType value;
            return min(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, byte> getKey
            , out byte value)
        {
            if (values != null)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                int count = -1;
                value = byte.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) value = getKey(nextValue);
                    else
                    {
                        byte nextKey = getKey(nextValue);
                        if (nextKey < value) value = nextKey;
                    }
                }
                if (count != -1) return true;
            }
            value = byte.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static byte minKey<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, byte> getKey
            , byte nullValue)
        {
            byte value;
            return minKey(values, getKey, out value) ? value : nullValue;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 可枚举相关扩展
    /// </summary>
    public static partial class iEnumerable
    {
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max
            (this System.Collections.Generic.IEnumerable<sbyte> values, out sbyte value)
        {
            if (values != null)
            {
                bool isValue = false;
                value = sbyte.MinValue;
                foreach (sbyte nextValue in values)
                {
                    if (nextValue > value) value = nextValue;
                    isValue = true;
                }
                if (isValue) return true;
            }
            value = sbyte.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static sbyte max
            (this System.Collections.Generic.IEnumerable<sbyte> values, sbyte nullValue)
        {
            sbyte value;
            return max(values, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, sbyte> getKey
            , out valueType value)
        {
            value = default(valueType);
            if (values != null)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                int count = -1;
                sbyte key = sbyte.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        sbyte nextKey = getKey(nextValue);
                        if (nextKey > key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                if (count != -1) return true;
            }
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static valueType max<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, sbyte> getKey
            , valueType nullValue)
        {
            valueType value;
            return max(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, sbyte> getKey
            , out sbyte value)
        {
            if (values != null)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                int count = -1;
                value = sbyte.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) value = getKey(nextValue);
                    else
                    {
                        sbyte nextKey = getKey(nextValue);
                        if (nextKey > value) value = nextKey;
                    }
                }
                if (count != -1) return true;
            }
            value = sbyte.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static sbyte maxKey<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, sbyte> getKey
            , sbyte nullValue)
        {
            sbyte value;
            return maxKey(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min
            (this System.Collections.Generic.IEnumerable<sbyte> values, out sbyte value)
        {
            if (values != null)
            {
                bool isValue = false;
                value = sbyte.MinValue;
                foreach (sbyte nextValue in values)
                {
                    if (nextValue < value) value = nextValue;
                    isValue = true;
                }
                if (isValue) return true;
            }
            value = sbyte.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static sbyte min
            (this System.Collections.Generic.IEnumerable<sbyte> values, sbyte nullValue)
        {
            sbyte value;
            return min(values, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, sbyte> getKey
            , out valueType value)
        {
            value = default(valueType);
            if (values != null)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                int count = -1;
                sbyte key = sbyte.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        sbyte nextKey = getKey(nextValue);
                        if (nextKey < key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                if (count != -1) return true;
            }
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static valueType min<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, sbyte> getKey
            , valueType nullValue)
        {
            valueType value;
            return min(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, sbyte> getKey
            , out sbyte value)
        {
            if (values != null)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                int count = -1;
                value = sbyte.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) value = getKey(nextValue);
                    else
                    {
                        sbyte nextKey = getKey(nextValue);
                        if (nextKey < value) value = nextKey;
                    }
                }
                if (count != -1) return true;
            }
            value = sbyte.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static sbyte minKey<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, sbyte> getKey
            , sbyte nullValue)
        {
            sbyte value;
            return minKey(values, getKey, out value) ? value : nullValue;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 可枚举相关扩展
    /// </summary>
    public static partial class iEnumerable
    {
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max
            (this System.Collections.Generic.IEnumerable<double> values, out double value)
        {
            if (values != null)
            {
                bool isValue = false;
                value = double.MinValue;
                foreach (double nextValue in values)
                {
                    if (nextValue > value) value = nextValue;
                    isValue = true;
                }
                if (isValue) return true;
            }
            value = double.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static double max
            (this System.Collections.Generic.IEnumerable<double> values, double nullValue)
        {
            double value;
            return max(values, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, double> getKey
            , out valueType value)
        {
            value = default(valueType);
            if (values != null)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                int count = -1;
                double key = double.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        double nextKey = getKey(nextValue);
                        if (nextKey > key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                if (count != -1) return true;
            }
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static valueType max<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, double> getKey
            , valueType nullValue)
        {
            valueType value;
            return max(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, double> getKey
            , out double value)
        {
            if (values != null)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                int count = -1;
                value = double.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) value = getKey(nextValue);
                    else
                    {
                        double nextKey = getKey(nextValue);
                        if (nextKey > value) value = nextKey;
                    }
                }
                if (count != -1) return true;
            }
            value = double.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static double maxKey<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, double> getKey
            , double nullValue)
        {
            double value;
            return maxKey(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min
            (this System.Collections.Generic.IEnumerable<double> values, out double value)
        {
            if (values != null)
            {
                bool isValue = false;
                value = double.MinValue;
                foreach (double nextValue in values)
                {
                    if (nextValue < value) value = nextValue;
                    isValue = true;
                }
                if (isValue) return true;
            }
            value = double.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static double min
            (this System.Collections.Generic.IEnumerable<double> values, double nullValue)
        {
            double value;
            return min(values, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, double> getKey
            , out valueType value)
        {
            value = default(valueType);
            if (values != null)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                int count = -1;
                double key = double.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        double nextKey = getKey(nextValue);
                        if (nextKey < key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                if (count != -1) return true;
            }
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static valueType min<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, double> getKey
            , valueType nullValue)
        {
            valueType value;
            return min(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, double> getKey
            , out double value)
        {
            if (values != null)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                int count = -1;
                value = double.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) value = getKey(nextValue);
                    else
                    {
                        double nextKey = getKey(nextValue);
                        if (nextKey < value) value = nextKey;
                    }
                }
                if (count != -1) return true;
            }
            value = double.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static double minKey<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, double> getKey
            , double nullValue)
        {
            double value;
            return minKey(values, getKey, out value) ? value : nullValue;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 可枚举相关扩展
    /// </summary>
    public static partial class iEnumerable
    {
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max
            (this System.Collections.Generic.IEnumerable<float> values, out float value)
        {
            if (values != null)
            {
                bool isValue = false;
                value = float.MinValue;
                foreach (float nextValue in values)
                {
                    if (nextValue > value) value = nextValue;
                    isValue = true;
                }
                if (isValue) return true;
            }
            value = float.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static float max
            (this System.Collections.Generic.IEnumerable<float> values, float nullValue)
        {
            float value;
            return max(values, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, float> getKey
            , out valueType value)
        {
            value = default(valueType);
            if (values != null)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                int count = -1;
                float key = float.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        float nextKey = getKey(nextValue);
                        if (nextKey > key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                if (count != -1) return true;
            }
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static valueType max<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, float> getKey
            , valueType nullValue)
        {
            valueType value;
            return max(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, float> getKey
            , out float value)
        {
            if (values != null)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                int count = -1;
                value = float.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) value = getKey(nextValue);
                    else
                    {
                        float nextKey = getKey(nextValue);
                        if (nextKey > value) value = nextKey;
                    }
                }
                if (count != -1) return true;
            }
            value = float.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static float maxKey<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, float> getKey
            , float nullValue)
        {
            float value;
            return maxKey(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min
            (this System.Collections.Generic.IEnumerable<float> values, out float value)
        {
            if (values != null)
            {
                bool isValue = false;
                value = float.MinValue;
                foreach (float nextValue in values)
                {
                    if (nextValue < value) value = nextValue;
                    isValue = true;
                }
                if (isValue) return true;
            }
            value = float.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static float min
            (this System.Collections.Generic.IEnumerable<float> values, float nullValue)
        {
            float value;
            return min(values, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, float> getKey
            , out valueType value)
        {
            value = default(valueType);
            if (values != null)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                int count = -1;
                float key = float.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        float nextKey = getKey(nextValue);
                        if (nextKey < key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                if (count != -1) return true;
            }
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static valueType min<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, float> getKey
            , valueType nullValue)
        {
            valueType value;
            return min(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, float> getKey
            , out float value)
        {
            if (values != null)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                int count = -1;
                value = float.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) value = getKey(nextValue);
                    else
                    {
                        float nextKey = getKey(nextValue);
                        if (nextKey < value) value = nextKey;
                    }
                }
                if (count != -1) return true;
            }
            value = float.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static float minKey<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, float> getKey
            , float nullValue)
        {
            float value;
            return minKey(values, getKey, out value) ? value : nullValue;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 可枚举相关扩展
    /// </summary>
    public static partial class iEnumerable
    {
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max
            (this System.Collections.Generic.IEnumerable<DateTime> values, out DateTime value)
        {
            if (values != null)
            {
                bool isValue = false;
                value = DateTime.MinValue;
                foreach (DateTime nextValue in values)
                {
                    if (nextValue > value) value = nextValue;
                    isValue = true;
                }
                if (isValue) return true;
            }
            value = DateTime.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static DateTime max
            (this System.Collections.Generic.IEnumerable<DateTime> values, DateTime nullValue)
        {
            DateTime value;
            return max(values, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, DateTime> getKey
            , out valueType value)
        {
            value = default(valueType);
            if (values != null)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                int count = -1;
                DateTime key = DateTime.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        DateTime nextKey = getKey(nextValue);
                        if (nextKey > key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                if (count != -1) return true;
            }
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static valueType max<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, DateTime> getKey
            , valueType nullValue)
        {
            valueType value;
            return max(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, DateTime> getKey
            , out DateTime value)
        {
            if (values != null)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                int count = -1;
                value = DateTime.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) value = getKey(nextValue);
                    else
                    {
                        DateTime nextKey = getKey(nextValue);
                        if (nextKey > value) value = nextKey;
                    }
                }
                if (count != -1) return true;
            }
            value = DateTime.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static DateTime maxKey<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, DateTime> getKey
            , DateTime nullValue)
        {
            DateTime value;
            return maxKey(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min
            (this System.Collections.Generic.IEnumerable<DateTime> values, out DateTime value)
        {
            if (values != null)
            {
                bool isValue = false;
                value = DateTime.MinValue;
                foreach (DateTime nextValue in values)
                {
                    if (nextValue < value) value = nextValue;
                    isValue = true;
                }
                if (isValue) return true;
            }
            value = DateTime.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static DateTime min
            (this System.Collections.Generic.IEnumerable<DateTime> values, DateTime nullValue)
        {
            DateTime value;
            return min(values, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, DateTime> getKey
            , out valueType value)
        {
            value = default(valueType);
            if (values != null)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                int count = -1;
                DateTime key = DateTime.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        DateTime nextKey = getKey(nextValue);
                        if (nextKey < key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                if (count != -1) return true;
            }
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static valueType min<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, DateTime> getKey
            , valueType nullValue)
        {
            valueType value;
            return min(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, DateTime> getKey
            , out DateTime value)
        {
            if (values != null)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                int count = -1;
                value = DateTime.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) value = getKey(nextValue);
                    else
                    {
                        DateTime nextKey = getKey(nextValue);
                        if (nextKey < value) value = nextKey;
                    }
                }
                if (count != -1) return true;
            }
            value = DateTime.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static DateTime minKey<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, DateTime> getKey
            , DateTime nullValue)
        {
            DateTime value;
            return minKey(values, getKey, out value) ? value : nullValue;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 单向动态数组扩展
    /// </summary>
    public static partial class list
    {
        /// <summary>
        /// 添加数据集合
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="values">数据集合</param>
        /// <returns>单向动态数组</returns>
        public unsafe static list<long> add
            (this list<long> list, System.Collections.Generic.ICollection<long> values)
        {
            if (list != null)
            {
                int count = values.count();
                if (count != 0)
                {
                    int index = list.Count;
                    list.AddLength(count);
                    fixed (long* valueFixed = list.Unsafer.Array)
                    {
                        long* write = valueFixed + index;
                        foreach (long nextValue in values) *write++ = nextValue;
                    }
                }
                return list;
            }
            return values.getList();
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this list<long> list, long value)
        {
            return list.count() != 0 ? list.Unsafer.Array.indexOf(0, list.Count, value) : -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this list<long> list, func<long, bool> isValue)
        {
            return list.count() != 0 ? list.Unsafer.Array.indexOf(0, list.Count, isValue) : -1;
        }
        /// <summary>
        /// 移除数据
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="index">数据位置</param>
        /// <returns>单向动态数组</returns>
        public static list<long> removeAt(this list<long> list, int index)
        {
            int count = list.count();
            if ((uint)index < (uint)count)
            {
                unsafer.array.Move(list.Unsafer.Array, index + 1, index, --count - index);
                list.Unsafer.AddLength(-1);
            }
            else log.Default.Throw(log.exceptionType.IndexOutOfRange);
            return list;
        }
        /// <summary>
        /// 移除数据
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="index">数据位置</param>
        /// <returns>被移除的数据</returns>
        public static long getRemoveAt(this list<long> list, int index)
        {
            int count = list.count();
            if ((uint)index < (uint)count)
            {
                list<long>.unsafer values = new list<long>.unsafer { List = list };
                long value = values.Array[index];
                unsafer.array.Move(values.Array, index + 1, index, --count - index);
                values.AddLength(-1);
                return value;
            }
            log.Default.Throw(log.exceptionType.IndexOutOfRange);
            return default(long);
        }
        /// <summary>
        /// 移除第一个数据
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="value">被移除的数据</param>
        /// <returns>单向动态数组</returns>
        public static list<long> removeFirst
            (this list<long> list, long value)
        {
            if (list != null)
            {
                int index = list.indexOf(value);
                if (index >= 0) list.removeAt(index);
            }
            return list;
        }
        /// <summary>
        /// 移除匹配值
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>单向动态数组</returns>
        public unsafe static list<long> remove
            (this list<long> list, func<long, bool> isValue)
        {
            int count = list.count();
            if (count != 0)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                fixed (long* valueFixed = list.Unsafer.Array)
                {
                    long* start = valueFixed, end = valueFixed + count;
                    while (start != end && !isValue(*start)) ++start;
                    long* write = start;
                    while (start != end)
                    {
                        if (!isValue(*start)) *write++ = *start;
                        ++start;
                    }
                    list.Unsafer.AddLength((int)(write - valueFixed) - count);
                }
            }
            return list;
        }
        /// <summary>
        /// 移除数据范围
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">移除数量</param>
        /// <returns>单向动态数组</returns>
        public static list<long> removeRange(this list<long> list, int index, int count)
        {
            int valueCount = list.count();
            if (index + count <= valueCount && index >= 0 && count >= 0 && list != null)
            {
                list.Unsafer.AddLength(-count);
                unsafer.array.Move(list.Unsafer.Array, index + count, index, list.Count - index);
            }
            else log.Default.Throw(log.exceptionType.IndexOutOfRange);
            return list;
        }
        /// <summary>
        /// 取子集合
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">子集合数据数量</param>
        /// <param name="getVlaue">数据获取器</param>
        /// <returns>子集合</returns>
        public unsafe static valueType[] getSub<valueType>
            (this list<long> list, int startIndex, int count, func<long, valueType> getVlaue)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            return (count = range.GetCount) != 0 ? list.Unsafer.Array.getSub(range.SkipCount, count, getVlaue) : nullValue<valueType>.Array;
        }
        /// <summary>
        /// 判断是否存在数据
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="value">匹配数据</param>
        /// <returns>是否存在数据</returns>
        public static bool contains(this list<long> list, long value)
        {
            return list.indexOf(value) != -1;
        }
        /// <summary>
        /// 判断是否存在匹配
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>是否存在匹配</returns>
        public static bool any(this list<long> list, func<long, bool> isValue)
        {
            return list.indexOf(isValue) != -1;
        }
        /// <summary>
        /// 替换第一个匹配值
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="value">新的数据值</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>单向动态数组</returns>
        public static list<long> replaceFirst
            (this list<long> list, long value, func<long, bool> isValue)
        {
            if (list != null)
            {
                int index = list.indexOf(isValue);
                if (index != -1) list.Unsafer.Array[index] = value;
            }
            return list;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配值,失败为 default(long)</returns>
        public static long firstOrDefault
            (this list<long> list, func<long, bool> isValue)
        {
            int index = list.indexOf(isValue);
            return index != -1 ? list.Unsafer.Array[index] : default(long);
        }
        /// <summary>
        /// 获取匹配值集合
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配值集合</returns>
        public static list<long> getFind
            (this list<long> list, func<long, bool> isValue)
        {
            return list.count() != 0 ? list.Unsafer.Array.getFind(0, list.Count, isValue) : null;
        }
        /// <summary>
        /// 获取匹配值集合
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配值数组</returns>
        public static long[] getFindArray
            (this list<long> list, func<long, bool> isValue)
        {
            return list.count() != 0 ? list.Unsafer.Array.getFindArray(0, list.Count, isValue) : nullValue<long>.Array;
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public static int count(this list<long> list, func<long, bool> isValue)
        {
            return list.count() != 0 ? list.Unsafer.Array.count(0, list.Count, isValue) : 0;
        }
        /// <summary>
        /// 清除所有数据
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <returns>单向动态数组</returns>
        public static list<long> clear(this list<long> list)
        {
            if (list != null) list.Unsafer.AddLength(-list.Count);
            return list;
        }
        /// <summary>
        /// 遍历foreach
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="method">调用函数</param>
        /// <returns>单向动态数组</returns>
        public static list<long> each
            (this list<long> list, action<long> method)
        {
            if (list.count() != 0) list.Unsafer.Array.each(0, list.Count, method);
            return list;
        }
        /// <summary>
        /// 获取数据分页
        /// </summary>
        /// <typeparam name="valueType">目标数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号,从1开始</param>
        /// <param name="getValue">数据转换器</param>
        /// <returns>分页数据数组</returns>
        public static valueType[] getPage<valueType>
            (this list<long> list, int pageSize, int currentPage, func<long, valueType> getValue)
        {
            array.page page = new array.page(list.count(), pageSize, currentPage);
            return list.getSub(page.SkipCount, page.CurrentPageSize, getValue);
        }
        /// <summary>
        /// 转换数据集合
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getValue">数据转换器</param>
        /// <returns>数据集合</returns>
        public static long[] getArray<valueType>
            (this list<valueType> list, func<valueType, long> getValue)
        {
            return list.count() != 0 ? list.Unsafer.Array.getSub(0, list.Count, getValue) : nullValue<long>.Array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max(this list<long> list, out long value)
        {
            if (list.count() != 0) return list.Unsafer.Array.max(0, list.Count, out value);
            value = long.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getKey">比较值获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>
            (this list<valueType> list, func<valueType, long> getKey, out long value)
        {
            if (list.count() != 0) return list.Unsafer.Array.maxKey(0, list.Count, getKey, out value);
            value = long.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getKey">比较值获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>(this list<valueType> list, func<valueType, long> getKey, out valueType value)
        {
            if (list.count() != 0) return list.Unsafer.Array.max(0, list.Count, getKey, out value);
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static long max(this list<long> list, long nullValue)
        {
            long value;
            return max(list, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getKey">比较值获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static long maxKey<valueType>
            (this list<valueType> list, func<valueType, long> getKey, long nullValue)
        {
            long value;
            return maxKey(list, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getKey">比较值获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static valueType max<valueType>(this list<valueType> list, func<valueType, long> getKey, valueType nullValue)
        {
            valueType value;
            return max(list, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min(this list<long> list, out long value)
        {
            if (list.count() != 0) return list.Unsafer.Array.min(0, list.Count, out value);
            value = long.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getKey">比较值获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>
            (this list<valueType> list, func<valueType, long> getKey, out long value)
        {
            if (list.count() != 0) return list.Unsafer.Array.minKey(0, list.Count, getKey, out value);
            value = long.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getKey">比较值获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>(this list<valueType> list, func<valueType, long> getKey, out valueType value)
        {
            if (list.count() != 0) return list.Unsafer.Array.min(0, list.Count, getKey, out value);
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static long min(this list<long> list, long nullValue)
        {
            long value;
            return min(list, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getKey">比较值获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static long minKey<valueType>
            (this list<valueType> list, func<valueType, long> getKey, long nullValue)
        {
            long value;
            return minKey(list, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getKey">比较值获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static valueType min<valueType>(this list<valueType> list, func<valueType, long> getKey, valueType nullValue)
        {
            valueType value;
            return min(list, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        public static list<valueType> distinct<valueType>
            (this list<long> list, func<long, valueType> getValue)
        {
            if (list.count() != 0) return list.Unsafer.Array.distinct(0, list.Count, getValue);
            return null;
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        public static list<long> distinct<valueType>
            (this list<valueType> list, func<valueType, long> getValue)
        {
            if (list.count() != 0) return list.Unsafer.Array.distinct(0, list.Count, getValue);
            return null;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 单向动态数组扩展
    /// </summary>
    public static partial class list
    {
        /// <summary>
        /// 添加数据集合
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="values">数据集合</param>
        /// <returns>单向动态数组</returns>
        public unsafe static list<uint> add
            (this list<uint> list, System.Collections.Generic.ICollection<uint> values)
        {
            if (list != null)
            {
                int count = values.count();
                if (count != 0)
                {
                    int index = list.Count;
                    list.AddLength(count);
                    fixed (uint* valueFixed = list.Unsafer.Array)
                    {
                        uint* write = valueFixed + index;
                        foreach (uint nextValue in values) *write++ = nextValue;
                    }
                }
                return list;
            }
            return values.getList();
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this list<uint> list, uint value)
        {
            return list.count() != 0 ? list.Unsafer.Array.indexOf(0, list.Count, value) : -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this list<uint> list, func<uint, bool> isValue)
        {
            return list.count() != 0 ? list.Unsafer.Array.indexOf(0, list.Count, isValue) : -1;
        }
        /// <summary>
        /// 移除数据
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="index">数据位置</param>
        /// <returns>单向动态数组</returns>
        public static list<uint> removeAt(this list<uint> list, int index)
        {
            int count = list.count();
            if ((uint)index < (uint)count)
            {
                unsafer.array.Move(list.Unsafer.Array, index + 1, index, --count - index);
                list.Unsafer.AddLength(-1);
            }
            else log.Default.Throw(log.exceptionType.IndexOutOfRange);
            return list;
        }
        /// <summary>
        /// 移除数据
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="index">数据位置</param>
        /// <returns>被移除的数据</returns>
        public static uint getRemoveAt(this list<uint> list, int index)
        {
            int count = list.count();
            if ((uint)index < (uint)count)
            {
                list<uint>.unsafer values = new list<uint>.unsafer { List = list };
                uint value = values.Array[index];
                unsafer.array.Move(values.Array, index + 1, index, --count - index);
                values.AddLength(-1);
                return value;
            }
            log.Default.Throw(log.exceptionType.IndexOutOfRange);
            return default(uint);
        }
        /// <summary>
        /// 移除第一个数据
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="value">被移除的数据</param>
        /// <returns>单向动态数组</returns>
        public static list<uint> removeFirst
            (this list<uint> list, uint value)
        {
            if (list != null)
            {
                int index = list.indexOf(value);
                if (index >= 0) list.removeAt(index);
            }
            return list;
        }
        /// <summary>
        /// 移除匹配值
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>单向动态数组</returns>
        public unsafe static list<uint> remove
            (this list<uint> list, func<uint, bool> isValue)
        {
            int count = list.count();
            if (count != 0)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                fixed (uint* valueFixed = list.Unsafer.Array)
                {
                    uint* start = valueFixed, end = valueFixed + count;
                    while (start != end && !isValue(*start)) ++start;
                    uint* write = start;
                    while (start != end)
                    {
                        if (!isValue(*start)) *write++ = *start;
                        ++start;
                    }
                    list.Unsafer.AddLength((int)(write - valueFixed) - count);
                }
            }
            return list;
        }
        /// <summary>
        /// 移除数据范围
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">移除数量</param>
        /// <returns>单向动态数组</returns>
        public static list<uint> removeRange(this list<uint> list, int index, int count)
        {
            int valueCount = list.count();
            if (index + count <= valueCount && index >= 0 && count >= 0 && list != null)
            {
                list.Unsafer.AddLength(-count);
                unsafer.array.Move(list.Unsafer.Array, index + count, index, list.Count - index);
            }
            else log.Default.Throw(log.exceptionType.IndexOutOfRange);
            return list;
        }
        /// <summary>
        /// 取子集合
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">子集合数据数量</param>
        /// <param name="getVlaue">数据获取器</param>
        /// <returns>子集合</returns>
        public unsafe static valueType[] getSub<valueType>
            (this list<uint> list, int startIndex, int count, func<uint, valueType> getVlaue)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            return (count = range.GetCount) != 0 ? list.Unsafer.Array.getSub(range.SkipCount, count, getVlaue) : nullValue<valueType>.Array;
        }
        /// <summary>
        /// 判断是否存在数据
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="value">匹配数据</param>
        /// <returns>是否存在数据</returns>
        public static bool contains(this list<uint> list, uint value)
        {
            return list.indexOf(value) != -1;
        }
        /// <summary>
        /// 判断是否存在匹配
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>是否存在匹配</returns>
        public static bool any(this list<uint> list, func<uint, bool> isValue)
        {
            return list.indexOf(isValue) != -1;
        }
        /// <summary>
        /// 替换第一个匹配值
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="value">新的数据值</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>单向动态数组</returns>
        public static list<uint> replaceFirst
            (this list<uint> list, uint value, func<uint, bool> isValue)
        {
            if (list != null)
            {
                int index = list.indexOf(isValue);
                if (index != -1) list.Unsafer.Array[index] = value;
            }
            return list;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配值,失败为 default(uint)</returns>
        public static uint firstOrDefault
            (this list<uint> list, func<uint, bool> isValue)
        {
            int index = list.indexOf(isValue);
            return index != -1 ? list.Unsafer.Array[index] : default(uint);
        }
        /// <summary>
        /// 获取匹配值集合
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配值集合</returns>
        public static list<uint> getFind
            (this list<uint> list, func<uint, bool> isValue)
        {
            return list.count() != 0 ? list.Unsafer.Array.getFind(0, list.Count, isValue) : null;
        }
        /// <summary>
        /// 获取匹配值集合
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配值数组</returns>
        public static uint[] getFindArray
            (this list<uint> list, func<uint, bool> isValue)
        {
            return list.count() != 0 ? list.Unsafer.Array.getFindArray(0, list.Count, isValue) : nullValue<uint>.Array;
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public static int count(this list<uint> list, func<uint, bool> isValue)
        {
            return list.count() != 0 ? list.Unsafer.Array.count(0, list.Count, isValue) : 0;
        }
        /// <summary>
        /// 清除所有数据
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <returns>单向动态数组</returns>
        public static list<uint> clear(this list<uint> list)
        {
            if (list != null) list.Unsafer.AddLength(-list.Count);
            return list;
        }
        /// <summary>
        /// 遍历foreach
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="method">调用函数</param>
        /// <returns>单向动态数组</returns>
        public static list<uint> each
            (this list<uint> list, action<uint> method)
        {
            if (list.count() != 0) list.Unsafer.Array.each(0, list.Count, method);
            return list;
        }
        /// <summary>
        /// 获取数据分页
        /// </summary>
        /// <typeparam name="valueType">目标数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号,从1开始</param>
        /// <param name="getValue">数据转换器</param>
        /// <returns>分页数据数组</returns>
        public static valueType[] getPage<valueType>
            (this list<uint> list, int pageSize, int currentPage, func<uint, valueType> getValue)
        {
            array.page page = new array.page(list.count(), pageSize, currentPage);
            return list.getSub(page.SkipCount, page.CurrentPageSize, getValue);
        }
        /// <summary>
        /// 转换数据集合
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getValue">数据转换器</param>
        /// <returns>数据集合</returns>
        public static uint[] getArray<valueType>
            (this list<valueType> list, func<valueType, uint> getValue)
        {
            return list.count() != 0 ? list.Unsafer.Array.getSub(0, list.Count, getValue) : nullValue<uint>.Array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max(this list<uint> list, out uint value)
        {
            if (list.count() != 0) return list.Unsafer.Array.max(0, list.Count, out value);
            value = uint.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getKey">比较值获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>
            (this list<valueType> list, func<valueType, uint> getKey, out uint value)
        {
            if (list.count() != 0) return list.Unsafer.Array.maxKey(0, list.Count, getKey, out value);
            value = uint.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getKey">比较值获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>(this list<valueType> list, func<valueType, uint> getKey, out valueType value)
        {
            if (list.count() != 0) return list.Unsafer.Array.max(0, list.Count, getKey, out value);
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static uint max(this list<uint> list, uint nullValue)
        {
            uint value;
            return max(list, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getKey">比较值获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static uint maxKey<valueType>
            (this list<valueType> list, func<valueType, uint> getKey, uint nullValue)
        {
            uint value;
            return maxKey(list, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getKey">比较值获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static valueType max<valueType>(this list<valueType> list, func<valueType, uint> getKey, valueType nullValue)
        {
            valueType value;
            return max(list, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min(this list<uint> list, out uint value)
        {
            if (list.count() != 0) return list.Unsafer.Array.min(0, list.Count, out value);
            value = uint.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getKey">比较值获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>
            (this list<valueType> list, func<valueType, uint> getKey, out uint value)
        {
            if (list.count() != 0) return list.Unsafer.Array.minKey(0, list.Count, getKey, out value);
            value = uint.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getKey">比较值获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>(this list<valueType> list, func<valueType, uint> getKey, out valueType value)
        {
            if (list.count() != 0) return list.Unsafer.Array.min(0, list.Count, getKey, out value);
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static uint min(this list<uint> list, uint nullValue)
        {
            uint value;
            return min(list, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getKey">比较值获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static uint minKey<valueType>
            (this list<valueType> list, func<valueType, uint> getKey, uint nullValue)
        {
            uint value;
            return minKey(list, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getKey">比较值获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static valueType min<valueType>(this list<valueType> list, func<valueType, uint> getKey, valueType nullValue)
        {
            valueType value;
            return min(list, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        public static list<valueType> distinct<valueType>
            (this list<uint> list, func<uint, valueType> getValue)
        {
            if (list.count() != 0) return list.Unsafer.Array.distinct(0, list.Count, getValue);
            return null;
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        public static list<uint> distinct<valueType>
            (this list<valueType> list, func<valueType, uint> getValue)
        {
            if (list.count() != 0) return list.Unsafer.Array.distinct(0, list.Count, getValue);
            return null;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 单向动态数组扩展
    /// </summary>
    public static partial class list
    {
        /// <summary>
        /// 添加数据集合
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="values">数据集合</param>
        /// <returns>单向动态数组</returns>
        public unsafe static list<int> add
            (this list<int> list, System.Collections.Generic.ICollection<int> values)
        {
            if (list != null)
            {
                int count = values.count();
                if (count != 0)
                {
                    int index = list.Count;
                    list.AddLength(count);
                    fixed (int* valueFixed = list.Unsafer.Array)
                    {
                        int* write = valueFixed + index;
                        foreach (int nextValue in values) *write++ = nextValue;
                    }
                }
                return list;
            }
            return values.getList();
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this list<int> list, int value)
        {
            return list.count() != 0 ? list.Unsafer.Array.indexOf(0, list.Count, value) : -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this list<int> list, func<int, bool> isValue)
        {
            return list.count() != 0 ? list.Unsafer.Array.indexOf(0, list.Count, isValue) : -1;
        }
        /// <summary>
        /// 移除数据
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="index">数据位置</param>
        /// <returns>单向动态数组</returns>
        public static list<int> removeAt(this list<int> list, int index)
        {
            int count = list.count();
            if ((uint)index < (uint)count)
            {
                unsafer.array.Move(list.Unsafer.Array, index + 1, index, --count - index);
                list.Unsafer.AddLength(-1);
            }
            else log.Default.Throw(log.exceptionType.IndexOutOfRange);
            return list;
        }
        /// <summary>
        /// 移除数据
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="index">数据位置</param>
        /// <returns>被移除的数据</returns>
        public static int getRemoveAt(this list<int> list, int index)
        {
            int count = list.count();
            if ((uint)index < (uint)count)
            {
                list<int>.unsafer values = new list<int>.unsafer { List = list };
                int value = values.Array[index];
                unsafer.array.Move(values.Array, index + 1, index, --count - index);
                values.AddLength(-1);
                return value;
            }
            log.Default.Throw(log.exceptionType.IndexOutOfRange);
            return default(int);
        }
        /// <summary>
        /// 移除第一个数据
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="value">被移除的数据</param>
        /// <returns>单向动态数组</returns>
        public static list<int> removeFirst
            (this list<int> list, int value)
        {
            if (list != null)
            {
                int index = list.indexOf(value);
                if (index >= 0) list.removeAt(index);
            }
            return list;
        }
        /// <summary>
        /// 移除匹配值
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>单向动态数组</returns>
        public unsafe static list<int> remove
            (this list<int> list, func<int, bool> isValue)
        {
            int count = list.count();
            if (count != 0)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                fixed (int* valueFixed = list.Unsafer.Array)
                {
                    int* start = valueFixed, end = valueFixed + count;
                    while (start != end && !isValue(*start)) ++start;
                    int* write = start;
                    while (start != end)
                    {
                        if (!isValue(*start)) *write++ = *start;
                        ++start;
                    }
                    list.Unsafer.AddLength((int)(write - valueFixed) - count);
                }
            }
            return list;
        }
        /// <summary>
        /// 移除数据范围
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">移除数量</param>
        /// <returns>单向动态数组</returns>
        public static list<int> removeRange(this list<int> list, int index, int count)
        {
            int valueCount = list.count();
            if (index + count <= valueCount && index >= 0 && count >= 0 && list != null)
            {
                list.Unsafer.AddLength(-count);
                unsafer.array.Move(list.Unsafer.Array, index + count, index, list.Count - index);
            }
            else log.Default.Throw(log.exceptionType.IndexOutOfRange);
            return list;
        }
        /// <summary>
        /// 取子集合
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">子集合数据数量</param>
        /// <param name="getVlaue">数据获取器</param>
        /// <returns>子集合</returns>
        public unsafe static valueType[] getSub<valueType>
            (this list<int> list, int startIndex, int count, func<int, valueType> getVlaue)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            return (count = range.GetCount) != 0 ? list.Unsafer.Array.getSub(range.SkipCount, count, getVlaue) : nullValue<valueType>.Array;
        }
        /// <summary>
        /// 判断是否存在数据
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="value">匹配数据</param>
        /// <returns>是否存在数据</returns>
        public static bool contains(this list<int> list, int value)
        {
            return list.indexOf(value) != -1;
        }
        /// <summary>
        /// 判断是否存在匹配
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>是否存在匹配</returns>
        public static bool any(this list<int> list, func<int, bool> isValue)
        {
            return list.indexOf(isValue) != -1;
        }
        /// <summary>
        /// 替换第一个匹配值
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="value">新的数据值</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>单向动态数组</returns>
        public static list<int> replaceFirst
            (this list<int> list, int value, func<int, bool> isValue)
        {
            if (list != null)
            {
                int index = list.indexOf(isValue);
                if (index != -1) list.Unsafer.Array[index] = value;
            }
            return list;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配值,失败为 default(int)</returns>
        public static int firstOrDefault
            (this list<int> list, func<int, bool> isValue)
        {
            int index = list.indexOf(isValue);
            return index != -1 ? list.Unsafer.Array[index] : default(int);
        }
        /// <summary>
        /// 获取匹配值集合
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配值集合</returns>
        public static list<int> getFind
            (this list<int> list, func<int, bool> isValue)
        {
            return list.count() != 0 ? list.Unsafer.Array.getFind(0, list.Count, isValue) : null;
        }
        /// <summary>
        /// 获取匹配值集合
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配值数组</returns>
        public static int[] getFindArray
            (this list<int> list, func<int, bool> isValue)
        {
            return list.count() != 0 ? list.Unsafer.Array.getFindArray(0, list.Count, isValue) : nullValue<int>.Array;
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public static int count(this list<int> list, func<int, bool> isValue)
        {
            return list.count() != 0 ? list.Unsafer.Array.count(0, list.Count, isValue) : 0;
        }
        /// <summary>
        /// 清除所有数据
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <returns>单向动态数组</returns>
        public static list<int> clear(this list<int> list)
        {
            if (list != null) list.Unsafer.AddLength(-list.Count);
            return list;
        }
        /// <summary>
        /// 遍历foreach
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="method">调用函数</param>
        /// <returns>单向动态数组</returns>
        public static list<int> each
            (this list<int> list, action<int> method)
        {
            if (list.count() != 0) list.Unsafer.Array.each(0, list.Count, method);
            return list;
        }
        /// <summary>
        /// 获取数据分页
        /// </summary>
        /// <typeparam name="valueType">目标数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号,从1开始</param>
        /// <param name="getValue">数据转换器</param>
        /// <returns>分页数据数组</returns>
        public static valueType[] getPage<valueType>
            (this list<int> list, int pageSize, int currentPage, func<int, valueType> getValue)
        {
            array.page page = new array.page(list.count(), pageSize, currentPage);
            return list.getSub(page.SkipCount, page.CurrentPageSize, getValue);
        }
        /// <summary>
        /// 转换数据集合
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getValue">数据转换器</param>
        /// <returns>数据集合</returns>
        public static int[] getArray<valueType>
            (this list<valueType> list, func<valueType, int> getValue)
        {
            return list.count() != 0 ? list.Unsafer.Array.getSub(0, list.Count, getValue) : nullValue<int>.Array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max(this list<int> list, out int value)
        {
            if (list.count() != 0) return list.Unsafer.Array.max(0, list.Count, out value);
            value = int.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getKey">比较值获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>
            (this list<valueType> list, func<valueType, int> getKey, out int value)
        {
            if (list.count() != 0) return list.Unsafer.Array.maxKey(0, list.Count, getKey, out value);
            value = int.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getKey">比较值获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>(this list<valueType> list, func<valueType, int> getKey, out valueType value)
        {
            if (list.count() != 0) return list.Unsafer.Array.max(0, list.Count, getKey, out value);
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static int max(this list<int> list, int nullValue)
        {
            int value;
            return max(list, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getKey">比较值获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static int maxKey<valueType>
            (this list<valueType> list, func<valueType, int> getKey, int nullValue)
        {
            int value;
            return maxKey(list, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getKey">比较值获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static valueType max<valueType>(this list<valueType> list, func<valueType, int> getKey, valueType nullValue)
        {
            valueType value;
            return max(list, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min(this list<int> list, out int value)
        {
            if (list.count() != 0) return list.Unsafer.Array.min(0, list.Count, out value);
            value = int.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getKey">比较值获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>
            (this list<valueType> list, func<valueType, int> getKey, out int value)
        {
            if (list.count() != 0) return list.Unsafer.Array.minKey(0, list.Count, getKey, out value);
            value = int.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getKey">比较值获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>(this list<valueType> list, func<valueType, int> getKey, out valueType value)
        {
            if (list.count() != 0) return list.Unsafer.Array.min(0, list.Count, getKey, out value);
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static int min(this list<int> list, int nullValue)
        {
            int value;
            return min(list, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getKey">比较值获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static int minKey<valueType>
            (this list<valueType> list, func<valueType, int> getKey, int nullValue)
        {
            int value;
            return minKey(list, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getKey">比较值获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static valueType min<valueType>(this list<valueType> list, func<valueType, int> getKey, valueType nullValue)
        {
            valueType value;
            return min(list, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        public static list<valueType> distinct<valueType>
            (this list<int> list, func<int, valueType> getValue)
        {
            if (list.count() != 0) return list.Unsafer.Array.distinct(0, list.Count, getValue);
            return null;
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        public static list<int> distinct<valueType>
            (this list<valueType> list, func<valueType, int> getValue)
        {
            if (list.count() != 0) return list.Unsafer.Array.distinct(0, list.Count, getValue);
            return null;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 单向动态数组扩展
    /// </summary>
    public static partial class list
    {
        /// <summary>
        /// 添加数据集合
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="values">数据集合</param>
        /// <returns>单向动态数组</returns>
        public unsafe static list<ushort> add
            (this list<ushort> list, System.Collections.Generic.ICollection<ushort> values)
        {
            if (list != null)
            {
                int count = values.count();
                if (count != 0)
                {
                    int index = list.Count;
                    list.AddLength(count);
                    fixed (ushort* valueFixed = list.Unsafer.Array)
                    {
                        ushort* write = valueFixed + index;
                        foreach (ushort nextValue in values) *write++ = nextValue;
                    }
                }
                return list;
            }
            return values.getList();
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this list<ushort> list, ushort value)
        {
            return list.count() != 0 ? list.Unsafer.Array.indexOf(0, list.Count, value) : -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this list<ushort> list, func<ushort, bool> isValue)
        {
            return list.count() != 0 ? list.Unsafer.Array.indexOf(0, list.Count, isValue) : -1;
        }
        /// <summary>
        /// 移除数据
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="index">数据位置</param>
        /// <returns>单向动态数组</returns>
        public static list<ushort> removeAt(this list<ushort> list, int index)
        {
            int count = list.count();
            if ((uint)index < (uint)count)
            {
                unsafer.array.Move(list.Unsafer.Array, index + 1, index, --count - index);
                list.Unsafer.AddLength(-1);
            }
            else log.Default.Throw(log.exceptionType.IndexOutOfRange);
            return list;
        }
        /// <summary>
        /// 移除数据
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="index">数据位置</param>
        /// <returns>被移除的数据</returns>
        public static ushort getRemoveAt(this list<ushort> list, int index)
        {
            int count = list.count();
            if ((uint)index < (uint)count)
            {
                list<ushort>.unsafer values = new list<ushort>.unsafer { List = list };
                ushort value = values.Array[index];
                unsafer.array.Move(values.Array, index + 1, index, --count - index);
                values.AddLength(-1);
                return value;
            }
            log.Default.Throw(log.exceptionType.IndexOutOfRange);
            return default(ushort);
        }
        /// <summary>
        /// 移除第一个数据
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="value">被移除的数据</param>
        /// <returns>单向动态数组</returns>
        public static list<ushort> removeFirst
            (this list<ushort> list, ushort value)
        {
            if (list != null)
            {
                int index = list.indexOf(value);
                if (index >= 0) list.removeAt(index);
            }
            return list;
        }
        /// <summary>
        /// 移除匹配值
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>单向动态数组</returns>
        public unsafe static list<ushort> remove
            (this list<ushort> list, func<ushort, bool> isValue)
        {
            int count = list.count();
            if (count != 0)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                fixed (ushort* valueFixed = list.Unsafer.Array)
                {
                    ushort* start = valueFixed, end = valueFixed + count;
                    while (start != end && !isValue(*start)) ++start;
                    ushort* write = start;
                    while (start != end)
                    {
                        if (!isValue(*start)) *write++ = *start;
                        ++start;
                    }
                    list.Unsafer.AddLength((int)(write - valueFixed) - count);
                }
            }
            return list;
        }
        /// <summary>
        /// 移除数据范围
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">移除数量</param>
        /// <returns>单向动态数组</returns>
        public static list<ushort> removeRange(this list<ushort> list, int index, int count)
        {
            int valueCount = list.count();
            if (index + count <= valueCount && index >= 0 && count >= 0 && list != null)
            {
                list.Unsafer.AddLength(-count);
                unsafer.array.Move(list.Unsafer.Array, index + count, index, list.Count - index);
            }
            else log.Default.Throw(log.exceptionType.IndexOutOfRange);
            return list;
        }
        /// <summary>
        /// 取子集合
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">子集合数据数量</param>
        /// <param name="getVlaue">数据获取器</param>
        /// <returns>子集合</returns>
        public unsafe static valueType[] getSub<valueType>
            (this list<ushort> list, int startIndex, int count, func<ushort, valueType> getVlaue)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            return (count = range.GetCount) != 0 ? list.Unsafer.Array.getSub(range.SkipCount, count, getVlaue) : nullValue<valueType>.Array;
        }
        /// <summary>
        /// 判断是否存在数据
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="value">匹配数据</param>
        /// <returns>是否存在数据</returns>
        public static bool contains(this list<ushort> list, ushort value)
        {
            return list.indexOf(value) != -1;
        }
        /// <summary>
        /// 判断是否存在匹配
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>是否存在匹配</returns>
        public static bool any(this list<ushort> list, func<ushort, bool> isValue)
        {
            return list.indexOf(isValue) != -1;
        }
        /// <summary>
        /// 替换第一个匹配值
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="value">新的数据值</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>单向动态数组</returns>
        public static list<ushort> replaceFirst
            (this list<ushort> list, ushort value, func<ushort, bool> isValue)
        {
            if (list != null)
            {
                int index = list.indexOf(isValue);
                if (index != -1) list.Unsafer.Array[index] = value;
            }
            return list;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配值,失败为 default(ushort)</returns>
        public static ushort firstOrDefault
            (this list<ushort> list, func<ushort, bool> isValue)
        {
            int index = list.indexOf(isValue);
            return index != -1 ? list.Unsafer.Array[index] : default(ushort);
        }
        /// <summary>
        /// 获取匹配值集合
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配值集合</returns>
        public static list<ushort> getFind
            (this list<ushort> list, func<ushort, bool> isValue)
        {
            return list.count() != 0 ? list.Unsafer.Array.getFind(0, list.Count, isValue) : null;
        }
        /// <summary>
        /// 获取匹配值集合
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配值数组</returns>
        public static ushort[] getFindArray
            (this list<ushort> list, func<ushort, bool> isValue)
        {
            return list.count() != 0 ? list.Unsafer.Array.getFindArray(0, list.Count, isValue) : nullValue<ushort>.Array;
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public static int count(this list<ushort> list, func<ushort, bool> isValue)
        {
            return list.count() != 0 ? list.Unsafer.Array.count(0, list.Count, isValue) : 0;
        }
        /// <summary>
        /// 清除所有数据
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <returns>单向动态数组</returns>
        public static list<ushort> clear(this list<ushort> list)
        {
            if (list != null) list.Unsafer.AddLength(-list.Count);
            return list;
        }
        /// <summary>
        /// 遍历foreach
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="method">调用函数</param>
        /// <returns>单向动态数组</returns>
        public static list<ushort> each
            (this list<ushort> list, action<ushort> method)
        {
            if (list.count() != 0) list.Unsafer.Array.each(0, list.Count, method);
            return list;
        }
        /// <summary>
        /// 获取数据分页
        /// </summary>
        /// <typeparam name="valueType">目标数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号,从1开始</param>
        /// <param name="getValue">数据转换器</param>
        /// <returns>分页数据数组</returns>
        public static valueType[] getPage<valueType>
            (this list<ushort> list, int pageSize, int currentPage, func<ushort, valueType> getValue)
        {
            array.page page = new array.page(list.count(), pageSize, currentPage);
            return list.getSub(page.SkipCount, page.CurrentPageSize, getValue);
        }
        /// <summary>
        /// 转换数据集合
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getValue">数据转换器</param>
        /// <returns>数据集合</returns>
        public static ushort[] getArray<valueType>
            (this list<valueType> list, func<valueType, ushort> getValue)
        {
            return list.count() != 0 ? list.Unsafer.Array.getSub(0, list.Count, getValue) : nullValue<ushort>.Array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max(this list<ushort> list, out ushort value)
        {
            if (list.count() != 0) return list.Unsafer.Array.max(0, list.Count, out value);
            value = ushort.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getKey">比较值获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>
            (this list<valueType> list, func<valueType, ushort> getKey, out ushort value)
        {
            if (list.count() != 0) return list.Unsafer.Array.maxKey(0, list.Count, getKey, out value);
            value = ushort.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getKey">比较值获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>(this list<valueType> list, func<valueType, ushort> getKey, out valueType value)
        {
            if (list.count() != 0) return list.Unsafer.Array.max(0, list.Count, getKey, out value);
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static ushort max(this list<ushort> list, ushort nullValue)
        {
            ushort value;
            return max(list, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getKey">比较值获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static ushort maxKey<valueType>
            (this list<valueType> list, func<valueType, ushort> getKey, ushort nullValue)
        {
            ushort value;
            return maxKey(list, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getKey">比较值获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static valueType max<valueType>(this list<valueType> list, func<valueType, ushort> getKey, valueType nullValue)
        {
            valueType value;
            return max(list, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min(this list<ushort> list, out ushort value)
        {
            if (list.count() != 0) return list.Unsafer.Array.min(0, list.Count, out value);
            value = ushort.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getKey">比较值获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>
            (this list<valueType> list, func<valueType, ushort> getKey, out ushort value)
        {
            if (list.count() != 0) return list.Unsafer.Array.minKey(0, list.Count, getKey, out value);
            value = ushort.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getKey">比较值获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>(this list<valueType> list, func<valueType, ushort> getKey, out valueType value)
        {
            if (list.count() != 0) return list.Unsafer.Array.min(0, list.Count, getKey, out value);
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static ushort min(this list<ushort> list, ushort nullValue)
        {
            ushort value;
            return min(list, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getKey">比较值获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static ushort minKey<valueType>
            (this list<valueType> list, func<valueType, ushort> getKey, ushort nullValue)
        {
            ushort value;
            return minKey(list, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getKey">比较值获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static valueType min<valueType>(this list<valueType> list, func<valueType, ushort> getKey, valueType nullValue)
        {
            valueType value;
            return min(list, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        public static list<valueType> distinct<valueType>
            (this list<ushort> list, func<ushort, valueType> getValue)
        {
            if (list.count() != 0) return list.Unsafer.Array.distinct(0, list.Count, getValue);
            return null;
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        public static list<ushort> distinct<valueType>
            (this list<valueType> list, func<valueType, ushort> getValue)
        {
            if (list.count() != 0) return list.Unsafer.Array.distinct(0, list.Count, getValue);
            return null;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 单向动态数组扩展
    /// </summary>
    public static partial class list
    {
        /// <summary>
        /// 添加数据集合
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="values">数据集合</param>
        /// <returns>单向动态数组</returns>
        public unsafe static list<short> add
            (this list<short> list, System.Collections.Generic.ICollection<short> values)
        {
            if (list != null)
            {
                int count = values.count();
                if (count != 0)
                {
                    int index = list.Count;
                    list.AddLength(count);
                    fixed (short* valueFixed = list.Unsafer.Array)
                    {
                        short* write = valueFixed + index;
                        foreach (short nextValue in values) *write++ = nextValue;
                    }
                }
                return list;
            }
            return values.getList();
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this list<short> list, short value)
        {
            return list.count() != 0 ? list.Unsafer.Array.indexOf(0, list.Count, value) : -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this list<short> list, func<short, bool> isValue)
        {
            return list.count() != 0 ? list.Unsafer.Array.indexOf(0, list.Count, isValue) : -1;
        }
        /// <summary>
        /// 移除数据
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="index">数据位置</param>
        /// <returns>单向动态数组</returns>
        public static list<short> removeAt(this list<short> list, int index)
        {
            int count = list.count();
            if ((uint)index < (uint)count)
            {
                unsafer.array.Move(list.Unsafer.Array, index + 1, index, --count - index);
                list.Unsafer.AddLength(-1);
            }
            else log.Default.Throw(log.exceptionType.IndexOutOfRange);
            return list;
        }
        /// <summary>
        /// 移除数据
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="index">数据位置</param>
        /// <returns>被移除的数据</returns>
        public static short getRemoveAt(this list<short> list, int index)
        {
            int count = list.count();
            if ((uint)index < (uint)count)
            {
                list<short>.unsafer values = new list<short>.unsafer { List = list };
                short value = values.Array[index];
                unsafer.array.Move(values.Array, index + 1, index, --count - index);
                values.AddLength(-1);
                return value;
            }
            log.Default.Throw(log.exceptionType.IndexOutOfRange);
            return default(short);
        }
        /// <summary>
        /// 移除第一个数据
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="value">被移除的数据</param>
        /// <returns>单向动态数组</returns>
        public static list<short> removeFirst
            (this list<short> list, short value)
        {
            if (list != null)
            {
                int index = list.indexOf(value);
                if (index >= 0) list.removeAt(index);
            }
            return list;
        }
        /// <summary>
        /// 移除匹配值
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>单向动态数组</returns>
        public unsafe static list<short> remove
            (this list<short> list, func<short, bool> isValue)
        {
            int count = list.count();
            if (count != 0)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                fixed (short* valueFixed = list.Unsafer.Array)
                {
                    short* start = valueFixed, end = valueFixed + count;
                    while (start != end && !isValue(*start)) ++start;
                    short* write = start;
                    while (start != end)
                    {
                        if (!isValue(*start)) *write++ = *start;
                        ++start;
                    }
                    list.Unsafer.AddLength((int)(write - valueFixed) - count);
                }
            }
            return list;
        }
        /// <summary>
        /// 移除数据范围
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">移除数量</param>
        /// <returns>单向动态数组</returns>
        public static list<short> removeRange(this list<short> list, int index, int count)
        {
            int valueCount = list.count();
            if (index + count <= valueCount && index >= 0 && count >= 0 && list != null)
            {
                list.Unsafer.AddLength(-count);
                unsafer.array.Move(list.Unsafer.Array, index + count, index, list.Count - index);
            }
            else log.Default.Throw(log.exceptionType.IndexOutOfRange);
            return list;
        }
        /// <summary>
        /// 取子集合
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">子集合数据数量</param>
        /// <param name="getVlaue">数据获取器</param>
        /// <returns>子集合</returns>
        public unsafe static valueType[] getSub<valueType>
            (this list<short> list, int startIndex, int count, func<short, valueType> getVlaue)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            return (count = range.GetCount) != 0 ? list.Unsafer.Array.getSub(range.SkipCount, count, getVlaue) : nullValue<valueType>.Array;
        }
        /// <summary>
        /// 判断是否存在数据
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="value">匹配数据</param>
        /// <returns>是否存在数据</returns>
        public static bool contains(this list<short> list, short value)
        {
            return list.indexOf(value) != -1;
        }
        /// <summary>
        /// 判断是否存在匹配
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>是否存在匹配</returns>
        public static bool any(this list<short> list, func<short, bool> isValue)
        {
            return list.indexOf(isValue) != -1;
        }
        /// <summary>
        /// 替换第一个匹配值
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="value">新的数据值</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>单向动态数组</returns>
        public static list<short> replaceFirst
            (this list<short> list, short value, func<short, bool> isValue)
        {
            if (list != null)
            {
                int index = list.indexOf(isValue);
                if (index != -1) list.Unsafer.Array[index] = value;
            }
            return list;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配值,失败为 default(short)</returns>
        public static short firstOrDefault
            (this list<short> list, func<short, bool> isValue)
        {
            int index = list.indexOf(isValue);
            return index != -1 ? list.Unsafer.Array[index] : default(short);
        }
        /// <summary>
        /// 获取匹配值集合
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配值集合</returns>
        public static list<short> getFind
            (this list<short> list, func<short, bool> isValue)
        {
            return list.count() != 0 ? list.Unsafer.Array.getFind(0, list.Count, isValue) : null;
        }
        /// <summary>
        /// 获取匹配值集合
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配值数组</returns>
        public static short[] getFindArray
            (this list<short> list, func<short, bool> isValue)
        {
            return list.count() != 0 ? list.Unsafer.Array.getFindArray(0, list.Count, isValue) : nullValue<short>.Array;
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public static int count(this list<short> list, func<short, bool> isValue)
        {
            return list.count() != 0 ? list.Unsafer.Array.count(0, list.Count, isValue) : 0;
        }
        /// <summary>
        /// 清除所有数据
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <returns>单向动态数组</returns>
        public static list<short> clear(this list<short> list)
        {
            if (list != null) list.Unsafer.AddLength(-list.Count);
            return list;
        }
        /// <summary>
        /// 遍历foreach
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="method">调用函数</param>
        /// <returns>单向动态数组</returns>
        public static list<short> each
            (this list<short> list, action<short> method)
        {
            if (list.count() != 0) list.Unsafer.Array.each(0, list.Count, method);
            return list;
        }
        /// <summary>
        /// 获取数据分页
        /// </summary>
        /// <typeparam name="valueType">目标数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号,从1开始</param>
        /// <param name="getValue">数据转换器</param>
        /// <returns>分页数据数组</returns>
        public static valueType[] getPage<valueType>
            (this list<short> list, int pageSize, int currentPage, func<short, valueType> getValue)
        {
            array.page page = new array.page(list.count(), pageSize, currentPage);
            return list.getSub(page.SkipCount, page.CurrentPageSize, getValue);
        }
        /// <summary>
        /// 转换数据集合
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getValue">数据转换器</param>
        /// <returns>数据集合</returns>
        public static short[] getArray<valueType>
            (this list<valueType> list, func<valueType, short> getValue)
        {
            return list.count() != 0 ? list.Unsafer.Array.getSub(0, list.Count, getValue) : nullValue<short>.Array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max(this list<short> list, out short value)
        {
            if (list.count() != 0) return list.Unsafer.Array.max(0, list.Count, out value);
            value = short.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getKey">比较值获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>
            (this list<valueType> list, func<valueType, short> getKey, out short value)
        {
            if (list.count() != 0) return list.Unsafer.Array.maxKey(0, list.Count, getKey, out value);
            value = short.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getKey">比较值获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>(this list<valueType> list, func<valueType, short> getKey, out valueType value)
        {
            if (list.count() != 0) return list.Unsafer.Array.max(0, list.Count, getKey, out value);
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static short max(this list<short> list, short nullValue)
        {
            short value;
            return max(list, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getKey">比较值获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static short maxKey<valueType>
            (this list<valueType> list, func<valueType, short> getKey, short nullValue)
        {
            short value;
            return maxKey(list, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getKey">比较值获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static valueType max<valueType>(this list<valueType> list, func<valueType, short> getKey, valueType nullValue)
        {
            valueType value;
            return max(list, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min(this list<short> list, out short value)
        {
            if (list.count() != 0) return list.Unsafer.Array.min(0, list.Count, out value);
            value = short.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getKey">比较值获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>
            (this list<valueType> list, func<valueType, short> getKey, out short value)
        {
            if (list.count() != 0) return list.Unsafer.Array.minKey(0, list.Count, getKey, out value);
            value = short.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getKey">比较值获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>(this list<valueType> list, func<valueType, short> getKey, out valueType value)
        {
            if (list.count() != 0) return list.Unsafer.Array.min(0, list.Count, getKey, out value);
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static short min(this list<short> list, short nullValue)
        {
            short value;
            return min(list, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getKey">比较值获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static short minKey<valueType>
            (this list<valueType> list, func<valueType, short> getKey, short nullValue)
        {
            short value;
            return minKey(list, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getKey">比较值获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static valueType min<valueType>(this list<valueType> list, func<valueType, short> getKey, valueType nullValue)
        {
            valueType value;
            return min(list, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        public static list<valueType> distinct<valueType>
            (this list<short> list, func<short, valueType> getValue)
        {
            if (list.count() != 0) return list.Unsafer.Array.distinct(0, list.Count, getValue);
            return null;
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        public static list<short> distinct<valueType>
            (this list<valueType> list, func<valueType, short> getValue)
        {
            if (list.count() != 0) return list.Unsafer.Array.distinct(0, list.Count, getValue);
            return null;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 单向动态数组扩展
    /// </summary>
    public static partial class list
    {
        /// <summary>
        /// 添加数据集合
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="values">数据集合</param>
        /// <returns>单向动态数组</returns>
        public unsafe static list<byte> add
            (this list<byte> list, System.Collections.Generic.ICollection<byte> values)
        {
            if (list != null)
            {
                int count = values.count();
                if (count != 0)
                {
                    int index = list.Count;
                    list.AddLength(count);
                    fixed (byte* valueFixed = list.Unsafer.Array)
                    {
                        byte* write = valueFixed + index;
                        foreach (byte nextValue in values) *write++ = nextValue;
                    }
                }
                return list;
            }
            return values.getList();
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this list<byte> list, byte value)
        {
            return list.count() != 0 ? list.Unsafer.Array.indexOf(0, list.Count, value) : -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this list<byte> list, func<byte, bool> isValue)
        {
            return list.count() != 0 ? list.Unsafer.Array.indexOf(0, list.Count, isValue) : -1;
        }
        /// <summary>
        /// 移除数据
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="index">数据位置</param>
        /// <returns>单向动态数组</returns>
        public static list<byte> removeAt(this list<byte> list, int index)
        {
            int count = list.count();
            if ((uint)index < (uint)count)
            {
                unsafer.array.Move(list.Unsafer.Array, index + 1, index, --count - index);
                list.Unsafer.AddLength(-1);
            }
            else log.Default.Throw(log.exceptionType.IndexOutOfRange);
            return list;
        }
        /// <summary>
        /// 移除数据
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="index">数据位置</param>
        /// <returns>被移除的数据</returns>
        public static byte getRemoveAt(this list<byte> list, int index)
        {
            int count = list.count();
            if ((uint)index < (uint)count)
            {
                list<byte>.unsafer values = new list<byte>.unsafer { List = list };
                byte value = values.Array[index];
                unsafer.array.Move(values.Array, index + 1, index, --count - index);
                values.AddLength(-1);
                return value;
            }
            log.Default.Throw(log.exceptionType.IndexOutOfRange);
            return default(byte);
        }
        /// <summary>
        /// 移除第一个数据
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="value">被移除的数据</param>
        /// <returns>单向动态数组</returns>
        public static list<byte> removeFirst
            (this list<byte> list, byte value)
        {
            if (list != null)
            {
                int index = list.indexOf(value);
                if (index >= 0) list.removeAt(index);
            }
            return list;
        }
        /// <summary>
        /// 移除匹配值
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>单向动态数组</returns>
        public unsafe static list<byte> remove
            (this list<byte> list, func<byte, bool> isValue)
        {
            int count = list.count();
            if (count != 0)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                fixed (byte* valueFixed = list.Unsafer.Array)
                {
                    byte* start = valueFixed, end = valueFixed + count;
                    while (start != end && !isValue(*start)) ++start;
                    byte* write = start;
                    while (start != end)
                    {
                        if (!isValue(*start)) *write++ = *start;
                        ++start;
                    }
                    list.Unsafer.AddLength((int)(write - valueFixed) - count);
                }
            }
            return list;
        }
        /// <summary>
        /// 移除数据范围
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">移除数量</param>
        /// <returns>单向动态数组</returns>
        public static list<byte> removeRange(this list<byte> list, int index, int count)
        {
            int valueCount = list.count();
            if (index + count <= valueCount && index >= 0 && count >= 0 && list != null)
            {
                list.Unsafer.AddLength(-count);
                unsafer.array.Move(list.Unsafer.Array, index + count, index, list.Count - index);
            }
            else log.Default.Throw(log.exceptionType.IndexOutOfRange);
            return list;
        }
        /// <summary>
        /// 取子集合
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">子集合数据数量</param>
        /// <param name="getVlaue">数据获取器</param>
        /// <returns>子集合</returns>
        public unsafe static valueType[] getSub<valueType>
            (this list<byte> list, int startIndex, int count, func<byte, valueType> getVlaue)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            return (count = range.GetCount) != 0 ? list.Unsafer.Array.getSub(range.SkipCount, count, getVlaue) : nullValue<valueType>.Array;
        }
        /// <summary>
        /// 判断是否存在数据
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="value">匹配数据</param>
        /// <returns>是否存在数据</returns>
        public static bool contains(this list<byte> list, byte value)
        {
            return list.indexOf(value) != -1;
        }
        /// <summary>
        /// 判断是否存在匹配
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>是否存在匹配</returns>
        public static bool any(this list<byte> list, func<byte, bool> isValue)
        {
            return list.indexOf(isValue) != -1;
        }
        /// <summary>
        /// 替换第一个匹配值
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="value">新的数据值</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>单向动态数组</returns>
        public static list<byte> replaceFirst
            (this list<byte> list, byte value, func<byte, bool> isValue)
        {
            if (list != null)
            {
                int index = list.indexOf(isValue);
                if (index != -1) list.Unsafer.Array[index] = value;
            }
            return list;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配值,失败为 default(byte)</returns>
        public static byte firstOrDefault
            (this list<byte> list, func<byte, bool> isValue)
        {
            int index = list.indexOf(isValue);
            return index != -1 ? list.Unsafer.Array[index] : default(byte);
        }
        /// <summary>
        /// 获取匹配值集合
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配值集合</returns>
        public static list<byte> getFind
            (this list<byte> list, func<byte, bool> isValue)
        {
            return list.count() != 0 ? list.Unsafer.Array.getFind(0, list.Count, isValue) : null;
        }
        /// <summary>
        /// 获取匹配值集合
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配值数组</returns>
        public static byte[] getFindArray
            (this list<byte> list, func<byte, bool> isValue)
        {
            return list.count() != 0 ? list.Unsafer.Array.getFindArray(0, list.Count, isValue) : nullValue<byte>.Array;
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public static int count(this list<byte> list, func<byte, bool> isValue)
        {
            return list.count() != 0 ? list.Unsafer.Array.count(0, list.Count, isValue) : 0;
        }
        /// <summary>
        /// 清除所有数据
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <returns>单向动态数组</returns>
        public static list<byte> clear(this list<byte> list)
        {
            if (list != null) list.Unsafer.AddLength(-list.Count);
            return list;
        }
        /// <summary>
        /// 遍历foreach
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="method">调用函数</param>
        /// <returns>单向动态数组</returns>
        public static list<byte> each
            (this list<byte> list, action<byte> method)
        {
            if (list.count() != 0) list.Unsafer.Array.each(0, list.Count, method);
            return list;
        }
        /// <summary>
        /// 获取数据分页
        /// </summary>
        /// <typeparam name="valueType">目标数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号,从1开始</param>
        /// <param name="getValue">数据转换器</param>
        /// <returns>分页数据数组</returns>
        public static valueType[] getPage<valueType>
            (this list<byte> list, int pageSize, int currentPage, func<byte, valueType> getValue)
        {
            array.page page = new array.page(list.count(), pageSize, currentPage);
            return list.getSub(page.SkipCount, page.CurrentPageSize, getValue);
        }
        /// <summary>
        /// 转换数据集合
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getValue">数据转换器</param>
        /// <returns>数据集合</returns>
        public static byte[] getArray<valueType>
            (this list<valueType> list, func<valueType, byte> getValue)
        {
            return list.count() != 0 ? list.Unsafer.Array.getSub(0, list.Count, getValue) : nullValue<byte>.Array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max(this list<byte> list, out byte value)
        {
            if (list.count() != 0) return list.Unsafer.Array.max(0, list.Count, out value);
            value = byte.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getKey">比较值获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>
            (this list<valueType> list, func<valueType, byte> getKey, out byte value)
        {
            if (list.count() != 0) return list.Unsafer.Array.maxKey(0, list.Count, getKey, out value);
            value = byte.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getKey">比较值获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>(this list<valueType> list, func<valueType, byte> getKey, out valueType value)
        {
            if (list.count() != 0) return list.Unsafer.Array.max(0, list.Count, getKey, out value);
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static byte max(this list<byte> list, byte nullValue)
        {
            byte value;
            return max(list, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getKey">比较值获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static byte maxKey<valueType>
            (this list<valueType> list, func<valueType, byte> getKey, byte nullValue)
        {
            byte value;
            return maxKey(list, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getKey">比较值获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static valueType max<valueType>(this list<valueType> list, func<valueType, byte> getKey, valueType nullValue)
        {
            valueType value;
            return max(list, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min(this list<byte> list, out byte value)
        {
            if (list.count() != 0) return list.Unsafer.Array.min(0, list.Count, out value);
            value = byte.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getKey">比较值获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>
            (this list<valueType> list, func<valueType, byte> getKey, out byte value)
        {
            if (list.count() != 0) return list.Unsafer.Array.minKey(0, list.Count, getKey, out value);
            value = byte.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getKey">比较值获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>(this list<valueType> list, func<valueType, byte> getKey, out valueType value)
        {
            if (list.count() != 0) return list.Unsafer.Array.min(0, list.Count, getKey, out value);
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static byte min(this list<byte> list, byte nullValue)
        {
            byte value;
            return min(list, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getKey">比较值获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static byte minKey<valueType>
            (this list<valueType> list, func<valueType, byte> getKey, byte nullValue)
        {
            byte value;
            return minKey(list, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getKey">比较值获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static valueType min<valueType>(this list<valueType> list, func<valueType, byte> getKey, valueType nullValue)
        {
            valueType value;
            return min(list, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        public static list<valueType> distinct<valueType>
            (this list<byte> list, func<byte, valueType> getValue)
        {
            if (list.count() != 0) return list.Unsafer.Array.distinct(0, list.Count, getValue);
            return null;
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        public static list<byte> distinct<valueType>
            (this list<valueType> list, func<valueType, byte> getValue)
        {
            if (list.count() != 0) return list.Unsafer.Array.distinct(0, list.Count, getValue);
            return null;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 单向动态数组扩展
    /// </summary>
    public static partial class list
    {
        /// <summary>
        /// 添加数据集合
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="values">数据集合</param>
        /// <returns>单向动态数组</returns>
        public unsafe static list<sbyte> add
            (this list<sbyte> list, System.Collections.Generic.ICollection<sbyte> values)
        {
            if (list != null)
            {
                int count = values.count();
                if (count != 0)
                {
                    int index = list.Count;
                    list.AddLength(count);
                    fixed (sbyte* valueFixed = list.Unsafer.Array)
                    {
                        sbyte* write = valueFixed + index;
                        foreach (sbyte nextValue in values) *write++ = nextValue;
                    }
                }
                return list;
            }
            return values.getList();
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this list<sbyte> list, sbyte value)
        {
            return list.count() != 0 ? list.Unsafer.Array.indexOf(0, list.Count, value) : -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this list<sbyte> list, func<sbyte, bool> isValue)
        {
            return list.count() != 0 ? list.Unsafer.Array.indexOf(0, list.Count, isValue) : -1;
        }
        /// <summary>
        /// 移除数据
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="index">数据位置</param>
        /// <returns>单向动态数组</returns>
        public static list<sbyte> removeAt(this list<sbyte> list, int index)
        {
            int count = list.count();
            if ((uint)index < (uint)count)
            {
                unsafer.array.Move(list.Unsafer.Array, index + 1, index, --count - index);
                list.Unsafer.AddLength(-1);
            }
            else log.Default.Throw(log.exceptionType.IndexOutOfRange);
            return list;
        }
        /// <summary>
        /// 移除数据
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="index">数据位置</param>
        /// <returns>被移除的数据</returns>
        public static sbyte getRemoveAt(this list<sbyte> list, int index)
        {
            int count = list.count();
            if ((uint)index < (uint)count)
            {
                list<sbyte>.unsafer values = new list<sbyte>.unsafer { List = list };
                sbyte value = values.Array[index];
                unsafer.array.Move(values.Array, index + 1, index, --count - index);
                values.AddLength(-1);
                return value;
            }
            log.Default.Throw(log.exceptionType.IndexOutOfRange);
            return default(sbyte);
        }
        /// <summary>
        /// 移除第一个数据
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="value">被移除的数据</param>
        /// <returns>单向动态数组</returns>
        public static list<sbyte> removeFirst
            (this list<sbyte> list, sbyte value)
        {
            if (list != null)
            {
                int index = list.indexOf(value);
                if (index >= 0) list.removeAt(index);
            }
            return list;
        }
        /// <summary>
        /// 移除匹配值
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>单向动态数组</returns>
        public unsafe static list<sbyte> remove
            (this list<sbyte> list, func<sbyte, bool> isValue)
        {
            int count = list.count();
            if (count != 0)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                fixed (sbyte* valueFixed = list.Unsafer.Array)
                {
                    sbyte* start = valueFixed, end = valueFixed + count;
                    while (start != end && !isValue(*start)) ++start;
                    sbyte* write = start;
                    while (start != end)
                    {
                        if (!isValue(*start)) *write++ = *start;
                        ++start;
                    }
                    list.Unsafer.AddLength((int)(write - valueFixed) - count);
                }
            }
            return list;
        }
        /// <summary>
        /// 移除数据范围
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">移除数量</param>
        /// <returns>单向动态数组</returns>
        public static list<sbyte> removeRange(this list<sbyte> list, int index, int count)
        {
            int valueCount = list.count();
            if (index + count <= valueCount && index >= 0 && count >= 0 && list != null)
            {
                list.Unsafer.AddLength(-count);
                unsafer.array.Move(list.Unsafer.Array, index + count, index, list.Count - index);
            }
            else log.Default.Throw(log.exceptionType.IndexOutOfRange);
            return list;
        }
        /// <summary>
        /// 取子集合
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">子集合数据数量</param>
        /// <param name="getVlaue">数据获取器</param>
        /// <returns>子集合</returns>
        public unsafe static valueType[] getSub<valueType>
            (this list<sbyte> list, int startIndex, int count, func<sbyte, valueType> getVlaue)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            return (count = range.GetCount) != 0 ? list.Unsafer.Array.getSub(range.SkipCount, count, getVlaue) : nullValue<valueType>.Array;
        }
        /// <summary>
        /// 判断是否存在数据
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="value">匹配数据</param>
        /// <returns>是否存在数据</returns>
        public static bool contains(this list<sbyte> list, sbyte value)
        {
            return list.indexOf(value) != -1;
        }
        /// <summary>
        /// 判断是否存在匹配
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>是否存在匹配</returns>
        public static bool any(this list<sbyte> list, func<sbyte, bool> isValue)
        {
            return list.indexOf(isValue) != -1;
        }
        /// <summary>
        /// 替换第一个匹配值
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="value">新的数据值</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>单向动态数组</returns>
        public static list<sbyte> replaceFirst
            (this list<sbyte> list, sbyte value, func<sbyte, bool> isValue)
        {
            if (list != null)
            {
                int index = list.indexOf(isValue);
                if (index != -1) list.Unsafer.Array[index] = value;
            }
            return list;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配值,失败为 default(sbyte)</returns>
        public static sbyte firstOrDefault
            (this list<sbyte> list, func<sbyte, bool> isValue)
        {
            int index = list.indexOf(isValue);
            return index != -1 ? list.Unsafer.Array[index] : default(sbyte);
        }
        /// <summary>
        /// 获取匹配值集合
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配值集合</returns>
        public static list<sbyte> getFind
            (this list<sbyte> list, func<sbyte, bool> isValue)
        {
            return list.count() != 0 ? list.Unsafer.Array.getFind(0, list.Count, isValue) : null;
        }
        /// <summary>
        /// 获取匹配值集合
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配值数组</returns>
        public static sbyte[] getFindArray
            (this list<sbyte> list, func<sbyte, bool> isValue)
        {
            return list.count() != 0 ? list.Unsafer.Array.getFindArray(0, list.Count, isValue) : nullValue<sbyte>.Array;
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public static int count(this list<sbyte> list, func<sbyte, bool> isValue)
        {
            return list.count() != 0 ? list.Unsafer.Array.count(0, list.Count, isValue) : 0;
        }
        /// <summary>
        /// 清除所有数据
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <returns>单向动态数组</returns>
        public static list<sbyte> clear(this list<sbyte> list)
        {
            if (list != null) list.Unsafer.AddLength(-list.Count);
            return list;
        }
        /// <summary>
        /// 遍历foreach
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="method">调用函数</param>
        /// <returns>单向动态数组</returns>
        public static list<sbyte> each
            (this list<sbyte> list, action<sbyte> method)
        {
            if (list.count() != 0) list.Unsafer.Array.each(0, list.Count, method);
            return list;
        }
        /// <summary>
        /// 获取数据分页
        /// </summary>
        /// <typeparam name="valueType">目标数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号,从1开始</param>
        /// <param name="getValue">数据转换器</param>
        /// <returns>分页数据数组</returns>
        public static valueType[] getPage<valueType>
            (this list<sbyte> list, int pageSize, int currentPage, func<sbyte, valueType> getValue)
        {
            array.page page = new array.page(list.count(), pageSize, currentPage);
            return list.getSub(page.SkipCount, page.CurrentPageSize, getValue);
        }
        /// <summary>
        /// 转换数据集合
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getValue">数据转换器</param>
        /// <returns>数据集合</returns>
        public static sbyte[] getArray<valueType>
            (this list<valueType> list, func<valueType, sbyte> getValue)
        {
            return list.count() != 0 ? list.Unsafer.Array.getSub(0, list.Count, getValue) : nullValue<sbyte>.Array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max(this list<sbyte> list, out sbyte value)
        {
            if (list.count() != 0) return list.Unsafer.Array.max(0, list.Count, out value);
            value = sbyte.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getKey">比较值获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>
            (this list<valueType> list, func<valueType, sbyte> getKey, out sbyte value)
        {
            if (list.count() != 0) return list.Unsafer.Array.maxKey(0, list.Count, getKey, out value);
            value = sbyte.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getKey">比较值获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>(this list<valueType> list, func<valueType, sbyte> getKey, out valueType value)
        {
            if (list.count() != 0) return list.Unsafer.Array.max(0, list.Count, getKey, out value);
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static sbyte max(this list<sbyte> list, sbyte nullValue)
        {
            sbyte value;
            return max(list, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getKey">比较值获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static sbyte maxKey<valueType>
            (this list<valueType> list, func<valueType, sbyte> getKey, sbyte nullValue)
        {
            sbyte value;
            return maxKey(list, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getKey">比较值获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static valueType max<valueType>(this list<valueType> list, func<valueType, sbyte> getKey, valueType nullValue)
        {
            valueType value;
            return max(list, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min(this list<sbyte> list, out sbyte value)
        {
            if (list.count() != 0) return list.Unsafer.Array.min(0, list.Count, out value);
            value = sbyte.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getKey">比较值获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>
            (this list<valueType> list, func<valueType, sbyte> getKey, out sbyte value)
        {
            if (list.count() != 0) return list.Unsafer.Array.minKey(0, list.Count, getKey, out value);
            value = sbyte.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getKey">比较值获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>(this list<valueType> list, func<valueType, sbyte> getKey, out valueType value)
        {
            if (list.count() != 0) return list.Unsafer.Array.min(0, list.Count, getKey, out value);
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static sbyte min(this list<sbyte> list, sbyte nullValue)
        {
            sbyte value;
            return min(list, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getKey">比较值获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static sbyte minKey<valueType>
            (this list<valueType> list, func<valueType, sbyte> getKey, sbyte nullValue)
        {
            sbyte value;
            return minKey(list, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getKey">比较值获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static valueType min<valueType>(this list<valueType> list, func<valueType, sbyte> getKey, valueType nullValue)
        {
            valueType value;
            return min(list, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        public static list<valueType> distinct<valueType>
            (this list<sbyte> list, func<sbyte, valueType> getValue)
        {
            if (list.count() != 0) return list.Unsafer.Array.distinct(0, list.Count, getValue);
            return null;
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        public static list<sbyte> distinct<valueType>
            (this list<valueType> list, func<valueType, sbyte> getValue)
        {
            if (list.count() != 0) return list.Unsafer.Array.distinct(0, list.Count, getValue);
            return null;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 单向动态数组扩展
    /// </summary>
    public static partial class list
    {
        /// <summary>
        /// 添加数据集合
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="values">数据集合</param>
        /// <returns>单向动态数组</returns>
        public unsafe static list<double> add
            (this list<double> list, System.Collections.Generic.ICollection<double> values)
        {
            if (list != null)
            {
                int count = values.count();
                if (count != 0)
                {
                    int index = list.Count;
                    list.AddLength(count);
                    fixed (double* valueFixed = list.Unsafer.Array)
                    {
                        double* write = valueFixed + index;
                        foreach (double nextValue in values) *write++ = nextValue;
                    }
                }
                return list;
            }
            return values.getList();
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this list<double> list, double value)
        {
            return list.count() != 0 ? list.Unsafer.Array.indexOf(0, list.Count, value) : -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this list<double> list, func<double, bool> isValue)
        {
            return list.count() != 0 ? list.Unsafer.Array.indexOf(0, list.Count, isValue) : -1;
        }
        /// <summary>
        /// 移除数据
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="index">数据位置</param>
        /// <returns>单向动态数组</returns>
        public static list<double> removeAt(this list<double> list, int index)
        {
            int count = list.count();
            if ((uint)index < (uint)count)
            {
                unsafer.array.Move(list.Unsafer.Array, index + 1, index, --count - index);
                list.Unsafer.AddLength(-1);
            }
            else log.Default.Throw(log.exceptionType.IndexOutOfRange);
            return list;
        }
        /// <summary>
        /// 移除数据
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="index">数据位置</param>
        /// <returns>被移除的数据</returns>
        public static double getRemoveAt(this list<double> list, int index)
        {
            int count = list.count();
            if ((uint)index < (uint)count)
            {
                list<double>.unsafer values = new list<double>.unsafer { List = list };
                double value = values.Array[index];
                unsafer.array.Move(values.Array, index + 1, index, --count - index);
                values.AddLength(-1);
                return value;
            }
            log.Default.Throw(log.exceptionType.IndexOutOfRange);
            return default(double);
        }
        /// <summary>
        /// 移除第一个数据
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="value">被移除的数据</param>
        /// <returns>单向动态数组</returns>
        public static list<double> removeFirst
            (this list<double> list, double value)
        {
            if (list != null)
            {
                int index = list.indexOf(value);
                if (index >= 0) list.removeAt(index);
            }
            return list;
        }
        /// <summary>
        /// 移除匹配值
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>单向动态数组</returns>
        public unsafe static list<double> remove
            (this list<double> list, func<double, bool> isValue)
        {
            int count = list.count();
            if (count != 0)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                fixed (double* valueFixed = list.Unsafer.Array)
                {
                    double* start = valueFixed, end = valueFixed + count;
                    while (start != end && !isValue(*start)) ++start;
                    double* write = start;
                    while (start != end)
                    {
                        if (!isValue(*start)) *write++ = *start;
                        ++start;
                    }
                    list.Unsafer.AddLength((int)(write - valueFixed) - count);
                }
            }
            return list;
        }
        /// <summary>
        /// 移除数据范围
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">移除数量</param>
        /// <returns>单向动态数组</returns>
        public static list<double> removeRange(this list<double> list, int index, int count)
        {
            int valueCount = list.count();
            if (index + count <= valueCount && index >= 0 && count >= 0 && list != null)
            {
                list.Unsafer.AddLength(-count);
                unsafer.array.Move(list.Unsafer.Array, index + count, index, list.Count - index);
            }
            else log.Default.Throw(log.exceptionType.IndexOutOfRange);
            return list;
        }
        /// <summary>
        /// 取子集合
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">子集合数据数量</param>
        /// <param name="getVlaue">数据获取器</param>
        /// <returns>子集合</returns>
        public unsafe static valueType[] getSub<valueType>
            (this list<double> list, int startIndex, int count, func<double, valueType> getVlaue)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            return (count = range.GetCount) != 0 ? list.Unsafer.Array.getSub(range.SkipCount, count, getVlaue) : nullValue<valueType>.Array;
        }
        /// <summary>
        /// 判断是否存在数据
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="value">匹配数据</param>
        /// <returns>是否存在数据</returns>
        public static bool contains(this list<double> list, double value)
        {
            return list.indexOf(value) != -1;
        }
        /// <summary>
        /// 判断是否存在匹配
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>是否存在匹配</returns>
        public static bool any(this list<double> list, func<double, bool> isValue)
        {
            return list.indexOf(isValue) != -1;
        }
        /// <summary>
        /// 替换第一个匹配值
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="value">新的数据值</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>单向动态数组</returns>
        public static list<double> replaceFirst
            (this list<double> list, double value, func<double, bool> isValue)
        {
            if (list != null)
            {
                int index = list.indexOf(isValue);
                if (index != -1) list.Unsafer.Array[index] = value;
            }
            return list;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配值,失败为 default(double)</returns>
        public static double firstOrDefault
            (this list<double> list, func<double, bool> isValue)
        {
            int index = list.indexOf(isValue);
            return index != -1 ? list.Unsafer.Array[index] : default(double);
        }
        /// <summary>
        /// 获取匹配值集合
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配值集合</returns>
        public static list<double> getFind
            (this list<double> list, func<double, bool> isValue)
        {
            return list.count() != 0 ? list.Unsafer.Array.getFind(0, list.Count, isValue) : null;
        }
        /// <summary>
        /// 获取匹配值集合
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配值数组</returns>
        public static double[] getFindArray
            (this list<double> list, func<double, bool> isValue)
        {
            return list.count() != 0 ? list.Unsafer.Array.getFindArray(0, list.Count, isValue) : nullValue<double>.Array;
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public static int count(this list<double> list, func<double, bool> isValue)
        {
            return list.count() != 0 ? list.Unsafer.Array.count(0, list.Count, isValue) : 0;
        }
        /// <summary>
        /// 清除所有数据
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <returns>单向动态数组</returns>
        public static list<double> clear(this list<double> list)
        {
            if (list != null) list.Unsafer.AddLength(-list.Count);
            return list;
        }
        /// <summary>
        /// 遍历foreach
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="method">调用函数</param>
        /// <returns>单向动态数组</returns>
        public static list<double> each
            (this list<double> list, action<double> method)
        {
            if (list.count() != 0) list.Unsafer.Array.each(0, list.Count, method);
            return list;
        }
        /// <summary>
        /// 获取数据分页
        /// </summary>
        /// <typeparam name="valueType">目标数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号,从1开始</param>
        /// <param name="getValue">数据转换器</param>
        /// <returns>分页数据数组</returns>
        public static valueType[] getPage<valueType>
            (this list<double> list, int pageSize, int currentPage, func<double, valueType> getValue)
        {
            array.page page = new array.page(list.count(), pageSize, currentPage);
            return list.getSub(page.SkipCount, page.CurrentPageSize, getValue);
        }
        /// <summary>
        /// 转换数据集合
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getValue">数据转换器</param>
        /// <returns>数据集合</returns>
        public static double[] getArray<valueType>
            (this list<valueType> list, func<valueType, double> getValue)
        {
            return list.count() != 0 ? list.Unsafer.Array.getSub(0, list.Count, getValue) : nullValue<double>.Array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max(this list<double> list, out double value)
        {
            if (list.count() != 0) return list.Unsafer.Array.max(0, list.Count, out value);
            value = double.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getKey">比较值获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>
            (this list<valueType> list, func<valueType, double> getKey, out double value)
        {
            if (list.count() != 0) return list.Unsafer.Array.maxKey(0, list.Count, getKey, out value);
            value = double.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getKey">比较值获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>(this list<valueType> list, func<valueType, double> getKey, out valueType value)
        {
            if (list.count() != 0) return list.Unsafer.Array.max(0, list.Count, getKey, out value);
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static double max(this list<double> list, double nullValue)
        {
            double value;
            return max(list, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getKey">比较值获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static double maxKey<valueType>
            (this list<valueType> list, func<valueType, double> getKey, double nullValue)
        {
            double value;
            return maxKey(list, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getKey">比较值获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static valueType max<valueType>(this list<valueType> list, func<valueType, double> getKey, valueType nullValue)
        {
            valueType value;
            return max(list, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min(this list<double> list, out double value)
        {
            if (list.count() != 0) return list.Unsafer.Array.min(0, list.Count, out value);
            value = double.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getKey">比较值获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>
            (this list<valueType> list, func<valueType, double> getKey, out double value)
        {
            if (list.count() != 0) return list.Unsafer.Array.minKey(0, list.Count, getKey, out value);
            value = double.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getKey">比较值获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>(this list<valueType> list, func<valueType, double> getKey, out valueType value)
        {
            if (list.count() != 0) return list.Unsafer.Array.min(0, list.Count, getKey, out value);
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static double min(this list<double> list, double nullValue)
        {
            double value;
            return min(list, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getKey">比较值获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static double minKey<valueType>
            (this list<valueType> list, func<valueType, double> getKey, double nullValue)
        {
            double value;
            return minKey(list, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getKey">比较值获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static valueType min<valueType>(this list<valueType> list, func<valueType, double> getKey, valueType nullValue)
        {
            valueType value;
            return min(list, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        public static list<valueType> distinct<valueType>
            (this list<double> list, func<double, valueType> getValue)
        {
            if (list.count() != 0) return list.Unsafer.Array.distinct(0, list.Count, getValue);
            return null;
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        public static list<double> distinct<valueType>
            (this list<valueType> list, func<valueType, double> getValue)
        {
            if (list.count() != 0) return list.Unsafer.Array.distinct(0, list.Count, getValue);
            return null;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 单向动态数组扩展
    /// </summary>
    public static partial class list
    {
        /// <summary>
        /// 添加数据集合
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="values">数据集合</param>
        /// <returns>单向动态数组</returns>
        public unsafe static list<float> add
            (this list<float> list, System.Collections.Generic.ICollection<float> values)
        {
            if (list != null)
            {
                int count = values.count();
                if (count != 0)
                {
                    int index = list.Count;
                    list.AddLength(count);
                    fixed (float* valueFixed = list.Unsafer.Array)
                    {
                        float* write = valueFixed + index;
                        foreach (float nextValue in values) *write++ = nextValue;
                    }
                }
                return list;
            }
            return values.getList();
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this list<float> list, float value)
        {
            return list.count() != 0 ? list.Unsafer.Array.indexOf(0, list.Count, value) : -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this list<float> list, func<float, bool> isValue)
        {
            return list.count() != 0 ? list.Unsafer.Array.indexOf(0, list.Count, isValue) : -1;
        }
        /// <summary>
        /// 移除数据
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="index">数据位置</param>
        /// <returns>单向动态数组</returns>
        public static list<float> removeAt(this list<float> list, int index)
        {
            int count = list.count();
            if ((uint)index < (uint)count)
            {
                unsafer.array.Move(list.Unsafer.Array, index + 1, index, --count - index);
                list.Unsafer.AddLength(-1);
            }
            else log.Default.Throw(log.exceptionType.IndexOutOfRange);
            return list;
        }
        /// <summary>
        /// 移除数据
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="index">数据位置</param>
        /// <returns>被移除的数据</returns>
        public static float getRemoveAt(this list<float> list, int index)
        {
            int count = list.count();
            if ((uint)index < (uint)count)
            {
                list<float>.unsafer values = new list<float>.unsafer { List = list };
                float value = values.Array[index];
                unsafer.array.Move(values.Array, index + 1, index, --count - index);
                values.AddLength(-1);
                return value;
            }
            log.Default.Throw(log.exceptionType.IndexOutOfRange);
            return default(float);
        }
        /// <summary>
        /// 移除第一个数据
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="value">被移除的数据</param>
        /// <returns>单向动态数组</returns>
        public static list<float> removeFirst
            (this list<float> list, float value)
        {
            if (list != null)
            {
                int index = list.indexOf(value);
                if (index >= 0) list.removeAt(index);
            }
            return list;
        }
        /// <summary>
        /// 移除匹配值
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>单向动态数组</returns>
        public unsafe static list<float> remove
            (this list<float> list, func<float, bool> isValue)
        {
            int count = list.count();
            if (count != 0)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                fixed (float* valueFixed = list.Unsafer.Array)
                {
                    float* start = valueFixed, end = valueFixed + count;
                    while (start != end && !isValue(*start)) ++start;
                    float* write = start;
                    while (start != end)
                    {
                        if (!isValue(*start)) *write++ = *start;
                        ++start;
                    }
                    list.Unsafer.AddLength((int)(write - valueFixed) - count);
                }
            }
            return list;
        }
        /// <summary>
        /// 移除数据范围
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">移除数量</param>
        /// <returns>单向动态数组</returns>
        public static list<float> removeRange(this list<float> list, int index, int count)
        {
            int valueCount = list.count();
            if (index + count <= valueCount && index >= 0 && count >= 0 && list != null)
            {
                list.Unsafer.AddLength(-count);
                unsafer.array.Move(list.Unsafer.Array, index + count, index, list.Count - index);
            }
            else log.Default.Throw(log.exceptionType.IndexOutOfRange);
            return list;
        }
        /// <summary>
        /// 取子集合
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">子集合数据数量</param>
        /// <param name="getVlaue">数据获取器</param>
        /// <returns>子集合</returns>
        public unsafe static valueType[] getSub<valueType>
            (this list<float> list, int startIndex, int count, func<float, valueType> getVlaue)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            return (count = range.GetCount) != 0 ? list.Unsafer.Array.getSub(range.SkipCount, count, getVlaue) : nullValue<valueType>.Array;
        }
        /// <summary>
        /// 判断是否存在数据
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="value">匹配数据</param>
        /// <returns>是否存在数据</returns>
        public static bool contains(this list<float> list, float value)
        {
            return list.indexOf(value) != -1;
        }
        /// <summary>
        /// 判断是否存在匹配
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>是否存在匹配</returns>
        public static bool any(this list<float> list, func<float, bool> isValue)
        {
            return list.indexOf(isValue) != -1;
        }
        /// <summary>
        /// 替换第一个匹配值
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="value">新的数据值</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>单向动态数组</returns>
        public static list<float> replaceFirst
            (this list<float> list, float value, func<float, bool> isValue)
        {
            if (list != null)
            {
                int index = list.indexOf(isValue);
                if (index != -1) list.Unsafer.Array[index] = value;
            }
            return list;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配值,失败为 default(float)</returns>
        public static float firstOrDefault
            (this list<float> list, func<float, bool> isValue)
        {
            int index = list.indexOf(isValue);
            return index != -1 ? list.Unsafer.Array[index] : default(float);
        }
        /// <summary>
        /// 获取匹配值集合
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配值集合</returns>
        public static list<float> getFind
            (this list<float> list, func<float, bool> isValue)
        {
            return list.count() != 0 ? list.Unsafer.Array.getFind(0, list.Count, isValue) : null;
        }
        /// <summary>
        /// 获取匹配值集合
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配值数组</returns>
        public static float[] getFindArray
            (this list<float> list, func<float, bool> isValue)
        {
            return list.count() != 0 ? list.Unsafer.Array.getFindArray(0, list.Count, isValue) : nullValue<float>.Array;
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public static int count(this list<float> list, func<float, bool> isValue)
        {
            return list.count() != 0 ? list.Unsafer.Array.count(0, list.Count, isValue) : 0;
        }
        /// <summary>
        /// 清除所有数据
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <returns>单向动态数组</returns>
        public static list<float> clear(this list<float> list)
        {
            if (list != null) list.Unsafer.AddLength(-list.Count);
            return list;
        }
        /// <summary>
        /// 遍历foreach
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="method">调用函数</param>
        /// <returns>单向动态数组</returns>
        public static list<float> each
            (this list<float> list, action<float> method)
        {
            if (list.count() != 0) list.Unsafer.Array.each(0, list.Count, method);
            return list;
        }
        /// <summary>
        /// 获取数据分页
        /// </summary>
        /// <typeparam name="valueType">目标数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号,从1开始</param>
        /// <param name="getValue">数据转换器</param>
        /// <returns>分页数据数组</returns>
        public static valueType[] getPage<valueType>
            (this list<float> list, int pageSize, int currentPage, func<float, valueType> getValue)
        {
            array.page page = new array.page(list.count(), pageSize, currentPage);
            return list.getSub(page.SkipCount, page.CurrentPageSize, getValue);
        }
        /// <summary>
        /// 转换数据集合
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getValue">数据转换器</param>
        /// <returns>数据集合</returns>
        public static float[] getArray<valueType>
            (this list<valueType> list, func<valueType, float> getValue)
        {
            return list.count() != 0 ? list.Unsafer.Array.getSub(0, list.Count, getValue) : nullValue<float>.Array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max(this list<float> list, out float value)
        {
            if (list.count() != 0) return list.Unsafer.Array.max(0, list.Count, out value);
            value = float.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getKey">比较值获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>
            (this list<valueType> list, func<valueType, float> getKey, out float value)
        {
            if (list.count() != 0) return list.Unsafer.Array.maxKey(0, list.Count, getKey, out value);
            value = float.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getKey">比较值获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>(this list<valueType> list, func<valueType, float> getKey, out valueType value)
        {
            if (list.count() != 0) return list.Unsafer.Array.max(0, list.Count, getKey, out value);
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static float max(this list<float> list, float nullValue)
        {
            float value;
            return max(list, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getKey">比较值获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static float maxKey<valueType>
            (this list<valueType> list, func<valueType, float> getKey, float nullValue)
        {
            float value;
            return maxKey(list, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getKey">比较值获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static valueType max<valueType>(this list<valueType> list, func<valueType, float> getKey, valueType nullValue)
        {
            valueType value;
            return max(list, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min(this list<float> list, out float value)
        {
            if (list.count() != 0) return list.Unsafer.Array.min(0, list.Count, out value);
            value = float.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getKey">比较值获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>
            (this list<valueType> list, func<valueType, float> getKey, out float value)
        {
            if (list.count() != 0) return list.Unsafer.Array.minKey(0, list.Count, getKey, out value);
            value = float.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getKey">比较值获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>(this list<valueType> list, func<valueType, float> getKey, out valueType value)
        {
            if (list.count() != 0) return list.Unsafer.Array.min(0, list.Count, getKey, out value);
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static float min(this list<float> list, float nullValue)
        {
            float value;
            return min(list, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getKey">比较值获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static float minKey<valueType>
            (this list<valueType> list, func<valueType, float> getKey, float nullValue)
        {
            float value;
            return minKey(list, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getKey">比较值获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static valueType min<valueType>(this list<valueType> list, func<valueType, float> getKey, valueType nullValue)
        {
            valueType value;
            return min(list, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        public static list<valueType> distinct<valueType>
            (this list<float> list, func<float, valueType> getValue)
        {
            if (list.count() != 0) return list.Unsafer.Array.distinct(0, list.Count, getValue);
            return null;
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        public static list<float> distinct<valueType>
            (this list<valueType> list, func<valueType, float> getValue)
        {
            if (list.count() != 0) return list.Unsafer.Array.distinct(0, list.Count, getValue);
            return null;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 单向动态数组扩展
    /// </summary>
    public static partial class list
    {
        /// <summary>
        /// 添加数据集合
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="values">数据集合</param>
        /// <returns>单向动态数组</returns>
        public unsafe static list<DateTime> add
            (this list<DateTime> list, System.Collections.Generic.ICollection<DateTime> values)
        {
            if (list != null)
            {
                int count = values.count();
                if (count != 0)
                {
                    int index = list.Count;
                    list.AddLength(count);
                    fixed (DateTime* valueFixed = list.Unsafer.Array)
                    {
                        DateTime* write = valueFixed + index;
                        foreach (DateTime nextValue in values) *write++ = nextValue;
                    }
                }
                return list;
            }
            return values.getList();
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this list<DateTime> list, DateTime value)
        {
            return list.count() != 0 ? list.Unsafer.Array.indexOf(0, list.Count, value) : -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this list<DateTime> list, func<DateTime, bool> isValue)
        {
            return list.count() != 0 ? list.Unsafer.Array.indexOf(0, list.Count, isValue) : -1;
        }
        /// <summary>
        /// 移除数据
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="index">数据位置</param>
        /// <returns>单向动态数组</returns>
        public static list<DateTime> removeAt(this list<DateTime> list, int index)
        {
            int count = list.count();
            if ((uint)index < (uint)count)
            {
                unsafer.array.Move(list.Unsafer.Array, index + 1, index, --count - index);
                list.Unsafer.AddLength(-1);
            }
            else log.Default.Throw(log.exceptionType.IndexOutOfRange);
            return list;
        }
        /// <summary>
        /// 移除数据
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="index">数据位置</param>
        /// <returns>被移除的数据</returns>
        public static DateTime getRemoveAt(this list<DateTime> list, int index)
        {
            int count = list.count();
            if ((uint)index < (uint)count)
            {
                list<DateTime>.unsafer values = new list<DateTime>.unsafer { List = list };
                DateTime value = values.Array[index];
                unsafer.array.Move(values.Array, index + 1, index, --count - index);
                values.AddLength(-1);
                return value;
            }
            log.Default.Throw(log.exceptionType.IndexOutOfRange);
            return default(DateTime);
        }
        /// <summary>
        /// 移除第一个数据
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="value">被移除的数据</param>
        /// <returns>单向动态数组</returns>
        public static list<DateTime> removeFirst
            (this list<DateTime> list, DateTime value)
        {
            if (list != null)
            {
                int index = list.indexOf(value);
                if (index >= 0) list.removeAt(index);
            }
            return list;
        }
        /// <summary>
        /// 移除匹配值
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>单向动态数组</returns>
        public unsafe static list<DateTime> remove
            (this list<DateTime> list, func<DateTime, bool> isValue)
        {
            int count = list.count();
            if (count != 0)
            {
                if (isValue == null) log.Default.Throw(log.exceptionType.Null);
                fixed (DateTime* valueFixed = list.Unsafer.Array)
                {
                    DateTime* start = valueFixed, end = valueFixed + count;
                    while (start != end && !isValue(*start)) ++start;
                    DateTime* write = start;
                    while (start != end)
                    {
                        if (!isValue(*start)) *write++ = *start;
                        ++start;
                    }
                    list.Unsafer.AddLength((int)(write - valueFixed) - count);
                }
            }
            return list;
        }
        /// <summary>
        /// 移除数据范围
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">移除数量</param>
        /// <returns>单向动态数组</returns>
        public static list<DateTime> removeRange(this list<DateTime> list, int index, int count)
        {
            int valueCount = list.count();
            if (index + count <= valueCount && index >= 0 && count >= 0 && list != null)
            {
                list.Unsafer.AddLength(-count);
                unsafer.array.Move(list.Unsafer.Array, index + count, index, list.Count - index);
            }
            else log.Default.Throw(log.exceptionType.IndexOutOfRange);
            return list;
        }
        /// <summary>
        /// 取子集合
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">子集合数据数量</param>
        /// <param name="getVlaue">数据获取器</param>
        /// <returns>子集合</returns>
        public unsafe static valueType[] getSub<valueType>
            (this list<DateTime> list, int startIndex, int count, func<DateTime, valueType> getVlaue)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            return (count = range.GetCount) != 0 ? list.Unsafer.Array.getSub(range.SkipCount, count, getVlaue) : nullValue<valueType>.Array;
        }
        /// <summary>
        /// 判断是否存在数据
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="value">匹配数据</param>
        /// <returns>是否存在数据</returns>
        public static bool contains(this list<DateTime> list, DateTime value)
        {
            return list.indexOf(value) != -1;
        }
        /// <summary>
        /// 判断是否存在匹配
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>是否存在匹配</returns>
        public static bool any(this list<DateTime> list, func<DateTime, bool> isValue)
        {
            return list.indexOf(isValue) != -1;
        }
        /// <summary>
        /// 替换第一个匹配值
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="value">新的数据值</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>单向动态数组</returns>
        public static list<DateTime> replaceFirst
            (this list<DateTime> list, DateTime value, func<DateTime, bool> isValue)
        {
            if (list != null)
            {
                int index = list.indexOf(isValue);
                if (index != -1) list.Unsafer.Array[index] = value;
            }
            return list;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配值,失败为 default(DateTime)</returns>
        public static DateTime firstOrDefault
            (this list<DateTime> list, func<DateTime, bool> isValue)
        {
            int index = list.indexOf(isValue);
            return index != -1 ? list.Unsafer.Array[index] : default(DateTime);
        }
        /// <summary>
        /// 获取匹配值集合
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配值集合</returns>
        public static list<DateTime> getFind
            (this list<DateTime> list, func<DateTime, bool> isValue)
        {
            return list.count() != 0 ? list.Unsafer.Array.getFind(0, list.Count, isValue) : null;
        }
        /// <summary>
        /// 获取匹配值集合
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配值数组</returns>
        public static DateTime[] getFindArray
            (this list<DateTime> list, func<DateTime, bool> isValue)
        {
            return list.count() != 0 ? list.Unsafer.Array.getFindArray(0, list.Count, isValue) : nullValue<DateTime>.Array;
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public static int count(this list<DateTime> list, func<DateTime, bool> isValue)
        {
            return list.count() != 0 ? list.Unsafer.Array.count(0, list.Count, isValue) : 0;
        }
        /// <summary>
        /// 清除所有数据
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <returns>单向动态数组</returns>
        public static list<DateTime> clear(this list<DateTime> list)
        {
            if (list != null) list.Unsafer.AddLength(-list.Count);
            return list;
        }
        /// <summary>
        /// 遍历foreach
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="method">调用函数</param>
        /// <returns>单向动态数组</returns>
        public static list<DateTime> each
            (this list<DateTime> list, action<DateTime> method)
        {
            if (list.count() != 0) list.Unsafer.Array.each(0, list.Count, method);
            return list;
        }
        /// <summary>
        /// 获取数据分页
        /// </summary>
        /// <typeparam name="valueType">目标数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号,从1开始</param>
        /// <param name="getValue">数据转换器</param>
        /// <returns>分页数据数组</returns>
        public static valueType[] getPage<valueType>
            (this list<DateTime> list, int pageSize, int currentPage, func<DateTime, valueType> getValue)
        {
            array.page page = new array.page(list.count(), pageSize, currentPage);
            return list.getSub(page.SkipCount, page.CurrentPageSize, getValue);
        }
        /// <summary>
        /// 转换数据集合
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getValue">数据转换器</param>
        /// <returns>数据集合</returns>
        public static DateTime[] getArray<valueType>
            (this list<valueType> list, func<valueType, DateTime> getValue)
        {
            return list.count() != 0 ? list.Unsafer.Array.getSub(0, list.Count, getValue) : nullValue<DateTime>.Array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max(this list<DateTime> list, out DateTime value)
        {
            if (list.count() != 0) return list.Unsafer.Array.max(0, list.Count, out value);
            value = DateTime.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getKey">比较值获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>
            (this list<valueType> list, func<valueType, DateTime> getKey, out DateTime value)
        {
            if (list.count() != 0) return list.Unsafer.Array.maxKey(0, list.Count, getKey, out value);
            value = DateTime.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getKey">比较值获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>(this list<valueType> list, func<valueType, DateTime> getKey, out valueType value)
        {
            if (list.count() != 0) return list.Unsafer.Array.max(0, list.Count, getKey, out value);
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static DateTime max(this list<DateTime> list, DateTime nullValue)
        {
            DateTime value;
            return max(list, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getKey">比较值获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static DateTime maxKey<valueType>
            (this list<valueType> list, func<valueType, DateTime> getKey, DateTime nullValue)
        {
            DateTime value;
            return maxKey(list, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getKey">比较值获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static valueType max<valueType>(this list<valueType> list, func<valueType, DateTime> getKey, valueType nullValue)
        {
            valueType value;
            return max(list, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min(this list<DateTime> list, out DateTime value)
        {
            if (list.count() != 0) return list.Unsafer.Array.min(0, list.Count, out value);
            value = DateTime.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getKey">比较值获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>
            (this list<valueType> list, func<valueType, DateTime> getKey, out DateTime value)
        {
            if (list.count() != 0) return list.Unsafer.Array.minKey(0, list.Count, getKey, out value);
            value = DateTime.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getKey">比较值获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>(this list<valueType> list, func<valueType, DateTime> getKey, out valueType value)
        {
            if (list.count() != 0) return list.Unsafer.Array.min(0, list.Count, getKey, out value);
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="list">单向动态数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static DateTime min(this list<DateTime> list, DateTime nullValue)
        {
            DateTime value;
            return min(list, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getKey">比较值获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static DateTime minKey<valueType>
            (this list<valueType> list, func<valueType, DateTime> getKey, DateTime nullValue)
        {
            DateTime value;
            return minKey(list, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getKey">比较值获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static valueType min<valueType>(this list<valueType> list, func<valueType, DateTime> getKey, valueType nullValue)
        {
            valueType value;
            return min(list, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        public static list<valueType> distinct<valueType>
            (this list<DateTime> list, func<DateTime, valueType> getValue)
        {
            if (list.count() != 0) return list.Unsafer.Array.distinct(0, list.Count, getValue);
            return null;
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">单向动态数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        public static list<DateTime> distinct<valueType>
            (this list<valueType> list, func<valueType, DateTime> getValue)
        {
            if (list.count() != 0) return list.Unsafer.Array.distinct(0, list.Count, getValue);
            return null;
        }
    }
}

namespace fastCSharp.unsafer
{
    /// <summary>
    /// 数组扩展操作(非安全,请自行确保数据可靠性)
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 归并排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="left">左侧数组</param>
        /// <param name="right">右侧数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <returns>归并排序结果</returns>
        public static valueType[] GetMergeSortDesc<valueType>(valueType[] left, valueType[] right, func<valueType, ulong> getKey)
        {
            int leftLength = left.length();
            if (leftLength == 0) return right.copy();
            int rightLenght = right.length();
            if (rightLenght == 0) return left.copy();
            int newIndex = 0, cmpIndex = 1;
            valueType[] newValues = new valueType[leftLength + rightLenght];
            if (getKey(left[leftLength - 1]) >= getKey(right[rightLenght - 1]))
            {
                valueType cmpValue = right[0];
                ulong cmpKey = getKey(cmpValue);
                foreach (valueType value in left)
                {
                    ulong key = getKey(value);
                    while (cmpKey > key)
                    {
                        newValues[newIndex++] = cmpValue;
                        cmpKey = getKey(cmpValue = right[cmpIndex++]);
                    }
                    newValues[newIndex++] = value;
                }
                newValues[newIndex++] = cmpValue;
                Array.Copy(right, cmpIndex, newValues, newIndex, newValues.Length - newIndex);
            }
            else
            {
                valueType cmpValue = left[0];
                ulong cmpKey = getKey(cmpValue);
                foreach (valueType value in right)
                {
                    ulong key = getKey(value);
                    while (cmpKey >= key)
                    {
                        newValues[newIndex++] = cmpValue;
                        cmpKey = getKey(cmpValue = left[cmpIndex++]);
                    }
                    newValues[newIndex++] = value;
                }
                newValues[newIndex++] = cmpValue;
                Array.Copy(left, cmpIndex, newValues, newIndex, newValues.Length - newIndex);
            }
            return newValues;
        }
    }
}

namespace fastCSharp.unsafer
{
    /// <summary>
    /// 数组扩展操作(非安全,请自行确保数据可靠性)
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 归并排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="left">左侧数组</param>
        /// <param name="right">右侧数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <returns>归并排序结果</returns>
        public static valueType[] GetMergeSort<valueType>(valueType[] left, valueType[] right, func<valueType, long> getKey)
        {
            int leftLength = left.length();
            if (leftLength == 0) return right.copy();
            int rightLenght = right.length();
            if (rightLenght == 0) return left.copy();
            int newIndex = 0, cmpIndex = 1;
            valueType[] newValues = new valueType[leftLength + rightLenght];
            if (getKey(left[leftLength - 1]) <= getKey(right[rightLenght - 1]))
            {
                valueType cmpValue = right[0];
                long cmpKey = getKey(cmpValue);
                foreach (valueType value in left)
                {
                    long key = getKey(value);
                    while (cmpKey < key)
                    {
                        newValues[newIndex++] = cmpValue;
                        cmpKey = getKey(cmpValue = right[cmpIndex++]);
                    }
                    newValues[newIndex++] = value;
                }
                newValues[newIndex++] = cmpValue;
                Array.Copy(right, cmpIndex, newValues, newIndex, newValues.Length - newIndex);
            }
            else
            {
                valueType cmpValue = left[0];
                long cmpKey = getKey(cmpValue);
                foreach (valueType value in right)
                {
                    long key = getKey(value);
                    while (cmpKey <= key)
                    {
                        newValues[newIndex++] = cmpValue;
                        cmpKey = getKey(cmpValue = left[cmpIndex++]);
                    }
                    newValues[newIndex++] = value;
                }
                newValues[newIndex++] = cmpValue;
                Array.Copy(left, cmpIndex, newValues, newIndex, newValues.Length - newIndex);
            }
            return newValues;
        }
    }
}

namespace fastCSharp.unsafer
{
    /// <summary>
    /// 数组扩展操作(非安全,请自行确保数据可靠性)
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 归并排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="left">左侧数组</param>
        /// <param name="right">右侧数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <returns>归并排序结果</returns>
        public static valueType[] GetMergeSortDesc<valueType>(valueType[] left, valueType[] right, func<valueType, long> getKey)
        {
            int leftLength = left.length();
            if (leftLength == 0) return right.copy();
            int rightLenght = right.length();
            if (rightLenght == 0) return left.copy();
            int newIndex = 0, cmpIndex = 1;
            valueType[] newValues = new valueType[leftLength + rightLenght];
            if (getKey(left[leftLength - 1]) >= getKey(right[rightLenght - 1]))
            {
                valueType cmpValue = right[0];
                long cmpKey = getKey(cmpValue);
                foreach (valueType value in left)
                {
                    long key = getKey(value);
                    while (cmpKey > key)
                    {
                        newValues[newIndex++] = cmpValue;
                        cmpKey = getKey(cmpValue = right[cmpIndex++]);
                    }
                    newValues[newIndex++] = value;
                }
                newValues[newIndex++] = cmpValue;
                Array.Copy(right, cmpIndex, newValues, newIndex, newValues.Length - newIndex);
            }
            else
            {
                valueType cmpValue = left[0];
                long cmpKey = getKey(cmpValue);
                foreach (valueType value in right)
                {
                    long key = getKey(value);
                    while (cmpKey >= key)
                    {
                        newValues[newIndex++] = cmpValue;
                        cmpKey = getKey(cmpValue = left[cmpIndex++]);
                    }
                    newValues[newIndex++] = value;
                }
                newValues[newIndex++] = cmpValue;
                Array.Copy(left, cmpIndex, newValues, newIndex, newValues.Length - newIndex);
            }
            return newValues;
        }
    }
}

namespace fastCSharp.unsafer
{
    /// <summary>
    /// 数组扩展操作(非安全,请自行确保数据可靠性)
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 归并排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="left">左侧数组</param>
        /// <param name="right">右侧数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <returns>归并排序结果</returns>
        public static valueType[] GetMergeSort<valueType>(valueType[] left, valueType[] right, func<valueType, uint> getKey)
        {
            int leftLength = left.length();
            if (leftLength == 0) return right.copy();
            int rightLenght = right.length();
            if (rightLenght == 0) return left.copy();
            int newIndex = 0, cmpIndex = 1;
            valueType[] newValues = new valueType[leftLength + rightLenght];
            if (getKey(left[leftLength - 1]) <= getKey(right[rightLenght - 1]))
            {
                valueType cmpValue = right[0];
                uint cmpKey = getKey(cmpValue);
                foreach (valueType value in left)
                {
                    uint key = getKey(value);
                    while (cmpKey < key)
                    {
                        newValues[newIndex++] = cmpValue;
                        cmpKey = getKey(cmpValue = right[cmpIndex++]);
                    }
                    newValues[newIndex++] = value;
                }
                newValues[newIndex++] = cmpValue;
                Array.Copy(right, cmpIndex, newValues, newIndex, newValues.Length - newIndex);
            }
            else
            {
                valueType cmpValue = left[0];
                uint cmpKey = getKey(cmpValue);
                foreach (valueType value in right)
                {
                    uint key = getKey(value);
                    while (cmpKey <= key)
                    {
                        newValues[newIndex++] = cmpValue;
                        cmpKey = getKey(cmpValue = left[cmpIndex++]);
                    }
                    newValues[newIndex++] = value;
                }
                newValues[newIndex++] = cmpValue;
                Array.Copy(left, cmpIndex, newValues, newIndex, newValues.Length - newIndex);
            }
            return newValues;
        }
    }
}

namespace fastCSharp.unsafer
{
    /// <summary>
    /// 数组扩展操作(非安全,请自行确保数据可靠性)
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 归并排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="left">左侧数组</param>
        /// <param name="right">右侧数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <returns>归并排序结果</returns>
        public static valueType[] GetMergeSortDesc<valueType>(valueType[] left, valueType[] right, func<valueType, uint> getKey)
        {
            int leftLength = left.length();
            if (leftLength == 0) return right.copy();
            int rightLenght = right.length();
            if (rightLenght == 0) return left.copy();
            int newIndex = 0, cmpIndex = 1;
            valueType[] newValues = new valueType[leftLength + rightLenght];
            if (getKey(left[leftLength - 1]) >= getKey(right[rightLenght - 1]))
            {
                valueType cmpValue = right[0];
                uint cmpKey = getKey(cmpValue);
                foreach (valueType value in left)
                {
                    uint key = getKey(value);
                    while (cmpKey > key)
                    {
                        newValues[newIndex++] = cmpValue;
                        cmpKey = getKey(cmpValue = right[cmpIndex++]);
                    }
                    newValues[newIndex++] = value;
                }
                newValues[newIndex++] = cmpValue;
                Array.Copy(right, cmpIndex, newValues, newIndex, newValues.Length - newIndex);
            }
            else
            {
                valueType cmpValue = left[0];
                uint cmpKey = getKey(cmpValue);
                foreach (valueType value in right)
                {
                    uint key = getKey(value);
                    while (cmpKey >= key)
                    {
                        newValues[newIndex++] = cmpValue;
                        cmpKey = getKey(cmpValue = left[cmpIndex++]);
                    }
                    newValues[newIndex++] = value;
                }
                newValues[newIndex++] = cmpValue;
                Array.Copy(left, cmpIndex, newValues, newIndex, newValues.Length - newIndex);
            }
            return newValues;
        }
    }
}

namespace fastCSharp.unsafer
{
    /// <summary>
    /// 数组扩展操作(非安全,请自行确保数据可靠性)
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 归并排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="left">左侧数组</param>
        /// <param name="right">右侧数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <returns>归并排序结果</returns>
        public static valueType[] GetMergeSort<valueType>(valueType[] left, valueType[] right, func<valueType, int> getKey)
        {
            int leftLength = left.length();
            if (leftLength == 0) return right.copy();
            int rightLenght = right.length();
            if (rightLenght == 0) return left.copy();
            int newIndex = 0, cmpIndex = 1;
            valueType[] newValues = new valueType[leftLength + rightLenght];
            if (getKey(left[leftLength - 1]) <= getKey(right[rightLenght - 1]))
            {
                valueType cmpValue = right[0];
                int cmpKey = getKey(cmpValue);
                foreach (valueType value in left)
                {
                    int key = getKey(value);
                    while (cmpKey < key)
                    {
                        newValues[newIndex++] = cmpValue;
                        cmpKey = getKey(cmpValue = right[cmpIndex++]);
                    }
                    newValues[newIndex++] = value;
                }
                newValues[newIndex++] = cmpValue;
                Array.Copy(right, cmpIndex, newValues, newIndex, newValues.Length - newIndex);
            }
            else
            {
                valueType cmpValue = left[0];
                int cmpKey = getKey(cmpValue);
                foreach (valueType value in right)
                {
                    int key = getKey(value);
                    while (cmpKey <= key)
                    {
                        newValues[newIndex++] = cmpValue;
                        cmpKey = getKey(cmpValue = left[cmpIndex++]);
                    }
                    newValues[newIndex++] = value;
                }
                newValues[newIndex++] = cmpValue;
                Array.Copy(left, cmpIndex, newValues, newIndex, newValues.Length - newIndex);
            }
            return newValues;
        }
    }
}

namespace fastCSharp.unsafer
{
    /// <summary>
    /// 数组扩展操作(非安全,请自行确保数据可靠性)
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 归并排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="left">左侧数组</param>
        /// <param name="right">右侧数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <returns>归并排序结果</returns>
        public static valueType[] GetMergeSortDesc<valueType>(valueType[] left, valueType[] right, func<valueType, int> getKey)
        {
            int leftLength = left.length();
            if (leftLength == 0) return right.copy();
            int rightLenght = right.length();
            if (rightLenght == 0) return left.copy();
            int newIndex = 0, cmpIndex = 1;
            valueType[] newValues = new valueType[leftLength + rightLenght];
            if (getKey(left[leftLength - 1]) >= getKey(right[rightLenght - 1]))
            {
                valueType cmpValue = right[0];
                int cmpKey = getKey(cmpValue);
                foreach (valueType value in left)
                {
                    int key = getKey(value);
                    while (cmpKey > key)
                    {
                        newValues[newIndex++] = cmpValue;
                        cmpKey = getKey(cmpValue = right[cmpIndex++]);
                    }
                    newValues[newIndex++] = value;
                }
                newValues[newIndex++] = cmpValue;
                Array.Copy(right, cmpIndex, newValues, newIndex, newValues.Length - newIndex);
            }
            else
            {
                valueType cmpValue = left[0];
                int cmpKey = getKey(cmpValue);
                foreach (valueType value in right)
                {
                    int key = getKey(value);
                    while (cmpKey >= key)
                    {
                        newValues[newIndex++] = cmpValue;
                        cmpKey = getKey(cmpValue = left[cmpIndex++]);
                    }
                    newValues[newIndex++] = value;
                }
                newValues[newIndex++] = cmpValue;
                Array.Copy(left, cmpIndex, newValues, newIndex, newValues.Length - newIndex);
            }
            return newValues;
        }
    }
}

namespace fastCSharp.unsafer
{
    /// <summary>
    /// 数组扩展操作(非安全,请自行确保数据可靠性)
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 归并排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="left">左侧数组</param>
        /// <param name="right">右侧数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <returns>归并排序结果</returns>
        public static valueType[] GetMergeSort<valueType>(valueType[] left, valueType[] right, func<valueType, ushort> getKey)
        {
            int leftLength = left.length();
            if (leftLength == 0) return right.copy();
            int rightLenght = right.length();
            if (rightLenght == 0) return left.copy();
            int newIndex = 0, cmpIndex = 1;
            valueType[] newValues = new valueType[leftLength + rightLenght];
            if (getKey(left[leftLength - 1]) <= getKey(right[rightLenght - 1]))
            {
                valueType cmpValue = right[0];
                ushort cmpKey = getKey(cmpValue);
                foreach (valueType value in left)
                {
                    ushort key = getKey(value);
                    while (cmpKey < key)
                    {
                        newValues[newIndex++] = cmpValue;
                        cmpKey = getKey(cmpValue = right[cmpIndex++]);
                    }
                    newValues[newIndex++] = value;
                }
                newValues[newIndex++] = cmpValue;
                Array.Copy(right, cmpIndex, newValues, newIndex, newValues.Length - newIndex);
            }
            else
            {
                valueType cmpValue = left[0];
                ushort cmpKey = getKey(cmpValue);
                foreach (valueType value in right)
                {
                    ushort key = getKey(value);
                    while (cmpKey <= key)
                    {
                        newValues[newIndex++] = cmpValue;
                        cmpKey = getKey(cmpValue = left[cmpIndex++]);
                    }
                    newValues[newIndex++] = value;
                }
                newValues[newIndex++] = cmpValue;
                Array.Copy(left, cmpIndex, newValues, newIndex, newValues.Length - newIndex);
            }
            return newValues;
        }
    }
}

namespace fastCSharp.unsafer
{
    /// <summary>
    /// 数组扩展操作(非安全,请自行确保数据可靠性)
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 归并排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="left">左侧数组</param>
        /// <param name="right">右侧数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <returns>归并排序结果</returns>
        public static valueType[] GetMergeSortDesc<valueType>(valueType[] left, valueType[] right, func<valueType, ushort> getKey)
        {
            int leftLength = left.length();
            if (leftLength == 0) return right.copy();
            int rightLenght = right.length();
            if (rightLenght == 0) return left.copy();
            int newIndex = 0, cmpIndex = 1;
            valueType[] newValues = new valueType[leftLength + rightLenght];
            if (getKey(left[leftLength - 1]) >= getKey(right[rightLenght - 1]))
            {
                valueType cmpValue = right[0];
                ushort cmpKey = getKey(cmpValue);
                foreach (valueType value in left)
                {
                    ushort key = getKey(value);
                    while (cmpKey > key)
                    {
                        newValues[newIndex++] = cmpValue;
                        cmpKey = getKey(cmpValue = right[cmpIndex++]);
                    }
                    newValues[newIndex++] = value;
                }
                newValues[newIndex++] = cmpValue;
                Array.Copy(right, cmpIndex, newValues, newIndex, newValues.Length - newIndex);
            }
            else
            {
                valueType cmpValue = left[0];
                ushort cmpKey = getKey(cmpValue);
                foreach (valueType value in right)
                {
                    ushort key = getKey(value);
                    while (cmpKey >= key)
                    {
                        newValues[newIndex++] = cmpValue;
                        cmpKey = getKey(cmpValue = left[cmpIndex++]);
                    }
                    newValues[newIndex++] = value;
                }
                newValues[newIndex++] = cmpValue;
                Array.Copy(left, cmpIndex, newValues, newIndex, newValues.Length - newIndex);
            }
            return newValues;
        }
    }
}

namespace fastCSharp.unsafer
{
    /// <summary>
    /// 数组扩展操作(非安全,请自行确保数据可靠性)
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 归并排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="left">左侧数组</param>
        /// <param name="right">右侧数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <returns>归并排序结果</returns>
        public static valueType[] GetMergeSort<valueType>(valueType[] left, valueType[] right, func<valueType, short> getKey)
        {
            int leftLength = left.length();
            if (leftLength == 0) return right.copy();
            int rightLenght = right.length();
            if (rightLenght == 0) return left.copy();
            int newIndex = 0, cmpIndex = 1;
            valueType[] newValues = new valueType[leftLength + rightLenght];
            if (getKey(left[leftLength - 1]) <= getKey(right[rightLenght - 1]))
            {
                valueType cmpValue = right[0];
                short cmpKey = getKey(cmpValue);
                foreach (valueType value in left)
                {
                    short key = getKey(value);
                    while (cmpKey < key)
                    {
                        newValues[newIndex++] = cmpValue;
                        cmpKey = getKey(cmpValue = right[cmpIndex++]);
                    }
                    newValues[newIndex++] = value;
                }
                newValues[newIndex++] = cmpValue;
                Array.Copy(right, cmpIndex, newValues, newIndex, newValues.Length - newIndex);
            }
            else
            {
                valueType cmpValue = left[0];
                short cmpKey = getKey(cmpValue);
                foreach (valueType value in right)
                {
                    short key = getKey(value);
                    while (cmpKey <= key)
                    {
                        newValues[newIndex++] = cmpValue;
                        cmpKey = getKey(cmpValue = left[cmpIndex++]);
                    }
                    newValues[newIndex++] = value;
                }
                newValues[newIndex++] = cmpValue;
                Array.Copy(left, cmpIndex, newValues, newIndex, newValues.Length - newIndex);
            }
            return newValues;
        }
    }
}

namespace fastCSharp.unsafer
{
    /// <summary>
    /// 数组扩展操作(非安全,请自行确保数据可靠性)
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 归并排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="left">左侧数组</param>
        /// <param name="right">右侧数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <returns>归并排序结果</returns>
        public static valueType[] GetMergeSortDesc<valueType>(valueType[] left, valueType[] right, func<valueType, short> getKey)
        {
            int leftLength = left.length();
            if (leftLength == 0) return right.copy();
            int rightLenght = right.length();
            if (rightLenght == 0) return left.copy();
            int newIndex = 0, cmpIndex = 1;
            valueType[] newValues = new valueType[leftLength + rightLenght];
            if (getKey(left[leftLength - 1]) >= getKey(right[rightLenght - 1]))
            {
                valueType cmpValue = right[0];
                short cmpKey = getKey(cmpValue);
                foreach (valueType value in left)
                {
                    short key = getKey(value);
                    while (cmpKey > key)
                    {
                        newValues[newIndex++] = cmpValue;
                        cmpKey = getKey(cmpValue = right[cmpIndex++]);
                    }
                    newValues[newIndex++] = value;
                }
                newValues[newIndex++] = cmpValue;
                Array.Copy(right, cmpIndex, newValues, newIndex, newValues.Length - newIndex);
            }
            else
            {
                valueType cmpValue = left[0];
                short cmpKey = getKey(cmpValue);
                foreach (valueType value in right)
                {
                    short key = getKey(value);
                    while (cmpKey >= key)
                    {
                        newValues[newIndex++] = cmpValue;
                        cmpKey = getKey(cmpValue = left[cmpIndex++]);
                    }
                    newValues[newIndex++] = value;
                }
                newValues[newIndex++] = cmpValue;
                Array.Copy(left, cmpIndex, newValues, newIndex, newValues.Length - newIndex);
            }
            return newValues;
        }
    }
}

namespace fastCSharp.unsafer
{
    /// <summary>
    /// 数组扩展操作(非安全,请自行确保数据可靠性)
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 归并排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="left">左侧数组</param>
        /// <param name="right">右侧数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <returns>归并排序结果</returns>
        public static valueType[] GetMergeSort<valueType>(valueType[] left, valueType[] right, func<valueType, byte> getKey)
        {
            int leftLength = left.length();
            if (leftLength == 0) return right.copy();
            int rightLenght = right.length();
            if (rightLenght == 0) return left.copy();
            int newIndex = 0, cmpIndex = 1;
            valueType[] newValues = new valueType[leftLength + rightLenght];
            if (getKey(left[leftLength - 1]) <= getKey(right[rightLenght - 1]))
            {
                valueType cmpValue = right[0];
                byte cmpKey = getKey(cmpValue);
                foreach (valueType value in left)
                {
                    byte key = getKey(value);
                    while (cmpKey < key)
                    {
                        newValues[newIndex++] = cmpValue;
                        cmpKey = getKey(cmpValue = right[cmpIndex++]);
                    }
                    newValues[newIndex++] = value;
                }
                newValues[newIndex++] = cmpValue;
                Array.Copy(right, cmpIndex, newValues, newIndex, newValues.Length - newIndex);
            }
            else
            {
                valueType cmpValue = left[0];
                byte cmpKey = getKey(cmpValue);
                foreach (valueType value in right)
                {
                    byte key = getKey(value);
                    while (cmpKey <= key)
                    {
                        newValues[newIndex++] = cmpValue;
                        cmpKey = getKey(cmpValue = left[cmpIndex++]);
                    }
                    newValues[newIndex++] = value;
                }
                newValues[newIndex++] = cmpValue;
                Array.Copy(left, cmpIndex, newValues, newIndex, newValues.Length - newIndex);
            }
            return newValues;
        }
    }
}

namespace fastCSharp.unsafer
{
    /// <summary>
    /// 数组扩展操作(非安全,请自行确保数据可靠性)
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 归并排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="left">左侧数组</param>
        /// <param name="right">右侧数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <returns>归并排序结果</returns>
        public static valueType[] GetMergeSortDesc<valueType>(valueType[] left, valueType[] right, func<valueType, byte> getKey)
        {
            int leftLength = left.length();
            if (leftLength == 0) return right.copy();
            int rightLenght = right.length();
            if (rightLenght == 0) return left.copy();
            int newIndex = 0, cmpIndex = 1;
            valueType[] newValues = new valueType[leftLength + rightLenght];
            if (getKey(left[leftLength - 1]) >= getKey(right[rightLenght - 1]))
            {
                valueType cmpValue = right[0];
                byte cmpKey = getKey(cmpValue);
                foreach (valueType value in left)
                {
                    byte key = getKey(value);
                    while (cmpKey > key)
                    {
                        newValues[newIndex++] = cmpValue;
                        cmpKey = getKey(cmpValue = right[cmpIndex++]);
                    }
                    newValues[newIndex++] = value;
                }
                newValues[newIndex++] = cmpValue;
                Array.Copy(right, cmpIndex, newValues, newIndex, newValues.Length - newIndex);
            }
            else
            {
                valueType cmpValue = left[0];
                byte cmpKey = getKey(cmpValue);
                foreach (valueType value in right)
                {
                    byte key = getKey(value);
                    while (cmpKey >= key)
                    {
                        newValues[newIndex++] = cmpValue;
                        cmpKey = getKey(cmpValue = left[cmpIndex++]);
                    }
                    newValues[newIndex++] = value;
                }
                newValues[newIndex++] = cmpValue;
                Array.Copy(left, cmpIndex, newValues, newIndex, newValues.Length - newIndex);
            }
            return newValues;
        }
    }
}

namespace fastCSharp.unsafer
{
    /// <summary>
    /// 数组扩展操作(非安全,请自行确保数据可靠性)
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 归并排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="left">左侧数组</param>
        /// <param name="right">右侧数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <returns>归并排序结果</returns>
        public static valueType[] GetMergeSort<valueType>(valueType[] left, valueType[] right, func<valueType, sbyte> getKey)
        {
            int leftLength = left.length();
            if (leftLength == 0) return right.copy();
            int rightLenght = right.length();
            if (rightLenght == 0) return left.copy();
            int newIndex = 0, cmpIndex = 1;
            valueType[] newValues = new valueType[leftLength + rightLenght];
            if (getKey(left[leftLength - 1]) <= getKey(right[rightLenght - 1]))
            {
                valueType cmpValue = right[0];
                sbyte cmpKey = getKey(cmpValue);
                foreach (valueType value in left)
                {
                    sbyte key = getKey(value);
                    while (cmpKey < key)
                    {
                        newValues[newIndex++] = cmpValue;
                        cmpKey = getKey(cmpValue = right[cmpIndex++]);
                    }
                    newValues[newIndex++] = value;
                }
                newValues[newIndex++] = cmpValue;
                Array.Copy(right, cmpIndex, newValues, newIndex, newValues.Length - newIndex);
            }
            else
            {
                valueType cmpValue = left[0];
                sbyte cmpKey = getKey(cmpValue);
                foreach (valueType value in right)
                {
                    sbyte key = getKey(value);
                    while (cmpKey <= key)
                    {
                        newValues[newIndex++] = cmpValue;
                        cmpKey = getKey(cmpValue = left[cmpIndex++]);
                    }
                    newValues[newIndex++] = value;
                }
                newValues[newIndex++] = cmpValue;
                Array.Copy(left, cmpIndex, newValues, newIndex, newValues.Length - newIndex);
            }
            return newValues;
        }
    }
}

namespace fastCSharp.unsafer
{
    /// <summary>
    /// 数组扩展操作(非安全,请自行确保数据可靠性)
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 归并排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="left">左侧数组</param>
        /// <param name="right">右侧数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <returns>归并排序结果</returns>
        public static valueType[] GetMergeSortDesc<valueType>(valueType[] left, valueType[] right, func<valueType, sbyte> getKey)
        {
            int leftLength = left.length();
            if (leftLength == 0) return right.copy();
            int rightLenght = right.length();
            if (rightLenght == 0) return left.copy();
            int newIndex = 0, cmpIndex = 1;
            valueType[] newValues = new valueType[leftLength + rightLenght];
            if (getKey(left[leftLength - 1]) >= getKey(right[rightLenght - 1]))
            {
                valueType cmpValue = right[0];
                sbyte cmpKey = getKey(cmpValue);
                foreach (valueType value in left)
                {
                    sbyte key = getKey(value);
                    while (cmpKey > key)
                    {
                        newValues[newIndex++] = cmpValue;
                        cmpKey = getKey(cmpValue = right[cmpIndex++]);
                    }
                    newValues[newIndex++] = value;
                }
                newValues[newIndex++] = cmpValue;
                Array.Copy(right, cmpIndex, newValues, newIndex, newValues.Length - newIndex);
            }
            else
            {
                valueType cmpValue = left[0];
                sbyte cmpKey = getKey(cmpValue);
                foreach (valueType value in right)
                {
                    sbyte key = getKey(value);
                    while (cmpKey >= key)
                    {
                        newValues[newIndex++] = cmpValue;
                        cmpKey = getKey(cmpValue = left[cmpIndex++]);
                    }
                    newValues[newIndex++] = value;
                }
                newValues[newIndex++] = cmpValue;
                Array.Copy(left, cmpIndex, newValues, newIndex, newValues.Length - newIndex);
            }
            return newValues;
        }
    }
}

namespace fastCSharp.unsafer
{
    /// <summary>
    /// 数组扩展操作(非安全,请自行确保数据可靠性)
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 归并排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="left">左侧数组</param>
        /// <param name="right">右侧数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <returns>归并排序结果</returns>
        public static valueType[] GetMergeSort<valueType>(valueType[] left, valueType[] right, func<valueType, double> getKey)
        {
            int leftLength = left.length();
            if (leftLength == 0) return right.copy();
            int rightLenght = right.length();
            if (rightLenght == 0) return left.copy();
            int newIndex = 0, cmpIndex = 1;
            valueType[] newValues = new valueType[leftLength + rightLenght];
            if (getKey(left[leftLength - 1]) <= getKey(right[rightLenght - 1]))
            {
                valueType cmpValue = right[0];
                double cmpKey = getKey(cmpValue);
                foreach (valueType value in left)
                {
                    double key = getKey(value);
                    while (cmpKey < key)
                    {
                        newValues[newIndex++] = cmpValue;
                        cmpKey = getKey(cmpValue = right[cmpIndex++]);
                    }
                    newValues[newIndex++] = value;
                }
                newValues[newIndex++] = cmpValue;
                Array.Copy(right, cmpIndex, newValues, newIndex, newValues.Length - newIndex);
            }
            else
            {
                valueType cmpValue = left[0];
                double cmpKey = getKey(cmpValue);
                foreach (valueType value in right)
                {
                    double key = getKey(value);
                    while (cmpKey <= key)
                    {
                        newValues[newIndex++] = cmpValue;
                        cmpKey = getKey(cmpValue = left[cmpIndex++]);
                    }
                    newValues[newIndex++] = value;
                }
                newValues[newIndex++] = cmpValue;
                Array.Copy(left, cmpIndex, newValues, newIndex, newValues.Length - newIndex);
            }
            return newValues;
        }
    }
}

namespace fastCSharp.unsafer
{
    /// <summary>
    /// 数组扩展操作(非安全,请自行确保数据可靠性)
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 归并排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="left">左侧数组</param>
        /// <param name="right">右侧数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <returns>归并排序结果</returns>
        public static valueType[] GetMergeSortDesc<valueType>(valueType[] left, valueType[] right, func<valueType, double> getKey)
        {
            int leftLength = left.length();
            if (leftLength == 0) return right.copy();
            int rightLenght = right.length();
            if (rightLenght == 0) return left.copy();
            int newIndex = 0, cmpIndex = 1;
            valueType[] newValues = new valueType[leftLength + rightLenght];
            if (getKey(left[leftLength - 1]) >= getKey(right[rightLenght - 1]))
            {
                valueType cmpValue = right[0];
                double cmpKey = getKey(cmpValue);
                foreach (valueType value in left)
                {
                    double key = getKey(value);
                    while (cmpKey > key)
                    {
                        newValues[newIndex++] = cmpValue;
                        cmpKey = getKey(cmpValue = right[cmpIndex++]);
                    }
                    newValues[newIndex++] = value;
                }
                newValues[newIndex++] = cmpValue;
                Array.Copy(right, cmpIndex, newValues, newIndex, newValues.Length - newIndex);
            }
            else
            {
                valueType cmpValue = left[0];
                double cmpKey = getKey(cmpValue);
                foreach (valueType value in right)
                {
                    double key = getKey(value);
                    while (cmpKey >= key)
                    {
                        newValues[newIndex++] = cmpValue;
                        cmpKey = getKey(cmpValue = left[cmpIndex++]);
                    }
                    newValues[newIndex++] = value;
                }
                newValues[newIndex++] = cmpValue;
                Array.Copy(left, cmpIndex, newValues, newIndex, newValues.Length - newIndex);
            }
            return newValues;
        }
    }
}

namespace fastCSharp.unsafer
{
    /// <summary>
    /// 数组扩展操作(非安全,请自行确保数据可靠性)
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 归并排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="left">左侧数组</param>
        /// <param name="right">右侧数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <returns>归并排序结果</returns>
        public static valueType[] GetMergeSort<valueType>(valueType[] left, valueType[] right, func<valueType, float> getKey)
        {
            int leftLength = left.length();
            if (leftLength == 0) return right.copy();
            int rightLenght = right.length();
            if (rightLenght == 0) return left.copy();
            int newIndex = 0, cmpIndex = 1;
            valueType[] newValues = new valueType[leftLength + rightLenght];
            if (getKey(left[leftLength - 1]) <= getKey(right[rightLenght - 1]))
            {
                valueType cmpValue = right[0];
                float cmpKey = getKey(cmpValue);
                foreach (valueType value in left)
                {
                    float key = getKey(value);
                    while (cmpKey < key)
                    {
                        newValues[newIndex++] = cmpValue;
                        cmpKey = getKey(cmpValue = right[cmpIndex++]);
                    }
                    newValues[newIndex++] = value;
                }
                newValues[newIndex++] = cmpValue;
                Array.Copy(right, cmpIndex, newValues, newIndex, newValues.Length - newIndex);
            }
            else
            {
                valueType cmpValue = left[0];
                float cmpKey = getKey(cmpValue);
                foreach (valueType value in right)
                {
                    float key = getKey(value);
                    while (cmpKey <= key)
                    {
                        newValues[newIndex++] = cmpValue;
                        cmpKey = getKey(cmpValue = left[cmpIndex++]);
                    }
                    newValues[newIndex++] = value;
                }
                newValues[newIndex++] = cmpValue;
                Array.Copy(left, cmpIndex, newValues, newIndex, newValues.Length - newIndex);
            }
            return newValues;
        }
    }
}

namespace fastCSharp.unsafer
{
    /// <summary>
    /// 数组扩展操作(非安全,请自行确保数据可靠性)
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 归并排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="left">左侧数组</param>
        /// <param name="right">右侧数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <returns>归并排序结果</returns>
        public static valueType[] GetMergeSortDesc<valueType>(valueType[] left, valueType[] right, func<valueType, float> getKey)
        {
            int leftLength = left.length();
            if (leftLength == 0) return right.copy();
            int rightLenght = right.length();
            if (rightLenght == 0) return left.copy();
            int newIndex = 0, cmpIndex = 1;
            valueType[] newValues = new valueType[leftLength + rightLenght];
            if (getKey(left[leftLength - 1]) >= getKey(right[rightLenght - 1]))
            {
                valueType cmpValue = right[0];
                float cmpKey = getKey(cmpValue);
                foreach (valueType value in left)
                {
                    float key = getKey(value);
                    while (cmpKey > key)
                    {
                        newValues[newIndex++] = cmpValue;
                        cmpKey = getKey(cmpValue = right[cmpIndex++]);
                    }
                    newValues[newIndex++] = value;
                }
                newValues[newIndex++] = cmpValue;
                Array.Copy(right, cmpIndex, newValues, newIndex, newValues.Length - newIndex);
            }
            else
            {
                valueType cmpValue = left[0];
                float cmpKey = getKey(cmpValue);
                foreach (valueType value in right)
                {
                    float key = getKey(value);
                    while (cmpKey >= key)
                    {
                        newValues[newIndex++] = cmpValue;
                        cmpKey = getKey(cmpValue = left[cmpIndex++]);
                    }
                    newValues[newIndex++] = value;
                }
                newValues[newIndex++] = cmpValue;
                Array.Copy(left, cmpIndex, newValues, newIndex, newValues.Length - newIndex);
            }
            return newValues;
        }
    }
}

namespace fastCSharp.unsafer
{
    /// <summary>
    /// 数组扩展操作(非安全,请自行确保数据可靠性)
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 归并排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="left">左侧数组</param>
        /// <param name="right">右侧数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <returns>归并排序结果</returns>
        public static valueType[] GetMergeSort<valueType>(valueType[] left, valueType[] right, func<valueType, DateTime> getKey)
        {
            int leftLength = left.length();
            if (leftLength == 0) return right.copy();
            int rightLenght = right.length();
            if (rightLenght == 0) return left.copy();
            int newIndex = 0, cmpIndex = 1;
            valueType[] newValues = new valueType[leftLength + rightLenght];
            if (getKey(left[leftLength - 1]) <= getKey(right[rightLenght - 1]))
            {
                valueType cmpValue = right[0];
                DateTime cmpKey = getKey(cmpValue);
                foreach (valueType value in left)
                {
                    DateTime key = getKey(value);
                    while (cmpKey < key)
                    {
                        newValues[newIndex++] = cmpValue;
                        cmpKey = getKey(cmpValue = right[cmpIndex++]);
                    }
                    newValues[newIndex++] = value;
                }
                newValues[newIndex++] = cmpValue;
                Array.Copy(right, cmpIndex, newValues, newIndex, newValues.Length - newIndex);
            }
            else
            {
                valueType cmpValue = left[0];
                DateTime cmpKey = getKey(cmpValue);
                foreach (valueType value in right)
                {
                    DateTime key = getKey(value);
                    while (cmpKey <= key)
                    {
                        newValues[newIndex++] = cmpValue;
                        cmpKey = getKey(cmpValue = left[cmpIndex++]);
                    }
                    newValues[newIndex++] = value;
                }
                newValues[newIndex++] = cmpValue;
                Array.Copy(left, cmpIndex, newValues, newIndex, newValues.Length - newIndex);
            }
            return newValues;
        }
    }
}

namespace fastCSharp.unsafer
{
    /// <summary>
    /// 数组扩展操作(非安全,请自行确保数据可靠性)
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 归并排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="left">左侧数组</param>
        /// <param name="right">右侧数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <returns>归并排序结果</returns>
        public static valueType[] GetMergeSortDesc<valueType>(valueType[] left, valueType[] right, func<valueType, DateTime> getKey)
        {
            int leftLength = left.length();
            if (leftLength == 0) return right.copy();
            int rightLenght = right.length();
            if (rightLenght == 0) return left.copy();
            int newIndex = 0, cmpIndex = 1;
            valueType[] newValues = new valueType[leftLength + rightLenght];
            if (getKey(left[leftLength - 1]) >= getKey(right[rightLenght - 1]))
            {
                valueType cmpValue = right[0];
                DateTime cmpKey = getKey(cmpValue);
                foreach (valueType value in left)
                {
                    DateTime key = getKey(value);
                    while (cmpKey > key)
                    {
                        newValues[newIndex++] = cmpValue;
                        cmpKey = getKey(cmpValue = right[cmpIndex++]);
                    }
                    newValues[newIndex++] = value;
                }
                newValues[newIndex++] = cmpValue;
                Array.Copy(right, cmpIndex, newValues, newIndex, newValues.Length - newIndex);
            }
            else
            {
                valueType cmpValue = left[0];
                DateTime cmpKey = getKey(cmpValue);
                foreach (valueType value in right)
                {
                    DateTime key = getKey(value);
                    while (cmpKey >= key)
                    {
                        newValues[newIndex++] = cmpValue;
                        cmpKey = getKey(cmpValue = left[cmpIndex++]);
                    }
                    newValues[newIndex++] = value;
                }
                newValues[newIndex++] = cmpValue;
                Array.Copy(left, cmpIndex, newValues, newIndex, newValues.Length - newIndex);
            }
            return newValues;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 可枚举相关扩展
    /// </summary>
    public static partial class iEnumerable
    {
        /// <summary>
        /// 求和
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">数据集合</param>
        /// <param name="getValue">数值获取器</param>
        /// <returns>数值求和</returns>
        public static long sum<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, long> getValue)
        {
            if (getValue == null) log.Default.Throw(log.exceptionType.Null);
            long value = 0;
            if (values != null)
            {
                foreach (valueType nextValue in values) value += getValue(nextValue);
            }
            return value;
        }
        /// <summary>
        /// 求和
        /// </summary>
        /// <param name="values">数值集合</param>
        /// <returns>数值求和</returns>
        public static long sum(this System.Collections.Generic.IEnumerable<long> values)
        {
            if (values != null)
            {
                long value = 0;
                foreach (long nextValue in values) value += nextValue;
                return value;
            }
            return 0;
        }
        /// <summary>
        /// 分组求和
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">数据集合</param>
        /// <returns>分组求和</returns>
        public static System.Collections.Generic.Dictionary<valueType, long> groupSum<valueType>
            (this System.Collections.Generic.IEnumerable<keyValue<valueType, long>> values)
        {
            if (values != null)
            {
                long sum;
                System.Collections.Generic.Dictionary<valueType, long> sums
                    = new System.Collections.Generic.Dictionary<valueType, long>();
                foreach (keyValue<valueType,long> value in values)
                {
                    if (sums.TryGetValue(value.Key, out sum)) sums[value.Key] = (long)(sum + value.Value);
                    else sums.Add(value.Key, value.Value);
                }
                return sums;
            }
            return null;
        }
        /// <summary>
        /// 分组求和
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="keyType">分组键值类型</typeparam>
        /// <param name="values">数据集合</param>
        /// <param name="getKey">键值获取器</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>分组求和</returns>
        public static System.Collections.Generic.Dictionary<keyType, long> groupSum<valueType, keyType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, keyType> getKey
            , func<valueType, long> getValue)
        {
            if (values != null)
            {
                if (getKey == null || getValue == null) log.Default.Throw(log.exceptionType.Null);
                long sum;
                System.Collections.Generic.Dictionary<keyType, long> sums
                    = new System.Collections.Generic.Dictionary<keyType, long>();
                foreach (valueType value in values)
                {
                    keyType key = getKey(value);
                    if (sums.TryGetValue(key, out sum)) sums[key] = (long)(sum + getValue(value));
                    else sums.Add(key, getValue(value));
                }
                return sums;
            }
            return null;
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="values">数据集合</param>
        /// <returns>字符串</returns>
        public static list<string> getString(this System.Collections.Generic.IEnumerable<long> values)
        {
            if (values != null)
            {
                list<string> newValues = new list<string>();
                foreach (long nextValue in values) newValues.Add(number.toString(nextValue));
                return newValues;
            }
            return null;
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="values">数据集合</param>
        /// <returns>字符串</returns>
        public static string joinString(this System.Collections.Generic.IEnumerable<long> values)
        {
            return string.Concat(getString(values).toArray());
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="values">数据集合</param>
        /// <param name="join">连接串</param>
        /// <returns>字符串</returns>
        public static string joinString(this System.Collections.Generic.IEnumerable<long> values, string join)
        {
            return string.Join(join, getString(values).toArray());
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="values">数据集合</param>
        /// <param name="join">连接串</param>
        /// <returns>字符串</returns>
        public static string joinString(this System.Collections.Generic.IEnumerable<long> values, char join)
        {
            return getString(values).toArray().joinString(join);
        }
    }
    /// <summary>
    /// 集合相关扩展
    /// </summary>
    public static partial class iCollection
    {
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="values">数据集合</param>
        /// <returns>字符串</returns>
        public static string[] getString(this System.Collections.Generic.ICollection<long> values)
        {
            if (values.count() != 0)
            {
                string[] newValues = new string[values.Count];
                int index = 0;
                foreach (long nextValue in values) newValues[index++] = number.toString(nextValue);
                return newValues;
            }
            return nullValue<string>.Array;
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="values">数据集合</param>
        /// <returns>字符串</returns>
        public static string joinString(this System.Collections.Generic.ICollection<long> values)
        {
            return string.Concat(getString(values));
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="values">数据集合</param>
        /// <param name="join">连接串</param>
        /// <returns>字符串</returns>
        public static string joinString(this System.Collections.Generic.ICollection<long> values, string join)
        {
            return string.Join(join, getString(values));
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="values">数据集合</param>
        /// <param name="join">连接串</param>
        /// <returns>字符串</returns>
        public static string joinString(this System.Collections.Generic.ICollection<long> values, char join)
        {
            return getString(values).joinString(join);
        }
    }
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 求和
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据集合</param>
        /// <param name="getValue">数值获取器</param>
        /// <returns>数值求和</returns>
        public static long sum<valueType>(this valueType[] array, func<valueType, long> getValue)
        {
            long sum = 0;
            if (array != null)
            {
                if (getValue == null) log.Default.Throw(log.exceptionType.Null);
                foreach (valueType value in array) sum += getValue(value);
            }
            return sum;
        }
        /// <summary>
        /// 求和
        /// </summary>
        /// <param name="array">数据集合</param>
        /// <returns>数值求和</returns>
        public unsafe static long sum(this long[] array)
        {
            if (array != null)
            {
                long value = 0;
                fixed (long* valueFixed = array)
                {
                    for (long* start = valueFixed, end = valueFixed + array.Length; start != end; value += *start++) ;
                }
                return value;
            }
            return 0;
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="array">数据集合</param>
        /// <returns>字符串</returns>
        public unsafe static string[] getString(this long[] array)
        {
            if (array.length() != 0)
            {
                string[] newValues = new string[array.Length];
                fixed (long* valueFixed = array)
                {
                    long* readValue = valueFixed;
                    for (int index = 0; index != newValues.Length; ++index)
                    {
                        newValues[index] = number.toString(*readValue++);
                    }
                }
                return newValues;
            }
            return nullValue<string>.Array;
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="array">数据集合</param>
        /// <returns>字符串</returns>
        public unsafe static string[] getString(this long[] array, int index, int count)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                string[] newValues = new string[count];
                fixed (long* valueFixed = array)
                {
                    long* readValue = valueFixed + range.SkipCount;
                    for (index = 0; index != count; newValues[index++] = number.toString(*readValue++)) ;
                }
                return newValues;
            }
            return nullValue<string>.Array;
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="array">数据集合</param>
        /// <returns>字符串</returns>
        public static string joinString(this long[] array)
        {
            return string.Concat(getString(array));
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="array">数据集合</param>
        /// <param name="join">连接串</param>
        /// <returns>字符串</returns>
        public static string joinString(this long[] array, string join)
        {
            return string.Join(join, getString(array));
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="array">数据集合</param>
        /// <param name="join">连接串</param>
        /// <returns>字符串</returns>
        public static string joinString(this long[] array, char join)
        {
            return getString(array).joinString(join);
        }
    }
    /// <summary>
    /// 单向动态数组扩展
    /// </summary>
    public static partial class list
    {
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="list">数据集合</param>
        /// <returns>字符串</returns>
        public static string[] getString(this list<long> list)
        {
            return list.count() != 0 ? list.Unsafer.Array.getString(0, list.Count) : nullValue<string>.Array;
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="list">数据集合</param>
        /// <returns>字符串</returns>
        public static string joinString(this list<long> list)
        {
            return string.Concat(getString(list));
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="list">数据集合</param>
        /// <param name="join">连接串</param>
        /// <returns>字符串</returns>
        public static string joinString(this list<long> list, string join)
        {
            return string.Join(join, getString(list));
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="list">数据集合</param>
        /// <param name="join">连接串</param>
        /// <returns>字符串</returns>
        public static string joinString(this list<long> list, char join)
        {
            return getString(list).joinString(join);
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 可枚举相关扩展
    /// </summary>
    public static partial class iEnumerable
    {
        /// <summary>
        /// 求和
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">数据集合</param>
        /// <param name="getValue">数值获取器</param>
        /// <returns>数值求和</returns>
        public static uint sum<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, uint> getValue)
        {
            if (getValue == null) log.Default.Throw(log.exceptionType.Null);
            uint value = 0;
            if (values != null)
            {
                foreach (valueType nextValue in values) value += getValue(nextValue);
            }
            return value;
        }
        /// <summary>
        /// 求和
        /// </summary>
        /// <param name="values">数值集合</param>
        /// <returns>数值求和</returns>
        public static uint sum(this System.Collections.Generic.IEnumerable<uint> values)
        {
            if (values != null)
            {
                uint value = 0;
                foreach (uint nextValue in values) value += nextValue;
                return value;
            }
            return 0;
        }
        /// <summary>
        /// 分组求和
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">数据集合</param>
        /// <returns>分组求和</returns>
        public static System.Collections.Generic.Dictionary<valueType, uint> groupSum<valueType>
            (this System.Collections.Generic.IEnumerable<keyValue<valueType, uint>> values)
        {
            if (values != null)
            {
                uint sum;
                System.Collections.Generic.Dictionary<valueType, uint> sums
                    = new System.Collections.Generic.Dictionary<valueType, uint>();
                foreach (keyValue<valueType,uint> value in values)
                {
                    if (sums.TryGetValue(value.Key, out sum)) sums[value.Key] = (uint)(sum + value.Value);
                    else sums.Add(value.Key, value.Value);
                }
                return sums;
            }
            return null;
        }
        /// <summary>
        /// 分组求和
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="keyType">分组键值类型</typeparam>
        /// <param name="values">数据集合</param>
        /// <param name="getKey">键值获取器</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>分组求和</returns>
        public static System.Collections.Generic.Dictionary<keyType, uint> groupSum<valueType, keyType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, keyType> getKey
            , func<valueType, uint> getValue)
        {
            if (values != null)
            {
                if (getKey == null || getValue == null) log.Default.Throw(log.exceptionType.Null);
                uint sum;
                System.Collections.Generic.Dictionary<keyType, uint> sums
                    = new System.Collections.Generic.Dictionary<keyType, uint>();
                foreach (valueType value in values)
                {
                    keyType key = getKey(value);
                    if (sums.TryGetValue(key, out sum)) sums[key] = (uint)(sum + getValue(value));
                    else sums.Add(key, getValue(value));
                }
                return sums;
            }
            return null;
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="values">数据集合</param>
        /// <returns>字符串</returns>
        public static list<string> getString(this System.Collections.Generic.IEnumerable<uint> values)
        {
            if (values != null)
            {
                list<string> newValues = new list<string>();
                foreach (uint nextValue in values) newValues.Add(number.toString(nextValue));
                return newValues;
            }
            return null;
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="values">数据集合</param>
        /// <returns>字符串</returns>
        public static string joinString(this System.Collections.Generic.IEnumerable<uint> values)
        {
            return string.Concat(getString(values).toArray());
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="values">数据集合</param>
        /// <param name="join">连接串</param>
        /// <returns>字符串</returns>
        public static string joinString(this System.Collections.Generic.IEnumerable<uint> values, string join)
        {
            return string.Join(join, getString(values).toArray());
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="values">数据集合</param>
        /// <param name="join">连接串</param>
        /// <returns>字符串</returns>
        public static string joinString(this System.Collections.Generic.IEnumerable<uint> values, char join)
        {
            return getString(values).toArray().joinString(join);
        }
    }
    /// <summary>
    /// 集合相关扩展
    /// </summary>
    public static partial class iCollection
    {
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="values">数据集合</param>
        /// <returns>字符串</returns>
        public static string[] getString(this System.Collections.Generic.ICollection<uint> values)
        {
            if (values.count() != 0)
            {
                string[] newValues = new string[values.Count];
                int index = 0;
                foreach (uint nextValue in values) newValues[index++] = number.toString(nextValue);
                return newValues;
            }
            return nullValue<string>.Array;
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="values">数据集合</param>
        /// <returns>字符串</returns>
        public static string joinString(this System.Collections.Generic.ICollection<uint> values)
        {
            return string.Concat(getString(values));
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="values">数据集合</param>
        /// <param name="join">连接串</param>
        /// <returns>字符串</returns>
        public static string joinString(this System.Collections.Generic.ICollection<uint> values, string join)
        {
            return string.Join(join, getString(values));
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="values">数据集合</param>
        /// <param name="join">连接串</param>
        /// <returns>字符串</returns>
        public static string joinString(this System.Collections.Generic.ICollection<uint> values, char join)
        {
            return getString(values).joinString(join);
        }
    }
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 求和
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据集合</param>
        /// <param name="getValue">数值获取器</param>
        /// <returns>数值求和</returns>
        public static uint sum<valueType>(this valueType[] array, func<valueType, uint> getValue)
        {
            uint sum = 0;
            if (array != null)
            {
                if (getValue == null) log.Default.Throw(log.exceptionType.Null);
                foreach (valueType value in array) sum += getValue(value);
            }
            return sum;
        }
        /// <summary>
        /// 求和
        /// </summary>
        /// <param name="array">数据集合</param>
        /// <returns>数值求和</returns>
        public unsafe static uint sum(this uint[] array)
        {
            if (array != null)
            {
                uint value = 0;
                fixed (uint* valueFixed = array)
                {
                    for (uint* start = valueFixed, end = valueFixed + array.Length; start != end; value += *start++) ;
                }
                return value;
            }
            return 0;
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="array">数据集合</param>
        /// <returns>字符串</returns>
        public unsafe static string[] getString(this uint[] array)
        {
            if (array.length() != 0)
            {
                string[] newValues = new string[array.Length];
                fixed (uint* valueFixed = array)
                {
                    uint* readValue = valueFixed;
                    for (int index = 0; index != newValues.Length; ++index)
                    {
                        newValues[index] = number.toString(*readValue++);
                    }
                }
                return newValues;
            }
            return nullValue<string>.Array;
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="array">数据集合</param>
        /// <returns>字符串</returns>
        public unsafe static string[] getString(this uint[] array, int index, int count)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                string[] newValues = new string[count];
                fixed (uint* valueFixed = array)
                {
                    uint* readValue = valueFixed + range.SkipCount;
                    for (index = 0; index != count; newValues[index++] = number.toString(*readValue++)) ;
                }
                return newValues;
            }
            return nullValue<string>.Array;
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="array">数据集合</param>
        /// <returns>字符串</returns>
        public static string joinString(this uint[] array)
        {
            return string.Concat(getString(array));
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="array">数据集合</param>
        /// <param name="join">连接串</param>
        /// <returns>字符串</returns>
        public static string joinString(this uint[] array, string join)
        {
            return string.Join(join, getString(array));
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="array">数据集合</param>
        /// <param name="join">连接串</param>
        /// <returns>字符串</returns>
        public static string joinString(this uint[] array, char join)
        {
            return getString(array).joinString(join);
        }
    }
    /// <summary>
    /// 单向动态数组扩展
    /// </summary>
    public static partial class list
    {
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="list">数据集合</param>
        /// <returns>字符串</returns>
        public static string[] getString(this list<uint> list)
        {
            return list.count() != 0 ? list.Unsafer.Array.getString(0, list.Count) : nullValue<string>.Array;
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="list">数据集合</param>
        /// <returns>字符串</returns>
        public static string joinString(this list<uint> list)
        {
            return string.Concat(getString(list));
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="list">数据集合</param>
        /// <param name="join">连接串</param>
        /// <returns>字符串</returns>
        public static string joinString(this list<uint> list, string join)
        {
            return string.Join(join, getString(list));
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="list">数据集合</param>
        /// <param name="join">连接串</param>
        /// <returns>字符串</returns>
        public static string joinString(this list<uint> list, char join)
        {
            return getString(list).joinString(join);
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 可枚举相关扩展
    /// </summary>
    public static partial class iEnumerable
    {
        /// <summary>
        /// 求和
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">数据集合</param>
        /// <param name="getValue">数值获取器</param>
        /// <returns>数值求和</returns>
        public static int sum<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, int> getValue)
        {
            if (getValue == null) log.Default.Throw(log.exceptionType.Null);
            int value = 0;
            if (values != null)
            {
                foreach (valueType nextValue in values) value += getValue(nextValue);
            }
            return value;
        }
        /// <summary>
        /// 求和
        /// </summary>
        /// <param name="values">数值集合</param>
        /// <returns>数值求和</returns>
        public static int sum(this System.Collections.Generic.IEnumerable<int> values)
        {
            if (values != null)
            {
                int value = 0;
                foreach (int nextValue in values) value += nextValue;
                return value;
            }
            return 0;
        }
        /// <summary>
        /// 分组求和
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">数据集合</param>
        /// <returns>分组求和</returns>
        public static System.Collections.Generic.Dictionary<valueType, int> groupSum<valueType>
            (this System.Collections.Generic.IEnumerable<keyValue<valueType, int>> values)
        {
            if (values != null)
            {
                int sum;
                System.Collections.Generic.Dictionary<valueType, int> sums
                    = new System.Collections.Generic.Dictionary<valueType, int>();
                foreach (keyValue<valueType,int> value in values)
                {
                    if (sums.TryGetValue(value.Key, out sum)) sums[value.Key] = (int)(sum + value.Value);
                    else sums.Add(value.Key, value.Value);
                }
                return sums;
            }
            return null;
        }
        /// <summary>
        /// 分组求和
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="keyType">分组键值类型</typeparam>
        /// <param name="values">数据集合</param>
        /// <param name="getKey">键值获取器</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>分组求和</returns>
        public static System.Collections.Generic.Dictionary<keyType, int> groupSum<valueType, keyType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, keyType> getKey
            , func<valueType, int> getValue)
        {
            if (values != null)
            {
                if (getKey == null || getValue == null) log.Default.Throw(log.exceptionType.Null);
                int sum;
                System.Collections.Generic.Dictionary<keyType, int> sums
                    = new System.Collections.Generic.Dictionary<keyType, int>();
                foreach (valueType value in values)
                {
                    keyType key = getKey(value);
                    if (sums.TryGetValue(key, out sum)) sums[key] = (int)(sum + getValue(value));
                    else sums.Add(key, getValue(value));
                }
                return sums;
            }
            return null;
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="values">数据集合</param>
        /// <returns>字符串</returns>
        public static list<string> getString(this System.Collections.Generic.IEnumerable<int> values)
        {
            if (values != null)
            {
                list<string> newValues = new list<string>();
                foreach (int nextValue in values) newValues.Add(number.toString(nextValue));
                return newValues;
            }
            return null;
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="values">数据集合</param>
        /// <returns>字符串</returns>
        public static string joinString(this System.Collections.Generic.IEnumerable<int> values)
        {
            return string.Concat(getString(values).toArray());
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="values">数据集合</param>
        /// <param name="join">连接串</param>
        /// <returns>字符串</returns>
        public static string joinString(this System.Collections.Generic.IEnumerable<int> values, string join)
        {
            return string.Join(join, getString(values).toArray());
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="values">数据集合</param>
        /// <param name="join">连接串</param>
        /// <returns>字符串</returns>
        public static string joinString(this System.Collections.Generic.IEnumerable<int> values, char join)
        {
            return getString(values).toArray().joinString(join);
        }
    }
    /// <summary>
    /// 集合相关扩展
    /// </summary>
    public static partial class iCollection
    {
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="values">数据集合</param>
        /// <returns>字符串</returns>
        public static string[] getString(this System.Collections.Generic.ICollection<int> values)
        {
            if (values.count() != 0)
            {
                string[] newValues = new string[values.Count];
                int index = 0;
                foreach (int nextValue in values) newValues[index++] = number.toString(nextValue);
                return newValues;
            }
            return nullValue<string>.Array;
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="values">数据集合</param>
        /// <returns>字符串</returns>
        public static string joinString(this System.Collections.Generic.ICollection<int> values)
        {
            return string.Concat(getString(values));
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="values">数据集合</param>
        /// <param name="join">连接串</param>
        /// <returns>字符串</returns>
        public static string joinString(this System.Collections.Generic.ICollection<int> values, string join)
        {
            return string.Join(join, getString(values));
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="values">数据集合</param>
        /// <param name="join">连接串</param>
        /// <returns>字符串</returns>
        public static string joinString(this System.Collections.Generic.ICollection<int> values, char join)
        {
            return getString(values).joinString(join);
        }
    }
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 求和
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据集合</param>
        /// <param name="getValue">数值获取器</param>
        /// <returns>数值求和</returns>
        public static int sum<valueType>(this valueType[] array, func<valueType, int> getValue)
        {
            int sum = 0;
            if (array != null)
            {
                if (getValue == null) log.Default.Throw(log.exceptionType.Null);
                foreach (valueType value in array) sum += getValue(value);
            }
            return sum;
        }
        /// <summary>
        /// 求和
        /// </summary>
        /// <param name="array">数据集合</param>
        /// <returns>数值求和</returns>
        public unsafe static int sum(this int[] array)
        {
            if (array != null)
            {
                int value = 0;
                fixed (int* valueFixed = array)
                {
                    for (int* start = valueFixed, end = valueFixed + array.Length; start != end; value += *start++) ;
                }
                return value;
            }
            return 0;
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="array">数据集合</param>
        /// <returns>字符串</returns>
        public unsafe static string[] getString(this int[] array)
        {
            if (array.length() != 0)
            {
                string[] newValues = new string[array.Length];
                fixed (int* valueFixed = array)
                {
                    int* readValue = valueFixed;
                    for (int index = 0; index != newValues.Length; ++index)
                    {
                        newValues[index] = number.toString(*readValue++);
                    }
                }
                return newValues;
            }
            return nullValue<string>.Array;
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="array">数据集合</param>
        /// <returns>字符串</returns>
        public unsafe static string[] getString(this int[] array, int index, int count)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                string[] newValues = new string[count];
                fixed (int* valueFixed = array)
                {
                    int* readValue = valueFixed + range.SkipCount;
                    for (index = 0; index != count; newValues[index++] = number.toString(*readValue++)) ;
                }
                return newValues;
            }
            return nullValue<string>.Array;
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="array">数据集合</param>
        /// <returns>字符串</returns>
        public static string joinString(this int[] array)
        {
            return string.Concat(getString(array));
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="array">数据集合</param>
        /// <param name="join">连接串</param>
        /// <returns>字符串</returns>
        public static string joinString(this int[] array, string join)
        {
            return string.Join(join, getString(array));
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="array">数据集合</param>
        /// <param name="join">连接串</param>
        /// <returns>字符串</returns>
        public static string joinString(this int[] array, char join)
        {
            return getString(array).joinString(join);
        }
    }
    /// <summary>
    /// 单向动态数组扩展
    /// </summary>
    public static partial class list
    {
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="list">数据集合</param>
        /// <returns>字符串</returns>
        public static string[] getString(this list<int> list)
        {
            return list.count() != 0 ? list.Unsafer.Array.getString(0, list.Count) : nullValue<string>.Array;
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="list">数据集合</param>
        /// <returns>字符串</returns>
        public static string joinString(this list<int> list)
        {
            return string.Concat(getString(list));
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="list">数据集合</param>
        /// <param name="join">连接串</param>
        /// <returns>字符串</returns>
        public static string joinString(this list<int> list, string join)
        {
            return string.Join(join, getString(list));
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="list">数据集合</param>
        /// <param name="join">连接串</param>
        /// <returns>字符串</returns>
        public static string joinString(this list<int> list, char join)
        {
            return getString(list).joinString(join);
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 可枚举相关扩展
    /// </summary>
    public static partial class iEnumerable
    {
        /// <summary>
        /// 求和
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">数据集合</param>
        /// <param name="getValue">数值获取器</param>
        /// <returns>数值求和</returns>
        public static ushort sum<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, ushort> getValue)
        {
            if (getValue == null) log.Default.Throw(log.exceptionType.Null);
            ushort value = 0;
            if (values != null)
            {
                foreach (valueType nextValue in values) value += getValue(nextValue);
            }
            return value;
        }
        /// <summary>
        /// 求和
        /// </summary>
        /// <param name="values">数值集合</param>
        /// <returns>数值求和</returns>
        public static ushort sum(this System.Collections.Generic.IEnumerable<ushort> values)
        {
            if (values != null)
            {
                ushort value = 0;
                foreach (ushort nextValue in values) value += nextValue;
                return value;
            }
            return 0;
        }
        /// <summary>
        /// 分组求和
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">数据集合</param>
        /// <returns>分组求和</returns>
        public static System.Collections.Generic.Dictionary<valueType, ushort> groupSum<valueType>
            (this System.Collections.Generic.IEnumerable<keyValue<valueType, ushort>> values)
        {
            if (values != null)
            {
                ushort sum;
                System.Collections.Generic.Dictionary<valueType, ushort> sums
                    = new System.Collections.Generic.Dictionary<valueType, ushort>();
                foreach (keyValue<valueType,ushort> value in values)
                {
                    if (sums.TryGetValue(value.Key, out sum)) sums[value.Key] = (ushort)(sum + value.Value);
                    else sums.Add(value.Key, value.Value);
                }
                return sums;
            }
            return null;
        }
        /// <summary>
        /// 分组求和
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="keyType">分组键值类型</typeparam>
        /// <param name="values">数据集合</param>
        /// <param name="getKey">键值获取器</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>分组求和</returns>
        public static System.Collections.Generic.Dictionary<keyType, ushort> groupSum<valueType, keyType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, keyType> getKey
            , func<valueType, ushort> getValue)
        {
            if (values != null)
            {
                if (getKey == null || getValue == null) log.Default.Throw(log.exceptionType.Null);
                ushort sum;
                System.Collections.Generic.Dictionary<keyType, ushort> sums
                    = new System.Collections.Generic.Dictionary<keyType, ushort>();
                foreach (valueType value in values)
                {
                    keyType key = getKey(value);
                    if (sums.TryGetValue(key, out sum)) sums[key] = (ushort)(sum + getValue(value));
                    else sums.Add(key, getValue(value));
                }
                return sums;
            }
            return null;
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="values">数据集合</param>
        /// <returns>字符串</returns>
        public static list<string> getString(this System.Collections.Generic.IEnumerable<ushort> values)
        {
            if (values != null)
            {
                list<string> newValues = new list<string>();
                foreach (ushort nextValue in values) newValues.Add(number.toString(nextValue));
                return newValues;
            }
            return null;
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="values">数据集合</param>
        /// <returns>字符串</returns>
        public static string joinString(this System.Collections.Generic.IEnumerable<ushort> values)
        {
            return string.Concat(getString(values).toArray());
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="values">数据集合</param>
        /// <param name="join">连接串</param>
        /// <returns>字符串</returns>
        public static string joinString(this System.Collections.Generic.IEnumerable<ushort> values, string join)
        {
            return string.Join(join, getString(values).toArray());
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="values">数据集合</param>
        /// <param name="join">连接串</param>
        /// <returns>字符串</returns>
        public static string joinString(this System.Collections.Generic.IEnumerable<ushort> values, char join)
        {
            return getString(values).toArray().joinString(join);
        }
    }
    /// <summary>
    /// 集合相关扩展
    /// </summary>
    public static partial class iCollection
    {
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="values">数据集合</param>
        /// <returns>字符串</returns>
        public static string[] getString(this System.Collections.Generic.ICollection<ushort> values)
        {
            if (values.count() != 0)
            {
                string[] newValues = new string[values.Count];
                int index = 0;
                foreach (ushort nextValue in values) newValues[index++] = number.toString(nextValue);
                return newValues;
            }
            return nullValue<string>.Array;
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="values">数据集合</param>
        /// <returns>字符串</returns>
        public static string joinString(this System.Collections.Generic.ICollection<ushort> values)
        {
            return string.Concat(getString(values));
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="values">数据集合</param>
        /// <param name="join">连接串</param>
        /// <returns>字符串</returns>
        public static string joinString(this System.Collections.Generic.ICollection<ushort> values, string join)
        {
            return string.Join(join, getString(values));
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="values">数据集合</param>
        /// <param name="join">连接串</param>
        /// <returns>字符串</returns>
        public static string joinString(this System.Collections.Generic.ICollection<ushort> values, char join)
        {
            return getString(values).joinString(join);
        }
    }
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 求和
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据集合</param>
        /// <param name="getValue">数值获取器</param>
        /// <returns>数值求和</returns>
        public static ushort sum<valueType>(this valueType[] array, func<valueType, ushort> getValue)
        {
            ushort sum = 0;
            if (array != null)
            {
                if (getValue == null) log.Default.Throw(log.exceptionType.Null);
                foreach (valueType value in array) sum += getValue(value);
            }
            return sum;
        }
        /// <summary>
        /// 求和
        /// </summary>
        /// <param name="array">数据集合</param>
        /// <returns>数值求和</returns>
        public unsafe static ushort sum(this ushort[] array)
        {
            if (array != null)
            {
                ushort value = 0;
                fixed (ushort* valueFixed = array)
                {
                    for (ushort* start = valueFixed, end = valueFixed + array.Length; start != end; value += *start++) ;
                }
                return value;
            }
            return 0;
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="array">数据集合</param>
        /// <returns>字符串</returns>
        public unsafe static string[] getString(this ushort[] array)
        {
            if (array.length() != 0)
            {
                string[] newValues = new string[array.Length];
                fixed (ushort* valueFixed = array)
                {
                    ushort* readValue = valueFixed;
                    for (int index = 0; index != newValues.Length; ++index)
                    {
                        newValues[index] = number.toString(*readValue++);
                    }
                }
                return newValues;
            }
            return nullValue<string>.Array;
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="array">数据集合</param>
        /// <returns>字符串</returns>
        public unsafe static string[] getString(this ushort[] array, int index, int count)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                string[] newValues = new string[count];
                fixed (ushort* valueFixed = array)
                {
                    ushort* readValue = valueFixed + range.SkipCount;
                    for (index = 0; index != count; newValues[index++] = number.toString(*readValue++)) ;
                }
                return newValues;
            }
            return nullValue<string>.Array;
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="array">数据集合</param>
        /// <returns>字符串</returns>
        public static string joinString(this ushort[] array)
        {
            return string.Concat(getString(array));
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="array">数据集合</param>
        /// <param name="join">连接串</param>
        /// <returns>字符串</returns>
        public static string joinString(this ushort[] array, string join)
        {
            return string.Join(join, getString(array));
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="array">数据集合</param>
        /// <param name="join">连接串</param>
        /// <returns>字符串</returns>
        public static string joinString(this ushort[] array, char join)
        {
            return getString(array).joinString(join);
        }
    }
    /// <summary>
    /// 单向动态数组扩展
    /// </summary>
    public static partial class list
    {
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="list">数据集合</param>
        /// <returns>字符串</returns>
        public static string[] getString(this list<ushort> list)
        {
            return list.count() != 0 ? list.Unsafer.Array.getString(0, list.Count) : nullValue<string>.Array;
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="list">数据集合</param>
        /// <returns>字符串</returns>
        public static string joinString(this list<ushort> list)
        {
            return string.Concat(getString(list));
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="list">数据集合</param>
        /// <param name="join">连接串</param>
        /// <returns>字符串</returns>
        public static string joinString(this list<ushort> list, string join)
        {
            return string.Join(join, getString(list));
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="list">数据集合</param>
        /// <param name="join">连接串</param>
        /// <returns>字符串</returns>
        public static string joinString(this list<ushort> list, char join)
        {
            return getString(list).joinString(join);
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 可枚举相关扩展
    /// </summary>
    public static partial class iEnumerable
    {
        /// <summary>
        /// 求和
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">数据集合</param>
        /// <param name="getValue">数值获取器</param>
        /// <returns>数值求和</returns>
        public static short sum<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, short> getValue)
        {
            if (getValue == null) log.Default.Throw(log.exceptionType.Null);
            short value = 0;
            if (values != null)
            {
                foreach (valueType nextValue in values) value += getValue(nextValue);
            }
            return value;
        }
        /// <summary>
        /// 求和
        /// </summary>
        /// <param name="values">数值集合</param>
        /// <returns>数值求和</returns>
        public static short sum(this System.Collections.Generic.IEnumerable<short> values)
        {
            if (values != null)
            {
                short value = 0;
                foreach (short nextValue in values) value += nextValue;
                return value;
            }
            return 0;
        }
        /// <summary>
        /// 分组求和
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">数据集合</param>
        /// <returns>分组求和</returns>
        public static System.Collections.Generic.Dictionary<valueType, short> groupSum<valueType>
            (this System.Collections.Generic.IEnumerable<keyValue<valueType, short>> values)
        {
            if (values != null)
            {
                short sum;
                System.Collections.Generic.Dictionary<valueType, short> sums
                    = new System.Collections.Generic.Dictionary<valueType, short>();
                foreach (keyValue<valueType,short> value in values)
                {
                    if (sums.TryGetValue(value.Key, out sum)) sums[value.Key] = (short)(sum + value.Value);
                    else sums.Add(value.Key, value.Value);
                }
                return sums;
            }
            return null;
        }
        /// <summary>
        /// 分组求和
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="keyType">分组键值类型</typeparam>
        /// <param name="values">数据集合</param>
        /// <param name="getKey">键值获取器</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>分组求和</returns>
        public static System.Collections.Generic.Dictionary<keyType, short> groupSum<valueType, keyType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, keyType> getKey
            , func<valueType, short> getValue)
        {
            if (values != null)
            {
                if (getKey == null || getValue == null) log.Default.Throw(log.exceptionType.Null);
                short sum;
                System.Collections.Generic.Dictionary<keyType, short> sums
                    = new System.Collections.Generic.Dictionary<keyType, short>();
                foreach (valueType value in values)
                {
                    keyType key = getKey(value);
                    if (sums.TryGetValue(key, out sum)) sums[key] = (short)(sum + getValue(value));
                    else sums.Add(key, getValue(value));
                }
                return sums;
            }
            return null;
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="values">数据集合</param>
        /// <returns>字符串</returns>
        public static list<string> getString(this System.Collections.Generic.IEnumerable<short> values)
        {
            if (values != null)
            {
                list<string> newValues = new list<string>();
                foreach (short nextValue in values) newValues.Add(number.toString(nextValue));
                return newValues;
            }
            return null;
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="values">数据集合</param>
        /// <returns>字符串</returns>
        public static string joinString(this System.Collections.Generic.IEnumerable<short> values)
        {
            return string.Concat(getString(values).toArray());
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="values">数据集合</param>
        /// <param name="join">连接串</param>
        /// <returns>字符串</returns>
        public static string joinString(this System.Collections.Generic.IEnumerable<short> values, string join)
        {
            return string.Join(join, getString(values).toArray());
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="values">数据集合</param>
        /// <param name="join">连接串</param>
        /// <returns>字符串</returns>
        public static string joinString(this System.Collections.Generic.IEnumerable<short> values, char join)
        {
            return getString(values).toArray().joinString(join);
        }
    }
    /// <summary>
    /// 集合相关扩展
    /// </summary>
    public static partial class iCollection
    {
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="values">数据集合</param>
        /// <returns>字符串</returns>
        public static string[] getString(this System.Collections.Generic.ICollection<short> values)
        {
            if (values.count() != 0)
            {
                string[] newValues = new string[values.Count];
                int index = 0;
                foreach (short nextValue in values) newValues[index++] = number.toString(nextValue);
                return newValues;
            }
            return nullValue<string>.Array;
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="values">数据集合</param>
        /// <returns>字符串</returns>
        public static string joinString(this System.Collections.Generic.ICollection<short> values)
        {
            return string.Concat(getString(values));
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="values">数据集合</param>
        /// <param name="join">连接串</param>
        /// <returns>字符串</returns>
        public static string joinString(this System.Collections.Generic.ICollection<short> values, string join)
        {
            return string.Join(join, getString(values));
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="values">数据集合</param>
        /// <param name="join">连接串</param>
        /// <returns>字符串</returns>
        public static string joinString(this System.Collections.Generic.ICollection<short> values, char join)
        {
            return getString(values).joinString(join);
        }
    }
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 求和
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据集合</param>
        /// <param name="getValue">数值获取器</param>
        /// <returns>数值求和</returns>
        public static short sum<valueType>(this valueType[] array, func<valueType, short> getValue)
        {
            short sum = 0;
            if (array != null)
            {
                if (getValue == null) log.Default.Throw(log.exceptionType.Null);
                foreach (valueType value in array) sum += getValue(value);
            }
            return sum;
        }
        /// <summary>
        /// 求和
        /// </summary>
        /// <param name="array">数据集合</param>
        /// <returns>数值求和</returns>
        public unsafe static short sum(this short[] array)
        {
            if (array != null)
            {
                short value = 0;
                fixed (short* valueFixed = array)
                {
                    for (short* start = valueFixed, end = valueFixed + array.Length; start != end; value += *start++) ;
                }
                return value;
            }
            return 0;
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="array">数据集合</param>
        /// <returns>字符串</returns>
        public unsafe static string[] getString(this short[] array)
        {
            if (array.length() != 0)
            {
                string[] newValues = new string[array.Length];
                fixed (short* valueFixed = array)
                {
                    short* readValue = valueFixed;
                    for (int index = 0; index != newValues.Length; ++index)
                    {
                        newValues[index] = number.toString(*readValue++);
                    }
                }
                return newValues;
            }
            return nullValue<string>.Array;
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="array">数据集合</param>
        /// <returns>字符串</returns>
        public unsafe static string[] getString(this short[] array, int index, int count)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                string[] newValues = new string[count];
                fixed (short* valueFixed = array)
                {
                    short* readValue = valueFixed + range.SkipCount;
                    for (index = 0; index != count; newValues[index++] = number.toString(*readValue++)) ;
                }
                return newValues;
            }
            return nullValue<string>.Array;
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="array">数据集合</param>
        /// <returns>字符串</returns>
        public static string joinString(this short[] array)
        {
            return string.Concat(getString(array));
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="array">数据集合</param>
        /// <param name="join">连接串</param>
        /// <returns>字符串</returns>
        public static string joinString(this short[] array, string join)
        {
            return string.Join(join, getString(array));
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="array">数据集合</param>
        /// <param name="join">连接串</param>
        /// <returns>字符串</returns>
        public static string joinString(this short[] array, char join)
        {
            return getString(array).joinString(join);
        }
    }
    /// <summary>
    /// 单向动态数组扩展
    /// </summary>
    public static partial class list
    {
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="list">数据集合</param>
        /// <returns>字符串</returns>
        public static string[] getString(this list<short> list)
        {
            return list.count() != 0 ? list.Unsafer.Array.getString(0, list.Count) : nullValue<string>.Array;
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="list">数据集合</param>
        /// <returns>字符串</returns>
        public static string joinString(this list<short> list)
        {
            return string.Concat(getString(list));
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="list">数据集合</param>
        /// <param name="join">连接串</param>
        /// <returns>字符串</returns>
        public static string joinString(this list<short> list, string join)
        {
            return string.Join(join, getString(list));
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="list">数据集合</param>
        /// <param name="join">连接串</param>
        /// <returns>字符串</returns>
        public static string joinString(this list<short> list, char join)
        {
            return getString(list).joinString(join);
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 可枚举相关扩展
    /// </summary>
    public static partial class iEnumerable
    {
        /// <summary>
        /// 求和
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">数据集合</param>
        /// <param name="getValue">数值获取器</param>
        /// <returns>数值求和</returns>
        public static byte sum<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, byte> getValue)
        {
            if (getValue == null) log.Default.Throw(log.exceptionType.Null);
            byte value = 0;
            if (values != null)
            {
                foreach (valueType nextValue in values) value += getValue(nextValue);
            }
            return value;
        }
        /// <summary>
        /// 求和
        /// </summary>
        /// <param name="values">数值集合</param>
        /// <returns>数值求和</returns>
        public static byte sum(this System.Collections.Generic.IEnumerable<byte> values)
        {
            if (values != null)
            {
                byte value = 0;
                foreach (byte nextValue in values) value += nextValue;
                return value;
            }
            return 0;
        }
        /// <summary>
        /// 分组求和
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">数据集合</param>
        /// <returns>分组求和</returns>
        public static System.Collections.Generic.Dictionary<valueType, byte> groupSum<valueType>
            (this System.Collections.Generic.IEnumerable<keyValue<valueType, byte>> values)
        {
            if (values != null)
            {
                byte sum;
                System.Collections.Generic.Dictionary<valueType, byte> sums
                    = new System.Collections.Generic.Dictionary<valueType, byte>();
                foreach (keyValue<valueType,byte> value in values)
                {
                    if (sums.TryGetValue(value.Key, out sum)) sums[value.Key] = (byte)(sum + value.Value);
                    else sums.Add(value.Key, value.Value);
                }
                return sums;
            }
            return null;
        }
        /// <summary>
        /// 分组求和
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="keyType">分组键值类型</typeparam>
        /// <param name="values">数据集合</param>
        /// <param name="getKey">键值获取器</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>分组求和</returns>
        public static System.Collections.Generic.Dictionary<keyType, byte> groupSum<valueType, keyType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, keyType> getKey
            , func<valueType, byte> getValue)
        {
            if (values != null)
            {
                if (getKey == null || getValue == null) log.Default.Throw(log.exceptionType.Null);
                byte sum;
                System.Collections.Generic.Dictionary<keyType, byte> sums
                    = new System.Collections.Generic.Dictionary<keyType, byte>();
                foreach (valueType value in values)
                {
                    keyType key = getKey(value);
                    if (sums.TryGetValue(key, out sum)) sums[key] = (byte)(sum + getValue(value));
                    else sums.Add(key, getValue(value));
                }
                return sums;
            }
            return null;
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="values">数据集合</param>
        /// <returns>字符串</returns>
        public static list<string> getString(this System.Collections.Generic.IEnumerable<byte> values)
        {
            if (values != null)
            {
                list<string> newValues = new list<string>();
                foreach (byte nextValue in values) newValues.Add(number.toString(nextValue));
                return newValues;
            }
            return null;
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="values">数据集合</param>
        /// <returns>字符串</returns>
        public static string joinString(this System.Collections.Generic.IEnumerable<byte> values)
        {
            return string.Concat(getString(values).toArray());
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="values">数据集合</param>
        /// <param name="join">连接串</param>
        /// <returns>字符串</returns>
        public static string joinString(this System.Collections.Generic.IEnumerable<byte> values, string join)
        {
            return string.Join(join, getString(values).toArray());
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="values">数据集合</param>
        /// <param name="join">连接串</param>
        /// <returns>字符串</returns>
        public static string joinString(this System.Collections.Generic.IEnumerable<byte> values, char join)
        {
            return getString(values).toArray().joinString(join);
        }
    }
    /// <summary>
    /// 集合相关扩展
    /// </summary>
    public static partial class iCollection
    {
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="values">数据集合</param>
        /// <returns>字符串</returns>
        public static string[] getString(this System.Collections.Generic.ICollection<byte> values)
        {
            if (values.count() != 0)
            {
                string[] newValues = new string[values.Count];
                int index = 0;
                foreach (byte nextValue in values) newValues[index++] = number.toString(nextValue);
                return newValues;
            }
            return nullValue<string>.Array;
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="values">数据集合</param>
        /// <returns>字符串</returns>
        public static string joinString(this System.Collections.Generic.ICollection<byte> values)
        {
            return string.Concat(getString(values));
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="values">数据集合</param>
        /// <param name="join">连接串</param>
        /// <returns>字符串</returns>
        public static string joinString(this System.Collections.Generic.ICollection<byte> values, string join)
        {
            return string.Join(join, getString(values));
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="values">数据集合</param>
        /// <param name="join">连接串</param>
        /// <returns>字符串</returns>
        public static string joinString(this System.Collections.Generic.ICollection<byte> values, char join)
        {
            return getString(values).joinString(join);
        }
    }
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 求和
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据集合</param>
        /// <param name="getValue">数值获取器</param>
        /// <returns>数值求和</returns>
        public static byte sum<valueType>(this valueType[] array, func<valueType, byte> getValue)
        {
            byte sum = 0;
            if (array != null)
            {
                if (getValue == null) log.Default.Throw(log.exceptionType.Null);
                foreach (valueType value in array) sum += getValue(value);
            }
            return sum;
        }
        /// <summary>
        /// 求和
        /// </summary>
        /// <param name="array">数据集合</param>
        /// <returns>数值求和</returns>
        public unsafe static byte sum(this byte[] array)
        {
            if (array != null)
            {
                byte value = 0;
                fixed (byte* valueFixed = array)
                {
                    for (byte* start = valueFixed, end = valueFixed + array.Length; start != end; value += *start++) ;
                }
                return value;
            }
            return 0;
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="array">数据集合</param>
        /// <returns>字符串</returns>
        public unsafe static string[] getString(this byte[] array)
        {
            if (array.length() != 0)
            {
                string[] newValues = new string[array.Length];
                fixed (byte* valueFixed = array)
                {
                    byte* readValue = valueFixed;
                    for (int index = 0; index != newValues.Length; ++index)
                    {
                        newValues[index] = number.toString(*readValue++);
                    }
                }
                return newValues;
            }
            return nullValue<string>.Array;
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="array">数据集合</param>
        /// <returns>字符串</returns>
        public unsafe static string[] getString(this byte[] array, int index, int count)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                string[] newValues = new string[count];
                fixed (byte* valueFixed = array)
                {
                    byte* readValue = valueFixed + range.SkipCount;
                    for (index = 0; index != count; newValues[index++] = number.toString(*readValue++)) ;
                }
                return newValues;
            }
            return nullValue<string>.Array;
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="array">数据集合</param>
        /// <returns>字符串</returns>
        public static string joinString(this byte[] array)
        {
            return string.Concat(getString(array));
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="array">数据集合</param>
        /// <param name="join">连接串</param>
        /// <returns>字符串</returns>
        public static string joinString(this byte[] array, string join)
        {
            return string.Join(join, getString(array));
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="array">数据集合</param>
        /// <param name="join">连接串</param>
        /// <returns>字符串</returns>
        public static string joinString(this byte[] array, char join)
        {
            return getString(array).joinString(join);
        }
    }
    /// <summary>
    /// 单向动态数组扩展
    /// </summary>
    public static partial class list
    {
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="list">数据集合</param>
        /// <returns>字符串</returns>
        public static string[] getString(this list<byte> list)
        {
            return list.count() != 0 ? list.Unsafer.Array.getString(0, list.Count) : nullValue<string>.Array;
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="list">数据集合</param>
        /// <returns>字符串</returns>
        public static string joinString(this list<byte> list)
        {
            return string.Concat(getString(list));
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="list">数据集合</param>
        /// <param name="join">连接串</param>
        /// <returns>字符串</returns>
        public static string joinString(this list<byte> list, string join)
        {
            return string.Join(join, getString(list));
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="list">数据集合</param>
        /// <param name="join">连接串</param>
        /// <returns>字符串</returns>
        public static string joinString(this list<byte> list, char join)
        {
            return getString(list).joinString(join);
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 可枚举相关扩展
    /// </summary>
    public static partial class iEnumerable
    {
        /// <summary>
        /// 求和
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">数据集合</param>
        /// <param name="getValue">数值获取器</param>
        /// <returns>数值求和</returns>
        public static sbyte sum<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, sbyte> getValue)
        {
            if (getValue == null) log.Default.Throw(log.exceptionType.Null);
            sbyte value = 0;
            if (values != null)
            {
                foreach (valueType nextValue in values) value += getValue(nextValue);
            }
            return value;
        }
        /// <summary>
        /// 求和
        /// </summary>
        /// <param name="values">数值集合</param>
        /// <returns>数值求和</returns>
        public static sbyte sum(this System.Collections.Generic.IEnumerable<sbyte> values)
        {
            if (values != null)
            {
                sbyte value = 0;
                foreach (sbyte nextValue in values) value += nextValue;
                return value;
            }
            return 0;
        }
        /// <summary>
        /// 分组求和
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">数据集合</param>
        /// <returns>分组求和</returns>
        public static System.Collections.Generic.Dictionary<valueType, sbyte> groupSum<valueType>
            (this System.Collections.Generic.IEnumerable<keyValue<valueType, sbyte>> values)
        {
            if (values != null)
            {
                sbyte sum;
                System.Collections.Generic.Dictionary<valueType, sbyte> sums
                    = new System.Collections.Generic.Dictionary<valueType, sbyte>();
                foreach (keyValue<valueType,sbyte> value in values)
                {
                    if (sums.TryGetValue(value.Key, out sum)) sums[value.Key] = (sbyte)(sum + value.Value);
                    else sums.Add(value.Key, value.Value);
                }
                return sums;
            }
            return null;
        }
        /// <summary>
        /// 分组求和
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="keyType">分组键值类型</typeparam>
        /// <param name="values">数据集合</param>
        /// <param name="getKey">键值获取器</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>分组求和</returns>
        public static System.Collections.Generic.Dictionary<keyType, sbyte> groupSum<valueType, keyType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, keyType> getKey
            , func<valueType, sbyte> getValue)
        {
            if (values != null)
            {
                if (getKey == null || getValue == null) log.Default.Throw(log.exceptionType.Null);
                sbyte sum;
                System.Collections.Generic.Dictionary<keyType, sbyte> sums
                    = new System.Collections.Generic.Dictionary<keyType, sbyte>();
                foreach (valueType value in values)
                {
                    keyType key = getKey(value);
                    if (sums.TryGetValue(key, out sum)) sums[key] = (sbyte)(sum + getValue(value));
                    else sums.Add(key, getValue(value));
                }
                return sums;
            }
            return null;
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="values">数据集合</param>
        /// <returns>字符串</returns>
        public static list<string> getString(this System.Collections.Generic.IEnumerable<sbyte> values)
        {
            if (values != null)
            {
                list<string> newValues = new list<string>();
                foreach (sbyte nextValue in values) newValues.Add(number.toString(nextValue));
                return newValues;
            }
            return null;
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="values">数据集合</param>
        /// <returns>字符串</returns>
        public static string joinString(this System.Collections.Generic.IEnumerable<sbyte> values)
        {
            return string.Concat(getString(values).toArray());
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="values">数据集合</param>
        /// <param name="join">连接串</param>
        /// <returns>字符串</returns>
        public static string joinString(this System.Collections.Generic.IEnumerable<sbyte> values, string join)
        {
            return string.Join(join, getString(values).toArray());
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="values">数据集合</param>
        /// <param name="join">连接串</param>
        /// <returns>字符串</returns>
        public static string joinString(this System.Collections.Generic.IEnumerable<sbyte> values, char join)
        {
            return getString(values).toArray().joinString(join);
        }
    }
    /// <summary>
    /// 集合相关扩展
    /// </summary>
    public static partial class iCollection
    {
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="values">数据集合</param>
        /// <returns>字符串</returns>
        public static string[] getString(this System.Collections.Generic.ICollection<sbyte> values)
        {
            if (values.count() != 0)
            {
                string[] newValues = new string[values.Count];
                int index = 0;
                foreach (sbyte nextValue in values) newValues[index++] = number.toString(nextValue);
                return newValues;
            }
            return nullValue<string>.Array;
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="values">数据集合</param>
        /// <returns>字符串</returns>
        public static string joinString(this System.Collections.Generic.ICollection<sbyte> values)
        {
            return string.Concat(getString(values));
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="values">数据集合</param>
        /// <param name="join">连接串</param>
        /// <returns>字符串</returns>
        public static string joinString(this System.Collections.Generic.ICollection<sbyte> values, string join)
        {
            return string.Join(join, getString(values));
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="values">数据集合</param>
        /// <param name="join">连接串</param>
        /// <returns>字符串</returns>
        public static string joinString(this System.Collections.Generic.ICollection<sbyte> values, char join)
        {
            return getString(values).joinString(join);
        }
    }
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 求和
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据集合</param>
        /// <param name="getValue">数值获取器</param>
        /// <returns>数值求和</returns>
        public static sbyte sum<valueType>(this valueType[] array, func<valueType, sbyte> getValue)
        {
            sbyte sum = 0;
            if (array != null)
            {
                if (getValue == null) log.Default.Throw(log.exceptionType.Null);
                foreach (valueType value in array) sum += getValue(value);
            }
            return sum;
        }
        /// <summary>
        /// 求和
        /// </summary>
        /// <param name="array">数据集合</param>
        /// <returns>数值求和</returns>
        public unsafe static sbyte sum(this sbyte[] array)
        {
            if (array != null)
            {
                sbyte value = 0;
                fixed (sbyte* valueFixed = array)
                {
                    for (sbyte* start = valueFixed, end = valueFixed + array.Length; start != end; value += *start++) ;
                }
                return value;
            }
            return 0;
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="array">数据集合</param>
        /// <returns>字符串</returns>
        public unsafe static string[] getString(this sbyte[] array)
        {
            if (array.length() != 0)
            {
                string[] newValues = new string[array.Length];
                fixed (sbyte* valueFixed = array)
                {
                    sbyte* readValue = valueFixed;
                    for (int index = 0; index != newValues.Length; ++index)
                    {
                        newValues[index] = number.toString(*readValue++);
                    }
                }
                return newValues;
            }
            return nullValue<string>.Array;
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="array">数据集合</param>
        /// <returns>字符串</returns>
        public unsafe static string[] getString(this sbyte[] array, int index, int count)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                string[] newValues = new string[count];
                fixed (sbyte* valueFixed = array)
                {
                    sbyte* readValue = valueFixed + range.SkipCount;
                    for (index = 0; index != count; newValues[index++] = number.toString(*readValue++)) ;
                }
                return newValues;
            }
            return nullValue<string>.Array;
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="array">数据集合</param>
        /// <returns>字符串</returns>
        public static string joinString(this sbyte[] array)
        {
            return string.Concat(getString(array));
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="array">数据集合</param>
        /// <param name="join">连接串</param>
        /// <returns>字符串</returns>
        public static string joinString(this sbyte[] array, string join)
        {
            return string.Join(join, getString(array));
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="array">数据集合</param>
        /// <param name="join">连接串</param>
        /// <returns>字符串</returns>
        public static string joinString(this sbyte[] array, char join)
        {
            return getString(array).joinString(join);
        }
    }
    /// <summary>
    /// 单向动态数组扩展
    /// </summary>
    public static partial class list
    {
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="list">数据集合</param>
        /// <returns>字符串</returns>
        public static string[] getString(this list<sbyte> list)
        {
            return list.count() != 0 ? list.Unsafer.Array.getString(0, list.Count) : nullValue<string>.Array;
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="list">数据集合</param>
        /// <returns>字符串</returns>
        public static string joinString(this list<sbyte> list)
        {
            return string.Concat(getString(list));
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="list">数据集合</param>
        /// <param name="join">连接串</param>
        /// <returns>字符串</returns>
        public static string joinString(this list<sbyte> list, string join)
        {
            return string.Join(join, getString(list));
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="list">数据集合</param>
        /// <param name="join">连接串</param>
        /// <returns>字符串</returns>
        public static string joinString(this list<sbyte> list, char join)
        {
            return getString(list).joinString(join);
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 可枚举相关扩展
    /// </summary>
    public static partial class iEnumerable
    {
        /// <summary>
        /// 求和
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">数据集合</param>
        /// <param name="getValue">数值获取器</param>
        /// <returns>数值求和</returns>
        public static double sum<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, double> getValue)
        {
            if (getValue == null) log.Default.Throw(log.exceptionType.Null);
            double value = 0;
            if (values != null)
            {
                foreach (valueType nextValue in values) value += getValue(nextValue);
            }
            return value;
        }
        /// <summary>
        /// 求和
        /// </summary>
        /// <param name="values">数值集合</param>
        /// <returns>数值求和</returns>
        public static double sum(this System.Collections.Generic.IEnumerable<double> values)
        {
            if (values != null)
            {
                double value = 0;
                foreach (double nextValue in values) value += nextValue;
                return value;
            }
            return 0;
        }
        /// <summary>
        /// 分组求和
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">数据集合</param>
        /// <returns>分组求和</returns>
        public static System.Collections.Generic.Dictionary<valueType, double> groupSum<valueType>
            (this System.Collections.Generic.IEnumerable<keyValue<valueType, double>> values)
        {
            if (values != null)
            {
                double sum;
                System.Collections.Generic.Dictionary<valueType, double> sums
                    = new System.Collections.Generic.Dictionary<valueType, double>();
                foreach (keyValue<valueType,double> value in values)
                {
                    if (sums.TryGetValue(value.Key, out sum)) sums[value.Key] = (double)(sum + value.Value);
                    else sums.Add(value.Key, value.Value);
                }
                return sums;
            }
            return null;
        }
        /// <summary>
        /// 分组求和
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="keyType">分组键值类型</typeparam>
        /// <param name="values">数据集合</param>
        /// <param name="getKey">键值获取器</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>分组求和</returns>
        public static System.Collections.Generic.Dictionary<keyType, double> groupSum<valueType, keyType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, keyType> getKey
            , func<valueType, double> getValue)
        {
            if (values != null)
            {
                if (getKey == null || getValue == null) log.Default.Throw(log.exceptionType.Null);
                double sum;
                System.Collections.Generic.Dictionary<keyType, double> sums
                    = new System.Collections.Generic.Dictionary<keyType, double>();
                foreach (valueType value in values)
                {
                    keyType key = getKey(value);
                    if (sums.TryGetValue(key, out sum)) sums[key] = (double)(sum + getValue(value));
                    else sums.Add(key, getValue(value));
                }
                return sums;
            }
            return null;
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="values">数据集合</param>
        /// <returns>字符串</returns>
        public static list<string> getString(this System.Collections.Generic.IEnumerable<double> values)
        {
            if (values != null)
            {
                list<string> newValues = new list<string>();
                foreach (double nextValue in values) newValues.Add(number.toString(nextValue));
                return newValues;
            }
            return null;
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="values">数据集合</param>
        /// <returns>字符串</returns>
        public static string joinString(this System.Collections.Generic.IEnumerable<double> values)
        {
            return string.Concat(getString(values).toArray());
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="values">数据集合</param>
        /// <param name="join">连接串</param>
        /// <returns>字符串</returns>
        public static string joinString(this System.Collections.Generic.IEnumerable<double> values, string join)
        {
            return string.Join(join, getString(values).toArray());
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="values">数据集合</param>
        /// <param name="join">连接串</param>
        /// <returns>字符串</returns>
        public static string joinString(this System.Collections.Generic.IEnumerable<double> values, char join)
        {
            return getString(values).toArray().joinString(join);
        }
    }
    /// <summary>
    /// 集合相关扩展
    /// </summary>
    public static partial class iCollection
    {
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="values">数据集合</param>
        /// <returns>字符串</returns>
        public static string[] getString(this System.Collections.Generic.ICollection<double> values)
        {
            if (values.count() != 0)
            {
                string[] newValues = new string[values.Count];
                int index = 0;
                foreach (double nextValue in values) newValues[index++] = number.toString(nextValue);
                return newValues;
            }
            return nullValue<string>.Array;
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="values">数据集合</param>
        /// <returns>字符串</returns>
        public static string joinString(this System.Collections.Generic.ICollection<double> values)
        {
            return string.Concat(getString(values));
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="values">数据集合</param>
        /// <param name="join">连接串</param>
        /// <returns>字符串</returns>
        public static string joinString(this System.Collections.Generic.ICollection<double> values, string join)
        {
            return string.Join(join, getString(values));
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="values">数据集合</param>
        /// <param name="join">连接串</param>
        /// <returns>字符串</returns>
        public static string joinString(this System.Collections.Generic.ICollection<double> values, char join)
        {
            return getString(values).joinString(join);
        }
    }
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 求和
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据集合</param>
        /// <param name="getValue">数值获取器</param>
        /// <returns>数值求和</returns>
        public static double sum<valueType>(this valueType[] array, func<valueType, double> getValue)
        {
            double sum = 0;
            if (array != null)
            {
                if (getValue == null) log.Default.Throw(log.exceptionType.Null);
                foreach (valueType value in array) sum += getValue(value);
            }
            return sum;
        }
        /// <summary>
        /// 求和
        /// </summary>
        /// <param name="array">数据集合</param>
        /// <returns>数值求和</returns>
        public unsafe static double sum(this double[] array)
        {
            if (array != null)
            {
                double value = 0;
                fixed (double* valueFixed = array)
                {
                    for (double* start = valueFixed, end = valueFixed + array.Length; start != end; value += *start++) ;
                }
                return value;
            }
            return 0;
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="array">数据集合</param>
        /// <returns>字符串</returns>
        public unsafe static string[] getString(this double[] array)
        {
            if (array.length() != 0)
            {
                string[] newValues = new string[array.Length];
                fixed (double* valueFixed = array)
                {
                    double* readValue = valueFixed;
                    for (int index = 0; index != newValues.Length; ++index)
                    {
                        newValues[index] = number.toString(*readValue++);
                    }
                }
                return newValues;
            }
            return nullValue<string>.Array;
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="array">数据集合</param>
        /// <returns>字符串</returns>
        public unsafe static string[] getString(this double[] array, int index, int count)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                string[] newValues = new string[count];
                fixed (double* valueFixed = array)
                {
                    double* readValue = valueFixed + range.SkipCount;
                    for (index = 0; index != count; newValues[index++] = number.toString(*readValue++)) ;
                }
                return newValues;
            }
            return nullValue<string>.Array;
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="array">数据集合</param>
        /// <returns>字符串</returns>
        public static string joinString(this double[] array)
        {
            return string.Concat(getString(array));
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="array">数据集合</param>
        /// <param name="join">连接串</param>
        /// <returns>字符串</returns>
        public static string joinString(this double[] array, string join)
        {
            return string.Join(join, getString(array));
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="array">数据集合</param>
        /// <param name="join">连接串</param>
        /// <returns>字符串</returns>
        public static string joinString(this double[] array, char join)
        {
            return getString(array).joinString(join);
        }
    }
    /// <summary>
    /// 单向动态数组扩展
    /// </summary>
    public static partial class list
    {
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="list">数据集合</param>
        /// <returns>字符串</returns>
        public static string[] getString(this list<double> list)
        {
            return list.count() != 0 ? list.Unsafer.Array.getString(0, list.Count) : nullValue<string>.Array;
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="list">数据集合</param>
        /// <returns>字符串</returns>
        public static string joinString(this list<double> list)
        {
            return string.Concat(getString(list));
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="list">数据集合</param>
        /// <param name="join">连接串</param>
        /// <returns>字符串</returns>
        public static string joinString(this list<double> list, string join)
        {
            return string.Join(join, getString(list));
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="list">数据集合</param>
        /// <param name="join">连接串</param>
        /// <returns>字符串</returns>
        public static string joinString(this list<double> list, char join)
        {
            return getString(list).joinString(join);
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 可枚举相关扩展
    /// </summary>
    public static partial class iEnumerable
    {
        /// <summary>
        /// 求和
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">数据集合</param>
        /// <param name="getValue">数值获取器</param>
        /// <returns>数值求和</returns>
        public static float sum<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, float> getValue)
        {
            if (getValue == null) log.Default.Throw(log.exceptionType.Null);
            float value = 0;
            if (values != null)
            {
                foreach (valueType nextValue in values) value += getValue(nextValue);
            }
            return value;
        }
        /// <summary>
        /// 求和
        /// </summary>
        /// <param name="values">数值集合</param>
        /// <returns>数值求和</returns>
        public static float sum(this System.Collections.Generic.IEnumerable<float> values)
        {
            if (values != null)
            {
                float value = 0;
                foreach (float nextValue in values) value += nextValue;
                return value;
            }
            return 0;
        }
        /// <summary>
        /// 分组求和
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">数据集合</param>
        /// <returns>分组求和</returns>
        public static System.Collections.Generic.Dictionary<valueType, float> groupSum<valueType>
            (this System.Collections.Generic.IEnumerable<keyValue<valueType, float>> values)
        {
            if (values != null)
            {
                float sum;
                System.Collections.Generic.Dictionary<valueType, float> sums
                    = new System.Collections.Generic.Dictionary<valueType, float>();
                foreach (keyValue<valueType,float> value in values)
                {
                    if (sums.TryGetValue(value.Key, out sum)) sums[value.Key] = (float)(sum + value.Value);
                    else sums.Add(value.Key, value.Value);
                }
                return sums;
            }
            return null;
        }
        /// <summary>
        /// 分组求和
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="keyType">分组键值类型</typeparam>
        /// <param name="values">数据集合</param>
        /// <param name="getKey">键值获取器</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>分组求和</returns>
        public static System.Collections.Generic.Dictionary<keyType, float> groupSum<valueType, keyType>
            (this System.Collections.Generic.IEnumerable<valueType> values, func<valueType, keyType> getKey
            , func<valueType, float> getValue)
        {
            if (values != null)
            {
                if (getKey == null || getValue == null) log.Default.Throw(log.exceptionType.Null);
                float sum;
                System.Collections.Generic.Dictionary<keyType, float> sums
                    = new System.Collections.Generic.Dictionary<keyType, float>();
                foreach (valueType value in values)
                {
                    keyType key = getKey(value);
                    if (sums.TryGetValue(key, out sum)) sums[key] = (float)(sum + getValue(value));
                    else sums.Add(key, getValue(value));
                }
                return sums;
            }
            return null;
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="values">数据集合</param>
        /// <returns>字符串</returns>
        public static list<string> getString(this System.Collections.Generic.IEnumerable<float> values)
        {
            if (values != null)
            {
                list<string> newValues = new list<string>();
                foreach (float nextValue in values) newValues.Add(number.toString(nextValue));
                return newValues;
            }
            return null;
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="values">数据集合</param>
        /// <returns>字符串</returns>
        public static string joinString(this System.Collections.Generic.IEnumerable<float> values)
        {
            return string.Concat(getString(values).toArray());
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="values">数据集合</param>
        /// <param name="join">连接串</param>
        /// <returns>字符串</returns>
        public static string joinString(this System.Collections.Generic.IEnumerable<float> values, string join)
        {
            return string.Join(join, getString(values).toArray());
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="values">数据集合</param>
        /// <param name="join">连接串</param>
        /// <returns>字符串</returns>
        public static string joinString(this System.Collections.Generic.IEnumerable<float> values, char join)
        {
            return getString(values).toArray().joinString(join);
        }
    }
    /// <summary>
    /// 集合相关扩展
    /// </summary>
    public static partial class iCollection
    {
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="values">数据集合</param>
        /// <returns>字符串</returns>
        public static string[] getString(this System.Collections.Generic.ICollection<float> values)
        {
            if (values.count() != 0)
            {
                string[] newValues = new string[values.Count];
                int index = 0;
                foreach (float nextValue in values) newValues[index++] = number.toString(nextValue);
                return newValues;
            }
            return nullValue<string>.Array;
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="values">数据集合</param>
        /// <returns>字符串</returns>
        public static string joinString(this System.Collections.Generic.ICollection<float> values)
        {
            return string.Concat(getString(values));
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="values">数据集合</param>
        /// <param name="join">连接串</param>
        /// <returns>字符串</returns>
        public static string joinString(this System.Collections.Generic.ICollection<float> values, string join)
        {
            return string.Join(join, getString(values));
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="values">数据集合</param>
        /// <param name="join">连接串</param>
        /// <returns>字符串</returns>
        public static string joinString(this System.Collections.Generic.ICollection<float> values, char join)
        {
            return getString(values).joinString(join);
        }
    }
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 求和
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据集合</param>
        /// <param name="getValue">数值获取器</param>
        /// <returns>数值求和</returns>
        public static float sum<valueType>(this valueType[] array, func<valueType, float> getValue)
        {
            float sum = 0;
            if (array != null)
            {
                if (getValue == null) log.Default.Throw(log.exceptionType.Null);
                foreach (valueType value in array) sum += getValue(value);
            }
            return sum;
        }
        /// <summary>
        /// 求和
        /// </summary>
        /// <param name="array">数据集合</param>
        /// <returns>数值求和</returns>
        public unsafe static float sum(this float[] array)
        {
            if (array != null)
            {
                float value = 0;
                fixed (float* valueFixed = array)
                {
                    for (float* start = valueFixed, end = valueFixed + array.Length; start != end; value += *start++) ;
                }
                return value;
            }
            return 0;
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="array">数据集合</param>
        /// <returns>字符串</returns>
        public unsafe static string[] getString(this float[] array)
        {
            if (array.length() != 0)
            {
                string[] newValues = new string[array.Length];
                fixed (float* valueFixed = array)
                {
                    float* readValue = valueFixed;
                    for (int index = 0; index != newValues.Length; ++index)
                    {
                        newValues[index] = number.toString(*readValue++);
                    }
                }
                return newValues;
            }
            return nullValue<string>.Array;
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="array">数据集合</param>
        /// <returns>字符串</returns>
        public unsafe static string[] getString(this float[] array, int index, int count)
        {
            array.range range = new array.range(array.length(), index, count);
            if ((count = range.GetCount) != 0)
            {
                string[] newValues = new string[count];
                fixed (float* valueFixed = array)
                {
                    float* readValue = valueFixed + range.SkipCount;
                    for (index = 0; index != count; newValues[index++] = number.toString(*readValue++)) ;
                }
                return newValues;
            }
            return nullValue<string>.Array;
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="array">数据集合</param>
        /// <returns>字符串</returns>
        public static string joinString(this float[] array)
        {
            return string.Concat(getString(array));
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="array">数据集合</param>
        /// <param name="join">连接串</param>
        /// <returns>字符串</returns>
        public static string joinString(this float[] array, string join)
        {
            return string.Join(join, getString(array));
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="array">数据集合</param>
        /// <param name="join">连接串</param>
        /// <returns>字符串</returns>
        public static string joinString(this float[] array, char join)
        {
            return getString(array).joinString(join);
        }
    }
    /// <summary>
    /// 单向动态数组扩展
    /// </summary>
    public static partial class list
    {
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="list">数据集合</param>
        /// <returns>字符串</returns>
        public static string[] getString(this list<float> list)
        {
            return list.count() != 0 ? list.Unsafer.Array.getString(0, list.Count) : nullValue<string>.Array;
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="list">数据集合</param>
        /// <returns>字符串</returns>
        public static string joinString(this list<float> list)
        {
            return string.Concat(getString(list));
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="list">数据集合</param>
        /// <param name="join">连接串</param>
        /// <returns>字符串</returns>
        public static string joinString(this list<float> list, string join)
        {
            return string.Join(join, getString(list));
        }
        /// <summary>
        /// 连接字符串
        /// </summary>
        /// <param name="list">数据集合</param>
        /// <param name="join">连接串</param>
        /// <returns>字符串</returns>
        public static string joinString(this list<float> list, char join)
        {
            return getString(list).joinString(join);
        }
    }
}

namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        private unsafe static void sortDesc
            (ulong* startIndex, ulong* endIndex)
        {
            do
            {
                ulong leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue < rightValue)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                ulong* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                ulong value = *averageIndex;
                if (leftValue < value)
                {
                    if (leftValue < rightValue)
                    {
                        *rightIndex = leftValue;
                        if (value < rightValue) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = value;
                        *averageIndex = value = leftValue;
                    }
                }
                else
                {
                    if (value < rightValue)
                    {
                        *rightIndex = value;
                        if (leftValue < rightValue)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = value = leftValue;
                        }
                        else *averageIndex = value = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                do
                {
                    while (*leftIndex > value) ++leftIndex;
                    while (value > *rightIndex) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sortDesc(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sortDesc(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        public unsafe static void SortDesc(ulong[] values)
        {
            if (values != null && values.Length > 1)
            {
                fixed (ulong* valueFixed = values)
                {
                    sortDesc(valueFixed, valueFixed + values.Length - 1);
                }
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static ulong[] GetSortDesc(ulong[] values)
        {
            if (values.length() != 0)
            {
                ulong[] newValue = new ulong[values.Length];
                Buffer.BlockCopy(values, 0, newValue, 0, values.Length * sizeof(ulong));
                fixed (ulong* newValueFixed = newValue, valueFixed = values)
                {
                    sortDesc(newValueFixed, newValueFixed + values.Length - 1);
                }
                return newValue;
            }
            return nullValue<ulong>.Array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        public unsafe static void SortDesc(ulong[] values, int startIndex, int count)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if (range.GetCount > 1)
            {
                fixed (ulong* valueFixed = values)
                {
                    sortDesc(valueFixed + range.SkipCount, valueFixed + range.EndIndex - 1);
                }
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static ulong[] GetSortDesc
            (ulong[] values, int startIndex, int count)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                ulong[] newValues = new ulong[count];
                Buffer.BlockCopy(values, range.SkipCount * sizeof(ulong), newValues, 0, count * sizeof(ulong));
                fixed (ulong* newValueFixed = newValues, valueFixed = values)
                {
                    if (--count > 0) sortDesc(newValueFixed, newValueFixed + count);
                }
                return newValues;
            }
            return nullValue<ulong>.Array;
        }
        /// <summary>
        /// 索引快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        private unsafe static void sortDesc
            (ulongSortIndex* startIndex, ulongSortIndex* endIndex)
        {
            do
            {
                ulongSortIndex leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue.Value < rightValue.Value)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                ulongSortIndex* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                ulongSortIndex indexValue = *averageIndex;
                if (leftValue.Value < indexValue.Value)
                {
                    if (leftValue.Value < rightValue.Value)
                    {
                        *rightIndex = leftValue;
                        if (indexValue.Value < rightValue.Value) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = indexValue;
                        *averageIndex = indexValue = leftValue;
                    }
                }
                else
                {
                    if (indexValue.Value < rightValue.Value)
                    {
                        *rightIndex = indexValue;
                        if (leftValue.Value < rightValue.Value)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = indexValue = leftValue;
                        }
                        else *averageIndex = indexValue = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                ulong value = indexValue.Value;
                do
                {
                    while ((*leftIndex).Value > value) ++leftIndex;
                    while (value > (*rightIndex).Value) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sortDesc(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sortDesc(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetSortDesc<valueType>
            (valueType[] values, func<valueType, ulong> getKey)
        {
            if (values.length() != 0)
            {
                if (values.Length > (config.pub.Default.StreamBufferLength >> 4))
                {
                    ulongSortIndex[] indexs = new ulongSortIndex[values.Length];
                    fixed (ulongSortIndex* fixedIndex = indexs)
                    {
                        return getSortDesc(values, getKey, fixedIndex);
                    }
                }
                else
                {
                    ulongSortIndex* fixedIndex = stackalloc ulongSortIndex[values.Length];
                    return getSortDesc(values, getKey, fixedIndex);
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getSortDesc<valueType>
            (valueType[] values, func<valueType, ulong> getKey, ulongSortIndex* fixedIndex)
        {
            ulongSortIndex* writeIndex = fixedIndex;
            if (values.Length > 1)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                for (int index = 0; index != values.Length; ++index)
                {
                    *writeIndex++ = new ulongSortIndex { Value = getKey(values[index]), Index = index };
                }
                sortDesc(writeIndex = fixedIndex, fixedIndex + values.Length - 1);
            }
            else *fixedIndex = new ulongSortIndex { Index = 0 };
            valueType[] newValues = new valueType[values.Length];
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetSortDesc<valueType>
            (valueType[] values, func<valueType, ulong> getKey, int startIndex, int count)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                if (count > (config.pub.Default.StreamBufferLength >> 4))
                {
                    ulongSortIndex[] indexs = new ulongSortIndex[count];
                    fixed (ulongSortIndex* fixedIndex = indexs)
                    {
                        return getSortDesc(values, getKey, range.SkipCount, count, fixedIndex);
                    }
                }
                else
                {
                    ulongSortIndex* fixedIndex = stackalloc ulongSortIndex[count];
                    return getSortDesc(values, getKey, range.SkipCount, count, fixedIndex);
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getSortDesc<valueType>
            (valueType[] values, func<valueType, ulong> getKey, int startIndex, int count
            , ulongSortIndex* fixedIndex)
        {
            ulongSortIndex* writeIndex = fixedIndex;
            if (count > 1)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                for (int index = startIndex, endIndex = startIndex + count; index != endIndex; ++index)
                {
                    *writeIndex++ = new ulongSortIndex { Value = getKey(values[index]), Index = index };
                }
                sortDesc(writeIndex = fixedIndex, fixedIndex + count - 1);
            }
            else *fixedIndex = new ulongSortIndex { Index = startIndex };
            valueType[] newValues = new valueType[count];
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的数组</returns>
        public static ulong[] sortDesc(this ulong[] array)
        {
            algorithm.quickSort.SortDesc(array);
            return array.notNull();
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        public static ulong[] getSortDesc(this ulong[] array)
        {
            return algorithm.quickSort.GetSortDesc(array);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的数组</returns>
        public static ulong[] sortDesc
            (this ulong[] array, int startIndex, int count)
        {
            algorithm.quickSort.SortDesc(array, startIndex, count);
            return array.notNull();
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的新数组</returns>
        public static ulong[] getSortDesc
            (this ulong[] array, int startIndex, int count)
        {
            return algorithm.quickSort.GetSortDesc(array, startIndex, count);
        }

        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <returns>排序后的数组</returns>
        public static valueType[] sortDesc<valueType>
            (this valueType[] array, func<valueType, ulong> getKey)
        {
            return algorithm.quickSort.GetSortDesc(array, getKey);
        }
        /// <summary>
        /// 排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的数组</returns>
        public static valueType[] sortDesc<valueType>
            (this valueType[] array, func<valueType, ulong> getKey, int startIndex, int count)
        {
            return algorithm.quickSort.GetSortDesc(array, getKey, startIndex, count);
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 单向动态数组扩展
    /// </summary>
    public static partial class list
    {
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <returns>排序后的单向动态数组</returns>
        public static list<ulong> sortDesc(this list<ulong> list)
        {
            if (list.count() != 0) algorithm.quickSort.SortDesc(list.Unsafer.Array, 0, list.Count);
            return list;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <returns>排序后新的单向动态数组</returns>
        public static ulong[] getSortDesc(this list<ulong> list)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.GetSortDesc(list.Unsafer.Array, 0, list.Count);
            }
            return nullValue<ulong>.Array;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的单向动态数组</returns>
        public static list<ulong> sortDesc
            (this list<ulong> list, int startIndex, int count)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                algorithm.quickSort.SortDesc(list.Unsafer.Array, range.SkipCount, count);
            }
            return list;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后新的单向动态数组</returns>
        public static ulong[] getSortDesc
            (this list<ulong> list, int startIndex, int count)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.GetSortDesc(list.Unsafer.Array, range.SkipCount, count);
            }
            return nullValue<ulong>.Array;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="getKey">排序键</param>
        /// <returns>排序后的新数组</returns>
        public static valueType[] sortDesc<valueType>
            (this list<valueType> list, func<valueType, ulong> getKey)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.GetSortDesc(list.Unsafer.Array, getKey, 0, list.Count);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的新数组</returns>
        public static valueType[] sortDesc<valueType>
            (this list<valueType> list, func<valueType, ulong> getKey, int startIndex, int count)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.GetSortDesc(list.Unsafer.Array, getKey, range.SkipCount, count);
            }
            return nullValue<valueType>.Array;
        }
    }
}


namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        private unsafe static void sort
            (long* startIndex, long* endIndex)
        {
            do
            {
                long leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue > rightValue)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                long* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                long value = *averageIndex;
                if (leftValue > value)
                {
                    if (leftValue > rightValue)
                    {
                        *rightIndex = leftValue;
                        if (value > rightValue) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = value;
                        *averageIndex = value = leftValue;
                    }
                }
                else
                {
                    if (value > rightValue)
                    {
                        *rightIndex = value;
                        if (leftValue > rightValue)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = value = leftValue;
                        }
                        else *averageIndex = value = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                do
                {
                    while (*leftIndex < value) ++leftIndex;
                    while (value < *rightIndex) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sort(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sort(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        public unsafe static void Sort(long[] values)
        {
            if (values != null && values.Length > 1)
            {
                fixed (long* valueFixed = values)
                {
                    sort(valueFixed, valueFixed + values.Length - 1);
                }
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static long[] GetSort(long[] values)
        {
            if (values.length() != 0)
            {
                long[] newValue = new long[values.Length];
                Buffer.BlockCopy(values, 0, newValue, 0, values.Length * sizeof(long));
                fixed (long* newValueFixed = newValue, valueFixed = values)
                {
                    sort(newValueFixed, newValueFixed + values.Length - 1);
                }
                return newValue;
            }
            return nullValue<long>.Array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        public unsafe static void Sort(long[] values, int startIndex, int count)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if (range.GetCount > 1)
            {
                fixed (long* valueFixed = values)
                {
                    sort(valueFixed + range.SkipCount, valueFixed + range.EndIndex - 1);
                }
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static long[] GetSort
            (long[] values, int startIndex, int count)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                long[] newValues = new long[count];
                Buffer.BlockCopy(values, range.SkipCount * sizeof(long), newValues, 0, count * sizeof(long));
                fixed (long* newValueFixed = newValues, valueFixed = values)
                {
                    if (--count > 0) sort(newValueFixed, newValueFixed + count);
                }
                return newValues;
            }
            return nullValue<long>.Array;
        }
        /// <summary>
        /// 索引快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        private unsafe static void sort
            (longSortIndex* startIndex, longSortIndex* endIndex)
        {
            do
            {
                longSortIndex leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue.Value > rightValue.Value)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                longSortIndex* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                longSortIndex indexValue = *averageIndex;
                if (leftValue.Value > indexValue.Value)
                {
                    if (leftValue.Value > rightValue.Value)
                    {
                        *rightIndex = leftValue;
                        if (indexValue.Value > rightValue.Value) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = indexValue;
                        *averageIndex = indexValue = leftValue;
                    }
                }
                else
                {
                    if (indexValue.Value > rightValue.Value)
                    {
                        *rightIndex = indexValue;
                        if (leftValue.Value > rightValue.Value)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = indexValue = leftValue;
                        }
                        else *averageIndex = indexValue = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                long value = indexValue.Value;
                do
                {
                    while ((*leftIndex).Value < value) ++leftIndex;
                    while (value < (*rightIndex).Value) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sort(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sort(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetSort<valueType>
            (valueType[] values, func<valueType, long> getKey)
        {
            if (values.length() != 0)
            {
                if (values.Length > (config.pub.Default.StreamBufferLength >> 4))
                {
                    longSortIndex[] indexs = new longSortIndex[values.Length];
                    fixed (longSortIndex* fixedIndex = indexs)
                    {
                        return getSort(values, getKey, fixedIndex);
                    }
                }
                else
                {
                    longSortIndex* fixedIndex = stackalloc longSortIndex[values.Length];
                    return getSort(values, getKey, fixedIndex);
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getSort<valueType>
            (valueType[] values, func<valueType, long> getKey, longSortIndex* fixedIndex)
        {
            longSortIndex* writeIndex = fixedIndex;
            if (values.Length > 1)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                for (int index = 0; index != values.Length; ++index)
                {
                    *writeIndex++ = new longSortIndex { Value = getKey(values[index]), Index = index };
                }
                sort(writeIndex = fixedIndex, fixedIndex + values.Length - 1);
            }
            else *fixedIndex = new longSortIndex { Index = 0 };
            valueType[] newValues = new valueType[values.Length];
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetSort<valueType>
            (valueType[] values, func<valueType, long> getKey, int startIndex, int count)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                if (count > (config.pub.Default.StreamBufferLength >> 4))
                {
                    longSortIndex[] indexs = new longSortIndex[count];
                    fixed (longSortIndex* fixedIndex = indexs)
                    {
                        return getSort(values, getKey, range.SkipCount, count, fixedIndex);
                    }
                }
                else
                {
                    longSortIndex* fixedIndex = stackalloc longSortIndex[count];
                    return getSort(values, getKey, range.SkipCount, count, fixedIndex);
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getSort<valueType>
            (valueType[] values, func<valueType, long> getKey, int startIndex, int count
            , longSortIndex* fixedIndex)
        {
            longSortIndex* writeIndex = fixedIndex;
            if (count > 1)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                for (int index = startIndex, endIndex = startIndex + count; index != endIndex; ++index)
                {
                    *writeIndex++ = new longSortIndex { Value = getKey(values[index]), Index = index };
                }
                sort(writeIndex = fixedIndex, fixedIndex + count - 1);
            }
            else *fixedIndex = new longSortIndex { Index = startIndex };
            valueType[] newValues = new valueType[count];
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的数组</returns>
        public static long[] sort(this long[] array)
        {
            algorithm.quickSort.Sort(array);
            return array.notNull();
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        public static long[] getSort(this long[] array)
        {
            return algorithm.quickSort.GetSort(array);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的数组</returns>
        public static long[] sort
            (this long[] array, int startIndex, int count)
        {
            algorithm.quickSort.Sort(array, startIndex, count);
            return array.notNull();
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的新数组</returns>
        public static long[] getSort
            (this long[] array, int startIndex, int count)
        {
            return algorithm.quickSort.GetSort(array, startIndex, count);
        }

        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <returns>排序后的数组</returns>
        public static valueType[] sort<valueType>
            (this valueType[] array, func<valueType, long> getKey)
        {
            return algorithm.quickSort.GetSort(array, getKey);
        }
        /// <summary>
        /// 排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的数组</returns>
        public static valueType[] sort<valueType>
            (this valueType[] array, func<valueType, long> getKey, int startIndex, int count)
        {
            return algorithm.quickSort.GetSort(array, getKey, startIndex, count);
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 单向动态数组扩展
    /// </summary>
    public static partial class list
    {
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <returns>排序后的单向动态数组</returns>
        public static list<long> sort(this list<long> list)
        {
            if (list.count() != 0) algorithm.quickSort.Sort(list.Unsafer.Array, 0, list.Count);
            return list;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <returns>排序后新的单向动态数组</returns>
        public static long[] getSort(this list<long> list)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.GetSort(list.Unsafer.Array, 0, list.Count);
            }
            return nullValue<long>.Array;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的单向动态数组</returns>
        public static list<long> sort
            (this list<long> list, int startIndex, int count)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                algorithm.quickSort.Sort(list.Unsafer.Array, range.SkipCount, count);
            }
            return list;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后新的单向动态数组</returns>
        public static long[] getSort
            (this list<long> list, int startIndex, int count)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.GetSort(list.Unsafer.Array, range.SkipCount, count);
            }
            return nullValue<long>.Array;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="getKey">排序键</param>
        /// <returns>排序后的新数组</returns>
        public static valueType[] sort<valueType>
            (this list<valueType> list, func<valueType, long> getKey)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.GetSort(list.Unsafer.Array, getKey, 0, list.Count);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的新数组</returns>
        public static valueType[] sort<valueType>
            (this list<valueType> list, func<valueType, long> getKey, int startIndex, int count)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.GetSort(list.Unsafer.Array, getKey, range.SkipCount, count);
            }
            return nullValue<valueType>.Array;
        }
    }
}


namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        private unsafe static void sortDesc
            (long* startIndex, long* endIndex)
        {
            do
            {
                long leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue < rightValue)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                long* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                long value = *averageIndex;
                if (leftValue < value)
                {
                    if (leftValue < rightValue)
                    {
                        *rightIndex = leftValue;
                        if (value < rightValue) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = value;
                        *averageIndex = value = leftValue;
                    }
                }
                else
                {
                    if (value < rightValue)
                    {
                        *rightIndex = value;
                        if (leftValue < rightValue)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = value = leftValue;
                        }
                        else *averageIndex = value = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                do
                {
                    while (*leftIndex > value) ++leftIndex;
                    while (value > *rightIndex) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sortDesc(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sortDesc(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        public unsafe static void SortDesc(long[] values)
        {
            if (values != null && values.Length > 1)
            {
                fixed (long* valueFixed = values)
                {
                    sortDesc(valueFixed, valueFixed + values.Length - 1);
                }
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static long[] GetSortDesc(long[] values)
        {
            if (values.length() != 0)
            {
                long[] newValue = new long[values.Length];
                Buffer.BlockCopy(values, 0, newValue, 0, values.Length * sizeof(long));
                fixed (long* newValueFixed = newValue, valueFixed = values)
                {
                    sortDesc(newValueFixed, newValueFixed + values.Length - 1);
                }
                return newValue;
            }
            return nullValue<long>.Array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        public unsafe static void SortDesc(long[] values, int startIndex, int count)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if (range.GetCount > 1)
            {
                fixed (long* valueFixed = values)
                {
                    sortDesc(valueFixed + range.SkipCount, valueFixed + range.EndIndex - 1);
                }
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static long[] GetSortDesc
            (long[] values, int startIndex, int count)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                long[] newValues = new long[count];
                Buffer.BlockCopy(values, range.SkipCount * sizeof(long), newValues, 0, count * sizeof(long));
                fixed (long* newValueFixed = newValues, valueFixed = values)
                {
                    if (--count > 0) sortDesc(newValueFixed, newValueFixed + count);
                }
                return newValues;
            }
            return nullValue<long>.Array;
        }
        /// <summary>
        /// 索引快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        private unsafe static void sortDesc
            (longSortIndex* startIndex, longSortIndex* endIndex)
        {
            do
            {
                longSortIndex leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue.Value < rightValue.Value)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                longSortIndex* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                longSortIndex indexValue = *averageIndex;
                if (leftValue.Value < indexValue.Value)
                {
                    if (leftValue.Value < rightValue.Value)
                    {
                        *rightIndex = leftValue;
                        if (indexValue.Value < rightValue.Value) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = indexValue;
                        *averageIndex = indexValue = leftValue;
                    }
                }
                else
                {
                    if (indexValue.Value < rightValue.Value)
                    {
                        *rightIndex = indexValue;
                        if (leftValue.Value < rightValue.Value)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = indexValue = leftValue;
                        }
                        else *averageIndex = indexValue = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                long value = indexValue.Value;
                do
                {
                    while ((*leftIndex).Value > value) ++leftIndex;
                    while (value > (*rightIndex).Value) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sortDesc(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sortDesc(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetSortDesc<valueType>
            (valueType[] values, func<valueType, long> getKey)
        {
            if (values.length() != 0)
            {
                if (values.Length > (config.pub.Default.StreamBufferLength >> 4))
                {
                    longSortIndex[] indexs = new longSortIndex[values.Length];
                    fixed (longSortIndex* fixedIndex = indexs)
                    {
                        return getSortDesc(values, getKey, fixedIndex);
                    }
                }
                else
                {
                    longSortIndex* fixedIndex = stackalloc longSortIndex[values.Length];
                    return getSortDesc(values, getKey, fixedIndex);
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getSortDesc<valueType>
            (valueType[] values, func<valueType, long> getKey, longSortIndex* fixedIndex)
        {
            longSortIndex* writeIndex = fixedIndex;
            if (values.Length > 1)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                for (int index = 0; index != values.Length; ++index)
                {
                    *writeIndex++ = new longSortIndex { Value = getKey(values[index]), Index = index };
                }
                sortDesc(writeIndex = fixedIndex, fixedIndex + values.Length - 1);
            }
            else *fixedIndex = new longSortIndex { Index = 0 };
            valueType[] newValues = new valueType[values.Length];
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetSortDesc<valueType>
            (valueType[] values, func<valueType, long> getKey, int startIndex, int count)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                if (count > (config.pub.Default.StreamBufferLength >> 4))
                {
                    longSortIndex[] indexs = new longSortIndex[count];
                    fixed (longSortIndex* fixedIndex = indexs)
                    {
                        return getSortDesc(values, getKey, range.SkipCount, count, fixedIndex);
                    }
                }
                else
                {
                    longSortIndex* fixedIndex = stackalloc longSortIndex[count];
                    return getSortDesc(values, getKey, range.SkipCount, count, fixedIndex);
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getSortDesc<valueType>
            (valueType[] values, func<valueType, long> getKey, int startIndex, int count
            , longSortIndex* fixedIndex)
        {
            longSortIndex* writeIndex = fixedIndex;
            if (count > 1)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                for (int index = startIndex, endIndex = startIndex + count; index != endIndex; ++index)
                {
                    *writeIndex++ = new longSortIndex { Value = getKey(values[index]), Index = index };
                }
                sortDesc(writeIndex = fixedIndex, fixedIndex + count - 1);
            }
            else *fixedIndex = new longSortIndex { Index = startIndex };
            valueType[] newValues = new valueType[count];
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的数组</returns>
        public static long[] sortDesc(this long[] array)
        {
            algorithm.quickSort.SortDesc(array);
            return array.notNull();
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        public static long[] getSortDesc(this long[] array)
        {
            return algorithm.quickSort.GetSortDesc(array);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的数组</returns>
        public static long[] sortDesc
            (this long[] array, int startIndex, int count)
        {
            algorithm.quickSort.SortDesc(array, startIndex, count);
            return array.notNull();
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的新数组</returns>
        public static long[] getSortDesc
            (this long[] array, int startIndex, int count)
        {
            return algorithm.quickSort.GetSortDesc(array, startIndex, count);
        }

        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <returns>排序后的数组</returns>
        public static valueType[] sortDesc<valueType>
            (this valueType[] array, func<valueType, long> getKey)
        {
            return algorithm.quickSort.GetSortDesc(array, getKey);
        }
        /// <summary>
        /// 排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的数组</returns>
        public static valueType[] sortDesc<valueType>
            (this valueType[] array, func<valueType, long> getKey, int startIndex, int count)
        {
            return algorithm.quickSort.GetSortDesc(array, getKey, startIndex, count);
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 单向动态数组扩展
    /// </summary>
    public static partial class list
    {
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <returns>排序后的单向动态数组</returns>
        public static list<long> sortDesc(this list<long> list)
        {
            if (list.count() != 0) algorithm.quickSort.SortDesc(list.Unsafer.Array, 0, list.Count);
            return list;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <returns>排序后新的单向动态数组</returns>
        public static long[] getSortDesc(this list<long> list)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.GetSortDesc(list.Unsafer.Array, 0, list.Count);
            }
            return nullValue<long>.Array;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的单向动态数组</returns>
        public static list<long> sortDesc
            (this list<long> list, int startIndex, int count)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                algorithm.quickSort.SortDesc(list.Unsafer.Array, range.SkipCount, count);
            }
            return list;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后新的单向动态数组</returns>
        public static long[] getSortDesc
            (this list<long> list, int startIndex, int count)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.GetSortDesc(list.Unsafer.Array, range.SkipCount, count);
            }
            return nullValue<long>.Array;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="getKey">排序键</param>
        /// <returns>排序后的新数组</returns>
        public static valueType[] sortDesc<valueType>
            (this list<valueType> list, func<valueType, long> getKey)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.GetSortDesc(list.Unsafer.Array, getKey, 0, list.Count);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的新数组</returns>
        public static valueType[] sortDesc<valueType>
            (this list<valueType> list, func<valueType, long> getKey, int startIndex, int count)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.GetSortDesc(list.Unsafer.Array, getKey, range.SkipCount, count);
            }
            return nullValue<valueType>.Array;
        }
    }
}


namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        private unsafe static void sort
            (uint* startIndex, uint* endIndex)
        {
            do
            {
                uint leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue > rightValue)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                uint* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                uint value = *averageIndex;
                if (leftValue > value)
                {
                    if (leftValue > rightValue)
                    {
                        *rightIndex = leftValue;
                        if (value > rightValue) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = value;
                        *averageIndex = value = leftValue;
                    }
                }
                else
                {
                    if (value > rightValue)
                    {
                        *rightIndex = value;
                        if (leftValue > rightValue)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = value = leftValue;
                        }
                        else *averageIndex = value = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                do
                {
                    while (*leftIndex < value) ++leftIndex;
                    while (value < *rightIndex) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sort(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sort(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        public unsafe static void Sort(uint[] values)
        {
            if (values != null && values.Length > 1)
            {
                fixed (uint* valueFixed = values)
                {
                    sort(valueFixed, valueFixed + values.Length - 1);
                }
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static uint[] GetSort(uint[] values)
        {
            if (values.length() != 0)
            {
                uint[] newValue = new uint[values.Length];
                Buffer.BlockCopy(values, 0, newValue, 0, values.Length * sizeof(uint));
                fixed (uint* newValueFixed = newValue, valueFixed = values)
                {
                    sort(newValueFixed, newValueFixed + values.Length - 1);
                }
                return newValue;
            }
            return nullValue<uint>.Array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        public unsafe static void Sort(uint[] values, int startIndex, int count)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if (range.GetCount > 1)
            {
                fixed (uint* valueFixed = values)
                {
                    sort(valueFixed + range.SkipCount, valueFixed + range.EndIndex - 1);
                }
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static uint[] GetSort
            (uint[] values, int startIndex, int count)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                uint[] newValues = new uint[count];
                Buffer.BlockCopy(values, range.SkipCount * sizeof(uint), newValues, 0, count * sizeof(uint));
                fixed (uint* newValueFixed = newValues, valueFixed = values)
                {
                    if (--count > 0) sort(newValueFixed, newValueFixed + count);
                }
                return newValues;
            }
            return nullValue<uint>.Array;
        }
        /// <summary>
        /// 索引快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        private unsafe static void sort
            (uintSortIndex* startIndex, uintSortIndex* endIndex)
        {
            do
            {
                uintSortIndex leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue.Value > rightValue.Value)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                uintSortIndex* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                uintSortIndex indexValue = *averageIndex;
                if (leftValue.Value > indexValue.Value)
                {
                    if (leftValue.Value > rightValue.Value)
                    {
                        *rightIndex = leftValue;
                        if (indexValue.Value > rightValue.Value) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = indexValue;
                        *averageIndex = indexValue = leftValue;
                    }
                }
                else
                {
                    if (indexValue.Value > rightValue.Value)
                    {
                        *rightIndex = indexValue;
                        if (leftValue.Value > rightValue.Value)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = indexValue = leftValue;
                        }
                        else *averageIndex = indexValue = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                uint value = indexValue.Value;
                do
                {
                    while ((*leftIndex).Value < value) ++leftIndex;
                    while (value < (*rightIndex).Value) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sort(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sort(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetSort<valueType>
            (valueType[] values, func<valueType, uint> getKey)
        {
            if (values.length() != 0)
            {
                if (values.Length > (config.pub.Default.StreamBufferLength >> 4))
                {
                    uintSortIndex[] indexs = new uintSortIndex[values.Length];
                    fixed (uintSortIndex* fixedIndex = indexs)
                    {
                        return getSort(values, getKey, fixedIndex);
                    }
                }
                else
                {
                    uintSortIndex* fixedIndex = stackalloc uintSortIndex[values.Length];
                    return getSort(values, getKey, fixedIndex);
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getSort<valueType>
            (valueType[] values, func<valueType, uint> getKey, uintSortIndex* fixedIndex)
        {
            uintSortIndex* writeIndex = fixedIndex;
            if (values.Length > 1)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                for (int index = 0; index != values.Length; ++index)
                {
                    *writeIndex++ = new uintSortIndex { Value = getKey(values[index]), Index = index };
                }
                sort(writeIndex = fixedIndex, fixedIndex + values.Length - 1);
            }
            else *fixedIndex = new uintSortIndex { Index = 0 };
            valueType[] newValues = new valueType[values.Length];
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetSort<valueType>
            (valueType[] values, func<valueType, uint> getKey, int startIndex, int count)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                if (count > (config.pub.Default.StreamBufferLength >> 4))
                {
                    uintSortIndex[] indexs = new uintSortIndex[count];
                    fixed (uintSortIndex* fixedIndex = indexs)
                    {
                        return getSort(values, getKey, range.SkipCount, count, fixedIndex);
                    }
                }
                else
                {
                    uintSortIndex* fixedIndex = stackalloc uintSortIndex[count];
                    return getSort(values, getKey, range.SkipCount, count, fixedIndex);
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getSort<valueType>
            (valueType[] values, func<valueType, uint> getKey, int startIndex, int count
            , uintSortIndex* fixedIndex)
        {
            uintSortIndex* writeIndex = fixedIndex;
            if (count > 1)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                for (int index = startIndex, endIndex = startIndex + count; index != endIndex; ++index)
                {
                    *writeIndex++ = new uintSortIndex { Value = getKey(values[index]), Index = index };
                }
                sort(writeIndex = fixedIndex, fixedIndex + count - 1);
            }
            else *fixedIndex = new uintSortIndex { Index = startIndex };
            valueType[] newValues = new valueType[count];
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的数组</returns>
        public static uint[] sort(this uint[] array)
        {
            algorithm.quickSort.Sort(array);
            return array.notNull();
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        public static uint[] getSort(this uint[] array)
        {
            return algorithm.quickSort.GetSort(array);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的数组</returns>
        public static uint[] sort
            (this uint[] array, int startIndex, int count)
        {
            algorithm.quickSort.Sort(array, startIndex, count);
            return array.notNull();
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的新数组</returns>
        public static uint[] getSort
            (this uint[] array, int startIndex, int count)
        {
            return algorithm.quickSort.GetSort(array, startIndex, count);
        }

        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <returns>排序后的数组</returns>
        public static valueType[] sort<valueType>
            (this valueType[] array, func<valueType, uint> getKey)
        {
            return algorithm.quickSort.GetSort(array, getKey);
        }
        /// <summary>
        /// 排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的数组</returns>
        public static valueType[] sort<valueType>
            (this valueType[] array, func<valueType, uint> getKey, int startIndex, int count)
        {
            return algorithm.quickSort.GetSort(array, getKey, startIndex, count);
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 单向动态数组扩展
    /// </summary>
    public static partial class list
    {
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <returns>排序后的单向动态数组</returns>
        public static list<uint> sort(this list<uint> list)
        {
            if (list.count() != 0) algorithm.quickSort.Sort(list.Unsafer.Array, 0, list.Count);
            return list;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <returns>排序后新的单向动态数组</returns>
        public static uint[] getSort(this list<uint> list)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.GetSort(list.Unsafer.Array, 0, list.Count);
            }
            return nullValue<uint>.Array;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的单向动态数组</returns>
        public static list<uint> sort
            (this list<uint> list, int startIndex, int count)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                algorithm.quickSort.Sort(list.Unsafer.Array, range.SkipCount, count);
            }
            return list;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后新的单向动态数组</returns>
        public static uint[] getSort
            (this list<uint> list, int startIndex, int count)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.GetSort(list.Unsafer.Array, range.SkipCount, count);
            }
            return nullValue<uint>.Array;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="getKey">排序键</param>
        /// <returns>排序后的新数组</returns>
        public static valueType[] sort<valueType>
            (this list<valueType> list, func<valueType, uint> getKey)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.GetSort(list.Unsafer.Array, getKey, 0, list.Count);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的新数组</returns>
        public static valueType[] sort<valueType>
            (this list<valueType> list, func<valueType, uint> getKey, int startIndex, int count)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.GetSort(list.Unsafer.Array, getKey, range.SkipCount, count);
            }
            return nullValue<valueType>.Array;
        }
    }
}


namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        private unsafe static void sortDesc
            (uint* startIndex, uint* endIndex)
        {
            do
            {
                uint leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue < rightValue)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                uint* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                uint value = *averageIndex;
                if (leftValue < value)
                {
                    if (leftValue < rightValue)
                    {
                        *rightIndex = leftValue;
                        if (value < rightValue) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = value;
                        *averageIndex = value = leftValue;
                    }
                }
                else
                {
                    if (value < rightValue)
                    {
                        *rightIndex = value;
                        if (leftValue < rightValue)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = value = leftValue;
                        }
                        else *averageIndex = value = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                do
                {
                    while (*leftIndex > value) ++leftIndex;
                    while (value > *rightIndex) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sortDesc(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sortDesc(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        public unsafe static void SortDesc(uint[] values)
        {
            if (values != null && values.Length > 1)
            {
                fixed (uint* valueFixed = values)
                {
                    sortDesc(valueFixed, valueFixed + values.Length - 1);
                }
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static uint[] GetSortDesc(uint[] values)
        {
            if (values.length() != 0)
            {
                uint[] newValue = new uint[values.Length];
                Buffer.BlockCopy(values, 0, newValue, 0, values.Length * sizeof(uint));
                fixed (uint* newValueFixed = newValue, valueFixed = values)
                {
                    sortDesc(newValueFixed, newValueFixed + values.Length - 1);
                }
                return newValue;
            }
            return nullValue<uint>.Array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        public unsafe static void SortDesc(uint[] values, int startIndex, int count)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if (range.GetCount > 1)
            {
                fixed (uint* valueFixed = values)
                {
                    sortDesc(valueFixed + range.SkipCount, valueFixed + range.EndIndex - 1);
                }
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static uint[] GetSortDesc
            (uint[] values, int startIndex, int count)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                uint[] newValues = new uint[count];
                Buffer.BlockCopy(values, range.SkipCount * sizeof(uint), newValues, 0, count * sizeof(uint));
                fixed (uint* newValueFixed = newValues, valueFixed = values)
                {
                    if (--count > 0) sortDesc(newValueFixed, newValueFixed + count);
                }
                return newValues;
            }
            return nullValue<uint>.Array;
        }
        /// <summary>
        /// 索引快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        private unsafe static void sortDesc
            (uintSortIndex* startIndex, uintSortIndex* endIndex)
        {
            do
            {
                uintSortIndex leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue.Value < rightValue.Value)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                uintSortIndex* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                uintSortIndex indexValue = *averageIndex;
                if (leftValue.Value < indexValue.Value)
                {
                    if (leftValue.Value < rightValue.Value)
                    {
                        *rightIndex = leftValue;
                        if (indexValue.Value < rightValue.Value) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = indexValue;
                        *averageIndex = indexValue = leftValue;
                    }
                }
                else
                {
                    if (indexValue.Value < rightValue.Value)
                    {
                        *rightIndex = indexValue;
                        if (leftValue.Value < rightValue.Value)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = indexValue = leftValue;
                        }
                        else *averageIndex = indexValue = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                uint value = indexValue.Value;
                do
                {
                    while ((*leftIndex).Value > value) ++leftIndex;
                    while (value > (*rightIndex).Value) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sortDesc(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sortDesc(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetSortDesc<valueType>
            (valueType[] values, func<valueType, uint> getKey)
        {
            if (values.length() != 0)
            {
                if (values.Length > (config.pub.Default.StreamBufferLength >> 4))
                {
                    uintSortIndex[] indexs = new uintSortIndex[values.Length];
                    fixed (uintSortIndex* fixedIndex = indexs)
                    {
                        return getSortDesc(values, getKey, fixedIndex);
                    }
                }
                else
                {
                    uintSortIndex* fixedIndex = stackalloc uintSortIndex[values.Length];
                    return getSortDesc(values, getKey, fixedIndex);
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getSortDesc<valueType>
            (valueType[] values, func<valueType, uint> getKey, uintSortIndex* fixedIndex)
        {
            uintSortIndex* writeIndex = fixedIndex;
            if (values.Length > 1)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                for (int index = 0; index != values.Length; ++index)
                {
                    *writeIndex++ = new uintSortIndex { Value = getKey(values[index]), Index = index };
                }
                sortDesc(writeIndex = fixedIndex, fixedIndex + values.Length - 1);
            }
            else *fixedIndex = new uintSortIndex { Index = 0 };
            valueType[] newValues = new valueType[values.Length];
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetSortDesc<valueType>
            (valueType[] values, func<valueType, uint> getKey, int startIndex, int count)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                if (count > (config.pub.Default.StreamBufferLength >> 4))
                {
                    uintSortIndex[] indexs = new uintSortIndex[count];
                    fixed (uintSortIndex* fixedIndex = indexs)
                    {
                        return getSortDesc(values, getKey, range.SkipCount, count, fixedIndex);
                    }
                }
                else
                {
                    uintSortIndex* fixedIndex = stackalloc uintSortIndex[count];
                    return getSortDesc(values, getKey, range.SkipCount, count, fixedIndex);
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getSortDesc<valueType>
            (valueType[] values, func<valueType, uint> getKey, int startIndex, int count
            , uintSortIndex* fixedIndex)
        {
            uintSortIndex* writeIndex = fixedIndex;
            if (count > 1)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                for (int index = startIndex, endIndex = startIndex + count; index != endIndex; ++index)
                {
                    *writeIndex++ = new uintSortIndex { Value = getKey(values[index]), Index = index };
                }
                sortDesc(writeIndex = fixedIndex, fixedIndex + count - 1);
            }
            else *fixedIndex = new uintSortIndex { Index = startIndex };
            valueType[] newValues = new valueType[count];
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的数组</returns>
        public static uint[] sortDesc(this uint[] array)
        {
            algorithm.quickSort.SortDesc(array);
            return array.notNull();
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        public static uint[] getSortDesc(this uint[] array)
        {
            return algorithm.quickSort.GetSortDesc(array);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的数组</returns>
        public static uint[] sortDesc
            (this uint[] array, int startIndex, int count)
        {
            algorithm.quickSort.SortDesc(array, startIndex, count);
            return array.notNull();
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的新数组</returns>
        public static uint[] getSortDesc
            (this uint[] array, int startIndex, int count)
        {
            return algorithm.quickSort.GetSortDesc(array, startIndex, count);
        }

        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <returns>排序后的数组</returns>
        public static valueType[] sortDesc<valueType>
            (this valueType[] array, func<valueType, uint> getKey)
        {
            return algorithm.quickSort.GetSortDesc(array, getKey);
        }
        /// <summary>
        /// 排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的数组</returns>
        public static valueType[] sortDesc<valueType>
            (this valueType[] array, func<valueType, uint> getKey, int startIndex, int count)
        {
            return algorithm.quickSort.GetSortDesc(array, getKey, startIndex, count);
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 单向动态数组扩展
    /// </summary>
    public static partial class list
    {
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <returns>排序后的单向动态数组</returns>
        public static list<uint> sortDesc(this list<uint> list)
        {
            if (list.count() != 0) algorithm.quickSort.SortDesc(list.Unsafer.Array, 0, list.Count);
            return list;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <returns>排序后新的单向动态数组</returns>
        public static uint[] getSortDesc(this list<uint> list)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.GetSortDesc(list.Unsafer.Array, 0, list.Count);
            }
            return nullValue<uint>.Array;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的单向动态数组</returns>
        public static list<uint> sortDesc
            (this list<uint> list, int startIndex, int count)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                algorithm.quickSort.SortDesc(list.Unsafer.Array, range.SkipCount, count);
            }
            return list;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后新的单向动态数组</returns>
        public static uint[] getSortDesc
            (this list<uint> list, int startIndex, int count)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.GetSortDesc(list.Unsafer.Array, range.SkipCount, count);
            }
            return nullValue<uint>.Array;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="getKey">排序键</param>
        /// <returns>排序后的新数组</returns>
        public static valueType[] sortDesc<valueType>
            (this list<valueType> list, func<valueType, uint> getKey)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.GetSortDesc(list.Unsafer.Array, getKey, 0, list.Count);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的新数组</returns>
        public static valueType[] sortDesc<valueType>
            (this list<valueType> list, func<valueType, uint> getKey, int startIndex, int count)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.GetSortDesc(list.Unsafer.Array, getKey, range.SkipCount, count);
            }
            return nullValue<valueType>.Array;
        }
    }
}


namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        private unsafe static void sort
            (int* startIndex, int* endIndex)
        {
            do
            {
                int leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue > rightValue)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                int* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                int value = *averageIndex;
                if (leftValue > value)
                {
                    if (leftValue > rightValue)
                    {
                        *rightIndex = leftValue;
                        if (value > rightValue) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = value;
                        *averageIndex = value = leftValue;
                    }
                }
                else
                {
                    if (value > rightValue)
                    {
                        *rightIndex = value;
                        if (leftValue > rightValue)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = value = leftValue;
                        }
                        else *averageIndex = value = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                do
                {
                    while (*leftIndex < value) ++leftIndex;
                    while (value < *rightIndex) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sort(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sort(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        public unsafe static void Sort(int[] values)
        {
            if (values != null && values.Length > 1)
            {
                fixed (int* valueFixed = values)
                {
                    sort(valueFixed, valueFixed + values.Length - 1);
                }
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static int[] GetSort(int[] values)
        {
            if (values.length() != 0)
            {
                int[] newValue = new int[values.Length];
                Buffer.BlockCopy(values, 0, newValue, 0, values.Length * sizeof(int));
                fixed (int* newValueFixed = newValue, valueFixed = values)
                {
                    sort(newValueFixed, newValueFixed + values.Length - 1);
                }
                return newValue;
            }
            return nullValue<int>.Array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        public unsafe static void Sort(int[] values, int startIndex, int count)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if (range.GetCount > 1)
            {
                fixed (int* valueFixed = values)
                {
                    sort(valueFixed + range.SkipCount, valueFixed + range.EndIndex - 1);
                }
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static int[] GetSort
            (int[] values, int startIndex, int count)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                int[] newValues = new int[count];
                Buffer.BlockCopy(values, range.SkipCount * sizeof(int), newValues, 0, count * sizeof(int));
                fixed (int* newValueFixed = newValues, valueFixed = values)
                {
                    if (--count > 0) sort(newValueFixed, newValueFixed + count);
                }
                return newValues;
            }
            return nullValue<int>.Array;
        }
        /// <summary>
        /// 索引快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        private unsafe static void sort
            (intSortIndex* startIndex, intSortIndex* endIndex)
        {
            do
            {
                intSortIndex leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue.Value > rightValue.Value)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                intSortIndex* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                intSortIndex indexValue = *averageIndex;
                if (leftValue.Value > indexValue.Value)
                {
                    if (leftValue.Value > rightValue.Value)
                    {
                        *rightIndex = leftValue;
                        if (indexValue.Value > rightValue.Value) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = indexValue;
                        *averageIndex = indexValue = leftValue;
                    }
                }
                else
                {
                    if (indexValue.Value > rightValue.Value)
                    {
                        *rightIndex = indexValue;
                        if (leftValue.Value > rightValue.Value)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = indexValue = leftValue;
                        }
                        else *averageIndex = indexValue = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                int value = indexValue.Value;
                do
                {
                    while ((*leftIndex).Value < value) ++leftIndex;
                    while (value < (*rightIndex).Value) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sort(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sort(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetSort<valueType>
            (valueType[] values, func<valueType, int> getKey)
        {
            if (values.length() != 0)
            {
                if (values.Length > (config.pub.Default.StreamBufferLength >> 4))
                {
                    intSortIndex[] indexs = new intSortIndex[values.Length];
                    fixed (intSortIndex* fixedIndex = indexs)
                    {
                        return getSort(values, getKey, fixedIndex);
                    }
                }
                else
                {
                    intSortIndex* fixedIndex = stackalloc intSortIndex[values.Length];
                    return getSort(values, getKey, fixedIndex);
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getSort<valueType>
            (valueType[] values, func<valueType, int> getKey, intSortIndex* fixedIndex)
        {
            intSortIndex* writeIndex = fixedIndex;
            if (values.Length > 1)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                for (int index = 0; index != values.Length; ++index)
                {
                    *writeIndex++ = new intSortIndex { Value = getKey(values[index]), Index = index };
                }
                sort(writeIndex = fixedIndex, fixedIndex + values.Length - 1);
            }
            else *fixedIndex = new intSortIndex { Index = 0 };
            valueType[] newValues = new valueType[values.Length];
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetSort<valueType>
            (valueType[] values, func<valueType, int> getKey, int startIndex, int count)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                if (count > (config.pub.Default.StreamBufferLength >> 4))
                {
                    intSortIndex[] indexs = new intSortIndex[count];
                    fixed (intSortIndex* fixedIndex = indexs)
                    {
                        return getSort(values, getKey, range.SkipCount, count, fixedIndex);
                    }
                }
                else
                {
                    intSortIndex* fixedIndex = stackalloc intSortIndex[count];
                    return getSort(values, getKey, range.SkipCount, count, fixedIndex);
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getSort<valueType>
            (valueType[] values, func<valueType, int> getKey, int startIndex, int count
            , intSortIndex* fixedIndex)
        {
            intSortIndex* writeIndex = fixedIndex;
            if (count > 1)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                for (int index = startIndex, endIndex = startIndex + count; index != endIndex; ++index)
                {
                    *writeIndex++ = new intSortIndex { Value = getKey(values[index]), Index = index };
                }
                sort(writeIndex = fixedIndex, fixedIndex + count - 1);
            }
            else *fixedIndex = new intSortIndex { Index = startIndex };
            valueType[] newValues = new valueType[count];
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的数组</returns>
        public static int[] sort(this int[] array)
        {
            algorithm.quickSort.Sort(array);
            return array.notNull();
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        public static int[] getSort(this int[] array)
        {
            return algorithm.quickSort.GetSort(array);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的数组</returns>
        public static int[] sort
            (this int[] array, int startIndex, int count)
        {
            algorithm.quickSort.Sort(array, startIndex, count);
            return array.notNull();
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的新数组</returns>
        public static int[] getSort
            (this int[] array, int startIndex, int count)
        {
            return algorithm.quickSort.GetSort(array, startIndex, count);
        }

        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <returns>排序后的数组</returns>
        public static valueType[] sort<valueType>
            (this valueType[] array, func<valueType, int> getKey)
        {
            return algorithm.quickSort.GetSort(array, getKey);
        }
        /// <summary>
        /// 排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的数组</returns>
        public static valueType[] sort<valueType>
            (this valueType[] array, func<valueType, int> getKey, int startIndex, int count)
        {
            return algorithm.quickSort.GetSort(array, getKey, startIndex, count);
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 单向动态数组扩展
    /// </summary>
    public static partial class list
    {
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <returns>排序后的单向动态数组</returns>
        public static list<int> sort(this list<int> list)
        {
            if (list.count() != 0) algorithm.quickSort.Sort(list.Unsafer.Array, 0, list.Count);
            return list;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <returns>排序后新的单向动态数组</returns>
        public static int[] getSort(this list<int> list)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.GetSort(list.Unsafer.Array, 0, list.Count);
            }
            return nullValue<int>.Array;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的单向动态数组</returns>
        public static list<int> sort
            (this list<int> list, int startIndex, int count)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                algorithm.quickSort.Sort(list.Unsafer.Array, range.SkipCount, count);
            }
            return list;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后新的单向动态数组</returns>
        public static int[] getSort
            (this list<int> list, int startIndex, int count)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.GetSort(list.Unsafer.Array, range.SkipCount, count);
            }
            return nullValue<int>.Array;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="getKey">排序键</param>
        /// <returns>排序后的新数组</returns>
        public static valueType[] sort<valueType>
            (this list<valueType> list, func<valueType, int> getKey)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.GetSort(list.Unsafer.Array, getKey, 0, list.Count);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的新数组</returns>
        public static valueType[] sort<valueType>
            (this list<valueType> list, func<valueType, int> getKey, int startIndex, int count)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.GetSort(list.Unsafer.Array, getKey, range.SkipCount, count);
            }
            return nullValue<valueType>.Array;
        }
    }
}


namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        private unsafe static void sortDesc
            (int* startIndex, int* endIndex)
        {
            do
            {
                int leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue < rightValue)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                int* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                int value = *averageIndex;
                if (leftValue < value)
                {
                    if (leftValue < rightValue)
                    {
                        *rightIndex = leftValue;
                        if (value < rightValue) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = value;
                        *averageIndex = value = leftValue;
                    }
                }
                else
                {
                    if (value < rightValue)
                    {
                        *rightIndex = value;
                        if (leftValue < rightValue)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = value = leftValue;
                        }
                        else *averageIndex = value = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                do
                {
                    while (*leftIndex > value) ++leftIndex;
                    while (value > *rightIndex) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sortDesc(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sortDesc(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        public unsafe static void SortDesc(int[] values)
        {
            if (values != null && values.Length > 1)
            {
                fixed (int* valueFixed = values)
                {
                    sortDesc(valueFixed, valueFixed + values.Length - 1);
                }
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static int[] GetSortDesc(int[] values)
        {
            if (values.length() != 0)
            {
                int[] newValue = new int[values.Length];
                Buffer.BlockCopy(values, 0, newValue, 0, values.Length * sizeof(int));
                fixed (int* newValueFixed = newValue, valueFixed = values)
                {
                    sortDesc(newValueFixed, newValueFixed + values.Length - 1);
                }
                return newValue;
            }
            return nullValue<int>.Array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        public unsafe static void SortDesc(int[] values, int startIndex, int count)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if (range.GetCount > 1)
            {
                fixed (int* valueFixed = values)
                {
                    sortDesc(valueFixed + range.SkipCount, valueFixed + range.EndIndex - 1);
                }
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static int[] GetSortDesc
            (int[] values, int startIndex, int count)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                int[] newValues = new int[count];
                Buffer.BlockCopy(values, range.SkipCount * sizeof(int), newValues, 0, count * sizeof(int));
                fixed (int* newValueFixed = newValues, valueFixed = values)
                {
                    if (--count > 0) sortDesc(newValueFixed, newValueFixed + count);
                }
                return newValues;
            }
            return nullValue<int>.Array;
        }
        /// <summary>
        /// 索引快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        private unsafe static void sortDesc
            (intSortIndex* startIndex, intSortIndex* endIndex)
        {
            do
            {
                intSortIndex leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue.Value < rightValue.Value)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                intSortIndex* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                intSortIndex indexValue = *averageIndex;
                if (leftValue.Value < indexValue.Value)
                {
                    if (leftValue.Value < rightValue.Value)
                    {
                        *rightIndex = leftValue;
                        if (indexValue.Value < rightValue.Value) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = indexValue;
                        *averageIndex = indexValue = leftValue;
                    }
                }
                else
                {
                    if (indexValue.Value < rightValue.Value)
                    {
                        *rightIndex = indexValue;
                        if (leftValue.Value < rightValue.Value)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = indexValue = leftValue;
                        }
                        else *averageIndex = indexValue = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                int value = indexValue.Value;
                do
                {
                    while ((*leftIndex).Value > value) ++leftIndex;
                    while (value > (*rightIndex).Value) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sortDesc(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sortDesc(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetSortDesc<valueType>
            (valueType[] values, func<valueType, int> getKey)
        {
            if (values.length() != 0)
            {
                if (values.Length > (config.pub.Default.StreamBufferLength >> 4))
                {
                    intSortIndex[] indexs = new intSortIndex[values.Length];
                    fixed (intSortIndex* fixedIndex = indexs)
                    {
                        return getSortDesc(values, getKey, fixedIndex);
                    }
                }
                else
                {
                    intSortIndex* fixedIndex = stackalloc intSortIndex[values.Length];
                    return getSortDesc(values, getKey, fixedIndex);
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getSortDesc<valueType>
            (valueType[] values, func<valueType, int> getKey, intSortIndex* fixedIndex)
        {
            intSortIndex* writeIndex = fixedIndex;
            if (values.Length > 1)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                for (int index = 0; index != values.Length; ++index)
                {
                    *writeIndex++ = new intSortIndex { Value = getKey(values[index]), Index = index };
                }
                sortDesc(writeIndex = fixedIndex, fixedIndex + values.Length - 1);
            }
            else *fixedIndex = new intSortIndex { Index = 0 };
            valueType[] newValues = new valueType[values.Length];
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetSortDesc<valueType>
            (valueType[] values, func<valueType, int> getKey, int startIndex, int count)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                if (count > (config.pub.Default.StreamBufferLength >> 4))
                {
                    intSortIndex[] indexs = new intSortIndex[count];
                    fixed (intSortIndex* fixedIndex = indexs)
                    {
                        return getSortDesc(values, getKey, range.SkipCount, count, fixedIndex);
                    }
                }
                else
                {
                    intSortIndex* fixedIndex = stackalloc intSortIndex[count];
                    return getSortDesc(values, getKey, range.SkipCount, count, fixedIndex);
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getSortDesc<valueType>
            (valueType[] values, func<valueType, int> getKey, int startIndex, int count
            , intSortIndex* fixedIndex)
        {
            intSortIndex* writeIndex = fixedIndex;
            if (count > 1)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                for (int index = startIndex, endIndex = startIndex + count; index != endIndex; ++index)
                {
                    *writeIndex++ = new intSortIndex { Value = getKey(values[index]), Index = index };
                }
                sortDesc(writeIndex = fixedIndex, fixedIndex + count - 1);
            }
            else *fixedIndex = new intSortIndex { Index = startIndex };
            valueType[] newValues = new valueType[count];
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的数组</returns>
        public static int[] sortDesc(this int[] array)
        {
            algorithm.quickSort.SortDesc(array);
            return array.notNull();
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        public static int[] getSortDesc(this int[] array)
        {
            return algorithm.quickSort.GetSortDesc(array);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的数组</returns>
        public static int[] sortDesc
            (this int[] array, int startIndex, int count)
        {
            algorithm.quickSort.SortDesc(array, startIndex, count);
            return array.notNull();
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的新数组</returns>
        public static int[] getSortDesc
            (this int[] array, int startIndex, int count)
        {
            return algorithm.quickSort.GetSortDesc(array, startIndex, count);
        }

        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <returns>排序后的数组</returns>
        public static valueType[] sortDesc<valueType>
            (this valueType[] array, func<valueType, int> getKey)
        {
            return algorithm.quickSort.GetSortDesc(array, getKey);
        }
        /// <summary>
        /// 排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的数组</returns>
        public static valueType[] sortDesc<valueType>
            (this valueType[] array, func<valueType, int> getKey, int startIndex, int count)
        {
            return algorithm.quickSort.GetSortDesc(array, getKey, startIndex, count);
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 单向动态数组扩展
    /// </summary>
    public static partial class list
    {
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <returns>排序后的单向动态数组</returns>
        public static list<int> sortDesc(this list<int> list)
        {
            if (list.count() != 0) algorithm.quickSort.SortDesc(list.Unsafer.Array, 0, list.Count);
            return list;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <returns>排序后新的单向动态数组</returns>
        public static int[] getSortDesc(this list<int> list)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.GetSortDesc(list.Unsafer.Array, 0, list.Count);
            }
            return nullValue<int>.Array;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的单向动态数组</returns>
        public static list<int> sortDesc
            (this list<int> list, int startIndex, int count)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                algorithm.quickSort.SortDesc(list.Unsafer.Array, range.SkipCount, count);
            }
            return list;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后新的单向动态数组</returns>
        public static int[] getSortDesc
            (this list<int> list, int startIndex, int count)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.GetSortDesc(list.Unsafer.Array, range.SkipCount, count);
            }
            return nullValue<int>.Array;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="getKey">排序键</param>
        /// <returns>排序后的新数组</returns>
        public static valueType[] sortDesc<valueType>
            (this list<valueType> list, func<valueType, int> getKey)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.GetSortDesc(list.Unsafer.Array, getKey, 0, list.Count);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的新数组</returns>
        public static valueType[] sortDesc<valueType>
            (this list<valueType> list, func<valueType, int> getKey, int startIndex, int count)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.GetSortDesc(list.Unsafer.Array, getKey, range.SkipCount, count);
            }
            return nullValue<valueType>.Array;
        }
    }
}


namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        private unsafe static void sort
            (ushort* startIndex, ushort* endIndex)
        {
            do
            {
                ushort leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue > rightValue)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                ushort* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                ushort value = *averageIndex;
                if (leftValue > value)
                {
                    if (leftValue > rightValue)
                    {
                        *rightIndex = leftValue;
                        if (value > rightValue) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = value;
                        *averageIndex = value = leftValue;
                    }
                }
                else
                {
                    if (value > rightValue)
                    {
                        *rightIndex = value;
                        if (leftValue > rightValue)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = value = leftValue;
                        }
                        else *averageIndex = value = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                do
                {
                    while (*leftIndex < value) ++leftIndex;
                    while (value < *rightIndex) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sort(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sort(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        public unsafe static void Sort(ushort[] values)
        {
            if (values != null && values.Length > 1)
            {
                fixed (ushort* valueFixed = values)
                {
                    sort(valueFixed, valueFixed + values.Length - 1);
                }
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static ushort[] GetSort(ushort[] values)
        {
            if (values.length() != 0)
            {
                ushort[] newValue = new ushort[values.Length];
                Buffer.BlockCopy(values, 0, newValue, 0, values.Length * sizeof(ushort));
                fixed (ushort* newValueFixed = newValue, valueFixed = values)
                {
                    sort(newValueFixed, newValueFixed + values.Length - 1);
                }
                return newValue;
            }
            return nullValue<ushort>.Array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        public unsafe static void Sort(ushort[] values, int startIndex, int count)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if (range.GetCount > 1)
            {
                fixed (ushort* valueFixed = values)
                {
                    sort(valueFixed + range.SkipCount, valueFixed + range.EndIndex - 1);
                }
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static ushort[] GetSort
            (ushort[] values, int startIndex, int count)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                ushort[] newValues = new ushort[count];
                Buffer.BlockCopy(values, range.SkipCount * sizeof(ushort), newValues, 0, count * sizeof(ushort));
                fixed (ushort* newValueFixed = newValues, valueFixed = values)
                {
                    if (--count > 0) sort(newValueFixed, newValueFixed + count);
                }
                return newValues;
            }
            return nullValue<ushort>.Array;
        }
        /// <summary>
        /// 索引快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        private unsafe static void sort
            (ushortSortIndex* startIndex, ushortSortIndex* endIndex)
        {
            do
            {
                ushortSortIndex leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue.Value > rightValue.Value)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                ushortSortIndex* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                ushortSortIndex indexValue = *averageIndex;
                if (leftValue.Value > indexValue.Value)
                {
                    if (leftValue.Value > rightValue.Value)
                    {
                        *rightIndex = leftValue;
                        if (indexValue.Value > rightValue.Value) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = indexValue;
                        *averageIndex = indexValue = leftValue;
                    }
                }
                else
                {
                    if (indexValue.Value > rightValue.Value)
                    {
                        *rightIndex = indexValue;
                        if (leftValue.Value > rightValue.Value)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = indexValue = leftValue;
                        }
                        else *averageIndex = indexValue = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                ushort value = indexValue.Value;
                do
                {
                    while ((*leftIndex).Value < value) ++leftIndex;
                    while (value < (*rightIndex).Value) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sort(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sort(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetSort<valueType>
            (valueType[] values, func<valueType, ushort> getKey)
        {
            if (values.length() != 0)
            {
                if (values.Length > (config.pub.Default.StreamBufferLength >> 4))
                {
                    ushortSortIndex[] indexs = new ushortSortIndex[values.Length];
                    fixed (ushortSortIndex* fixedIndex = indexs)
                    {
                        return getSort(values, getKey, fixedIndex);
                    }
                }
                else
                {
                    ushortSortIndex* fixedIndex = stackalloc ushortSortIndex[values.Length];
                    return getSort(values, getKey, fixedIndex);
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getSort<valueType>
            (valueType[] values, func<valueType, ushort> getKey, ushortSortIndex* fixedIndex)
        {
            ushortSortIndex* writeIndex = fixedIndex;
            if (values.Length > 1)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                for (int index = 0; index != values.Length; ++index)
                {
                    *writeIndex++ = new ushortSortIndex { Value = getKey(values[index]), Index = index };
                }
                sort(writeIndex = fixedIndex, fixedIndex + values.Length - 1);
            }
            else *fixedIndex = new ushortSortIndex { Index = 0 };
            valueType[] newValues = new valueType[values.Length];
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetSort<valueType>
            (valueType[] values, func<valueType, ushort> getKey, int startIndex, int count)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                if (count > (config.pub.Default.StreamBufferLength >> 4))
                {
                    ushortSortIndex[] indexs = new ushortSortIndex[count];
                    fixed (ushortSortIndex* fixedIndex = indexs)
                    {
                        return getSort(values, getKey, range.SkipCount, count, fixedIndex);
                    }
                }
                else
                {
                    ushortSortIndex* fixedIndex = stackalloc ushortSortIndex[count];
                    return getSort(values, getKey, range.SkipCount, count, fixedIndex);
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getSort<valueType>
            (valueType[] values, func<valueType, ushort> getKey, int startIndex, int count
            , ushortSortIndex* fixedIndex)
        {
            ushortSortIndex* writeIndex = fixedIndex;
            if (count > 1)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                for (int index = startIndex, endIndex = startIndex + count; index != endIndex; ++index)
                {
                    *writeIndex++ = new ushortSortIndex { Value = getKey(values[index]), Index = index };
                }
                sort(writeIndex = fixedIndex, fixedIndex + count - 1);
            }
            else *fixedIndex = new ushortSortIndex { Index = startIndex };
            valueType[] newValues = new valueType[count];
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的数组</returns>
        public static ushort[] sort(this ushort[] array)
        {
            algorithm.quickSort.Sort(array);
            return array.notNull();
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        public static ushort[] getSort(this ushort[] array)
        {
            return algorithm.quickSort.GetSort(array);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的数组</returns>
        public static ushort[] sort
            (this ushort[] array, int startIndex, int count)
        {
            algorithm.quickSort.Sort(array, startIndex, count);
            return array.notNull();
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的新数组</returns>
        public static ushort[] getSort
            (this ushort[] array, int startIndex, int count)
        {
            return algorithm.quickSort.GetSort(array, startIndex, count);
        }

        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <returns>排序后的数组</returns>
        public static valueType[] sort<valueType>
            (this valueType[] array, func<valueType, ushort> getKey)
        {
            return algorithm.quickSort.GetSort(array, getKey);
        }
        /// <summary>
        /// 排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的数组</returns>
        public static valueType[] sort<valueType>
            (this valueType[] array, func<valueType, ushort> getKey, int startIndex, int count)
        {
            return algorithm.quickSort.GetSort(array, getKey, startIndex, count);
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 单向动态数组扩展
    /// </summary>
    public static partial class list
    {
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <returns>排序后的单向动态数组</returns>
        public static list<ushort> sort(this list<ushort> list)
        {
            if (list.count() != 0) algorithm.quickSort.Sort(list.Unsafer.Array, 0, list.Count);
            return list;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <returns>排序后新的单向动态数组</returns>
        public static ushort[] getSort(this list<ushort> list)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.GetSort(list.Unsafer.Array, 0, list.Count);
            }
            return nullValue<ushort>.Array;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的单向动态数组</returns>
        public static list<ushort> sort
            (this list<ushort> list, int startIndex, int count)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                algorithm.quickSort.Sort(list.Unsafer.Array, range.SkipCount, count);
            }
            return list;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后新的单向动态数组</returns>
        public static ushort[] getSort
            (this list<ushort> list, int startIndex, int count)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.GetSort(list.Unsafer.Array, range.SkipCount, count);
            }
            return nullValue<ushort>.Array;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="getKey">排序键</param>
        /// <returns>排序后的新数组</returns>
        public static valueType[] sort<valueType>
            (this list<valueType> list, func<valueType, ushort> getKey)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.GetSort(list.Unsafer.Array, getKey, 0, list.Count);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的新数组</returns>
        public static valueType[] sort<valueType>
            (this list<valueType> list, func<valueType, ushort> getKey, int startIndex, int count)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.GetSort(list.Unsafer.Array, getKey, range.SkipCount, count);
            }
            return nullValue<valueType>.Array;
        }
    }
}


namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        private unsafe static void sortDesc
            (ushort* startIndex, ushort* endIndex)
        {
            do
            {
                ushort leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue < rightValue)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                ushort* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                ushort value = *averageIndex;
                if (leftValue < value)
                {
                    if (leftValue < rightValue)
                    {
                        *rightIndex = leftValue;
                        if (value < rightValue) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = value;
                        *averageIndex = value = leftValue;
                    }
                }
                else
                {
                    if (value < rightValue)
                    {
                        *rightIndex = value;
                        if (leftValue < rightValue)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = value = leftValue;
                        }
                        else *averageIndex = value = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                do
                {
                    while (*leftIndex > value) ++leftIndex;
                    while (value > *rightIndex) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sortDesc(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sortDesc(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        public unsafe static void SortDesc(ushort[] values)
        {
            if (values != null && values.Length > 1)
            {
                fixed (ushort* valueFixed = values)
                {
                    sortDesc(valueFixed, valueFixed + values.Length - 1);
                }
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static ushort[] GetSortDesc(ushort[] values)
        {
            if (values.length() != 0)
            {
                ushort[] newValue = new ushort[values.Length];
                Buffer.BlockCopy(values, 0, newValue, 0, values.Length * sizeof(ushort));
                fixed (ushort* newValueFixed = newValue, valueFixed = values)
                {
                    sortDesc(newValueFixed, newValueFixed + values.Length - 1);
                }
                return newValue;
            }
            return nullValue<ushort>.Array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        public unsafe static void SortDesc(ushort[] values, int startIndex, int count)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if (range.GetCount > 1)
            {
                fixed (ushort* valueFixed = values)
                {
                    sortDesc(valueFixed + range.SkipCount, valueFixed + range.EndIndex - 1);
                }
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static ushort[] GetSortDesc
            (ushort[] values, int startIndex, int count)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                ushort[] newValues = new ushort[count];
                Buffer.BlockCopy(values, range.SkipCount * sizeof(ushort), newValues, 0, count * sizeof(ushort));
                fixed (ushort* newValueFixed = newValues, valueFixed = values)
                {
                    if (--count > 0) sortDesc(newValueFixed, newValueFixed + count);
                }
                return newValues;
            }
            return nullValue<ushort>.Array;
        }
        /// <summary>
        /// 索引快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        private unsafe static void sortDesc
            (ushortSortIndex* startIndex, ushortSortIndex* endIndex)
        {
            do
            {
                ushortSortIndex leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue.Value < rightValue.Value)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                ushortSortIndex* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                ushortSortIndex indexValue = *averageIndex;
                if (leftValue.Value < indexValue.Value)
                {
                    if (leftValue.Value < rightValue.Value)
                    {
                        *rightIndex = leftValue;
                        if (indexValue.Value < rightValue.Value) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = indexValue;
                        *averageIndex = indexValue = leftValue;
                    }
                }
                else
                {
                    if (indexValue.Value < rightValue.Value)
                    {
                        *rightIndex = indexValue;
                        if (leftValue.Value < rightValue.Value)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = indexValue = leftValue;
                        }
                        else *averageIndex = indexValue = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                ushort value = indexValue.Value;
                do
                {
                    while ((*leftIndex).Value > value) ++leftIndex;
                    while (value > (*rightIndex).Value) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sortDesc(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sortDesc(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetSortDesc<valueType>
            (valueType[] values, func<valueType, ushort> getKey)
        {
            if (values.length() != 0)
            {
                if (values.Length > (config.pub.Default.StreamBufferLength >> 4))
                {
                    ushortSortIndex[] indexs = new ushortSortIndex[values.Length];
                    fixed (ushortSortIndex* fixedIndex = indexs)
                    {
                        return getSortDesc(values, getKey, fixedIndex);
                    }
                }
                else
                {
                    ushortSortIndex* fixedIndex = stackalloc ushortSortIndex[values.Length];
                    return getSortDesc(values, getKey, fixedIndex);
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getSortDesc<valueType>
            (valueType[] values, func<valueType, ushort> getKey, ushortSortIndex* fixedIndex)
        {
            ushortSortIndex* writeIndex = fixedIndex;
            if (values.Length > 1)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                for (int index = 0; index != values.Length; ++index)
                {
                    *writeIndex++ = new ushortSortIndex { Value = getKey(values[index]), Index = index };
                }
                sortDesc(writeIndex = fixedIndex, fixedIndex + values.Length - 1);
            }
            else *fixedIndex = new ushortSortIndex { Index = 0 };
            valueType[] newValues = new valueType[values.Length];
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetSortDesc<valueType>
            (valueType[] values, func<valueType, ushort> getKey, int startIndex, int count)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                if (count > (config.pub.Default.StreamBufferLength >> 4))
                {
                    ushortSortIndex[] indexs = new ushortSortIndex[count];
                    fixed (ushortSortIndex* fixedIndex = indexs)
                    {
                        return getSortDesc(values, getKey, range.SkipCount, count, fixedIndex);
                    }
                }
                else
                {
                    ushortSortIndex* fixedIndex = stackalloc ushortSortIndex[count];
                    return getSortDesc(values, getKey, range.SkipCount, count, fixedIndex);
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getSortDesc<valueType>
            (valueType[] values, func<valueType, ushort> getKey, int startIndex, int count
            , ushortSortIndex* fixedIndex)
        {
            ushortSortIndex* writeIndex = fixedIndex;
            if (count > 1)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                for (int index = startIndex, endIndex = startIndex + count; index != endIndex; ++index)
                {
                    *writeIndex++ = new ushortSortIndex { Value = getKey(values[index]), Index = index };
                }
                sortDesc(writeIndex = fixedIndex, fixedIndex + count - 1);
            }
            else *fixedIndex = new ushortSortIndex { Index = startIndex };
            valueType[] newValues = new valueType[count];
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的数组</returns>
        public static ushort[] sortDesc(this ushort[] array)
        {
            algorithm.quickSort.SortDesc(array);
            return array.notNull();
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        public static ushort[] getSortDesc(this ushort[] array)
        {
            return algorithm.quickSort.GetSortDesc(array);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的数组</returns>
        public static ushort[] sortDesc
            (this ushort[] array, int startIndex, int count)
        {
            algorithm.quickSort.SortDesc(array, startIndex, count);
            return array.notNull();
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的新数组</returns>
        public static ushort[] getSortDesc
            (this ushort[] array, int startIndex, int count)
        {
            return algorithm.quickSort.GetSortDesc(array, startIndex, count);
        }

        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <returns>排序后的数组</returns>
        public static valueType[] sortDesc<valueType>
            (this valueType[] array, func<valueType, ushort> getKey)
        {
            return algorithm.quickSort.GetSortDesc(array, getKey);
        }
        /// <summary>
        /// 排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的数组</returns>
        public static valueType[] sortDesc<valueType>
            (this valueType[] array, func<valueType, ushort> getKey, int startIndex, int count)
        {
            return algorithm.quickSort.GetSortDesc(array, getKey, startIndex, count);
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 单向动态数组扩展
    /// </summary>
    public static partial class list
    {
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <returns>排序后的单向动态数组</returns>
        public static list<ushort> sortDesc(this list<ushort> list)
        {
            if (list.count() != 0) algorithm.quickSort.SortDesc(list.Unsafer.Array, 0, list.Count);
            return list;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <returns>排序后新的单向动态数组</returns>
        public static ushort[] getSortDesc(this list<ushort> list)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.GetSortDesc(list.Unsafer.Array, 0, list.Count);
            }
            return nullValue<ushort>.Array;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的单向动态数组</returns>
        public static list<ushort> sortDesc
            (this list<ushort> list, int startIndex, int count)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                algorithm.quickSort.SortDesc(list.Unsafer.Array, range.SkipCount, count);
            }
            return list;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后新的单向动态数组</returns>
        public static ushort[] getSortDesc
            (this list<ushort> list, int startIndex, int count)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.GetSortDesc(list.Unsafer.Array, range.SkipCount, count);
            }
            return nullValue<ushort>.Array;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="getKey">排序键</param>
        /// <returns>排序后的新数组</returns>
        public static valueType[] sortDesc<valueType>
            (this list<valueType> list, func<valueType, ushort> getKey)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.GetSortDesc(list.Unsafer.Array, getKey, 0, list.Count);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的新数组</returns>
        public static valueType[] sortDesc<valueType>
            (this list<valueType> list, func<valueType, ushort> getKey, int startIndex, int count)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.GetSortDesc(list.Unsafer.Array, getKey, range.SkipCount, count);
            }
            return nullValue<valueType>.Array;
        }
    }
}


namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        private unsafe static void sort
            (short* startIndex, short* endIndex)
        {
            do
            {
                short leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue > rightValue)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                short* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                short value = *averageIndex;
                if (leftValue > value)
                {
                    if (leftValue > rightValue)
                    {
                        *rightIndex = leftValue;
                        if (value > rightValue) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = value;
                        *averageIndex = value = leftValue;
                    }
                }
                else
                {
                    if (value > rightValue)
                    {
                        *rightIndex = value;
                        if (leftValue > rightValue)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = value = leftValue;
                        }
                        else *averageIndex = value = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                do
                {
                    while (*leftIndex < value) ++leftIndex;
                    while (value < *rightIndex) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sort(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sort(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        public unsafe static void Sort(short[] values)
        {
            if (values != null && values.Length > 1)
            {
                fixed (short* valueFixed = values)
                {
                    sort(valueFixed, valueFixed + values.Length - 1);
                }
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static short[] GetSort(short[] values)
        {
            if (values.length() != 0)
            {
                short[] newValue = new short[values.Length];
                Buffer.BlockCopy(values, 0, newValue, 0, values.Length * sizeof(short));
                fixed (short* newValueFixed = newValue, valueFixed = values)
                {
                    sort(newValueFixed, newValueFixed + values.Length - 1);
                }
                return newValue;
            }
            return nullValue<short>.Array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        public unsafe static void Sort(short[] values, int startIndex, int count)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if (range.GetCount > 1)
            {
                fixed (short* valueFixed = values)
                {
                    sort(valueFixed + range.SkipCount, valueFixed + range.EndIndex - 1);
                }
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static short[] GetSort
            (short[] values, int startIndex, int count)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                short[] newValues = new short[count];
                Buffer.BlockCopy(values, range.SkipCount * sizeof(short), newValues, 0, count * sizeof(short));
                fixed (short* newValueFixed = newValues, valueFixed = values)
                {
                    if (--count > 0) sort(newValueFixed, newValueFixed + count);
                }
                return newValues;
            }
            return nullValue<short>.Array;
        }
        /// <summary>
        /// 索引快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        private unsafe static void sort
            (shortSortIndex* startIndex, shortSortIndex* endIndex)
        {
            do
            {
                shortSortIndex leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue.Value > rightValue.Value)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                shortSortIndex* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                shortSortIndex indexValue = *averageIndex;
                if (leftValue.Value > indexValue.Value)
                {
                    if (leftValue.Value > rightValue.Value)
                    {
                        *rightIndex = leftValue;
                        if (indexValue.Value > rightValue.Value) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = indexValue;
                        *averageIndex = indexValue = leftValue;
                    }
                }
                else
                {
                    if (indexValue.Value > rightValue.Value)
                    {
                        *rightIndex = indexValue;
                        if (leftValue.Value > rightValue.Value)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = indexValue = leftValue;
                        }
                        else *averageIndex = indexValue = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                short value = indexValue.Value;
                do
                {
                    while ((*leftIndex).Value < value) ++leftIndex;
                    while (value < (*rightIndex).Value) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sort(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sort(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetSort<valueType>
            (valueType[] values, func<valueType, short> getKey)
        {
            if (values.length() != 0)
            {
                if (values.Length > (config.pub.Default.StreamBufferLength >> 4))
                {
                    shortSortIndex[] indexs = new shortSortIndex[values.Length];
                    fixed (shortSortIndex* fixedIndex = indexs)
                    {
                        return getSort(values, getKey, fixedIndex);
                    }
                }
                else
                {
                    shortSortIndex* fixedIndex = stackalloc shortSortIndex[values.Length];
                    return getSort(values, getKey, fixedIndex);
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getSort<valueType>
            (valueType[] values, func<valueType, short> getKey, shortSortIndex* fixedIndex)
        {
            shortSortIndex* writeIndex = fixedIndex;
            if (values.Length > 1)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                for (int index = 0; index != values.Length; ++index)
                {
                    *writeIndex++ = new shortSortIndex { Value = getKey(values[index]), Index = index };
                }
                sort(writeIndex = fixedIndex, fixedIndex + values.Length - 1);
            }
            else *fixedIndex = new shortSortIndex { Index = 0 };
            valueType[] newValues = new valueType[values.Length];
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetSort<valueType>
            (valueType[] values, func<valueType, short> getKey, int startIndex, int count)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                if (count > (config.pub.Default.StreamBufferLength >> 4))
                {
                    shortSortIndex[] indexs = new shortSortIndex[count];
                    fixed (shortSortIndex* fixedIndex = indexs)
                    {
                        return getSort(values, getKey, range.SkipCount, count, fixedIndex);
                    }
                }
                else
                {
                    shortSortIndex* fixedIndex = stackalloc shortSortIndex[count];
                    return getSort(values, getKey, range.SkipCount, count, fixedIndex);
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getSort<valueType>
            (valueType[] values, func<valueType, short> getKey, int startIndex, int count
            , shortSortIndex* fixedIndex)
        {
            shortSortIndex* writeIndex = fixedIndex;
            if (count > 1)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                for (int index = startIndex, endIndex = startIndex + count; index != endIndex; ++index)
                {
                    *writeIndex++ = new shortSortIndex { Value = getKey(values[index]), Index = index };
                }
                sort(writeIndex = fixedIndex, fixedIndex + count - 1);
            }
            else *fixedIndex = new shortSortIndex { Index = startIndex };
            valueType[] newValues = new valueType[count];
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的数组</returns>
        public static short[] sort(this short[] array)
        {
            algorithm.quickSort.Sort(array);
            return array.notNull();
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        public static short[] getSort(this short[] array)
        {
            return algorithm.quickSort.GetSort(array);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的数组</returns>
        public static short[] sort
            (this short[] array, int startIndex, int count)
        {
            algorithm.quickSort.Sort(array, startIndex, count);
            return array.notNull();
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的新数组</returns>
        public static short[] getSort
            (this short[] array, int startIndex, int count)
        {
            return algorithm.quickSort.GetSort(array, startIndex, count);
        }

        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <returns>排序后的数组</returns>
        public static valueType[] sort<valueType>
            (this valueType[] array, func<valueType, short> getKey)
        {
            return algorithm.quickSort.GetSort(array, getKey);
        }
        /// <summary>
        /// 排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的数组</returns>
        public static valueType[] sort<valueType>
            (this valueType[] array, func<valueType, short> getKey, int startIndex, int count)
        {
            return algorithm.quickSort.GetSort(array, getKey, startIndex, count);
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 单向动态数组扩展
    /// </summary>
    public static partial class list
    {
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <returns>排序后的单向动态数组</returns>
        public static list<short> sort(this list<short> list)
        {
            if (list.count() != 0) algorithm.quickSort.Sort(list.Unsafer.Array, 0, list.Count);
            return list;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <returns>排序后新的单向动态数组</returns>
        public static short[] getSort(this list<short> list)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.GetSort(list.Unsafer.Array, 0, list.Count);
            }
            return nullValue<short>.Array;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的单向动态数组</returns>
        public static list<short> sort
            (this list<short> list, int startIndex, int count)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                algorithm.quickSort.Sort(list.Unsafer.Array, range.SkipCount, count);
            }
            return list;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后新的单向动态数组</returns>
        public static short[] getSort
            (this list<short> list, int startIndex, int count)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.GetSort(list.Unsafer.Array, range.SkipCount, count);
            }
            return nullValue<short>.Array;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="getKey">排序键</param>
        /// <returns>排序后的新数组</returns>
        public static valueType[] sort<valueType>
            (this list<valueType> list, func<valueType, short> getKey)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.GetSort(list.Unsafer.Array, getKey, 0, list.Count);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的新数组</returns>
        public static valueType[] sort<valueType>
            (this list<valueType> list, func<valueType, short> getKey, int startIndex, int count)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.GetSort(list.Unsafer.Array, getKey, range.SkipCount, count);
            }
            return nullValue<valueType>.Array;
        }
    }
}


namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        private unsafe static void sortDesc
            (short* startIndex, short* endIndex)
        {
            do
            {
                short leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue < rightValue)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                short* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                short value = *averageIndex;
                if (leftValue < value)
                {
                    if (leftValue < rightValue)
                    {
                        *rightIndex = leftValue;
                        if (value < rightValue) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = value;
                        *averageIndex = value = leftValue;
                    }
                }
                else
                {
                    if (value < rightValue)
                    {
                        *rightIndex = value;
                        if (leftValue < rightValue)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = value = leftValue;
                        }
                        else *averageIndex = value = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                do
                {
                    while (*leftIndex > value) ++leftIndex;
                    while (value > *rightIndex) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sortDesc(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sortDesc(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        public unsafe static void SortDesc(short[] values)
        {
            if (values != null && values.Length > 1)
            {
                fixed (short* valueFixed = values)
                {
                    sortDesc(valueFixed, valueFixed + values.Length - 1);
                }
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static short[] GetSortDesc(short[] values)
        {
            if (values.length() != 0)
            {
                short[] newValue = new short[values.Length];
                Buffer.BlockCopy(values, 0, newValue, 0, values.Length * sizeof(short));
                fixed (short* newValueFixed = newValue, valueFixed = values)
                {
                    sortDesc(newValueFixed, newValueFixed + values.Length - 1);
                }
                return newValue;
            }
            return nullValue<short>.Array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        public unsafe static void SortDesc(short[] values, int startIndex, int count)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if (range.GetCount > 1)
            {
                fixed (short* valueFixed = values)
                {
                    sortDesc(valueFixed + range.SkipCount, valueFixed + range.EndIndex - 1);
                }
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static short[] GetSortDesc
            (short[] values, int startIndex, int count)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                short[] newValues = new short[count];
                Buffer.BlockCopy(values, range.SkipCount * sizeof(short), newValues, 0, count * sizeof(short));
                fixed (short* newValueFixed = newValues, valueFixed = values)
                {
                    if (--count > 0) sortDesc(newValueFixed, newValueFixed + count);
                }
                return newValues;
            }
            return nullValue<short>.Array;
        }
        /// <summary>
        /// 索引快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        private unsafe static void sortDesc
            (shortSortIndex* startIndex, shortSortIndex* endIndex)
        {
            do
            {
                shortSortIndex leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue.Value < rightValue.Value)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                shortSortIndex* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                shortSortIndex indexValue = *averageIndex;
                if (leftValue.Value < indexValue.Value)
                {
                    if (leftValue.Value < rightValue.Value)
                    {
                        *rightIndex = leftValue;
                        if (indexValue.Value < rightValue.Value) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = indexValue;
                        *averageIndex = indexValue = leftValue;
                    }
                }
                else
                {
                    if (indexValue.Value < rightValue.Value)
                    {
                        *rightIndex = indexValue;
                        if (leftValue.Value < rightValue.Value)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = indexValue = leftValue;
                        }
                        else *averageIndex = indexValue = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                short value = indexValue.Value;
                do
                {
                    while ((*leftIndex).Value > value) ++leftIndex;
                    while (value > (*rightIndex).Value) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sortDesc(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sortDesc(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetSortDesc<valueType>
            (valueType[] values, func<valueType, short> getKey)
        {
            if (values.length() != 0)
            {
                if (values.Length > (config.pub.Default.StreamBufferLength >> 4))
                {
                    shortSortIndex[] indexs = new shortSortIndex[values.Length];
                    fixed (shortSortIndex* fixedIndex = indexs)
                    {
                        return getSortDesc(values, getKey, fixedIndex);
                    }
                }
                else
                {
                    shortSortIndex* fixedIndex = stackalloc shortSortIndex[values.Length];
                    return getSortDesc(values, getKey, fixedIndex);
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getSortDesc<valueType>
            (valueType[] values, func<valueType, short> getKey, shortSortIndex* fixedIndex)
        {
            shortSortIndex* writeIndex = fixedIndex;
            if (values.Length > 1)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                for (int index = 0; index != values.Length; ++index)
                {
                    *writeIndex++ = new shortSortIndex { Value = getKey(values[index]), Index = index };
                }
                sortDesc(writeIndex = fixedIndex, fixedIndex + values.Length - 1);
            }
            else *fixedIndex = new shortSortIndex { Index = 0 };
            valueType[] newValues = new valueType[values.Length];
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetSortDesc<valueType>
            (valueType[] values, func<valueType, short> getKey, int startIndex, int count)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                if (count > (config.pub.Default.StreamBufferLength >> 4))
                {
                    shortSortIndex[] indexs = new shortSortIndex[count];
                    fixed (shortSortIndex* fixedIndex = indexs)
                    {
                        return getSortDesc(values, getKey, range.SkipCount, count, fixedIndex);
                    }
                }
                else
                {
                    shortSortIndex* fixedIndex = stackalloc shortSortIndex[count];
                    return getSortDesc(values, getKey, range.SkipCount, count, fixedIndex);
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getSortDesc<valueType>
            (valueType[] values, func<valueType, short> getKey, int startIndex, int count
            , shortSortIndex* fixedIndex)
        {
            shortSortIndex* writeIndex = fixedIndex;
            if (count > 1)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                for (int index = startIndex, endIndex = startIndex + count; index != endIndex; ++index)
                {
                    *writeIndex++ = new shortSortIndex { Value = getKey(values[index]), Index = index };
                }
                sortDesc(writeIndex = fixedIndex, fixedIndex + count - 1);
            }
            else *fixedIndex = new shortSortIndex { Index = startIndex };
            valueType[] newValues = new valueType[count];
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的数组</returns>
        public static short[] sortDesc(this short[] array)
        {
            algorithm.quickSort.SortDesc(array);
            return array.notNull();
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        public static short[] getSortDesc(this short[] array)
        {
            return algorithm.quickSort.GetSortDesc(array);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的数组</returns>
        public static short[] sortDesc
            (this short[] array, int startIndex, int count)
        {
            algorithm.quickSort.SortDesc(array, startIndex, count);
            return array.notNull();
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的新数组</returns>
        public static short[] getSortDesc
            (this short[] array, int startIndex, int count)
        {
            return algorithm.quickSort.GetSortDesc(array, startIndex, count);
        }

        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <returns>排序后的数组</returns>
        public static valueType[] sortDesc<valueType>
            (this valueType[] array, func<valueType, short> getKey)
        {
            return algorithm.quickSort.GetSortDesc(array, getKey);
        }
        /// <summary>
        /// 排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的数组</returns>
        public static valueType[] sortDesc<valueType>
            (this valueType[] array, func<valueType, short> getKey, int startIndex, int count)
        {
            return algorithm.quickSort.GetSortDesc(array, getKey, startIndex, count);
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 单向动态数组扩展
    /// </summary>
    public static partial class list
    {
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <returns>排序后的单向动态数组</returns>
        public static list<short> sortDesc(this list<short> list)
        {
            if (list.count() != 0) algorithm.quickSort.SortDesc(list.Unsafer.Array, 0, list.Count);
            return list;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <returns>排序后新的单向动态数组</returns>
        public static short[] getSortDesc(this list<short> list)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.GetSortDesc(list.Unsafer.Array, 0, list.Count);
            }
            return nullValue<short>.Array;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的单向动态数组</returns>
        public static list<short> sortDesc
            (this list<short> list, int startIndex, int count)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                algorithm.quickSort.SortDesc(list.Unsafer.Array, range.SkipCount, count);
            }
            return list;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后新的单向动态数组</returns>
        public static short[] getSortDesc
            (this list<short> list, int startIndex, int count)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.GetSortDesc(list.Unsafer.Array, range.SkipCount, count);
            }
            return nullValue<short>.Array;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="getKey">排序键</param>
        /// <returns>排序后的新数组</returns>
        public static valueType[] sortDesc<valueType>
            (this list<valueType> list, func<valueType, short> getKey)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.GetSortDesc(list.Unsafer.Array, getKey, 0, list.Count);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的新数组</returns>
        public static valueType[] sortDesc<valueType>
            (this list<valueType> list, func<valueType, short> getKey, int startIndex, int count)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.GetSortDesc(list.Unsafer.Array, getKey, range.SkipCount, count);
            }
            return nullValue<valueType>.Array;
        }
    }
}


namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        private unsafe static void sort
            (byte* startIndex, byte* endIndex)
        {
            do
            {
                byte leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue > rightValue)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                byte* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                byte value = *averageIndex;
                if (leftValue > value)
                {
                    if (leftValue > rightValue)
                    {
                        *rightIndex = leftValue;
                        if (value > rightValue) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = value;
                        *averageIndex = value = leftValue;
                    }
                }
                else
                {
                    if (value > rightValue)
                    {
                        *rightIndex = value;
                        if (leftValue > rightValue)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = value = leftValue;
                        }
                        else *averageIndex = value = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                do
                {
                    while (*leftIndex < value) ++leftIndex;
                    while (value < *rightIndex) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sort(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sort(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        public unsafe static void Sort(byte[] values)
        {
            if (values != null && values.Length > 1)
            {
                fixed (byte* valueFixed = values)
                {
                    sort(valueFixed, valueFixed + values.Length - 1);
                }
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static byte[] GetSort(byte[] values)
        {
            if (values.length() != 0)
            {
                byte[] newValue = new byte[values.Length];
                Buffer.BlockCopy(values, 0, newValue, 0, values.Length * sizeof(byte));
                fixed (byte* newValueFixed = newValue, valueFixed = values)
                {
                    sort(newValueFixed, newValueFixed + values.Length - 1);
                }
                return newValue;
            }
            return nullValue<byte>.Array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        public unsafe static void Sort(byte[] values, int startIndex, int count)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if (range.GetCount > 1)
            {
                fixed (byte* valueFixed = values)
                {
                    sort(valueFixed + range.SkipCount, valueFixed + range.EndIndex - 1);
                }
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static byte[] GetSort
            (byte[] values, int startIndex, int count)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                byte[] newValues = new byte[count];
                Buffer.BlockCopy(values, range.SkipCount * sizeof(byte), newValues, 0, count * sizeof(byte));
                fixed (byte* newValueFixed = newValues, valueFixed = values)
                {
                    if (--count > 0) sort(newValueFixed, newValueFixed + count);
                }
                return newValues;
            }
            return nullValue<byte>.Array;
        }
        /// <summary>
        /// 索引快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        private unsafe static void sort
            (byteSortIndex* startIndex, byteSortIndex* endIndex)
        {
            do
            {
                byteSortIndex leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue.Value > rightValue.Value)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                byteSortIndex* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                byteSortIndex indexValue = *averageIndex;
                if (leftValue.Value > indexValue.Value)
                {
                    if (leftValue.Value > rightValue.Value)
                    {
                        *rightIndex = leftValue;
                        if (indexValue.Value > rightValue.Value) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = indexValue;
                        *averageIndex = indexValue = leftValue;
                    }
                }
                else
                {
                    if (indexValue.Value > rightValue.Value)
                    {
                        *rightIndex = indexValue;
                        if (leftValue.Value > rightValue.Value)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = indexValue = leftValue;
                        }
                        else *averageIndex = indexValue = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                byte value = indexValue.Value;
                do
                {
                    while ((*leftIndex).Value < value) ++leftIndex;
                    while (value < (*rightIndex).Value) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sort(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sort(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetSort<valueType>
            (valueType[] values, func<valueType, byte> getKey)
        {
            if (values.length() != 0)
            {
                if (values.Length > (config.pub.Default.StreamBufferLength >> 4))
                {
                    byteSortIndex[] indexs = new byteSortIndex[values.Length];
                    fixed (byteSortIndex* fixedIndex = indexs)
                    {
                        return getSort(values, getKey, fixedIndex);
                    }
                }
                else
                {
                    byteSortIndex* fixedIndex = stackalloc byteSortIndex[values.Length];
                    return getSort(values, getKey, fixedIndex);
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getSort<valueType>
            (valueType[] values, func<valueType, byte> getKey, byteSortIndex* fixedIndex)
        {
            byteSortIndex* writeIndex = fixedIndex;
            if (values.Length > 1)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                for (int index = 0; index != values.Length; ++index)
                {
                    *writeIndex++ = new byteSortIndex { Value = getKey(values[index]), Index = index };
                }
                sort(writeIndex = fixedIndex, fixedIndex + values.Length - 1);
            }
            else *fixedIndex = new byteSortIndex { Index = 0 };
            valueType[] newValues = new valueType[values.Length];
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetSort<valueType>
            (valueType[] values, func<valueType, byte> getKey, int startIndex, int count)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                if (count > (config.pub.Default.StreamBufferLength >> 4))
                {
                    byteSortIndex[] indexs = new byteSortIndex[count];
                    fixed (byteSortIndex* fixedIndex = indexs)
                    {
                        return getSort(values, getKey, range.SkipCount, count, fixedIndex);
                    }
                }
                else
                {
                    byteSortIndex* fixedIndex = stackalloc byteSortIndex[count];
                    return getSort(values, getKey, range.SkipCount, count, fixedIndex);
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getSort<valueType>
            (valueType[] values, func<valueType, byte> getKey, int startIndex, int count
            , byteSortIndex* fixedIndex)
        {
            byteSortIndex* writeIndex = fixedIndex;
            if (count > 1)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                for (int index = startIndex, endIndex = startIndex + count; index != endIndex; ++index)
                {
                    *writeIndex++ = new byteSortIndex { Value = getKey(values[index]), Index = index };
                }
                sort(writeIndex = fixedIndex, fixedIndex + count - 1);
            }
            else *fixedIndex = new byteSortIndex { Index = startIndex };
            valueType[] newValues = new valueType[count];
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的数组</returns>
        public static byte[] sort(this byte[] array)
        {
            algorithm.quickSort.Sort(array);
            return array.notNull();
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        public static byte[] getSort(this byte[] array)
        {
            return algorithm.quickSort.GetSort(array);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的数组</returns>
        public static byte[] sort
            (this byte[] array, int startIndex, int count)
        {
            algorithm.quickSort.Sort(array, startIndex, count);
            return array.notNull();
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的新数组</returns>
        public static byte[] getSort
            (this byte[] array, int startIndex, int count)
        {
            return algorithm.quickSort.GetSort(array, startIndex, count);
        }

        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <returns>排序后的数组</returns>
        public static valueType[] sort<valueType>
            (this valueType[] array, func<valueType, byte> getKey)
        {
            return algorithm.quickSort.GetSort(array, getKey);
        }
        /// <summary>
        /// 排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的数组</returns>
        public static valueType[] sort<valueType>
            (this valueType[] array, func<valueType, byte> getKey, int startIndex, int count)
        {
            return algorithm.quickSort.GetSort(array, getKey, startIndex, count);
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 单向动态数组扩展
    /// </summary>
    public static partial class list
    {
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <returns>排序后的单向动态数组</returns>
        public static list<byte> sort(this list<byte> list)
        {
            if (list.count() != 0) algorithm.quickSort.Sort(list.Unsafer.Array, 0, list.Count);
            return list;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <returns>排序后新的单向动态数组</returns>
        public static byte[] getSort(this list<byte> list)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.GetSort(list.Unsafer.Array, 0, list.Count);
            }
            return nullValue<byte>.Array;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的单向动态数组</returns>
        public static list<byte> sort
            (this list<byte> list, int startIndex, int count)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                algorithm.quickSort.Sort(list.Unsafer.Array, range.SkipCount, count);
            }
            return list;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后新的单向动态数组</returns>
        public static byte[] getSort
            (this list<byte> list, int startIndex, int count)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.GetSort(list.Unsafer.Array, range.SkipCount, count);
            }
            return nullValue<byte>.Array;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="getKey">排序键</param>
        /// <returns>排序后的新数组</returns>
        public static valueType[] sort<valueType>
            (this list<valueType> list, func<valueType, byte> getKey)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.GetSort(list.Unsafer.Array, getKey, 0, list.Count);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的新数组</returns>
        public static valueType[] sort<valueType>
            (this list<valueType> list, func<valueType, byte> getKey, int startIndex, int count)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.GetSort(list.Unsafer.Array, getKey, range.SkipCount, count);
            }
            return nullValue<valueType>.Array;
        }
    }
}


namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        private unsafe static void sortDesc
            (byte* startIndex, byte* endIndex)
        {
            do
            {
                byte leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue < rightValue)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                byte* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                byte value = *averageIndex;
                if (leftValue < value)
                {
                    if (leftValue < rightValue)
                    {
                        *rightIndex = leftValue;
                        if (value < rightValue) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = value;
                        *averageIndex = value = leftValue;
                    }
                }
                else
                {
                    if (value < rightValue)
                    {
                        *rightIndex = value;
                        if (leftValue < rightValue)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = value = leftValue;
                        }
                        else *averageIndex = value = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                do
                {
                    while (*leftIndex > value) ++leftIndex;
                    while (value > *rightIndex) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sortDesc(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sortDesc(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        public unsafe static void SortDesc(byte[] values)
        {
            if (values != null && values.Length > 1)
            {
                fixed (byte* valueFixed = values)
                {
                    sortDesc(valueFixed, valueFixed + values.Length - 1);
                }
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static byte[] GetSortDesc(byte[] values)
        {
            if (values.length() != 0)
            {
                byte[] newValue = new byte[values.Length];
                Buffer.BlockCopy(values, 0, newValue, 0, values.Length * sizeof(byte));
                fixed (byte* newValueFixed = newValue, valueFixed = values)
                {
                    sortDesc(newValueFixed, newValueFixed + values.Length - 1);
                }
                return newValue;
            }
            return nullValue<byte>.Array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        public unsafe static void SortDesc(byte[] values, int startIndex, int count)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if (range.GetCount > 1)
            {
                fixed (byte* valueFixed = values)
                {
                    sortDesc(valueFixed + range.SkipCount, valueFixed + range.EndIndex - 1);
                }
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static byte[] GetSortDesc
            (byte[] values, int startIndex, int count)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                byte[] newValues = new byte[count];
                Buffer.BlockCopy(values, range.SkipCount * sizeof(byte), newValues, 0, count * sizeof(byte));
                fixed (byte* newValueFixed = newValues, valueFixed = values)
                {
                    if (--count > 0) sortDesc(newValueFixed, newValueFixed + count);
                }
                return newValues;
            }
            return nullValue<byte>.Array;
        }
        /// <summary>
        /// 索引快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        private unsafe static void sortDesc
            (byteSortIndex* startIndex, byteSortIndex* endIndex)
        {
            do
            {
                byteSortIndex leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue.Value < rightValue.Value)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                byteSortIndex* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                byteSortIndex indexValue = *averageIndex;
                if (leftValue.Value < indexValue.Value)
                {
                    if (leftValue.Value < rightValue.Value)
                    {
                        *rightIndex = leftValue;
                        if (indexValue.Value < rightValue.Value) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = indexValue;
                        *averageIndex = indexValue = leftValue;
                    }
                }
                else
                {
                    if (indexValue.Value < rightValue.Value)
                    {
                        *rightIndex = indexValue;
                        if (leftValue.Value < rightValue.Value)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = indexValue = leftValue;
                        }
                        else *averageIndex = indexValue = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                byte value = indexValue.Value;
                do
                {
                    while ((*leftIndex).Value > value) ++leftIndex;
                    while (value > (*rightIndex).Value) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sortDesc(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sortDesc(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetSortDesc<valueType>
            (valueType[] values, func<valueType, byte> getKey)
        {
            if (values.length() != 0)
            {
                if (values.Length > (config.pub.Default.StreamBufferLength >> 4))
                {
                    byteSortIndex[] indexs = new byteSortIndex[values.Length];
                    fixed (byteSortIndex* fixedIndex = indexs)
                    {
                        return getSortDesc(values, getKey, fixedIndex);
                    }
                }
                else
                {
                    byteSortIndex* fixedIndex = stackalloc byteSortIndex[values.Length];
                    return getSortDesc(values, getKey, fixedIndex);
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getSortDesc<valueType>
            (valueType[] values, func<valueType, byte> getKey, byteSortIndex* fixedIndex)
        {
            byteSortIndex* writeIndex = fixedIndex;
            if (values.Length > 1)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                for (int index = 0; index != values.Length; ++index)
                {
                    *writeIndex++ = new byteSortIndex { Value = getKey(values[index]), Index = index };
                }
                sortDesc(writeIndex = fixedIndex, fixedIndex + values.Length - 1);
            }
            else *fixedIndex = new byteSortIndex { Index = 0 };
            valueType[] newValues = new valueType[values.Length];
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetSortDesc<valueType>
            (valueType[] values, func<valueType, byte> getKey, int startIndex, int count)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                if (count > (config.pub.Default.StreamBufferLength >> 4))
                {
                    byteSortIndex[] indexs = new byteSortIndex[count];
                    fixed (byteSortIndex* fixedIndex = indexs)
                    {
                        return getSortDesc(values, getKey, range.SkipCount, count, fixedIndex);
                    }
                }
                else
                {
                    byteSortIndex* fixedIndex = stackalloc byteSortIndex[count];
                    return getSortDesc(values, getKey, range.SkipCount, count, fixedIndex);
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getSortDesc<valueType>
            (valueType[] values, func<valueType, byte> getKey, int startIndex, int count
            , byteSortIndex* fixedIndex)
        {
            byteSortIndex* writeIndex = fixedIndex;
            if (count > 1)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                for (int index = startIndex, endIndex = startIndex + count; index != endIndex; ++index)
                {
                    *writeIndex++ = new byteSortIndex { Value = getKey(values[index]), Index = index };
                }
                sortDesc(writeIndex = fixedIndex, fixedIndex + count - 1);
            }
            else *fixedIndex = new byteSortIndex { Index = startIndex };
            valueType[] newValues = new valueType[count];
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的数组</returns>
        public static byte[] sortDesc(this byte[] array)
        {
            algorithm.quickSort.SortDesc(array);
            return array.notNull();
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        public static byte[] getSortDesc(this byte[] array)
        {
            return algorithm.quickSort.GetSortDesc(array);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的数组</returns>
        public static byte[] sortDesc
            (this byte[] array, int startIndex, int count)
        {
            algorithm.quickSort.SortDesc(array, startIndex, count);
            return array.notNull();
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的新数组</returns>
        public static byte[] getSortDesc
            (this byte[] array, int startIndex, int count)
        {
            return algorithm.quickSort.GetSortDesc(array, startIndex, count);
        }

        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <returns>排序后的数组</returns>
        public static valueType[] sortDesc<valueType>
            (this valueType[] array, func<valueType, byte> getKey)
        {
            return algorithm.quickSort.GetSortDesc(array, getKey);
        }
        /// <summary>
        /// 排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的数组</returns>
        public static valueType[] sortDesc<valueType>
            (this valueType[] array, func<valueType, byte> getKey, int startIndex, int count)
        {
            return algorithm.quickSort.GetSortDesc(array, getKey, startIndex, count);
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 单向动态数组扩展
    /// </summary>
    public static partial class list
    {
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <returns>排序后的单向动态数组</returns>
        public static list<byte> sortDesc(this list<byte> list)
        {
            if (list.count() != 0) algorithm.quickSort.SortDesc(list.Unsafer.Array, 0, list.Count);
            return list;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <returns>排序后新的单向动态数组</returns>
        public static byte[] getSortDesc(this list<byte> list)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.GetSortDesc(list.Unsafer.Array, 0, list.Count);
            }
            return nullValue<byte>.Array;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的单向动态数组</returns>
        public static list<byte> sortDesc
            (this list<byte> list, int startIndex, int count)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                algorithm.quickSort.SortDesc(list.Unsafer.Array, range.SkipCount, count);
            }
            return list;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后新的单向动态数组</returns>
        public static byte[] getSortDesc
            (this list<byte> list, int startIndex, int count)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.GetSortDesc(list.Unsafer.Array, range.SkipCount, count);
            }
            return nullValue<byte>.Array;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="getKey">排序键</param>
        /// <returns>排序后的新数组</returns>
        public static valueType[] sortDesc<valueType>
            (this list<valueType> list, func<valueType, byte> getKey)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.GetSortDesc(list.Unsafer.Array, getKey, 0, list.Count);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的新数组</returns>
        public static valueType[] sortDesc<valueType>
            (this list<valueType> list, func<valueType, byte> getKey, int startIndex, int count)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.GetSortDesc(list.Unsafer.Array, getKey, range.SkipCount, count);
            }
            return nullValue<valueType>.Array;
        }
    }
}


namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        private unsafe static void sort
            (sbyte* startIndex, sbyte* endIndex)
        {
            do
            {
                sbyte leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue > rightValue)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                sbyte* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                sbyte value = *averageIndex;
                if (leftValue > value)
                {
                    if (leftValue > rightValue)
                    {
                        *rightIndex = leftValue;
                        if (value > rightValue) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = value;
                        *averageIndex = value = leftValue;
                    }
                }
                else
                {
                    if (value > rightValue)
                    {
                        *rightIndex = value;
                        if (leftValue > rightValue)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = value = leftValue;
                        }
                        else *averageIndex = value = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                do
                {
                    while (*leftIndex < value) ++leftIndex;
                    while (value < *rightIndex) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sort(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sort(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        public unsafe static void Sort(sbyte[] values)
        {
            if (values != null && values.Length > 1)
            {
                fixed (sbyte* valueFixed = values)
                {
                    sort(valueFixed, valueFixed + values.Length - 1);
                }
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static sbyte[] GetSort(sbyte[] values)
        {
            if (values.length() != 0)
            {
                sbyte[] newValue = new sbyte[values.Length];
                Buffer.BlockCopy(values, 0, newValue, 0, values.Length * sizeof(sbyte));
                fixed (sbyte* newValueFixed = newValue, valueFixed = values)
                {
                    sort(newValueFixed, newValueFixed + values.Length - 1);
                }
                return newValue;
            }
            return nullValue<sbyte>.Array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        public unsafe static void Sort(sbyte[] values, int startIndex, int count)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if (range.GetCount > 1)
            {
                fixed (sbyte* valueFixed = values)
                {
                    sort(valueFixed + range.SkipCount, valueFixed + range.EndIndex - 1);
                }
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static sbyte[] GetSort
            (sbyte[] values, int startIndex, int count)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                sbyte[] newValues = new sbyte[count];
                Buffer.BlockCopy(values, range.SkipCount * sizeof(sbyte), newValues, 0, count * sizeof(sbyte));
                fixed (sbyte* newValueFixed = newValues, valueFixed = values)
                {
                    if (--count > 0) sort(newValueFixed, newValueFixed + count);
                }
                return newValues;
            }
            return nullValue<sbyte>.Array;
        }
        /// <summary>
        /// 索引快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        private unsafe static void sort
            (sbyteSortIndex* startIndex, sbyteSortIndex* endIndex)
        {
            do
            {
                sbyteSortIndex leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue.Value > rightValue.Value)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                sbyteSortIndex* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                sbyteSortIndex indexValue = *averageIndex;
                if (leftValue.Value > indexValue.Value)
                {
                    if (leftValue.Value > rightValue.Value)
                    {
                        *rightIndex = leftValue;
                        if (indexValue.Value > rightValue.Value) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = indexValue;
                        *averageIndex = indexValue = leftValue;
                    }
                }
                else
                {
                    if (indexValue.Value > rightValue.Value)
                    {
                        *rightIndex = indexValue;
                        if (leftValue.Value > rightValue.Value)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = indexValue = leftValue;
                        }
                        else *averageIndex = indexValue = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                sbyte value = indexValue.Value;
                do
                {
                    while ((*leftIndex).Value < value) ++leftIndex;
                    while (value < (*rightIndex).Value) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sort(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sort(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetSort<valueType>
            (valueType[] values, func<valueType, sbyte> getKey)
        {
            if (values.length() != 0)
            {
                if (values.Length > (config.pub.Default.StreamBufferLength >> 4))
                {
                    sbyteSortIndex[] indexs = new sbyteSortIndex[values.Length];
                    fixed (sbyteSortIndex* fixedIndex = indexs)
                    {
                        return getSort(values, getKey, fixedIndex);
                    }
                }
                else
                {
                    sbyteSortIndex* fixedIndex = stackalloc sbyteSortIndex[values.Length];
                    return getSort(values, getKey, fixedIndex);
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getSort<valueType>
            (valueType[] values, func<valueType, sbyte> getKey, sbyteSortIndex* fixedIndex)
        {
            sbyteSortIndex* writeIndex = fixedIndex;
            if (values.Length > 1)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                for (int index = 0; index != values.Length; ++index)
                {
                    *writeIndex++ = new sbyteSortIndex { Value = getKey(values[index]), Index = index };
                }
                sort(writeIndex = fixedIndex, fixedIndex + values.Length - 1);
            }
            else *fixedIndex = new sbyteSortIndex { Index = 0 };
            valueType[] newValues = new valueType[values.Length];
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetSort<valueType>
            (valueType[] values, func<valueType, sbyte> getKey, int startIndex, int count)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                if (count > (config.pub.Default.StreamBufferLength >> 4))
                {
                    sbyteSortIndex[] indexs = new sbyteSortIndex[count];
                    fixed (sbyteSortIndex* fixedIndex = indexs)
                    {
                        return getSort(values, getKey, range.SkipCount, count, fixedIndex);
                    }
                }
                else
                {
                    sbyteSortIndex* fixedIndex = stackalloc sbyteSortIndex[count];
                    return getSort(values, getKey, range.SkipCount, count, fixedIndex);
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getSort<valueType>
            (valueType[] values, func<valueType, sbyte> getKey, int startIndex, int count
            , sbyteSortIndex* fixedIndex)
        {
            sbyteSortIndex* writeIndex = fixedIndex;
            if (count > 1)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                for (int index = startIndex, endIndex = startIndex + count; index != endIndex; ++index)
                {
                    *writeIndex++ = new sbyteSortIndex { Value = getKey(values[index]), Index = index };
                }
                sort(writeIndex = fixedIndex, fixedIndex + count - 1);
            }
            else *fixedIndex = new sbyteSortIndex { Index = startIndex };
            valueType[] newValues = new valueType[count];
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的数组</returns>
        public static sbyte[] sort(this sbyte[] array)
        {
            algorithm.quickSort.Sort(array);
            return array.notNull();
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        public static sbyte[] getSort(this sbyte[] array)
        {
            return algorithm.quickSort.GetSort(array);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的数组</returns>
        public static sbyte[] sort
            (this sbyte[] array, int startIndex, int count)
        {
            algorithm.quickSort.Sort(array, startIndex, count);
            return array.notNull();
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的新数组</returns>
        public static sbyte[] getSort
            (this sbyte[] array, int startIndex, int count)
        {
            return algorithm.quickSort.GetSort(array, startIndex, count);
        }

        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <returns>排序后的数组</returns>
        public static valueType[] sort<valueType>
            (this valueType[] array, func<valueType, sbyte> getKey)
        {
            return algorithm.quickSort.GetSort(array, getKey);
        }
        /// <summary>
        /// 排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的数组</returns>
        public static valueType[] sort<valueType>
            (this valueType[] array, func<valueType, sbyte> getKey, int startIndex, int count)
        {
            return algorithm.quickSort.GetSort(array, getKey, startIndex, count);
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 单向动态数组扩展
    /// </summary>
    public static partial class list
    {
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <returns>排序后的单向动态数组</returns>
        public static list<sbyte> sort(this list<sbyte> list)
        {
            if (list.count() != 0) algorithm.quickSort.Sort(list.Unsafer.Array, 0, list.Count);
            return list;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <returns>排序后新的单向动态数组</returns>
        public static sbyte[] getSort(this list<sbyte> list)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.GetSort(list.Unsafer.Array, 0, list.Count);
            }
            return nullValue<sbyte>.Array;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的单向动态数组</returns>
        public static list<sbyte> sort
            (this list<sbyte> list, int startIndex, int count)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                algorithm.quickSort.Sort(list.Unsafer.Array, range.SkipCount, count);
            }
            return list;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后新的单向动态数组</returns>
        public static sbyte[] getSort
            (this list<sbyte> list, int startIndex, int count)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.GetSort(list.Unsafer.Array, range.SkipCount, count);
            }
            return nullValue<sbyte>.Array;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="getKey">排序键</param>
        /// <returns>排序后的新数组</returns>
        public static valueType[] sort<valueType>
            (this list<valueType> list, func<valueType, sbyte> getKey)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.GetSort(list.Unsafer.Array, getKey, 0, list.Count);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的新数组</returns>
        public static valueType[] sort<valueType>
            (this list<valueType> list, func<valueType, sbyte> getKey, int startIndex, int count)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.GetSort(list.Unsafer.Array, getKey, range.SkipCount, count);
            }
            return nullValue<valueType>.Array;
        }
    }
}


namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        private unsafe static void sortDesc
            (sbyte* startIndex, sbyte* endIndex)
        {
            do
            {
                sbyte leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue < rightValue)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                sbyte* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                sbyte value = *averageIndex;
                if (leftValue < value)
                {
                    if (leftValue < rightValue)
                    {
                        *rightIndex = leftValue;
                        if (value < rightValue) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = value;
                        *averageIndex = value = leftValue;
                    }
                }
                else
                {
                    if (value < rightValue)
                    {
                        *rightIndex = value;
                        if (leftValue < rightValue)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = value = leftValue;
                        }
                        else *averageIndex = value = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                do
                {
                    while (*leftIndex > value) ++leftIndex;
                    while (value > *rightIndex) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sortDesc(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sortDesc(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        public unsafe static void SortDesc(sbyte[] values)
        {
            if (values != null && values.Length > 1)
            {
                fixed (sbyte* valueFixed = values)
                {
                    sortDesc(valueFixed, valueFixed + values.Length - 1);
                }
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static sbyte[] GetSortDesc(sbyte[] values)
        {
            if (values.length() != 0)
            {
                sbyte[] newValue = new sbyte[values.Length];
                Buffer.BlockCopy(values, 0, newValue, 0, values.Length * sizeof(sbyte));
                fixed (sbyte* newValueFixed = newValue, valueFixed = values)
                {
                    sortDesc(newValueFixed, newValueFixed + values.Length - 1);
                }
                return newValue;
            }
            return nullValue<sbyte>.Array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        public unsafe static void SortDesc(sbyte[] values, int startIndex, int count)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if (range.GetCount > 1)
            {
                fixed (sbyte* valueFixed = values)
                {
                    sortDesc(valueFixed + range.SkipCount, valueFixed + range.EndIndex - 1);
                }
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static sbyte[] GetSortDesc
            (sbyte[] values, int startIndex, int count)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                sbyte[] newValues = new sbyte[count];
                Buffer.BlockCopy(values, range.SkipCount * sizeof(sbyte), newValues, 0, count * sizeof(sbyte));
                fixed (sbyte* newValueFixed = newValues, valueFixed = values)
                {
                    if (--count > 0) sortDesc(newValueFixed, newValueFixed + count);
                }
                return newValues;
            }
            return nullValue<sbyte>.Array;
        }
        /// <summary>
        /// 索引快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        private unsafe static void sortDesc
            (sbyteSortIndex* startIndex, sbyteSortIndex* endIndex)
        {
            do
            {
                sbyteSortIndex leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue.Value < rightValue.Value)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                sbyteSortIndex* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                sbyteSortIndex indexValue = *averageIndex;
                if (leftValue.Value < indexValue.Value)
                {
                    if (leftValue.Value < rightValue.Value)
                    {
                        *rightIndex = leftValue;
                        if (indexValue.Value < rightValue.Value) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = indexValue;
                        *averageIndex = indexValue = leftValue;
                    }
                }
                else
                {
                    if (indexValue.Value < rightValue.Value)
                    {
                        *rightIndex = indexValue;
                        if (leftValue.Value < rightValue.Value)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = indexValue = leftValue;
                        }
                        else *averageIndex = indexValue = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                sbyte value = indexValue.Value;
                do
                {
                    while ((*leftIndex).Value > value) ++leftIndex;
                    while (value > (*rightIndex).Value) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sortDesc(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sortDesc(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetSortDesc<valueType>
            (valueType[] values, func<valueType, sbyte> getKey)
        {
            if (values.length() != 0)
            {
                if (values.Length > (config.pub.Default.StreamBufferLength >> 4))
                {
                    sbyteSortIndex[] indexs = new sbyteSortIndex[values.Length];
                    fixed (sbyteSortIndex* fixedIndex = indexs)
                    {
                        return getSortDesc(values, getKey, fixedIndex);
                    }
                }
                else
                {
                    sbyteSortIndex* fixedIndex = stackalloc sbyteSortIndex[values.Length];
                    return getSortDesc(values, getKey, fixedIndex);
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getSortDesc<valueType>
            (valueType[] values, func<valueType, sbyte> getKey, sbyteSortIndex* fixedIndex)
        {
            sbyteSortIndex* writeIndex = fixedIndex;
            if (values.Length > 1)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                for (int index = 0; index != values.Length; ++index)
                {
                    *writeIndex++ = new sbyteSortIndex { Value = getKey(values[index]), Index = index };
                }
                sortDesc(writeIndex = fixedIndex, fixedIndex + values.Length - 1);
            }
            else *fixedIndex = new sbyteSortIndex { Index = 0 };
            valueType[] newValues = new valueType[values.Length];
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetSortDesc<valueType>
            (valueType[] values, func<valueType, sbyte> getKey, int startIndex, int count)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                if (count > (config.pub.Default.StreamBufferLength >> 4))
                {
                    sbyteSortIndex[] indexs = new sbyteSortIndex[count];
                    fixed (sbyteSortIndex* fixedIndex = indexs)
                    {
                        return getSortDesc(values, getKey, range.SkipCount, count, fixedIndex);
                    }
                }
                else
                {
                    sbyteSortIndex* fixedIndex = stackalloc sbyteSortIndex[count];
                    return getSortDesc(values, getKey, range.SkipCount, count, fixedIndex);
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getSortDesc<valueType>
            (valueType[] values, func<valueType, sbyte> getKey, int startIndex, int count
            , sbyteSortIndex* fixedIndex)
        {
            sbyteSortIndex* writeIndex = fixedIndex;
            if (count > 1)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                for (int index = startIndex, endIndex = startIndex + count; index != endIndex; ++index)
                {
                    *writeIndex++ = new sbyteSortIndex { Value = getKey(values[index]), Index = index };
                }
                sortDesc(writeIndex = fixedIndex, fixedIndex + count - 1);
            }
            else *fixedIndex = new sbyteSortIndex { Index = startIndex };
            valueType[] newValues = new valueType[count];
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的数组</returns>
        public static sbyte[] sortDesc(this sbyte[] array)
        {
            algorithm.quickSort.SortDesc(array);
            return array.notNull();
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        public static sbyte[] getSortDesc(this sbyte[] array)
        {
            return algorithm.quickSort.GetSortDesc(array);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的数组</returns>
        public static sbyte[] sortDesc
            (this sbyte[] array, int startIndex, int count)
        {
            algorithm.quickSort.SortDesc(array, startIndex, count);
            return array.notNull();
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的新数组</returns>
        public static sbyte[] getSortDesc
            (this sbyte[] array, int startIndex, int count)
        {
            return algorithm.quickSort.GetSortDesc(array, startIndex, count);
        }

        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <returns>排序后的数组</returns>
        public static valueType[] sortDesc<valueType>
            (this valueType[] array, func<valueType, sbyte> getKey)
        {
            return algorithm.quickSort.GetSortDesc(array, getKey);
        }
        /// <summary>
        /// 排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的数组</returns>
        public static valueType[] sortDesc<valueType>
            (this valueType[] array, func<valueType, sbyte> getKey, int startIndex, int count)
        {
            return algorithm.quickSort.GetSortDesc(array, getKey, startIndex, count);
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 单向动态数组扩展
    /// </summary>
    public static partial class list
    {
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <returns>排序后的单向动态数组</returns>
        public static list<sbyte> sortDesc(this list<sbyte> list)
        {
            if (list.count() != 0) algorithm.quickSort.SortDesc(list.Unsafer.Array, 0, list.Count);
            return list;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <returns>排序后新的单向动态数组</returns>
        public static sbyte[] getSortDesc(this list<sbyte> list)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.GetSortDesc(list.Unsafer.Array, 0, list.Count);
            }
            return nullValue<sbyte>.Array;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的单向动态数组</returns>
        public static list<sbyte> sortDesc
            (this list<sbyte> list, int startIndex, int count)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                algorithm.quickSort.SortDesc(list.Unsafer.Array, range.SkipCount, count);
            }
            return list;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后新的单向动态数组</returns>
        public static sbyte[] getSortDesc
            (this list<sbyte> list, int startIndex, int count)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.GetSortDesc(list.Unsafer.Array, range.SkipCount, count);
            }
            return nullValue<sbyte>.Array;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="getKey">排序键</param>
        /// <returns>排序后的新数组</returns>
        public static valueType[] sortDesc<valueType>
            (this list<valueType> list, func<valueType, sbyte> getKey)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.GetSortDesc(list.Unsafer.Array, getKey, 0, list.Count);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的新数组</returns>
        public static valueType[] sortDesc<valueType>
            (this list<valueType> list, func<valueType, sbyte> getKey, int startIndex, int count)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.GetSortDesc(list.Unsafer.Array, getKey, range.SkipCount, count);
            }
            return nullValue<valueType>.Array;
        }
    }
}


namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        private unsafe static void sort
            (double* startIndex, double* endIndex)
        {
            do
            {
                double leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue > rightValue)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                double* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                double value = *averageIndex;
                if (leftValue > value)
                {
                    if (leftValue > rightValue)
                    {
                        *rightIndex = leftValue;
                        if (value > rightValue) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = value;
                        *averageIndex = value = leftValue;
                    }
                }
                else
                {
                    if (value > rightValue)
                    {
                        *rightIndex = value;
                        if (leftValue > rightValue)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = value = leftValue;
                        }
                        else *averageIndex = value = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                do
                {
                    while (*leftIndex < value) ++leftIndex;
                    while (value < *rightIndex) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sort(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sort(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        public unsafe static void Sort(double[] values)
        {
            if (values != null && values.Length > 1)
            {
                fixed (double* valueFixed = values)
                {
                    sort(valueFixed, valueFixed + values.Length - 1);
                }
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static double[] GetSort(double[] values)
        {
            if (values.length() != 0)
            {
                double[] newValue = new double[values.Length];
                Buffer.BlockCopy(values, 0, newValue, 0, values.Length * sizeof(double));
                fixed (double* newValueFixed = newValue, valueFixed = values)
                {
                    sort(newValueFixed, newValueFixed + values.Length - 1);
                }
                return newValue;
            }
            return nullValue<double>.Array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        public unsafe static void Sort(double[] values, int startIndex, int count)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if (range.GetCount > 1)
            {
                fixed (double* valueFixed = values)
                {
                    sort(valueFixed + range.SkipCount, valueFixed + range.EndIndex - 1);
                }
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static double[] GetSort
            (double[] values, int startIndex, int count)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                double[] newValues = new double[count];
                Buffer.BlockCopy(values, range.SkipCount * sizeof(double), newValues, 0, count * sizeof(double));
                fixed (double* newValueFixed = newValues, valueFixed = values)
                {
                    if (--count > 0) sort(newValueFixed, newValueFixed + count);
                }
                return newValues;
            }
            return nullValue<double>.Array;
        }
        /// <summary>
        /// 索引快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        private unsafe static void sort
            (doubleSortIndex* startIndex, doubleSortIndex* endIndex)
        {
            do
            {
                doubleSortIndex leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue.Value > rightValue.Value)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                doubleSortIndex* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                doubleSortIndex indexValue = *averageIndex;
                if (leftValue.Value > indexValue.Value)
                {
                    if (leftValue.Value > rightValue.Value)
                    {
                        *rightIndex = leftValue;
                        if (indexValue.Value > rightValue.Value) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = indexValue;
                        *averageIndex = indexValue = leftValue;
                    }
                }
                else
                {
                    if (indexValue.Value > rightValue.Value)
                    {
                        *rightIndex = indexValue;
                        if (leftValue.Value > rightValue.Value)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = indexValue = leftValue;
                        }
                        else *averageIndex = indexValue = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                double value = indexValue.Value;
                do
                {
                    while ((*leftIndex).Value < value) ++leftIndex;
                    while (value < (*rightIndex).Value) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sort(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sort(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetSort<valueType>
            (valueType[] values, func<valueType, double> getKey)
        {
            if (values.length() != 0)
            {
                if (values.Length > (config.pub.Default.StreamBufferLength >> 4))
                {
                    doubleSortIndex[] indexs = new doubleSortIndex[values.Length];
                    fixed (doubleSortIndex* fixedIndex = indexs)
                    {
                        return getSort(values, getKey, fixedIndex);
                    }
                }
                else
                {
                    doubleSortIndex* fixedIndex = stackalloc doubleSortIndex[values.Length];
                    return getSort(values, getKey, fixedIndex);
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getSort<valueType>
            (valueType[] values, func<valueType, double> getKey, doubleSortIndex* fixedIndex)
        {
            doubleSortIndex* writeIndex = fixedIndex;
            if (values.Length > 1)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                for (int index = 0; index != values.Length; ++index)
                {
                    *writeIndex++ = new doubleSortIndex { Value = getKey(values[index]), Index = index };
                }
                sort(writeIndex = fixedIndex, fixedIndex + values.Length - 1);
            }
            else *fixedIndex = new doubleSortIndex { Index = 0 };
            valueType[] newValues = new valueType[values.Length];
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetSort<valueType>
            (valueType[] values, func<valueType, double> getKey, int startIndex, int count)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                if (count > (config.pub.Default.StreamBufferLength >> 4))
                {
                    doubleSortIndex[] indexs = new doubleSortIndex[count];
                    fixed (doubleSortIndex* fixedIndex = indexs)
                    {
                        return getSort(values, getKey, range.SkipCount, count, fixedIndex);
                    }
                }
                else
                {
                    doubleSortIndex* fixedIndex = stackalloc doubleSortIndex[count];
                    return getSort(values, getKey, range.SkipCount, count, fixedIndex);
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getSort<valueType>
            (valueType[] values, func<valueType, double> getKey, int startIndex, int count
            , doubleSortIndex* fixedIndex)
        {
            doubleSortIndex* writeIndex = fixedIndex;
            if (count > 1)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                for (int index = startIndex, endIndex = startIndex + count; index != endIndex; ++index)
                {
                    *writeIndex++ = new doubleSortIndex { Value = getKey(values[index]), Index = index };
                }
                sort(writeIndex = fixedIndex, fixedIndex + count - 1);
            }
            else *fixedIndex = new doubleSortIndex { Index = startIndex };
            valueType[] newValues = new valueType[count];
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的数组</returns>
        public static double[] sort(this double[] array)
        {
            algorithm.quickSort.Sort(array);
            return array.notNull();
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        public static double[] getSort(this double[] array)
        {
            return algorithm.quickSort.GetSort(array);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的数组</returns>
        public static double[] sort
            (this double[] array, int startIndex, int count)
        {
            algorithm.quickSort.Sort(array, startIndex, count);
            return array.notNull();
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的新数组</returns>
        public static double[] getSort
            (this double[] array, int startIndex, int count)
        {
            return algorithm.quickSort.GetSort(array, startIndex, count);
        }

        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <returns>排序后的数组</returns>
        public static valueType[] sort<valueType>
            (this valueType[] array, func<valueType, double> getKey)
        {
            return algorithm.quickSort.GetSort(array, getKey);
        }
        /// <summary>
        /// 排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的数组</returns>
        public static valueType[] sort<valueType>
            (this valueType[] array, func<valueType, double> getKey, int startIndex, int count)
        {
            return algorithm.quickSort.GetSort(array, getKey, startIndex, count);
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 单向动态数组扩展
    /// </summary>
    public static partial class list
    {
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <returns>排序后的单向动态数组</returns>
        public static list<double> sort(this list<double> list)
        {
            if (list.count() != 0) algorithm.quickSort.Sort(list.Unsafer.Array, 0, list.Count);
            return list;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <returns>排序后新的单向动态数组</returns>
        public static double[] getSort(this list<double> list)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.GetSort(list.Unsafer.Array, 0, list.Count);
            }
            return nullValue<double>.Array;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的单向动态数组</returns>
        public static list<double> sort
            (this list<double> list, int startIndex, int count)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                algorithm.quickSort.Sort(list.Unsafer.Array, range.SkipCount, count);
            }
            return list;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后新的单向动态数组</returns>
        public static double[] getSort
            (this list<double> list, int startIndex, int count)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.GetSort(list.Unsafer.Array, range.SkipCount, count);
            }
            return nullValue<double>.Array;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="getKey">排序键</param>
        /// <returns>排序后的新数组</returns>
        public static valueType[] sort<valueType>
            (this list<valueType> list, func<valueType, double> getKey)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.GetSort(list.Unsafer.Array, getKey, 0, list.Count);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的新数组</returns>
        public static valueType[] sort<valueType>
            (this list<valueType> list, func<valueType, double> getKey, int startIndex, int count)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.GetSort(list.Unsafer.Array, getKey, range.SkipCount, count);
            }
            return nullValue<valueType>.Array;
        }
    }
}


namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        private unsafe static void sortDesc
            (double* startIndex, double* endIndex)
        {
            do
            {
                double leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue < rightValue)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                double* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                double value = *averageIndex;
                if (leftValue < value)
                {
                    if (leftValue < rightValue)
                    {
                        *rightIndex = leftValue;
                        if (value < rightValue) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = value;
                        *averageIndex = value = leftValue;
                    }
                }
                else
                {
                    if (value < rightValue)
                    {
                        *rightIndex = value;
                        if (leftValue < rightValue)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = value = leftValue;
                        }
                        else *averageIndex = value = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                do
                {
                    while (*leftIndex > value) ++leftIndex;
                    while (value > *rightIndex) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sortDesc(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sortDesc(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        public unsafe static void SortDesc(double[] values)
        {
            if (values != null && values.Length > 1)
            {
                fixed (double* valueFixed = values)
                {
                    sortDesc(valueFixed, valueFixed + values.Length - 1);
                }
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static double[] GetSortDesc(double[] values)
        {
            if (values.length() != 0)
            {
                double[] newValue = new double[values.Length];
                Buffer.BlockCopy(values, 0, newValue, 0, values.Length * sizeof(double));
                fixed (double* newValueFixed = newValue, valueFixed = values)
                {
                    sortDesc(newValueFixed, newValueFixed + values.Length - 1);
                }
                return newValue;
            }
            return nullValue<double>.Array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        public unsafe static void SortDesc(double[] values, int startIndex, int count)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if (range.GetCount > 1)
            {
                fixed (double* valueFixed = values)
                {
                    sortDesc(valueFixed + range.SkipCount, valueFixed + range.EndIndex - 1);
                }
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static double[] GetSortDesc
            (double[] values, int startIndex, int count)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                double[] newValues = new double[count];
                Buffer.BlockCopy(values, range.SkipCount * sizeof(double), newValues, 0, count * sizeof(double));
                fixed (double* newValueFixed = newValues, valueFixed = values)
                {
                    if (--count > 0) sortDesc(newValueFixed, newValueFixed + count);
                }
                return newValues;
            }
            return nullValue<double>.Array;
        }
        /// <summary>
        /// 索引快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        private unsafe static void sortDesc
            (doubleSortIndex* startIndex, doubleSortIndex* endIndex)
        {
            do
            {
                doubleSortIndex leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue.Value < rightValue.Value)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                doubleSortIndex* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                doubleSortIndex indexValue = *averageIndex;
                if (leftValue.Value < indexValue.Value)
                {
                    if (leftValue.Value < rightValue.Value)
                    {
                        *rightIndex = leftValue;
                        if (indexValue.Value < rightValue.Value) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = indexValue;
                        *averageIndex = indexValue = leftValue;
                    }
                }
                else
                {
                    if (indexValue.Value < rightValue.Value)
                    {
                        *rightIndex = indexValue;
                        if (leftValue.Value < rightValue.Value)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = indexValue = leftValue;
                        }
                        else *averageIndex = indexValue = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                double value = indexValue.Value;
                do
                {
                    while ((*leftIndex).Value > value) ++leftIndex;
                    while (value > (*rightIndex).Value) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sortDesc(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sortDesc(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetSortDesc<valueType>
            (valueType[] values, func<valueType, double> getKey)
        {
            if (values.length() != 0)
            {
                if (values.Length > (config.pub.Default.StreamBufferLength >> 4))
                {
                    doubleSortIndex[] indexs = new doubleSortIndex[values.Length];
                    fixed (doubleSortIndex* fixedIndex = indexs)
                    {
                        return getSortDesc(values, getKey, fixedIndex);
                    }
                }
                else
                {
                    doubleSortIndex* fixedIndex = stackalloc doubleSortIndex[values.Length];
                    return getSortDesc(values, getKey, fixedIndex);
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getSortDesc<valueType>
            (valueType[] values, func<valueType, double> getKey, doubleSortIndex* fixedIndex)
        {
            doubleSortIndex* writeIndex = fixedIndex;
            if (values.Length > 1)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                for (int index = 0; index != values.Length; ++index)
                {
                    *writeIndex++ = new doubleSortIndex { Value = getKey(values[index]), Index = index };
                }
                sortDesc(writeIndex = fixedIndex, fixedIndex + values.Length - 1);
            }
            else *fixedIndex = new doubleSortIndex { Index = 0 };
            valueType[] newValues = new valueType[values.Length];
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetSortDesc<valueType>
            (valueType[] values, func<valueType, double> getKey, int startIndex, int count)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                if (count > (config.pub.Default.StreamBufferLength >> 4))
                {
                    doubleSortIndex[] indexs = new doubleSortIndex[count];
                    fixed (doubleSortIndex* fixedIndex = indexs)
                    {
                        return getSortDesc(values, getKey, range.SkipCount, count, fixedIndex);
                    }
                }
                else
                {
                    doubleSortIndex* fixedIndex = stackalloc doubleSortIndex[count];
                    return getSortDesc(values, getKey, range.SkipCount, count, fixedIndex);
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getSortDesc<valueType>
            (valueType[] values, func<valueType, double> getKey, int startIndex, int count
            , doubleSortIndex* fixedIndex)
        {
            doubleSortIndex* writeIndex = fixedIndex;
            if (count > 1)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                for (int index = startIndex, endIndex = startIndex + count; index != endIndex; ++index)
                {
                    *writeIndex++ = new doubleSortIndex { Value = getKey(values[index]), Index = index };
                }
                sortDesc(writeIndex = fixedIndex, fixedIndex + count - 1);
            }
            else *fixedIndex = new doubleSortIndex { Index = startIndex };
            valueType[] newValues = new valueType[count];
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的数组</returns>
        public static double[] sortDesc(this double[] array)
        {
            algorithm.quickSort.SortDesc(array);
            return array.notNull();
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        public static double[] getSortDesc(this double[] array)
        {
            return algorithm.quickSort.GetSortDesc(array);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的数组</returns>
        public static double[] sortDesc
            (this double[] array, int startIndex, int count)
        {
            algorithm.quickSort.SortDesc(array, startIndex, count);
            return array.notNull();
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的新数组</returns>
        public static double[] getSortDesc
            (this double[] array, int startIndex, int count)
        {
            return algorithm.quickSort.GetSortDesc(array, startIndex, count);
        }

        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <returns>排序后的数组</returns>
        public static valueType[] sortDesc<valueType>
            (this valueType[] array, func<valueType, double> getKey)
        {
            return algorithm.quickSort.GetSortDesc(array, getKey);
        }
        /// <summary>
        /// 排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的数组</returns>
        public static valueType[] sortDesc<valueType>
            (this valueType[] array, func<valueType, double> getKey, int startIndex, int count)
        {
            return algorithm.quickSort.GetSortDesc(array, getKey, startIndex, count);
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 单向动态数组扩展
    /// </summary>
    public static partial class list
    {
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <returns>排序后的单向动态数组</returns>
        public static list<double> sortDesc(this list<double> list)
        {
            if (list.count() != 0) algorithm.quickSort.SortDesc(list.Unsafer.Array, 0, list.Count);
            return list;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <returns>排序后新的单向动态数组</returns>
        public static double[] getSortDesc(this list<double> list)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.GetSortDesc(list.Unsafer.Array, 0, list.Count);
            }
            return nullValue<double>.Array;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的单向动态数组</returns>
        public static list<double> sortDesc
            (this list<double> list, int startIndex, int count)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                algorithm.quickSort.SortDesc(list.Unsafer.Array, range.SkipCount, count);
            }
            return list;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后新的单向动态数组</returns>
        public static double[] getSortDesc
            (this list<double> list, int startIndex, int count)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.GetSortDesc(list.Unsafer.Array, range.SkipCount, count);
            }
            return nullValue<double>.Array;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="getKey">排序键</param>
        /// <returns>排序后的新数组</returns>
        public static valueType[] sortDesc<valueType>
            (this list<valueType> list, func<valueType, double> getKey)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.GetSortDesc(list.Unsafer.Array, getKey, 0, list.Count);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的新数组</returns>
        public static valueType[] sortDesc<valueType>
            (this list<valueType> list, func<valueType, double> getKey, int startIndex, int count)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.GetSortDesc(list.Unsafer.Array, getKey, range.SkipCount, count);
            }
            return nullValue<valueType>.Array;
        }
    }
}


namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        private unsafe static void sort
            (float* startIndex, float* endIndex)
        {
            do
            {
                float leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue > rightValue)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                float* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                float value = *averageIndex;
                if (leftValue > value)
                {
                    if (leftValue > rightValue)
                    {
                        *rightIndex = leftValue;
                        if (value > rightValue) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = value;
                        *averageIndex = value = leftValue;
                    }
                }
                else
                {
                    if (value > rightValue)
                    {
                        *rightIndex = value;
                        if (leftValue > rightValue)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = value = leftValue;
                        }
                        else *averageIndex = value = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                do
                {
                    while (*leftIndex < value) ++leftIndex;
                    while (value < *rightIndex) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sort(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sort(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        public unsafe static void Sort(float[] values)
        {
            if (values != null && values.Length > 1)
            {
                fixed (float* valueFixed = values)
                {
                    sort(valueFixed, valueFixed + values.Length - 1);
                }
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static float[] GetSort(float[] values)
        {
            if (values.length() != 0)
            {
                float[] newValue = new float[values.Length];
                Buffer.BlockCopy(values, 0, newValue, 0, values.Length * sizeof(float));
                fixed (float* newValueFixed = newValue, valueFixed = values)
                {
                    sort(newValueFixed, newValueFixed + values.Length - 1);
                }
                return newValue;
            }
            return nullValue<float>.Array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        public unsafe static void Sort(float[] values, int startIndex, int count)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if (range.GetCount > 1)
            {
                fixed (float* valueFixed = values)
                {
                    sort(valueFixed + range.SkipCount, valueFixed + range.EndIndex - 1);
                }
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static float[] GetSort
            (float[] values, int startIndex, int count)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                float[] newValues = new float[count];
                Buffer.BlockCopy(values, range.SkipCount * sizeof(float), newValues, 0, count * sizeof(float));
                fixed (float* newValueFixed = newValues, valueFixed = values)
                {
                    if (--count > 0) sort(newValueFixed, newValueFixed + count);
                }
                return newValues;
            }
            return nullValue<float>.Array;
        }
        /// <summary>
        /// 索引快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        private unsafe static void sort
            (floatSortIndex* startIndex, floatSortIndex* endIndex)
        {
            do
            {
                floatSortIndex leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue.Value > rightValue.Value)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                floatSortIndex* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                floatSortIndex indexValue = *averageIndex;
                if (leftValue.Value > indexValue.Value)
                {
                    if (leftValue.Value > rightValue.Value)
                    {
                        *rightIndex = leftValue;
                        if (indexValue.Value > rightValue.Value) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = indexValue;
                        *averageIndex = indexValue = leftValue;
                    }
                }
                else
                {
                    if (indexValue.Value > rightValue.Value)
                    {
                        *rightIndex = indexValue;
                        if (leftValue.Value > rightValue.Value)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = indexValue = leftValue;
                        }
                        else *averageIndex = indexValue = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                float value = indexValue.Value;
                do
                {
                    while ((*leftIndex).Value < value) ++leftIndex;
                    while (value < (*rightIndex).Value) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sort(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sort(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetSort<valueType>
            (valueType[] values, func<valueType, float> getKey)
        {
            if (values.length() != 0)
            {
                if (values.Length > (config.pub.Default.StreamBufferLength >> 4))
                {
                    floatSortIndex[] indexs = new floatSortIndex[values.Length];
                    fixed (floatSortIndex* fixedIndex = indexs)
                    {
                        return getSort(values, getKey, fixedIndex);
                    }
                }
                else
                {
                    floatSortIndex* fixedIndex = stackalloc floatSortIndex[values.Length];
                    return getSort(values, getKey, fixedIndex);
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getSort<valueType>
            (valueType[] values, func<valueType, float> getKey, floatSortIndex* fixedIndex)
        {
            floatSortIndex* writeIndex = fixedIndex;
            if (values.Length > 1)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                for (int index = 0; index != values.Length; ++index)
                {
                    *writeIndex++ = new floatSortIndex { Value = getKey(values[index]), Index = index };
                }
                sort(writeIndex = fixedIndex, fixedIndex + values.Length - 1);
            }
            else *fixedIndex = new floatSortIndex { Index = 0 };
            valueType[] newValues = new valueType[values.Length];
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetSort<valueType>
            (valueType[] values, func<valueType, float> getKey, int startIndex, int count)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                if (count > (config.pub.Default.StreamBufferLength >> 4))
                {
                    floatSortIndex[] indexs = new floatSortIndex[count];
                    fixed (floatSortIndex* fixedIndex = indexs)
                    {
                        return getSort(values, getKey, range.SkipCount, count, fixedIndex);
                    }
                }
                else
                {
                    floatSortIndex* fixedIndex = stackalloc floatSortIndex[count];
                    return getSort(values, getKey, range.SkipCount, count, fixedIndex);
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getSort<valueType>
            (valueType[] values, func<valueType, float> getKey, int startIndex, int count
            , floatSortIndex* fixedIndex)
        {
            floatSortIndex* writeIndex = fixedIndex;
            if (count > 1)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                for (int index = startIndex, endIndex = startIndex + count; index != endIndex; ++index)
                {
                    *writeIndex++ = new floatSortIndex { Value = getKey(values[index]), Index = index };
                }
                sort(writeIndex = fixedIndex, fixedIndex + count - 1);
            }
            else *fixedIndex = new floatSortIndex { Index = startIndex };
            valueType[] newValues = new valueType[count];
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的数组</returns>
        public static float[] sort(this float[] array)
        {
            algorithm.quickSort.Sort(array);
            return array.notNull();
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        public static float[] getSort(this float[] array)
        {
            return algorithm.quickSort.GetSort(array);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的数组</returns>
        public static float[] sort
            (this float[] array, int startIndex, int count)
        {
            algorithm.quickSort.Sort(array, startIndex, count);
            return array.notNull();
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的新数组</returns>
        public static float[] getSort
            (this float[] array, int startIndex, int count)
        {
            return algorithm.quickSort.GetSort(array, startIndex, count);
        }

        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <returns>排序后的数组</returns>
        public static valueType[] sort<valueType>
            (this valueType[] array, func<valueType, float> getKey)
        {
            return algorithm.quickSort.GetSort(array, getKey);
        }
        /// <summary>
        /// 排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的数组</returns>
        public static valueType[] sort<valueType>
            (this valueType[] array, func<valueType, float> getKey, int startIndex, int count)
        {
            return algorithm.quickSort.GetSort(array, getKey, startIndex, count);
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 单向动态数组扩展
    /// </summary>
    public static partial class list
    {
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <returns>排序后的单向动态数组</returns>
        public static list<float> sort(this list<float> list)
        {
            if (list.count() != 0) algorithm.quickSort.Sort(list.Unsafer.Array, 0, list.Count);
            return list;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <returns>排序后新的单向动态数组</returns>
        public static float[] getSort(this list<float> list)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.GetSort(list.Unsafer.Array, 0, list.Count);
            }
            return nullValue<float>.Array;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的单向动态数组</returns>
        public static list<float> sort
            (this list<float> list, int startIndex, int count)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                algorithm.quickSort.Sort(list.Unsafer.Array, range.SkipCount, count);
            }
            return list;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后新的单向动态数组</returns>
        public static float[] getSort
            (this list<float> list, int startIndex, int count)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.GetSort(list.Unsafer.Array, range.SkipCount, count);
            }
            return nullValue<float>.Array;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="getKey">排序键</param>
        /// <returns>排序后的新数组</returns>
        public static valueType[] sort<valueType>
            (this list<valueType> list, func<valueType, float> getKey)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.GetSort(list.Unsafer.Array, getKey, 0, list.Count);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的新数组</returns>
        public static valueType[] sort<valueType>
            (this list<valueType> list, func<valueType, float> getKey, int startIndex, int count)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.GetSort(list.Unsafer.Array, getKey, range.SkipCount, count);
            }
            return nullValue<valueType>.Array;
        }
    }
}


namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        private unsafe static void sortDesc
            (float* startIndex, float* endIndex)
        {
            do
            {
                float leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue < rightValue)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                float* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                float value = *averageIndex;
                if (leftValue < value)
                {
                    if (leftValue < rightValue)
                    {
                        *rightIndex = leftValue;
                        if (value < rightValue) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = value;
                        *averageIndex = value = leftValue;
                    }
                }
                else
                {
                    if (value < rightValue)
                    {
                        *rightIndex = value;
                        if (leftValue < rightValue)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = value = leftValue;
                        }
                        else *averageIndex = value = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                do
                {
                    while (*leftIndex > value) ++leftIndex;
                    while (value > *rightIndex) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sortDesc(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sortDesc(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        public unsafe static void SortDesc(float[] values)
        {
            if (values != null && values.Length > 1)
            {
                fixed (float* valueFixed = values)
                {
                    sortDesc(valueFixed, valueFixed + values.Length - 1);
                }
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static float[] GetSortDesc(float[] values)
        {
            if (values.length() != 0)
            {
                float[] newValue = new float[values.Length];
                Buffer.BlockCopy(values, 0, newValue, 0, values.Length * sizeof(float));
                fixed (float* newValueFixed = newValue, valueFixed = values)
                {
                    sortDesc(newValueFixed, newValueFixed + values.Length - 1);
                }
                return newValue;
            }
            return nullValue<float>.Array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        public unsafe static void SortDesc(float[] values, int startIndex, int count)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if (range.GetCount > 1)
            {
                fixed (float* valueFixed = values)
                {
                    sortDesc(valueFixed + range.SkipCount, valueFixed + range.EndIndex - 1);
                }
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static float[] GetSortDesc
            (float[] values, int startIndex, int count)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                float[] newValues = new float[count];
                Buffer.BlockCopy(values, range.SkipCount * sizeof(float), newValues, 0, count * sizeof(float));
                fixed (float* newValueFixed = newValues, valueFixed = values)
                {
                    if (--count > 0) sortDesc(newValueFixed, newValueFixed + count);
                }
                return newValues;
            }
            return nullValue<float>.Array;
        }
        /// <summary>
        /// 索引快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        private unsafe static void sortDesc
            (floatSortIndex* startIndex, floatSortIndex* endIndex)
        {
            do
            {
                floatSortIndex leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue.Value < rightValue.Value)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                floatSortIndex* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                floatSortIndex indexValue = *averageIndex;
                if (leftValue.Value < indexValue.Value)
                {
                    if (leftValue.Value < rightValue.Value)
                    {
                        *rightIndex = leftValue;
                        if (indexValue.Value < rightValue.Value) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = indexValue;
                        *averageIndex = indexValue = leftValue;
                    }
                }
                else
                {
                    if (indexValue.Value < rightValue.Value)
                    {
                        *rightIndex = indexValue;
                        if (leftValue.Value < rightValue.Value)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = indexValue = leftValue;
                        }
                        else *averageIndex = indexValue = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                float value = indexValue.Value;
                do
                {
                    while ((*leftIndex).Value > value) ++leftIndex;
                    while (value > (*rightIndex).Value) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sortDesc(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sortDesc(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetSortDesc<valueType>
            (valueType[] values, func<valueType, float> getKey)
        {
            if (values.length() != 0)
            {
                if (values.Length > (config.pub.Default.StreamBufferLength >> 4))
                {
                    floatSortIndex[] indexs = new floatSortIndex[values.Length];
                    fixed (floatSortIndex* fixedIndex = indexs)
                    {
                        return getSortDesc(values, getKey, fixedIndex);
                    }
                }
                else
                {
                    floatSortIndex* fixedIndex = stackalloc floatSortIndex[values.Length];
                    return getSortDesc(values, getKey, fixedIndex);
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getSortDesc<valueType>
            (valueType[] values, func<valueType, float> getKey, floatSortIndex* fixedIndex)
        {
            floatSortIndex* writeIndex = fixedIndex;
            if (values.Length > 1)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                for (int index = 0; index != values.Length; ++index)
                {
                    *writeIndex++ = new floatSortIndex { Value = getKey(values[index]), Index = index };
                }
                sortDesc(writeIndex = fixedIndex, fixedIndex + values.Length - 1);
            }
            else *fixedIndex = new floatSortIndex { Index = 0 };
            valueType[] newValues = new valueType[values.Length];
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetSortDesc<valueType>
            (valueType[] values, func<valueType, float> getKey, int startIndex, int count)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                if (count > (config.pub.Default.StreamBufferLength >> 4))
                {
                    floatSortIndex[] indexs = new floatSortIndex[count];
                    fixed (floatSortIndex* fixedIndex = indexs)
                    {
                        return getSortDesc(values, getKey, range.SkipCount, count, fixedIndex);
                    }
                }
                else
                {
                    floatSortIndex* fixedIndex = stackalloc floatSortIndex[count];
                    return getSortDesc(values, getKey, range.SkipCount, count, fixedIndex);
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getSortDesc<valueType>
            (valueType[] values, func<valueType, float> getKey, int startIndex, int count
            , floatSortIndex* fixedIndex)
        {
            floatSortIndex* writeIndex = fixedIndex;
            if (count > 1)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                for (int index = startIndex, endIndex = startIndex + count; index != endIndex; ++index)
                {
                    *writeIndex++ = new floatSortIndex { Value = getKey(values[index]), Index = index };
                }
                sortDesc(writeIndex = fixedIndex, fixedIndex + count - 1);
            }
            else *fixedIndex = new floatSortIndex { Index = startIndex };
            valueType[] newValues = new valueType[count];
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的数组</returns>
        public static float[] sortDesc(this float[] array)
        {
            algorithm.quickSort.SortDesc(array);
            return array.notNull();
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        public static float[] getSortDesc(this float[] array)
        {
            return algorithm.quickSort.GetSortDesc(array);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的数组</returns>
        public static float[] sortDesc
            (this float[] array, int startIndex, int count)
        {
            algorithm.quickSort.SortDesc(array, startIndex, count);
            return array.notNull();
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的新数组</returns>
        public static float[] getSortDesc
            (this float[] array, int startIndex, int count)
        {
            return algorithm.quickSort.GetSortDesc(array, startIndex, count);
        }

        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <returns>排序后的数组</returns>
        public static valueType[] sortDesc<valueType>
            (this valueType[] array, func<valueType, float> getKey)
        {
            return algorithm.quickSort.GetSortDesc(array, getKey);
        }
        /// <summary>
        /// 排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的数组</returns>
        public static valueType[] sortDesc<valueType>
            (this valueType[] array, func<valueType, float> getKey, int startIndex, int count)
        {
            return algorithm.quickSort.GetSortDesc(array, getKey, startIndex, count);
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 单向动态数组扩展
    /// </summary>
    public static partial class list
    {
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <returns>排序后的单向动态数组</returns>
        public static list<float> sortDesc(this list<float> list)
        {
            if (list.count() != 0) algorithm.quickSort.SortDesc(list.Unsafer.Array, 0, list.Count);
            return list;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <returns>排序后新的单向动态数组</returns>
        public static float[] getSortDesc(this list<float> list)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.GetSortDesc(list.Unsafer.Array, 0, list.Count);
            }
            return nullValue<float>.Array;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的单向动态数组</returns>
        public static list<float> sortDesc
            (this list<float> list, int startIndex, int count)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                algorithm.quickSort.SortDesc(list.Unsafer.Array, range.SkipCount, count);
            }
            return list;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后新的单向动态数组</returns>
        public static float[] getSortDesc
            (this list<float> list, int startIndex, int count)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.GetSortDesc(list.Unsafer.Array, range.SkipCount, count);
            }
            return nullValue<float>.Array;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="getKey">排序键</param>
        /// <returns>排序后的新数组</returns>
        public static valueType[] sortDesc<valueType>
            (this list<valueType> list, func<valueType, float> getKey)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.GetSortDesc(list.Unsafer.Array, getKey, 0, list.Count);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的新数组</returns>
        public static valueType[] sortDesc<valueType>
            (this list<valueType> list, func<valueType, float> getKey, int startIndex, int count)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.GetSortDesc(list.Unsafer.Array, getKey, range.SkipCount, count);
            }
            return nullValue<valueType>.Array;
        }
    }
}


namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        private unsafe static void sort
            (DateTime* startIndex, DateTime* endIndex)
        {
            do
            {
                DateTime leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue > rightValue)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                DateTime* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                DateTime value = *averageIndex;
                if (leftValue > value)
                {
                    if (leftValue > rightValue)
                    {
                        *rightIndex = leftValue;
                        if (value > rightValue) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = value;
                        *averageIndex = value = leftValue;
                    }
                }
                else
                {
                    if (value > rightValue)
                    {
                        *rightIndex = value;
                        if (leftValue > rightValue)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = value = leftValue;
                        }
                        else *averageIndex = value = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                do
                {
                    while (*leftIndex < value) ++leftIndex;
                    while (value < *rightIndex) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sort(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sort(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        public unsafe static void Sort(DateTime[] values)
        {
            if (values != null && values.Length > 1)
            {
                fixed (DateTime* valueFixed = values)
                {
                    sort(valueFixed, valueFixed + values.Length - 1);
                }
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static DateTime[] GetSort(DateTime[] values)
        {
            if (values.length() != 0)
            {
                DateTime[] newValue = new DateTime[values.Length];
                Buffer.BlockCopy(values, 0, newValue, 0, values.Length * sizeof(DateTime));
                fixed (DateTime* newValueFixed = newValue, valueFixed = values)
                {
                    sort(newValueFixed, newValueFixed + values.Length - 1);
                }
                return newValue;
            }
            return nullValue<DateTime>.Array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        public unsafe static void Sort(DateTime[] values, int startIndex, int count)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if (range.GetCount > 1)
            {
                fixed (DateTime* valueFixed = values)
                {
                    sort(valueFixed + range.SkipCount, valueFixed + range.EndIndex - 1);
                }
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static DateTime[] GetSort
            (DateTime[] values, int startIndex, int count)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                DateTime[] newValues = new DateTime[count];
                Buffer.BlockCopy(values, range.SkipCount * sizeof(DateTime), newValues, 0, count * sizeof(DateTime));
                fixed (DateTime* newValueFixed = newValues, valueFixed = values)
                {
                    if (--count > 0) sort(newValueFixed, newValueFixed + count);
                }
                return newValues;
            }
            return nullValue<DateTime>.Array;
        }
        /// <summary>
        /// 索引快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        private unsafe static void sort
            (dateTimeSortIndex* startIndex, dateTimeSortIndex* endIndex)
        {
            do
            {
                dateTimeSortIndex leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue.Value > rightValue.Value)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                dateTimeSortIndex* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                dateTimeSortIndex indexValue = *averageIndex;
                if (leftValue.Value > indexValue.Value)
                {
                    if (leftValue.Value > rightValue.Value)
                    {
                        *rightIndex = leftValue;
                        if (indexValue.Value > rightValue.Value) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = indexValue;
                        *averageIndex = indexValue = leftValue;
                    }
                }
                else
                {
                    if (indexValue.Value > rightValue.Value)
                    {
                        *rightIndex = indexValue;
                        if (leftValue.Value > rightValue.Value)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = indexValue = leftValue;
                        }
                        else *averageIndex = indexValue = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                DateTime value = indexValue.Value;
                do
                {
                    while ((*leftIndex).Value < value) ++leftIndex;
                    while (value < (*rightIndex).Value) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sort(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sort(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetSort<valueType>
            (valueType[] values, func<valueType, DateTime> getKey)
        {
            if (values.length() != 0)
            {
                if (values.Length > (config.pub.Default.StreamBufferLength >> 4))
                {
                    dateTimeSortIndex[] indexs = new dateTimeSortIndex[values.Length];
                    fixed (dateTimeSortIndex* fixedIndex = indexs)
                    {
                        return getSort(values, getKey, fixedIndex);
                    }
                }
                else
                {
                    dateTimeSortIndex* fixedIndex = stackalloc dateTimeSortIndex[values.Length];
                    return getSort(values, getKey, fixedIndex);
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getSort<valueType>
            (valueType[] values, func<valueType, DateTime> getKey, dateTimeSortIndex* fixedIndex)
        {
            dateTimeSortIndex* writeIndex = fixedIndex;
            if (values.Length > 1)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                for (int index = 0; index != values.Length; ++index)
                {
                    *writeIndex++ = new dateTimeSortIndex { Value = getKey(values[index]), Index = index };
                }
                sort(writeIndex = fixedIndex, fixedIndex + values.Length - 1);
            }
            else *fixedIndex = new dateTimeSortIndex { Index = 0 };
            valueType[] newValues = new valueType[values.Length];
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetSort<valueType>
            (valueType[] values, func<valueType, DateTime> getKey, int startIndex, int count)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                if (count > (config.pub.Default.StreamBufferLength >> 4))
                {
                    dateTimeSortIndex[] indexs = new dateTimeSortIndex[count];
                    fixed (dateTimeSortIndex* fixedIndex = indexs)
                    {
                        return getSort(values, getKey, range.SkipCount, count, fixedIndex);
                    }
                }
                else
                {
                    dateTimeSortIndex* fixedIndex = stackalloc dateTimeSortIndex[count];
                    return getSort(values, getKey, range.SkipCount, count, fixedIndex);
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getSort<valueType>
            (valueType[] values, func<valueType, DateTime> getKey, int startIndex, int count
            , dateTimeSortIndex* fixedIndex)
        {
            dateTimeSortIndex* writeIndex = fixedIndex;
            if (count > 1)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                for (int index = startIndex, endIndex = startIndex + count; index != endIndex; ++index)
                {
                    *writeIndex++ = new dateTimeSortIndex { Value = getKey(values[index]), Index = index };
                }
                sort(writeIndex = fixedIndex, fixedIndex + count - 1);
            }
            else *fixedIndex = new dateTimeSortIndex { Index = startIndex };
            valueType[] newValues = new valueType[count];
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的数组</returns>
        public static DateTime[] sort(this DateTime[] array)
        {
            algorithm.quickSort.Sort(array);
            return array.notNull();
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        public static DateTime[] getSort(this DateTime[] array)
        {
            return algorithm.quickSort.GetSort(array);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的数组</returns>
        public static DateTime[] sort
            (this DateTime[] array, int startIndex, int count)
        {
            algorithm.quickSort.Sort(array, startIndex, count);
            return array.notNull();
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的新数组</returns>
        public static DateTime[] getSort
            (this DateTime[] array, int startIndex, int count)
        {
            return algorithm.quickSort.GetSort(array, startIndex, count);
        }

        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <returns>排序后的数组</returns>
        public static valueType[] sort<valueType>
            (this valueType[] array, func<valueType, DateTime> getKey)
        {
            return algorithm.quickSort.GetSort(array, getKey);
        }
        /// <summary>
        /// 排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的数组</returns>
        public static valueType[] sort<valueType>
            (this valueType[] array, func<valueType, DateTime> getKey, int startIndex, int count)
        {
            return algorithm.quickSort.GetSort(array, getKey, startIndex, count);
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 单向动态数组扩展
    /// </summary>
    public static partial class list
    {
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <returns>排序后的单向动态数组</returns>
        public static list<DateTime> sort(this list<DateTime> list)
        {
            if (list.count() != 0) algorithm.quickSort.Sort(list.Unsafer.Array, 0, list.Count);
            return list;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <returns>排序后新的单向动态数组</returns>
        public static DateTime[] getSort(this list<DateTime> list)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.GetSort(list.Unsafer.Array, 0, list.Count);
            }
            return nullValue<DateTime>.Array;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的单向动态数组</returns>
        public static list<DateTime> sort
            (this list<DateTime> list, int startIndex, int count)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                algorithm.quickSort.Sort(list.Unsafer.Array, range.SkipCount, count);
            }
            return list;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后新的单向动态数组</returns>
        public static DateTime[] getSort
            (this list<DateTime> list, int startIndex, int count)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.GetSort(list.Unsafer.Array, range.SkipCount, count);
            }
            return nullValue<DateTime>.Array;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="getKey">排序键</param>
        /// <returns>排序后的新数组</returns>
        public static valueType[] sort<valueType>
            (this list<valueType> list, func<valueType, DateTime> getKey)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.GetSort(list.Unsafer.Array, getKey, 0, list.Count);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的新数组</returns>
        public static valueType[] sort<valueType>
            (this list<valueType> list, func<valueType, DateTime> getKey, int startIndex, int count)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.GetSort(list.Unsafer.Array, getKey, range.SkipCount, count);
            }
            return nullValue<valueType>.Array;
        }
    }
}


namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        private unsafe static void sortDesc
            (DateTime* startIndex, DateTime* endIndex)
        {
            do
            {
                DateTime leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue < rightValue)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                DateTime* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                DateTime value = *averageIndex;
                if (leftValue < value)
                {
                    if (leftValue < rightValue)
                    {
                        *rightIndex = leftValue;
                        if (value < rightValue) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = value;
                        *averageIndex = value = leftValue;
                    }
                }
                else
                {
                    if (value < rightValue)
                    {
                        *rightIndex = value;
                        if (leftValue < rightValue)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = value = leftValue;
                        }
                        else *averageIndex = value = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                do
                {
                    while (*leftIndex > value) ++leftIndex;
                    while (value > *rightIndex) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sortDesc(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sortDesc(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        public unsafe static void SortDesc(DateTime[] values)
        {
            if (values != null && values.Length > 1)
            {
                fixed (DateTime* valueFixed = values)
                {
                    sortDesc(valueFixed, valueFixed + values.Length - 1);
                }
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static DateTime[] GetSortDesc(DateTime[] values)
        {
            if (values.length() != 0)
            {
                DateTime[] newValue = new DateTime[values.Length];
                Buffer.BlockCopy(values, 0, newValue, 0, values.Length * sizeof(DateTime));
                fixed (DateTime* newValueFixed = newValue, valueFixed = values)
                {
                    sortDesc(newValueFixed, newValueFixed + values.Length - 1);
                }
                return newValue;
            }
            return nullValue<DateTime>.Array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        public unsafe static void SortDesc(DateTime[] values, int startIndex, int count)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if (range.GetCount > 1)
            {
                fixed (DateTime* valueFixed = values)
                {
                    sortDesc(valueFixed + range.SkipCount, valueFixed + range.EndIndex - 1);
                }
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static DateTime[] GetSortDesc
            (DateTime[] values, int startIndex, int count)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                DateTime[] newValues = new DateTime[count];
                Buffer.BlockCopy(values, range.SkipCount * sizeof(DateTime), newValues, 0, count * sizeof(DateTime));
                fixed (DateTime* newValueFixed = newValues, valueFixed = values)
                {
                    if (--count > 0) sortDesc(newValueFixed, newValueFixed + count);
                }
                return newValues;
            }
            return nullValue<DateTime>.Array;
        }
        /// <summary>
        /// 索引快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        private unsafe static void sortDesc
            (dateTimeSortIndex* startIndex, dateTimeSortIndex* endIndex)
        {
            do
            {
                dateTimeSortIndex leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue.Value < rightValue.Value)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                dateTimeSortIndex* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                dateTimeSortIndex indexValue = *averageIndex;
                if (leftValue.Value < indexValue.Value)
                {
                    if (leftValue.Value < rightValue.Value)
                    {
                        *rightIndex = leftValue;
                        if (indexValue.Value < rightValue.Value) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = indexValue;
                        *averageIndex = indexValue = leftValue;
                    }
                }
                else
                {
                    if (indexValue.Value < rightValue.Value)
                    {
                        *rightIndex = indexValue;
                        if (leftValue.Value < rightValue.Value)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = indexValue = leftValue;
                        }
                        else *averageIndex = indexValue = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                DateTime value = indexValue.Value;
                do
                {
                    while ((*leftIndex).Value > value) ++leftIndex;
                    while (value > (*rightIndex).Value) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sortDesc(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sortDesc(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetSortDesc<valueType>
            (valueType[] values, func<valueType, DateTime> getKey)
        {
            if (values.length() != 0)
            {
                if (values.Length > (config.pub.Default.StreamBufferLength >> 4))
                {
                    dateTimeSortIndex[] indexs = new dateTimeSortIndex[values.Length];
                    fixed (dateTimeSortIndex* fixedIndex = indexs)
                    {
                        return getSortDesc(values, getKey, fixedIndex);
                    }
                }
                else
                {
                    dateTimeSortIndex* fixedIndex = stackalloc dateTimeSortIndex[values.Length];
                    return getSortDesc(values, getKey, fixedIndex);
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getSortDesc<valueType>
            (valueType[] values, func<valueType, DateTime> getKey, dateTimeSortIndex* fixedIndex)
        {
            dateTimeSortIndex* writeIndex = fixedIndex;
            if (values.Length > 1)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                for (int index = 0; index != values.Length; ++index)
                {
                    *writeIndex++ = new dateTimeSortIndex { Value = getKey(values[index]), Index = index };
                }
                sortDesc(writeIndex = fixedIndex, fixedIndex + values.Length - 1);
            }
            else *fixedIndex = new dateTimeSortIndex { Index = 0 };
            valueType[] newValues = new valueType[values.Length];
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetSortDesc<valueType>
            (valueType[] values, func<valueType, DateTime> getKey, int startIndex, int count)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                if (count > (config.pub.Default.StreamBufferLength >> 4))
                {
                    dateTimeSortIndex[] indexs = new dateTimeSortIndex[count];
                    fixed (dateTimeSortIndex* fixedIndex = indexs)
                    {
                        return getSortDesc(values, getKey, range.SkipCount, count, fixedIndex);
                    }
                }
                else
                {
                    dateTimeSortIndex* fixedIndex = stackalloc dateTimeSortIndex[count];
                    return getSortDesc(values, getKey, range.SkipCount, count, fixedIndex);
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getSortDesc<valueType>
            (valueType[] values, func<valueType, DateTime> getKey, int startIndex, int count
            , dateTimeSortIndex* fixedIndex)
        {
            dateTimeSortIndex* writeIndex = fixedIndex;
            if (count > 1)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                for (int index = startIndex, endIndex = startIndex + count; index != endIndex; ++index)
                {
                    *writeIndex++ = new dateTimeSortIndex { Value = getKey(values[index]), Index = index };
                }
                sortDesc(writeIndex = fixedIndex, fixedIndex + count - 1);
            }
            else *fixedIndex = new dateTimeSortIndex { Index = startIndex };
            valueType[] newValues = new valueType[count];
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的数组</returns>
        public static DateTime[] sortDesc(this DateTime[] array)
        {
            algorithm.quickSort.SortDesc(array);
            return array.notNull();
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        public static DateTime[] getSortDesc(this DateTime[] array)
        {
            return algorithm.quickSort.GetSortDesc(array);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的数组</returns>
        public static DateTime[] sortDesc
            (this DateTime[] array, int startIndex, int count)
        {
            algorithm.quickSort.SortDesc(array, startIndex, count);
            return array.notNull();
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的新数组</returns>
        public static DateTime[] getSortDesc
            (this DateTime[] array, int startIndex, int count)
        {
            return algorithm.quickSort.GetSortDesc(array, startIndex, count);
        }

        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <returns>排序后的数组</returns>
        public static valueType[] sortDesc<valueType>
            (this valueType[] array, func<valueType, DateTime> getKey)
        {
            return algorithm.quickSort.GetSortDesc(array, getKey);
        }
        /// <summary>
        /// 排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的数组</returns>
        public static valueType[] sortDesc<valueType>
            (this valueType[] array, func<valueType, DateTime> getKey, int startIndex, int count)
        {
            return algorithm.quickSort.GetSortDesc(array, getKey, startIndex, count);
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 单向动态数组扩展
    /// </summary>
    public static partial class list
    {
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <returns>排序后的单向动态数组</returns>
        public static list<DateTime> sortDesc(this list<DateTime> list)
        {
            if (list.count() != 0) algorithm.quickSort.SortDesc(list.Unsafer.Array, 0, list.Count);
            return list;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <returns>排序后新的单向动态数组</returns>
        public static DateTime[] getSortDesc(this list<DateTime> list)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.GetSortDesc(list.Unsafer.Array, 0, list.Count);
            }
            return nullValue<DateTime>.Array;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的单向动态数组</returns>
        public static list<DateTime> sortDesc
            (this list<DateTime> list, int startIndex, int count)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                algorithm.quickSort.SortDesc(list.Unsafer.Array, range.SkipCount, count);
            }
            return list;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后新的单向动态数组</returns>
        public static DateTime[] getSortDesc
            (this list<DateTime> list, int startIndex, int count)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.GetSortDesc(list.Unsafer.Array, range.SkipCount, count);
            }
            return nullValue<DateTime>.Array;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="getKey">排序键</param>
        /// <returns>排序后的新数组</returns>
        public static valueType[] sortDesc<valueType>
            (this list<valueType> list, func<valueType, DateTime> getKey)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.GetSortDesc(list.Unsafer.Array, getKey, 0, list.Count);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 单向动态数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的新数组</returns>
        public static valueType[] sortDesc<valueType>
            (this list<valueType> list, func<valueType, DateTime> getKey, int startIndex, int count)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.GetSortDesc(list.Unsafer.Array, getKey, range.SkipCount, count);
            }
            return nullValue<valueType>.Array;
        }
    }
}


namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 范围排序器(一般用于获取分页)
        /// </summary>
        private unsafe struct ulongRangeSorterDesc
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public ulong* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public ulong* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(ulong* startIndex, ulong* endIndex)
            {
                do
                {
                    ulong leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue < rightValue)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    ulong* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    ulong value = *averageIndex;
                    if (leftValue < value)
                    {
                        if (leftValue < rightValue)
                        {
                            *rightIndex = leftValue;
                            if (value < rightValue) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = value;
                                *averageIndex = value = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = leftValue;
                        }
                    }
                    else
                    {
                        if (value < rightValue)
                        {
                            *rightIndex = value;
                            if (leftValue < rightValue)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = value = leftValue;
                            }
                            else *averageIndex = value = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    do
                    {
                        while (*leftIndex > value) ++leftIndex;
                        while (value > *rightIndex) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static collection<ulong> RangeSortDesc
            (ulong[] values, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (ulong* valueFixed = values)
                {
                    new ulongRangeSorterDesc
                    {
                        SkipCount = valueFixed + range.SkipCount,
                        GetEndIndex = valueFixed + range.EndIndex - 1
                    }.Sort(valueFixed, valueFixed + values.Length - 1);
                }
                return new collection<ulong>(values, range.SkipCount, getCount, true);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static collection<ulong> GetRangeSortDesc
            (ulong[] values, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                ulong[] newValues = new ulong[values.Length];
                Buffer.BlockCopy(values, 0, newValues, 0, values.Length * sizeof(ulong));
                fixed (ulong* newValueFixed = newValues, valueFixed = values)
                {
                    new ulongRangeSorterDesc
                    {
                        SkipCount = newValueFixed + range.SkipCount,
                        GetEndIndex = newValueFixed + range.EndIndex - 1
                    }.Sort(newValueFixed, newValueFixed + values.Length - 1);
                }
                return new collection<ulong>(newValues, range.SkipCount, getCount, true);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static collection<ulong> RangeSortDesc
            (ulong[] values, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    skipCount = range.SkipCount + getRange.SkipCount;
                    fixed (ulong* valueFixed = values)
                    {
                        ulong* skip = valueFixed + skipCount, start = valueFixed + range.SkipCount;
                        new ulongRangeSorterDesc
                        {
                            SkipCount = skip,
                            GetEndIndex = skip + getCount - 1
                        }.Sort(start, start + --count);
                    }
                    return new collection<ulong>(values, skipCount, getCount, true);
                }
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static collection<ulong> GetRangeSortDesc
            (ulong[] values, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    ulong[] newValues = new ulong[count];
                    Buffer.BlockCopy(values, range.SkipCount * sizeof(ulong), newValues, 0, count * sizeof(ulong));
                    fixed (ulong* newValueFixed = newValues, valueFixed = values)
                    {
                        new ulongRangeSorterDesc
                        {
                            SkipCount = newValueFixed + getRange.SkipCount,
                            GetEndIndex = newValueFixed + getRange.SkipCount + getCount - 1
                        }.Sort(newValueFixed, newValueFixed + count - 1);
                    }
                    return new collection<ulong>(newValues, getRange.SkipCount, getCount, true);
                }
            }
            return null;
        }

        /// <summary>
        /// 索引范围排序器
        /// </summary>
        private unsafe struct ulongRangeIndexSorterDesc
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public ulongSortIndex* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public ulongSortIndex* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(ulongSortIndex* startIndex, ulongSortIndex* endIndex)
            {
                do
                {
                    ulongSortIndex leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue.Value < rightValue.Value)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    ulongSortIndex* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    ulongSortIndex indexValue = *averageIndex;
                    if (leftValue.Value < indexValue.Value)
                    {
                        if (leftValue.Value < rightValue.Value)
                        {
                            *rightIndex = leftValue;
                            if (indexValue.Value < rightValue.Value) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = indexValue;
                                *averageIndex = indexValue = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = leftValue;
                        }
                    }
                    else
                    {
                        if (indexValue.Value < rightValue.Value)
                        {
                            *rightIndex = indexValue;
                            if (leftValue.Value < rightValue.Value)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = indexValue = leftValue;
                            }
                            else *averageIndex = indexValue = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    ulong value = indexValue.Value;
                    do
                    {
                        while ((*leftIndex).Value > value) ++leftIndex;
                        while (value > (*rightIndex).Value) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSortDesc<valueType>
            (valueType[] values, func<valueType, ulong> getKey, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                if (values.Length > (config.pub.Default.StreamBufferLength >> 4))
                {
                    ulongSortIndex[] indexs = new ulongSortIndex[values.Length];
                    fixed (ulongSortIndex* fixedIndex = indexs)
                    {
                        return getRangeSortDesc(values, getKey, range.SkipCount, getCount, fixedIndex);
                    }
                }
                else
                {
                    ulongSortIndex* fixedIndex = stackalloc ulongSortIndex[values.Length];
                    return getRangeSortDesc(values, getKey, range.SkipCount, getCount, fixedIndex);
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSortDesc<valueType>
            (valueType[] values, func<valueType, ulong> getKey, int skipCount, int getCount
            , ulongSortIndex* fixedIndex)
        {
            ulongSortIndex* writeIndex = fixedIndex;
            for (int index = 0; index != values.Length; ++index)
            {
                *writeIndex++ = new ulongSortIndex { Value = getKey(values[index]), Index = index };
            }
            return getRangeSortDesc(values, skipCount, getCount, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSortDesc<valueType>
            (valueType[] values, int skipCount, int getCount, ulongSortIndex* fixedIndex)
        {
            new ulongRangeIndexSorterDesc
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + values.Length - 1);
            valueType[] newValues = new valueType[getCount];
            ulongSortIndex* writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="indexs">排序索引</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSortDesc<valueType>
            (valueType[] values, ulongSortIndex[] indexs, int skipCount, int getCount)
        {
            if (values.length() != indexs.length()) log.Default.Throw(log.exceptionType.IndexOutOfRange);
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (ulongSortIndex* fixedIndex = indexs) return getRangeSortDesc(values, skipCount, getCount, fixedIndex);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSortDesc<valueType>
            (valueType[] values, int startIndex, int count, func<valueType, ulong> getKey, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                    if (values.Length > (config.pub.Default.StreamBufferLength >> 4))
                    {
                        ulongSortIndex[] indexs = new ulongSortIndex[count];
                        fixed (ulongSortIndex* fixedIndex = indexs)
                        {
                            return getRangeSortDesc
                                (values, range.SkipCount, count, getKey, getRange.SkipCount, getCount, fixedIndex);
                        }
                    }
                    else
                    {
                        ulongSortIndex* fixedIndex = stackalloc ulongSortIndex[count];
                        return getRangeSortDesc
                            (values, range.SkipCount, count, getKey, getRange.SkipCount, getCount, fixedIndex);
                    }
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSortDesc<valueType>
            (valueType[] values, int startIndex, int count, func<valueType, ulong> getKey, int skipCount, int getCount
            , ulongSortIndex* fixedIndex)
        {
            ulongSortIndex* writeIndex = fixedIndex;
            for (int index = startIndex, endIndex = startIndex + count; index != endIndex; ++index)
            {
                *writeIndex++ = new ulongSortIndex { Value = getKey(values[index]), Index = index };
            }
            new ulongRangeIndexSorterDesc
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + count - 1);
            valueType[] newValues = new valueType[getCount];
            writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static collection<ulong> rangeSortDesc
            (this ulong[] array, int skipCount, int getCount)
        {
            return algorithm.quickSort.RangeSortDesc(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static collection<ulong> getRangeSortDesc
            (this ulong[] array, int skipCount, int getCount)
        {
            return algorithm.quickSort.GetRangeSortDesc(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSortDesc<valueType>
            (this valueType[] array, func<valueType, ulong> getKey, int skipCount, int getCount)
        {
            return algorithm.quickSort.GetRangeSortDesc(array, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static collection<ulong> rangeSortDesc
            (this ulong[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return algorithm.quickSort.RangeSortDesc(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static collection<ulong> getRangeSortDesc
            (this ulong[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return algorithm.quickSort.GetRangeSortDesc(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSortDesc<valueType>
            (this valueType[] array, int startIndex, int count, func<valueType, ulong> getKey, int skipCount, int getCount)
        {
            return algorithm.quickSort.GetRangeSortDesc(array, startIndex, count, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static collection<ulong> pageSortDesc
            (this ulong[] array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return algorithm.quickSort.RangeSortDesc(array, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static valueType[] getPageSortDesc<valueType>
            (this valueType[] array, func<valueType, ulong> getKey, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return algorithm.quickSort.GetRangeSortDesc(array, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static collection<ulong> getPageSortDesc
            (this ulong[] array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return algorithm.quickSort.GetRangeSortDesc(array, page.SkipCount, page.CurrentPageSize);
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 单向动态数组扩展
    /// </summary>
    public static partial class list
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static collection<ulong> rangeSortDesc
            (this list<ulong> list, int skipCount, int getCount)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.RangeSortDesc(list.Unsafer.Array, 0, list.Count, skipCount, getCount);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static collection<ulong> getRangeSortDesc
            (this list<ulong> list, int skipCount, int getCount)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.GetRangeSortDesc(list.Unsafer.Array, 0, list.Count, skipCount, getCount);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSortDesc<valueType>
            (this list<valueType> list, func<valueType, ulong> getKey, int skipCount, int getCount)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.GetRangeSortDesc
                    (list.Unsafer.Array, 0, list.Count, getKey, skipCount, getCount);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static collection<ulong> rangeSortDesc
            (this list<ulong> list, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.RangeSortDesc
                    (list.Unsafer.Array, range.SkipCount, count, skipCount, getCount);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static collection<ulong> getRangeSortDesc
            (this list<ulong> list, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.GetRangeSortDesc
                    (list.Unsafer.Array, range.SkipCount, count, skipCount, getCount);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSortDesc<valueType>
            (this list<valueType> list, int startIndex, int count, func<valueType, ulong> getKey
            , int skipCount, int getCount)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.GetRangeSortDesc
                    (list.Unsafer.Array, range.SkipCount, count, getKey, skipCount, getCount);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static collection<ulong> pageSortDesc
            (this list<ulong> list, int pageSize, int currentPage)
        {
            array.page page = new array.page(list.count(), pageSize, currentPage);
            int count = page.CurrentPageSize;
            if (count != 0)
            {
                return algorithm.quickSort.RangeSortDesc(list.Unsafer.Array, page.SkipCount, count);
            }
            return null;
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static collection<ulong> getPageSortDesc
            (this list<ulong> list, int pageSize, int currentPage)
        {
            array.page page = new array.page(list.count(), pageSize, currentPage);
            int count = page.CurrentPageSize;
            if (count != 0)
            {
                return algorithm.quickSort.GetRangeSortDesc(list.Unsafer.Array, page.SkipCount, count);
            }
            return null;
        }
    }
}
namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 范围排序器(一般用于获取分页)
        /// </summary>
        private unsafe struct longRangeSorter
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public long* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public long* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(long* startIndex, long* endIndex)
            {
                do
                {
                    long leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue > rightValue)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    long* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    long value = *averageIndex;
                    if (leftValue > value)
                    {
                        if (leftValue > rightValue)
                        {
                            *rightIndex = leftValue;
                            if (value > rightValue) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = value;
                                *averageIndex = value = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = leftValue;
                        }
                    }
                    else
                    {
                        if (value > rightValue)
                        {
                            *rightIndex = value;
                            if (leftValue > rightValue)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = value = leftValue;
                            }
                            else *averageIndex = value = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    do
                    {
                        while (*leftIndex < value) ++leftIndex;
                        while (value < *rightIndex) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static collection<long> RangeSort
            (long[] values, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (long* valueFixed = values)
                {
                    new longRangeSorter
                    {
                        SkipCount = valueFixed + range.SkipCount,
                        GetEndIndex = valueFixed + range.EndIndex - 1
                    }.Sort(valueFixed, valueFixed + values.Length - 1);
                }
                return new collection<long>(values, range.SkipCount, getCount, true);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static collection<long> GetRangeSort
            (long[] values, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                long[] newValues = new long[values.Length];
                Buffer.BlockCopy(values, 0, newValues, 0, values.Length * sizeof(long));
                fixed (long* newValueFixed = newValues, valueFixed = values)
                {
                    new longRangeSorter
                    {
                        SkipCount = newValueFixed + range.SkipCount,
                        GetEndIndex = newValueFixed + range.EndIndex - 1
                    }.Sort(newValueFixed, newValueFixed + values.Length - 1);
                }
                return new collection<long>(newValues, range.SkipCount, getCount, true);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static collection<long> RangeSort
            (long[] values, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    skipCount = range.SkipCount + getRange.SkipCount;
                    fixed (long* valueFixed = values)
                    {
                        long* skip = valueFixed + skipCount, start = valueFixed + range.SkipCount;
                        new longRangeSorter
                        {
                            SkipCount = skip,
                            GetEndIndex = skip + getCount - 1
                        }.Sort(start, start + --count);
                    }
                    return new collection<long>(values, skipCount, getCount, true);
                }
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static collection<long> GetRangeSort
            (long[] values, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    long[] newValues = new long[count];
                    Buffer.BlockCopy(values, range.SkipCount * sizeof(long), newValues, 0, count * sizeof(long));
                    fixed (long* newValueFixed = newValues, valueFixed = values)
                    {
                        new longRangeSorter
                        {
                            SkipCount = newValueFixed + getRange.SkipCount,
                            GetEndIndex = newValueFixed + getRange.SkipCount + getCount - 1
                        }.Sort(newValueFixed, newValueFixed + count - 1);
                    }
                    return new collection<long>(newValues, getRange.SkipCount, getCount, true);
                }
            }
            return null;
        }

        /// <summary>
        /// 索引范围排序器
        /// </summary>
        private unsafe struct longRangeIndexSorter
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public longSortIndex* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public longSortIndex* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(longSortIndex* startIndex, longSortIndex* endIndex)
            {
                do
                {
                    longSortIndex leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue.Value > rightValue.Value)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    longSortIndex* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    longSortIndex indexValue = *averageIndex;
                    if (leftValue.Value > indexValue.Value)
                    {
                        if (leftValue.Value > rightValue.Value)
                        {
                            *rightIndex = leftValue;
                            if (indexValue.Value > rightValue.Value) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = indexValue;
                                *averageIndex = indexValue = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = leftValue;
                        }
                    }
                    else
                    {
                        if (indexValue.Value > rightValue.Value)
                        {
                            *rightIndex = indexValue;
                            if (leftValue.Value > rightValue.Value)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = indexValue = leftValue;
                            }
                            else *averageIndex = indexValue = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    long value = indexValue.Value;
                    do
                    {
                        while ((*leftIndex).Value < value) ++leftIndex;
                        while (value < (*rightIndex).Value) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSort<valueType>
            (valueType[] values, func<valueType, long> getKey, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                if (values.Length > (config.pub.Default.StreamBufferLength >> 4))
                {
                    longSortIndex[] indexs = new longSortIndex[values.Length];
                    fixed (longSortIndex* fixedIndex = indexs)
                    {
                        return getRangeSort(values, getKey, range.SkipCount, getCount, fixedIndex);
                    }
                }
                else
                {
                    longSortIndex* fixedIndex = stackalloc longSortIndex[values.Length];
                    return getRangeSort(values, getKey, range.SkipCount, getCount, fixedIndex);
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSort<valueType>
            (valueType[] values, func<valueType, long> getKey, int skipCount, int getCount
            , longSortIndex* fixedIndex)
        {
            longSortIndex* writeIndex = fixedIndex;
            for (int index = 0; index != values.Length; ++index)
            {
                *writeIndex++ = new longSortIndex { Value = getKey(values[index]), Index = index };
            }
            return getRangeSort(values, skipCount, getCount, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSort<valueType>
            (valueType[] values, int skipCount, int getCount, longSortIndex* fixedIndex)
        {
            new longRangeIndexSorter
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + values.Length - 1);
            valueType[] newValues = new valueType[getCount];
            longSortIndex* writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="indexs">排序索引</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSort<valueType>
            (valueType[] values, longSortIndex[] indexs, int skipCount, int getCount)
        {
            if (values.length() != indexs.length()) log.Default.Throw(log.exceptionType.IndexOutOfRange);
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (longSortIndex* fixedIndex = indexs) return getRangeSort(values, skipCount, getCount, fixedIndex);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSort<valueType>
            (valueType[] values, int startIndex, int count, func<valueType, long> getKey, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                    if (values.Length > (config.pub.Default.StreamBufferLength >> 4))
                    {
                        longSortIndex[] indexs = new longSortIndex[count];
                        fixed (longSortIndex* fixedIndex = indexs)
                        {
                            return getRangeSort
                                (values, range.SkipCount, count, getKey, getRange.SkipCount, getCount, fixedIndex);
                        }
                    }
                    else
                    {
                        longSortIndex* fixedIndex = stackalloc longSortIndex[count];
                        return getRangeSort
                            (values, range.SkipCount, count, getKey, getRange.SkipCount, getCount, fixedIndex);
                    }
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSort<valueType>
            (valueType[] values, int startIndex, int count, func<valueType, long> getKey, int skipCount, int getCount
            , longSortIndex* fixedIndex)
        {
            longSortIndex* writeIndex = fixedIndex;
            for (int index = startIndex, endIndex = startIndex + count; index != endIndex; ++index)
            {
                *writeIndex++ = new longSortIndex { Value = getKey(values[index]), Index = index };
            }
            new longRangeIndexSorter
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + count - 1);
            valueType[] newValues = new valueType[getCount];
            writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static collection<long> rangeSort
            (this long[] array, int skipCount, int getCount)
        {
            return algorithm.quickSort.RangeSort(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static collection<long> getRangeSort
            (this long[] array, int skipCount, int getCount)
        {
            return algorithm.quickSort.GetRangeSort(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSort<valueType>
            (this valueType[] array, func<valueType, long> getKey, int skipCount, int getCount)
        {
            return algorithm.quickSort.GetRangeSort(array, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static collection<long> rangeSort
            (this long[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return algorithm.quickSort.RangeSort(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static collection<long> getRangeSort
            (this long[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return algorithm.quickSort.GetRangeSort(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSort<valueType>
            (this valueType[] array, int startIndex, int count, func<valueType, long> getKey, int skipCount, int getCount)
        {
            return algorithm.quickSort.GetRangeSort(array, startIndex, count, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static collection<long> pageSort
            (this long[] array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return algorithm.quickSort.RangeSort(array, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static valueType[] getPageSort<valueType>
            (this valueType[] array, func<valueType, long> getKey, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return algorithm.quickSort.GetRangeSort(array, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static collection<long> getPageSort
            (this long[] array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return algorithm.quickSort.GetRangeSort(array, page.SkipCount, page.CurrentPageSize);
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 单向动态数组扩展
    /// </summary>
    public static partial class list
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static collection<long> rangeSort
            (this list<long> list, int skipCount, int getCount)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.RangeSort(list.Unsafer.Array, 0, list.Count, skipCount, getCount);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static collection<long> getRangeSort
            (this list<long> list, int skipCount, int getCount)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.GetRangeSort(list.Unsafer.Array, 0, list.Count, skipCount, getCount);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSort<valueType>
            (this list<valueType> list, func<valueType, long> getKey, int skipCount, int getCount)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.GetRangeSort
                    (list.Unsafer.Array, 0, list.Count, getKey, skipCount, getCount);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static collection<long> rangeSort
            (this list<long> list, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.RangeSort
                    (list.Unsafer.Array, range.SkipCount, count, skipCount, getCount);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static collection<long> getRangeSort
            (this list<long> list, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.GetRangeSort
                    (list.Unsafer.Array, range.SkipCount, count, skipCount, getCount);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSort<valueType>
            (this list<valueType> list, int startIndex, int count, func<valueType, long> getKey
            , int skipCount, int getCount)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.GetRangeSort
                    (list.Unsafer.Array, range.SkipCount, count, getKey, skipCount, getCount);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static collection<long> pageSort
            (this list<long> list, int pageSize, int currentPage)
        {
            array.page page = new array.page(list.count(), pageSize, currentPage);
            int count = page.CurrentPageSize;
            if (count != 0)
            {
                return algorithm.quickSort.RangeSort(list.Unsafer.Array, page.SkipCount, count);
            }
            return null;
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static collection<long> getPageSort
            (this list<long> list, int pageSize, int currentPage)
        {
            array.page page = new array.page(list.count(), pageSize, currentPage);
            int count = page.CurrentPageSize;
            if (count != 0)
            {
                return algorithm.quickSort.GetRangeSort(list.Unsafer.Array, page.SkipCount, count);
            }
            return null;
        }
    }
}
namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 范围排序器(一般用于获取分页)
        /// </summary>
        private unsafe struct longRangeSorterDesc
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public long* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public long* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(long* startIndex, long* endIndex)
            {
                do
                {
                    long leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue < rightValue)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    long* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    long value = *averageIndex;
                    if (leftValue < value)
                    {
                        if (leftValue < rightValue)
                        {
                            *rightIndex = leftValue;
                            if (value < rightValue) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = value;
                                *averageIndex = value = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = leftValue;
                        }
                    }
                    else
                    {
                        if (value < rightValue)
                        {
                            *rightIndex = value;
                            if (leftValue < rightValue)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = value = leftValue;
                            }
                            else *averageIndex = value = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    do
                    {
                        while (*leftIndex > value) ++leftIndex;
                        while (value > *rightIndex) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static collection<long> RangeSortDesc
            (long[] values, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (long* valueFixed = values)
                {
                    new longRangeSorterDesc
                    {
                        SkipCount = valueFixed + range.SkipCount,
                        GetEndIndex = valueFixed + range.EndIndex - 1
                    }.Sort(valueFixed, valueFixed + values.Length - 1);
                }
                return new collection<long>(values, range.SkipCount, getCount, true);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static collection<long> GetRangeSortDesc
            (long[] values, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                long[] newValues = new long[values.Length];
                Buffer.BlockCopy(values, 0, newValues, 0, values.Length * sizeof(long));
                fixed (long* newValueFixed = newValues, valueFixed = values)
                {
                    new longRangeSorterDesc
                    {
                        SkipCount = newValueFixed + range.SkipCount,
                        GetEndIndex = newValueFixed + range.EndIndex - 1
                    }.Sort(newValueFixed, newValueFixed + values.Length - 1);
                }
                return new collection<long>(newValues, range.SkipCount, getCount, true);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static collection<long> RangeSortDesc
            (long[] values, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    skipCount = range.SkipCount + getRange.SkipCount;
                    fixed (long* valueFixed = values)
                    {
                        long* skip = valueFixed + skipCount, start = valueFixed + range.SkipCount;
                        new longRangeSorterDesc
                        {
                            SkipCount = skip,
                            GetEndIndex = skip + getCount - 1
                        }.Sort(start, start + --count);
                    }
                    return new collection<long>(values, skipCount, getCount, true);
                }
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static collection<long> GetRangeSortDesc
            (long[] values, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    long[] newValues = new long[count];
                    Buffer.BlockCopy(values, range.SkipCount * sizeof(long), newValues, 0, count * sizeof(long));
                    fixed (long* newValueFixed = newValues, valueFixed = values)
                    {
                        new longRangeSorterDesc
                        {
                            SkipCount = newValueFixed + getRange.SkipCount,
                            GetEndIndex = newValueFixed + getRange.SkipCount + getCount - 1
                        }.Sort(newValueFixed, newValueFixed + count - 1);
                    }
                    return new collection<long>(newValues, getRange.SkipCount, getCount, true);
                }
            }
            return null;
        }

        /// <summary>
        /// 索引范围排序器
        /// </summary>
        private unsafe struct longRangeIndexSorterDesc
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public longSortIndex* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public longSortIndex* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(longSortIndex* startIndex, longSortIndex* endIndex)
            {
                do
                {
                    longSortIndex leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue.Value < rightValue.Value)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    longSortIndex* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    longSortIndex indexValue = *averageIndex;
                    if (leftValue.Value < indexValue.Value)
                    {
                        if (leftValue.Value < rightValue.Value)
                        {
                            *rightIndex = leftValue;
                            if (indexValue.Value < rightValue.Value) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = indexValue;
                                *averageIndex = indexValue = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = leftValue;
                        }
                    }
                    else
                    {
                        if (indexValue.Value < rightValue.Value)
                        {
                            *rightIndex = indexValue;
                            if (leftValue.Value < rightValue.Value)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = indexValue = leftValue;
                            }
                            else *averageIndex = indexValue = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    long value = indexValue.Value;
                    do
                    {
                        while ((*leftIndex).Value > value) ++leftIndex;
                        while (value > (*rightIndex).Value) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSortDesc<valueType>
            (valueType[] values, func<valueType, long> getKey, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                if (values.Length > (config.pub.Default.StreamBufferLength >> 4))
                {
                    longSortIndex[] indexs = new longSortIndex[values.Length];
                    fixed (longSortIndex* fixedIndex = indexs)
                    {
                        return getRangeSortDesc(values, getKey, range.SkipCount, getCount, fixedIndex);
                    }
                }
                else
                {
                    longSortIndex* fixedIndex = stackalloc longSortIndex[values.Length];
                    return getRangeSortDesc(values, getKey, range.SkipCount, getCount, fixedIndex);
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSortDesc<valueType>
            (valueType[] values, func<valueType, long> getKey, int skipCount, int getCount
            , longSortIndex* fixedIndex)
        {
            longSortIndex* writeIndex = fixedIndex;
            for (int index = 0; index != values.Length; ++index)
            {
                *writeIndex++ = new longSortIndex { Value = getKey(values[index]), Index = index };
            }
            return getRangeSortDesc(values, skipCount, getCount, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSortDesc<valueType>
            (valueType[] values, int skipCount, int getCount, longSortIndex* fixedIndex)
        {
            new longRangeIndexSorterDesc
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + values.Length - 1);
            valueType[] newValues = new valueType[getCount];
            longSortIndex* writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="indexs">排序索引</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSortDesc<valueType>
            (valueType[] values, longSortIndex[] indexs, int skipCount, int getCount)
        {
            if (values.length() != indexs.length()) log.Default.Throw(log.exceptionType.IndexOutOfRange);
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (longSortIndex* fixedIndex = indexs) return getRangeSortDesc(values, skipCount, getCount, fixedIndex);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSortDesc<valueType>
            (valueType[] values, int startIndex, int count, func<valueType, long> getKey, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                    if (values.Length > (config.pub.Default.StreamBufferLength >> 4))
                    {
                        longSortIndex[] indexs = new longSortIndex[count];
                        fixed (longSortIndex* fixedIndex = indexs)
                        {
                            return getRangeSortDesc
                                (values, range.SkipCount, count, getKey, getRange.SkipCount, getCount, fixedIndex);
                        }
                    }
                    else
                    {
                        longSortIndex* fixedIndex = stackalloc longSortIndex[count];
                        return getRangeSortDesc
                            (values, range.SkipCount, count, getKey, getRange.SkipCount, getCount, fixedIndex);
                    }
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSortDesc<valueType>
            (valueType[] values, int startIndex, int count, func<valueType, long> getKey, int skipCount, int getCount
            , longSortIndex* fixedIndex)
        {
            longSortIndex* writeIndex = fixedIndex;
            for (int index = startIndex, endIndex = startIndex + count; index != endIndex; ++index)
            {
                *writeIndex++ = new longSortIndex { Value = getKey(values[index]), Index = index };
            }
            new longRangeIndexSorterDesc
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + count - 1);
            valueType[] newValues = new valueType[getCount];
            writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static collection<long> rangeSortDesc
            (this long[] array, int skipCount, int getCount)
        {
            return algorithm.quickSort.RangeSortDesc(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static collection<long> getRangeSortDesc
            (this long[] array, int skipCount, int getCount)
        {
            return algorithm.quickSort.GetRangeSortDesc(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSortDesc<valueType>
            (this valueType[] array, func<valueType, long> getKey, int skipCount, int getCount)
        {
            return algorithm.quickSort.GetRangeSortDesc(array, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static collection<long> rangeSortDesc
            (this long[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return algorithm.quickSort.RangeSortDesc(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static collection<long> getRangeSortDesc
            (this long[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return algorithm.quickSort.GetRangeSortDesc(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSortDesc<valueType>
            (this valueType[] array, int startIndex, int count, func<valueType, long> getKey, int skipCount, int getCount)
        {
            return algorithm.quickSort.GetRangeSortDesc(array, startIndex, count, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static collection<long> pageSortDesc
            (this long[] array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return algorithm.quickSort.RangeSortDesc(array, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static valueType[] getPageSortDesc<valueType>
            (this valueType[] array, func<valueType, long> getKey, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return algorithm.quickSort.GetRangeSortDesc(array, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static collection<long> getPageSortDesc
            (this long[] array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return algorithm.quickSort.GetRangeSortDesc(array, page.SkipCount, page.CurrentPageSize);
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 单向动态数组扩展
    /// </summary>
    public static partial class list
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static collection<long> rangeSortDesc
            (this list<long> list, int skipCount, int getCount)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.RangeSortDesc(list.Unsafer.Array, 0, list.Count, skipCount, getCount);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static collection<long> getRangeSortDesc
            (this list<long> list, int skipCount, int getCount)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.GetRangeSortDesc(list.Unsafer.Array, 0, list.Count, skipCount, getCount);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSortDesc<valueType>
            (this list<valueType> list, func<valueType, long> getKey, int skipCount, int getCount)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.GetRangeSortDesc
                    (list.Unsafer.Array, 0, list.Count, getKey, skipCount, getCount);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static collection<long> rangeSortDesc
            (this list<long> list, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.RangeSortDesc
                    (list.Unsafer.Array, range.SkipCount, count, skipCount, getCount);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static collection<long> getRangeSortDesc
            (this list<long> list, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.GetRangeSortDesc
                    (list.Unsafer.Array, range.SkipCount, count, skipCount, getCount);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSortDesc<valueType>
            (this list<valueType> list, int startIndex, int count, func<valueType, long> getKey
            , int skipCount, int getCount)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.GetRangeSortDesc
                    (list.Unsafer.Array, range.SkipCount, count, getKey, skipCount, getCount);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static collection<long> pageSortDesc
            (this list<long> list, int pageSize, int currentPage)
        {
            array.page page = new array.page(list.count(), pageSize, currentPage);
            int count = page.CurrentPageSize;
            if (count != 0)
            {
                return algorithm.quickSort.RangeSortDesc(list.Unsafer.Array, page.SkipCount, count);
            }
            return null;
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static collection<long> getPageSortDesc
            (this list<long> list, int pageSize, int currentPage)
        {
            array.page page = new array.page(list.count(), pageSize, currentPage);
            int count = page.CurrentPageSize;
            if (count != 0)
            {
                return algorithm.quickSort.GetRangeSortDesc(list.Unsafer.Array, page.SkipCount, count);
            }
            return null;
        }
    }
}
namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 范围排序器(一般用于获取分页)
        /// </summary>
        private unsafe struct uintRangeSorter
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public uint* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public uint* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(uint* startIndex, uint* endIndex)
            {
                do
                {
                    uint leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue > rightValue)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    uint* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    uint value = *averageIndex;
                    if (leftValue > value)
                    {
                        if (leftValue > rightValue)
                        {
                            *rightIndex = leftValue;
                            if (value > rightValue) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = value;
                                *averageIndex = value = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = leftValue;
                        }
                    }
                    else
                    {
                        if (value > rightValue)
                        {
                            *rightIndex = value;
                            if (leftValue > rightValue)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = value = leftValue;
                            }
                            else *averageIndex = value = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    do
                    {
                        while (*leftIndex < value) ++leftIndex;
                        while (value < *rightIndex) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static collection<uint> RangeSort
            (uint[] values, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (uint* valueFixed = values)
                {
                    new uintRangeSorter
                    {
                        SkipCount = valueFixed + range.SkipCount,
                        GetEndIndex = valueFixed + range.EndIndex - 1
                    }.Sort(valueFixed, valueFixed + values.Length - 1);
                }
                return new collection<uint>(values, range.SkipCount, getCount, true);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static collection<uint> GetRangeSort
            (uint[] values, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                uint[] newValues = new uint[values.Length];
                Buffer.BlockCopy(values, 0, newValues, 0, values.Length * sizeof(uint));
                fixed (uint* newValueFixed = newValues, valueFixed = values)
                {
                    new uintRangeSorter
                    {
                        SkipCount = newValueFixed + range.SkipCount,
                        GetEndIndex = newValueFixed + range.EndIndex - 1
                    }.Sort(newValueFixed, newValueFixed + values.Length - 1);
                }
                return new collection<uint>(newValues, range.SkipCount, getCount, true);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static collection<uint> RangeSort
            (uint[] values, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    skipCount = range.SkipCount + getRange.SkipCount;
                    fixed (uint* valueFixed = values)
                    {
                        uint* skip = valueFixed + skipCount, start = valueFixed + range.SkipCount;
                        new uintRangeSorter
                        {
                            SkipCount = skip,
                            GetEndIndex = skip + getCount - 1
                        }.Sort(start, start + --count);
                    }
                    return new collection<uint>(values, skipCount, getCount, true);
                }
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static collection<uint> GetRangeSort
            (uint[] values, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    uint[] newValues = new uint[count];
                    Buffer.BlockCopy(values, range.SkipCount * sizeof(uint), newValues, 0, count * sizeof(uint));
                    fixed (uint* newValueFixed = newValues, valueFixed = values)
                    {
                        new uintRangeSorter
                        {
                            SkipCount = newValueFixed + getRange.SkipCount,
                            GetEndIndex = newValueFixed + getRange.SkipCount + getCount - 1
                        }.Sort(newValueFixed, newValueFixed + count - 1);
                    }
                    return new collection<uint>(newValues, getRange.SkipCount, getCount, true);
                }
            }
            return null;
        }

        /// <summary>
        /// 索引范围排序器
        /// </summary>
        private unsafe struct uintRangeIndexSorter
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public uintSortIndex* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public uintSortIndex* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(uintSortIndex* startIndex, uintSortIndex* endIndex)
            {
                do
                {
                    uintSortIndex leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue.Value > rightValue.Value)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    uintSortIndex* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    uintSortIndex indexValue = *averageIndex;
                    if (leftValue.Value > indexValue.Value)
                    {
                        if (leftValue.Value > rightValue.Value)
                        {
                            *rightIndex = leftValue;
                            if (indexValue.Value > rightValue.Value) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = indexValue;
                                *averageIndex = indexValue = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = leftValue;
                        }
                    }
                    else
                    {
                        if (indexValue.Value > rightValue.Value)
                        {
                            *rightIndex = indexValue;
                            if (leftValue.Value > rightValue.Value)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = indexValue = leftValue;
                            }
                            else *averageIndex = indexValue = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    uint value = indexValue.Value;
                    do
                    {
                        while ((*leftIndex).Value < value) ++leftIndex;
                        while (value < (*rightIndex).Value) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSort<valueType>
            (valueType[] values, func<valueType, uint> getKey, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                if (values.Length > (config.pub.Default.StreamBufferLength >> 4))
                {
                    uintSortIndex[] indexs = new uintSortIndex[values.Length];
                    fixed (uintSortIndex* fixedIndex = indexs)
                    {
                        return getRangeSort(values, getKey, range.SkipCount, getCount, fixedIndex);
                    }
                }
                else
                {
                    uintSortIndex* fixedIndex = stackalloc uintSortIndex[values.Length];
                    return getRangeSort(values, getKey, range.SkipCount, getCount, fixedIndex);
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSort<valueType>
            (valueType[] values, func<valueType, uint> getKey, int skipCount, int getCount
            , uintSortIndex* fixedIndex)
        {
            uintSortIndex* writeIndex = fixedIndex;
            for (int index = 0; index != values.Length; ++index)
            {
                *writeIndex++ = new uintSortIndex { Value = getKey(values[index]), Index = index };
            }
            return getRangeSort(values, skipCount, getCount, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSort<valueType>
            (valueType[] values, int skipCount, int getCount, uintSortIndex* fixedIndex)
        {
            new uintRangeIndexSorter
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + values.Length - 1);
            valueType[] newValues = new valueType[getCount];
            uintSortIndex* writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="indexs">排序索引</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSort<valueType>
            (valueType[] values, uintSortIndex[] indexs, int skipCount, int getCount)
        {
            if (values.length() != indexs.length()) log.Default.Throw(log.exceptionType.IndexOutOfRange);
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (uintSortIndex* fixedIndex = indexs) return getRangeSort(values, skipCount, getCount, fixedIndex);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSort<valueType>
            (valueType[] values, int startIndex, int count, func<valueType, uint> getKey, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                    if (values.Length > (config.pub.Default.StreamBufferLength >> 4))
                    {
                        uintSortIndex[] indexs = new uintSortIndex[count];
                        fixed (uintSortIndex* fixedIndex = indexs)
                        {
                            return getRangeSort
                                (values, range.SkipCount, count, getKey, getRange.SkipCount, getCount, fixedIndex);
                        }
                    }
                    else
                    {
                        uintSortIndex* fixedIndex = stackalloc uintSortIndex[count];
                        return getRangeSort
                            (values, range.SkipCount, count, getKey, getRange.SkipCount, getCount, fixedIndex);
                    }
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSort<valueType>
            (valueType[] values, int startIndex, int count, func<valueType, uint> getKey, int skipCount, int getCount
            , uintSortIndex* fixedIndex)
        {
            uintSortIndex* writeIndex = fixedIndex;
            for (int index = startIndex, endIndex = startIndex + count; index != endIndex; ++index)
            {
                *writeIndex++ = new uintSortIndex { Value = getKey(values[index]), Index = index };
            }
            new uintRangeIndexSorter
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + count - 1);
            valueType[] newValues = new valueType[getCount];
            writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static collection<uint> rangeSort
            (this uint[] array, int skipCount, int getCount)
        {
            return algorithm.quickSort.RangeSort(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static collection<uint> getRangeSort
            (this uint[] array, int skipCount, int getCount)
        {
            return algorithm.quickSort.GetRangeSort(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSort<valueType>
            (this valueType[] array, func<valueType, uint> getKey, int skipCount, int getCount)
        {
            return algorithm.quickSort.GetRangeSort(array, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static collection<uint> rangeSort
            (this uint[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return algorithm.quickSort.RangeSort(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static collection<uint> getRangeSort
            (this uint[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return algorithm.quickSort.GetRangeSort(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSort<valueType>
            (this valueType[] array, int startIndex, int count, func<valueType, uint> getKey, int skipCount, int getCount)
        {
            return algorithm.quickSort.GetRangeSort(array, startIndex, count, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static collection<uint> pageSort
            (this uint[] array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return algorithm.quickSort.RangeSort(array, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static valueType[] getPageSort<valueType>
            (this valueType[] array, func<valueType, uint> getKey, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return algorithm.quickSort.GetRangeSort(array, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static collection<uint> getPageSort
            (this uint[] array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return algorithm.quickSort.GetRangeSort(array, page.SkipCount, page.CurrentPageSize);
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 单向动态数组扩展
    /// </summary>
    public static partial class list
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static collection<uint> rangeSort
            (this list<uint> list, int skipCount, int getCount)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.RangeSort(list.Unsafer.Array, 0, list.Count, skipCount, getCount);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static collection<uint> getRangeSort
            (this list<uint> list, int skipCount, int getCount)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.GetRangeSort(list.Unsafer.Array, 0, list.Count, skipCount, getCount);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSort<valueType>
            (this list<valueType> list, func<valueType, uint> getKey, int skipCount, int getCount)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.GetRangeSort
                    (list.Unsafer.Array, 0, list.Count, getKey, skipCount, getCount);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static collection<uint> rangeSort
            (this list<uint> list, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.RangeSort
                    (list.Unsafer.Array, range.SkipCount, count, skipCount, getCount);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static collection<uint> getRangeSort
            (this list<uint> list, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.GetRangeSort
                    (list.Unsafer.Array, range.SkipCount, count, skipCount, getCount);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSort<valueType>
            (this list<valueType> list, int startIndex, int count, func<valueType, uint> getKey
            , int skipCount, int getCount)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.GetRangeSort
                    (list.Unsafer.Array, range.SkipCount, count, getKey, skipCount, getCount);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static collection<uint> pageSort
            (this list<uint> list, int pageSize, int currentPage)
        {
            array.page page = new array.page(list.count(), pageSize, currentPage);
            int count = page.CurrentPageSize;
            if (count != 0)
            {
                return algorithm.quickSort.RangeSort(list.Unsafer.Array, page.SkipCount, count);
            }
            return null;
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static collection<uint> getPageSort
            (this list<uint> list, int pageSize, int currentPage)
        {
            array.page page = new array.page(list.count(), pageSize, currentPage);
            int count = page.CurrentPageSize;
            if (count != 0)
            {
                return algorithm.quickSort.GetRangeSort(list.Unsafer.Array, page.SkipCount, count);
            }
            return null;
        }
    }
}
namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 范围排序器(一般用于获取分页)
        /// </summary>
        private unsafe struct uintRangeSorterDesc
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public uint* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public uint* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(uint* startIndex, uint* endIndex)
            {
                do
                {
                    uint leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue < rightValue)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    uint* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    uint value = *averageIndex;
                    if (leftValue < value)
                    {
                        if (leftValue < rightValue)
                        {
                            *rightIndex = leftValue;
                            if (value < rightValue) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = value;
                                *averageIndex = value = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = leftValue;
                        }
                    }
                    else
                    {
                        if (value < rightValue)
                        {
                            *rightIndex = value;
                            if (leftValue < rightValue)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = value = leftValue;
                            }
                            else *averageIndex = value = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    do
                    {
                        while (*leftIndex > value) ++leftIndex;
                        while (value > *rightIndex) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static collection<uint> RangeSortDesc
            (uint[] values, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (uint* valueFixed = values)
                {
                    new uintRangeSorterDesc
                    {
                        SkipCount = valueFixed + range.SkipCount,
                        GetEndIndex = valueFixed + range.EndIndex - 1
                    }.Sort(valueFixed, valueFixed + values.Length - 1);
                }
                return new collection<uint>(values, range.SkipCount, getCount, true);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static collection<uint> GetRangeSortDesc
            (uint[] values, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                uint[] newValues = new uint[values.Length];
                Buffer.BlockCopy(values, 0, newValues, 0, values.Length * sizeof(uint));
                fixed (uint* newValueFixed = newValues, valueFixed = values)
                {
                    new uintRangeSorterDesc
                    {
                        SkipCount = newValueFixed + range.SkipCount,
                        GetEndIndex = newValueFixed + range.EndIndex - 1
                    }.Sort(newValueFixed, newValueFixed + values.Length - 1);
                }
                return new collection<uint>(newValues, range.SkipCount, getCount, true);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static collection<uint> RangeSortDesc
            (uint[] values, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    skipCount = range.SkipCount + getRange.SkipCount;
                    fixed (uint* valueFixed = values)
                    {
                        uint* skip = valueFixed + skipCount, start = valueFixed + range.SkipCount;
                        new uintRangeSorterDesc
                        {
                            SkipCount = skip,
                            GetEndIndex = skip + getCount - 1
                        }.Sort(start, start + --count);
                    }
                    return new collection<uint>(values, skipCount, getCount, true);
                }
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static collection<uint> GetRangeSortDesc
            (uint[] values, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    uint[] newValues = new uint[count];
                    Buffer.BlockCopy(values, range.SkipCount * sizeof(uint), newValues, 0, count * sizeof(uint));
                    fixed (uint* newValueFixed = newValues, valueFixed = values)
                    {
                        new uintRangeSorterDesc
                        {
                            SkipCount = newValueFixed + getRange.SkipCount,
                            GetEndIndex = newValueFixed + getRange.SkipCount + getCount - 1
                        }.Sort(newValueFixed, newValueFixed + count - 1);
                    }
                    return new collection<uint>(newValues, getRange.SkipCount, getCount, true);
                }
            }
            return null;
        }

        /// <summary>
        /// 索引范围排序器
        /// </summary>
        private unsafe struct uintRangeIndexSorterDesc
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public uintSortIndex* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public uintSortIndex* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(uintSortIndex* startIndex, uintSortIndex* endIndex)
            {
                do
                {
                    uintSortIndex leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue.Value < rightValue.Value)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    uintSortIndex* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    uintSortIndex indexValue = *averageIndex;
                    if (leftValue.Value < indexValue.Value)
                    {
                        if (leftValue.Value < rightValue.Value)
                        {
                            *rightIndex = leftValue;
                            if (indexValue.Value < rightValue.Value) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = indexValue;
                                *averageIndex = indexValue = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = leftValue;
                        }
                    }
                    else
                    {
                        if (indexValue.Value < rightValue.Value)
                        {
                            *rightIndex = indexValue;
                            if (leftValue.Value < rightValue.Value)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = indexValue = leftValue;
                            }
                            else *averageIndex = indexValue = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    uint value = indexValue.Value;
                    do
                    {
                        while ((*leftIndex).Value > value) ++leftIndex;
                        while (value > (*rightIndex).Value) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSortDesc<valueType>
            (valueType[] values, func<valueType, uint> getKey, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                if (values.Length > (config.pub.Default.StreamBufferLength >> 4))
                {
                    uintSortIndex[] indexs = new uintSortIndex[values.Length];
                    fixed (uintSortIndex* fixedIndex = indexs)
                    {
                        return getRangeSortDesc(values, getKey, range.SkipCount, getCount, fixedIndex);
                    }
                }
                else
                {
                    uintSortIndex* fixedIndex = stackalloc uintSortIndex[values.Length];
                    return getRangeSortDesc(values, getKey, range.SkipCount, getCount, fixedIndex);
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSortDesc<valueType>
            (valueType[] values, func<valueType, uint> getKey, int skipCount, int getCount
            , uintSortIndex* fixedIndex)
        {
            uintSortIndex* writeIndex = fixedIndex;
            for (int index = 0; index != values.Length; ++index)
            {
                *writeIndex++ = new uintSortIndex { Value = getKey(values[index]), Index = index };
            }
            return getRangeSortDesc(values, skipCount, getCount, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSortDesc<valueType>
            (valueType[] values, int skipCount, int getCount, uintSortIndex* fixedIndex)
        {
            new uintRangeIndexSorterDesc
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + values.Length - 1);
            valueType[] newValues = new valueType[getCount];
            uintSortIndex* writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="indexs">排序索引</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSortDesc<valueType>
            (valueType[] values, uintSortIndex[] indexs, int skipCount, int getCount)
        {
            if (values.length() != indexs.length()) log.Default.Throw(log.exceptionType.IndexOutOfRange);
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (uintSortIndex* fixedIndex = indexs) return getRangeSortDesc(values, skipCount, getCount, fixedIndex);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSortDesc<valueType>
            (valueType[] values, int startIndex, int count, func<valueType, uint> getKey, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                    if (values.Length > (config.pub.Default.StreamBufferLength >> 4))
                    {
                        uintSortIndex[] indexs = new uintSortIndex[count];
                        fixed (uintSortIndex* fixedIndex = indexs)
                        {
                            return getRangeSortDesc
                                (values, range.SkipCount, count, getKey, getRange.SkipCount, getCount, fixedIndex);
                        }
                    }
                    else
                    {
                        uintSortIndex* fixedIndex = stackalloc uintSortIndex[count];
                        return getRangeSortDesc
                            (values, range.SkipCount, count, getKey, getRange.SkipCount, getCount, fixedIndex);
                    }
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSortDesc<valueType>
            (valueType[] values, int startIndex, int count, func<valueType, uint> getKey, int skipCount, int getCount
            , uintSortIndex* fixedIndex)
        {
            uintSortIndex* writeIndex = fixedIndex;
            for (int index = startIndex, endIndex = startIndex + count; index != endIndex; ++index)
            {
                *writeIndex++ = new uintSortIndex { Value = getKey(values[index]), Index = index };
            }
            new uintRangeIndexSorterDesc
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + count - 1);
            valueType[] newValues = new valueType[getCount];
            writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static collection<uint> rangeSortDesc
            (this uint[] array, int skipCount, int getCount)
        {
            return algorithm.quickSort.RangeSortDesc(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static collection<uint> getRangeSortDesc
            (this uint[] array, int skipCount, int getCount)
        {
            return algorithm.quickSort.GetRangeSortDesc(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSortDesc<valueType>
            (this valueType[] array, func<valueType, uint> getKey, int skipCount, int getCount)
        {
            return algorithm.quickSort.GetRangeSortDesc(array, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static collection<uint> rangeSortDesc
            (this uint[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return algorithm.quickSort.RangeSortDesc(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static collection<uint> getRangeSortDesc
            (this uint[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return algorithm.quickSort.GetRangeSortDesc(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSortDesc<valueType>
            (this valueType[] array, int startIndex, int count, func<valueType, uint> getKey, int skipCount, int getCount)
        {
            return algorithm.quickSort.GetRangeSortDesc(array, startIndex, count, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static collection<uint> pageSortDesc
            (this uint[] array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return algorithm.quickSort.RangeSortDesc(array, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static valueType[] getPageSortDesc<valueType>
            (this valueType[] array, func<valueType, uint> getKey, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return algorithm.quickSort.GetRangeSortDesc(array, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static collection<uint> getPageSortDesc
            (this uint[] array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return algorithm.quickSort.GetRangeSortDesc(array, page.SkipCount, page.CurrentPageSize);
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 单向动态数组扩展
    /// </summary>
    public static partial class list
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static collection<uint> rangeSortDesc
            (this list<uint> list, int skipCount, int getCount)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.RangeSortDesc(list.Unsafer.Array, 0, list.Count, skipCount, getCount);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static collection<uint> getRangeSortDesc
            (this list<uint> list, int skipCount, int getCount)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.GetRangeSortDesc(list.Unsafer.Array, 0, list.Count, skipCount, getCount);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSortDesc<valueType>
            (this list<valueType> list, func<valueType, uint> getKey, int skipCount, int getCount)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.GetRangeSortDesc
                    (list.Unsafer.Array, 0, list.Count, getKey, skipCount, getCount);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static collection<uint> rangeSortDesc
            (this list<uint> list, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.RangeSortDesc
                    (list.Unsafer.Array, range.SkipCount, count, skipCount, getCount);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static collection<uint> getRangeSortDesc
            (this list<uint> list, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.GetRangeSortDesc
                    (list.Unsafer.Array, range.SkipCount, count, skipCount, getCount);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSortDesc<valueType>
            (this list<valueType> list, int startIndex, int count, func<valueType, uint> getKey
            , int skipCount, int getCount)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.GetRangeSortDesc
                    (list.Unsafer.Array, range.SkipCount, count, getKey, skipCount, getCount);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static collection<uint> pageSortDesc
            (this list<uint> list, int pageSize, int currentPage)
        {
            array.page page = new array.page(list.count(), pageSize, currentPage);
            int count = page.CurrentPageSize;
            if (count != 0)
            {
                return algorithm.quickSort.RangeSortDesc(list.Unsafer.Array, page.SkipCount, count);
            }
            return null;
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static collection<uint> getPageSortDesc
            (this list<uint> list, int pageSize, int currentPage)
        {
            array.page page = new array.page(list.count(), pageSize, currentPage);
            int count = page.CurrentPageSize;
            if (count != 0)
            {
                return algorithm.quickSort.GetRangeSortDesc(list.Unsafer.Array, page.SkipCount, count);
            }
            return null;
        }
    }
}
namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 范围排序器(一般用于获取分页)
        /// </summary>
        private unsafe struct intRangeSorter
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public int* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public int* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(int* startIndex, int* endIndex)
            {
                do
                {
                    int leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue > rightValue)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    int* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    int value = *averageIndex;
                    if (leftValue > value)
                    {
                        if (leftValue > rightValue)
                        {
                            *rightIndex = leftValue;
                            if (value > rightValue) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = value;
                                *averageIndex = value = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = leftValue;
                        }
                    }
                    else
                    {
                        if (value > rightValue)
                        {
                            *rightIndex = value;
                            if (leftValue > rightValue)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = value = leftValue;
                            }
                            else *averageIndex = value = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    do
                    {
                        while (*leftIndex < value) ++leftIndex;
                        while (value < *rightIndex) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static collection<int> RangeSort
            (int[] values, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (int* valueFixed = values)
                {
                    new intRangeSorter
                    {
                        SkipCount = valueFixed + range.SkipCount,
                        GetEndIndex = valueFixed + range.EndIndex - 1
                    }.Sort(valueFixed, valueFixed + values.Length - 1);
                }
                return new collection<int>(values, range.SkipCount, getCount, true);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static collection<int> GetRangeSort
            (int[] values, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                int[] newValues = new int[values.Length];
                Buffer.BlockCopy(values, 0, newValues, 0, values.Length * sizeof(int));
                fixed (int* newValueFixed = newValues, valueFixed = values)
                {
                    new intRangeSorter
                    {
                        SkipCount = newValueFixed + range.SkipCount,
                        GetEndIndex = newValueFixed + range.EndIndex - 1
                    }.Sort(newValueFixed, newValueFixed + values.Length - 1);
                }
                return new collection<int>(newValues, range.SkipCount, getCount, true);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static collection<int> RangeSort
            (int[] values, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    skipCount = range.SkipCount + getRange.SkipCount;
                    fixed (int* valueFixed = values)
                    {
                        int* skip = valueFixed + skipCount, start = valueFixed + range.SkipCount;
                        new intRangeSorter
                        {
                            SkipCount = skip,
                            GetEndIndex = skip + getCount - 1
                        }.Sort(start, start + --count);
                    }
                    return new collection<int>(values, skipCount, getCount, true);
                }
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static collection<int> GetRangeSort
            (int[] values, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    int[] newValues = new int[count];
                    Buffer.BlockCopy(values, range.SkipCount * sizeof(int), newValues, 0, count * sizeof(int));
                    fixed (int* newValueFixed = newValues, valueFixed = values)
                    {
                        new intRangeSorter
                        {
                            SkipCount = newValueFixed + getRange.SkipCount,
                            GetEndIndex = newValueFixed + getRange.SkipCount + getCount - 1
                        }.Sort(newValueFixed, newValueFixed + count - 1);
                    }
                    return new collection<int>(newValues, getRange.SkipCount, getCount, true);
                }
            }
            return null;
        }

        /// <summary>
        /// 索引范围排序器
        /// </summary>
        private unsafe struct intRangeIndexSorter
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public intSortIndex* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public intSortIndex* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(intSortIndex* startIndex, intSortIndex* endIndex)
            {
                do
                {
                    intSortIndex leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue.Value > rightValue.Value)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    intSortIndex* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    intSortIndex indexValue = *averageIndex;
                    if (leftValue.Value > indexValue.Value)
                    {
                        if (leftValue.Value > rightValue.Value)
                        {
                            *rightIndex = leftValue;
                            if (indexValue.Value > rightValue.Value) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = indexValue;
                                *averageIndex = indexValue = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = leftValue;
                        }
                    }
                    else
                    {
                        if (indexValue.Value > rightValue.Value)
                        {
                            *rightIndex = indexValue;
                            if (leftValue.Value > rightValue.Value)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = indexValue = leftValue;
                            }
                            else *averageIndex = indexValue = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    int value = indexValue.Value;
                    do
                    {
                        while ((*leftIndex).Value < value) ++leftIndex;
                        while (value < (*rightIndex).Value) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSort<valueType>
            (valueType[] values, func<valueType, int> getKey, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                if (values.Length > (config.pub.Default.StreamBufferLength >> 4))
                {
                    intSortIndex[] indexs = new intSortIndex[values.Length];
                    fixed (intSortIndex* fixedIndex = indexs)
                    {
                        return getRangeSort(values, getKey, range.SkipCount, getCount, fixedIndex);
                    }
                }
                else
                {
                    intSortIndex* fixedIndex = stackalloc intSortIndex[values.Length];
                    return getRangeSort(values, getKey, range.SkipCount, getCount, fixedIndex);
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSort<valueType>
            (valueType[] values, func<valueType, int> getKey, int skipCount, int getCount
            , intSortIndex* fixedIndex)
        {
            intSortIndex* writeIndex = fixedIndex;
            for (int index = 0; index != values.Length; ++index)
            {
                *writeIndex++ = new intSortIndex { Value = getKey(values[index]), Index = index };
            }
            return getRangeSort(values, skipCount, getCount, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSort<valueType>
            (valueType[] values, int skipCount, int getCount, intSortIndex* fixedIndex)
        {
            new intRangeIndexSorter
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + values.Length - 1);
            valueType[] newValues = new valueType[getCount];
            intSortIndex* writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="indexs">排序索引</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSort<valueType>
            (valueType[] values, intSortIndex[] indexs, int skipCount, int getCount)
        {
            if (values.length() != indexs.length()) log.Default.Throw(log.exceptionType.IndexOutOfRange);
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (intSortIndex* fixedIndex = indexs) return getRangeSort(values, skipCount, getCount, fixedIndex);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSort<valueType>
            (valueType[] values, int startIndex, int count, func<valueType, int> getKey, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                    if (values.Length > (config.pub.Default.StreamBufferLength >> 4))
                    {
                        intSortIndex[] indexs = new intSortIndex[count];
                        fixed (intSortIndex* fixedIndex = indexs)
                        {
                            return getRangeSort
                                (values, range.SkipCount, count, getKey, getRange.SkipCount, getCount, fixedIndex);
                        }
                    }
                    else
                    {
                        intSortIndex* fixedIndex = stackalloc intSortIndex[count];
                        return getRangeSort
                            (values, range.SkipCount, count, getKey, getRange.SkipCount, getCount, fixedIndex);
                    }
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSort<valueType>
            (valueType[] values, int startIndex, int count, func<valueType, int> getKey, int skipCount, int getCount
            , intSortIndex* fixedIndex)
        {
            intSortIndex* writeIndex = fixedIndex;
            for (int index = startIndex, endIndex = startIndex + count; index != endIndex; ++index)
            {
                *writeIndex++ = new intSortIndex { Value = getKey(values[index]), Index = index };
            }
            new intRangeIndexSorter
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + count - 1);
            valueType[] newValues = new valueType[getCount];
            writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static collection<int> rangeSort
            (this int[] array, int skipCount, int getCount)
        {
            return algorithm.quickSort.RangeSort(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static collection<int> getRangeSort
            (this int[] array, int skipCount, int getCount)
        {
            return algorithm.quickSort.GetRangeSort(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSort<valueType>
            (this valueType[] array, func<valueType, int> getKey, int skipCount, int getCount)
        {
            return algorithm.quickSort.GetRangeSort(array, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static collection<int> rangeSort
            (this int[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return algorithm.quickSort.RangeSort(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static collection<int> getRangeSort
            (this int[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return algorithm.quickSort.GetRangeSort(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSort<valueType>
            (this valueType[] array, int startIndex, int count, func<valueType, int> getKey, int skipCount, int getCount)
        {
            return algorithm.quickSort.GetRangeSort(array, startIndex, count, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static collection<int> pageSort
            (this int[] array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return algorithm.quickSort.RangeSort(array, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static valueType[] getPageSort<valueType>
            (this valueType[] array, func<valueType, int> getKey, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return algorithm.quickSort.GetRangeSort(array, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static collection<int> getPageSort
            (this int[] array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return algorithm.quickSort.GetRangeSort(array, page.SkipCount, page.CurrentPageSize);
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 单向动态数组扩展
    /// </summary>
    public static partial class list
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static collection<int> rangeSort
            (this list<int> list, int skipCount, int getCount)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.RangeSort(list.Unsafer.Array, 0, list.Count, skipCount, getCount);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static collection<int> getRangeSort
            (this list<int> list, int skipCount, int getCount)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.GetRangeSort(list.Unsafer.Array, 0, list.Count, skipCount, getCount);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSort<valueType>
            (this list<valueType> list, func<valueType, int> getKey, int skipCount, int getCount)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.GetRangeSort
                    (list.Unsafer.Array, 0, list.Count, getKey, skipCount, getCount);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static collection<int> rangeSort
            (this list<int> list, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.RangeSort
                    (list.Unsafer.Array, range.SkipCount, count, skipCount, getCount);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static collection<int> getRangeSort
            (this list<int> list, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.GetRangeSort
                    (list.Unsafer.Array, range.SkipCount, count, skipCount, getCount);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSort<valueType>
            (this list<valueType> list, int startIndex, int count, func<valueType, int> getKey
            , int skipCount, int getCount)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.GetRangeSort
                    (list.Unsafer.Array, range.SkipCount, count, getKey, skipCount, getCount);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static collection<int> pageSort
            (this list<int> list, int pageSize, int currentPage)
        {
            array.page page = new array.page(list.count(), pageSize, currentPage);
            int count = page.CurrentPageSize;
            if (count != 0)
            {
                return algorithm.quickSort.RangeSort(list.Unsafer.Array, page.SkipCount, count);
            }
            return null;
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static collection<int> getPageSort
            (this list<int> list, int pageSize, int currentPage)
        {
            array.page page = new array.page(list.count(), pageSize, currentPage);
            int count = page.CurrentPageSize;
            if (count != 0)
            {
                return algorithm.quickSort.GetRangeSort(list.Unsafer.Array, page.SkipCount, count);
            }
            return null;
        }
    }
}
namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 范围排序器(一般用于获取分页)
        /// </summary>
        private unsafe struct intRangeSorterDesc
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public int* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public int* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(int* startIndex, int* endIndex)
            {
                do
                {
                    int leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue < rightValue)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    int* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    int value = *averageIndex;
                    if (leftValue < value)
                    {
                        if (leftValue < rightValue)
                        {
                            *rightIndex = leftValue;
                            if (value < rightValue) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = value;
                                *averageIndex = value = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = leftValue;
                        }
                    }
                    else
                    {
                        if (value < rightValue)
                        {
                            *rightIndex = value;
                            if (leftValue < rightValue)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = value = leftValue;
                            }
                            else *averageIndex = value = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    do
                    {
                        while (*leftIndex > value) ++leftIndex;
                        while (value > *rightIndex) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static collection<int> RangeSortDesc
            (int[] values, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (int* valueFixed = values)
                {
                    new intRangeSorterDesc
                    {
                        SkipCount = valueFixed + range.SkipCount,
                        GetEndIndex = valueFixed + range.EndIndex - 1
                    }.Sort(valueFixed, valueFixed + values.Length - 1);
                }
                return new collection<int>(values, range.SkipCount, getCount, true);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static collection<int> GetRangeSortDesc
            (int[] values, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                int[] newValues = new int[values.Length];
                Buffer.BlockCopy(values, 0, newValues, 0, values.Length * sizeof(int));
                fixed (int* newValueFixed = newValues, valueFixed = values)
                {
                    new intRangeSorterDesc
                    {
                        SkipCount = newValueFixed + range.SkipCount,
                        GetEndIndex = newValueFixed + range.EndIndex - 1
                    }.Sort(newValueFixed, newValueFixed + values.Length - 1);
                }
                return new collection<int>(newValues, range.SkipCount, getCount, true);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static collection<int> RangeSortDesc
            (int[] values, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    skipCount = range.SkipCount + getRange.SkipCount;
                    fixed (int* valueFixed = values)
                    {
                        int* skip = valueFixed + skipCount, start = valueFixed + range.SkipCount;
                        new intRangeSorterDesc
                        {
                            SkipCount = skip,
                            GetEndIndex = skip + getCount - 1
                        }.Sort(start, start + --count);
                    }
                    return new collection<int>(values, skipCount, getCount, true);
                }
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static collection<int> GetRangeSortDesc
            (int[] values, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    int[] newValues = new int[count];
                    Buffer.BlockCopy(values, range.SkipCount * sizeof(int), newValues, 0, count * sizeof(int));
                    fixed (int* newValueFixed = newValues, valueFixed = values)
                    {
                        new intRangeSorterDesc
                        {
                            SkipCount = newValueFixed + getRange.SkipCount,
                            GetEndIndex = newValueFixed + getRange.SkipCount + getCount - 1
                        }.Sort(newValueFixed, newValueFixed + count - 1);
                    }
                    return new collection<int>(newValues, getRange.SkipCount, getCount, true);
                }
            }
            return null;
        }

        /// <summary>
        /// 索引范围排序器
        /// </summary>
        private unsafe struct intRangeIndexSorterDesc
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public intSortIndex* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public intSortIndex* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(intSortIndex* startIndex, intSortIndex* endIndex)
            {
                do
                {
                    intSortIndex leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue.Value < rightValue.Value)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    intSortIndex* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    intSortIndex indexValue = *averageIndex;
                    if (leftValue.Value < indexValue.Value)
                    {
                        if (leftValue.Value < rightValue.Value)
                        {
                            *rightIndex = leftValue;
                            if (indexValue.Value < rightValue.Value) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = indexValue;
                                *averageIndex = indexValue = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = leftValue;
                        }
                    }
                    else
                    {
                        if (indexValue.Value < rightValue.Value)
                        {
                            *rightIndex = indexValue;
                            if (leftValue.Value < rightValue.Value)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = indexValue = leftValue;
                            }
                            else *averageIndex = indexValue = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    int value = indexValue.Value;
                    do
                    {
                        while ((*leftIndex).Value > value) ++leftIndex;
                        while (value > (*rightIndex).Value) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSortDesc<valueType>
            (valueType[] values, func<valueType, int> getKey, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                if (values.Length > (config.pub.Default.StreamBufferLength >> 4))
                {
                    intSortIndex[] indexs = new intSortIndex[values.Length];
                    fixed (intSortIndex* fixedIndex = indexs)
                    {
                        return getRangeSortDesc(values, getKey, range.SkipCount, getCount, fixedIndex);
                    }
                }
                else
                {
                    intSortIndex* fixedIndex = stackalloc intSortIndex[values.Length];
                    return getRangeSortDesc(values, getKey, range.SkipCount, getCount, fixedIndex);
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSortDesc<valueType>
            (valueType[] values, func<valueType, int> getKey, int skipCount, int getCount
            , intSortIndex* fixedIndex)
        {
            intSortIndex* writeIndex = fixedIndex;
            for (int index = 0; index != values.Length; ++index)
            {
                *writeIndex++ = new intSortIndex { Value = getKey(values[index]), Index = index };
            }
            return getRangeSortDesc(values, skipCount, getCount, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSortDesc<valueType>
            (valueType[] values, int skipCount, int getCount, intSortIndex* fixedIndex)
        {
            new intRangeIndexSorterDesc
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + values.Length - 1);
            valueType[] newValues = new valueType[getCount];
            intSortIndex* writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="indexs">排序索引</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSortDesc<valueType>
            (valueType[] values, intSortIndex[] indexs, int skipCount, int getCount)
        {
            if (values.length() != indexs.length()) log.Default.Throw(log.exceptionType.IndexOutOfRange);
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (intSortIndex* fixedIndex = indexs) return getRangeSortDesc(values, skipCount, getCount, fixedIndex);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSortDesc<valueType>
            (valueType[] values, int startIndex, int count, func<valueType, int> getKey, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                    if (values.Length > (config.pub.Default.StreamBufferLength >> 4))
                    {
                        intSortIndex[] indexs = new intSortIndex[count];
                        fixed (intSortIndex* fixedIndex = indexs)
                        {
                            return getRangeSortDesc
                                (values, range.SkipCount, count, getKey, getRange.SkipCount, getCount, fixedIndex);
                        }
                    }
                    else
                    {
                        intSortIndex* fixedIndex = stackalloc intSortIndex[count];
                        return getRangeSortDesc
                            (values, range.SkipCount, count, getKey, getRange.SkipCount, getCount, fixedIndex);
                    }
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSortDesc<valueType>
            (valueType[] values, int startIndex, int count, func<valueType, int> getKey, int skipCount, int getCount
            , intSortIndex* fixedIndex)
        {
            intSortIndex* writeIndex = fixedIndex;
            for (int index = startIndex, endIndex = startIndex + count; index != endIndex; ++index)
            {
                *writeIndex++ = new intSortIndex { Value = getKey(values[index]), Index = index };
            }
            new intRangeIndexSorterDesc
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + count - 1);
            valueType[] newValues = new valueType[getCount];
            writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static collection<int> rangeSortDesc
            (this int[] array, int skipCount, int getCount)
        {
            return algorithm.quickSort.RangeSortDesc(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static collection<int> getRangeSortDesc
            (this int[] array, int skipCount, int getCount)
        {
            return algorithm.quickSort.GetRangeSortDesc(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSortDesc<valueType>
            (this valueType[] array, func<valueType, int> getKey, int skipCount, int getCount)
        {
            return algorithm.quickSort.GetRangeSortDesc(array, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static collection<int> rangeSortDesc
            (this int[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return algorithm.quickSort.RangeSortDesc(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static collection<int> getRangeSortDesc
            (this int[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return algorithm.quickSort.GetRangeSortDesc(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSortDesc<valueType>
            (this valueType[] array, int startIndex, int count, func<valueType, int> getKey, int skipCount, int getCount)
        {
            return algorithm.quickSort.GetRangeSortDesc(array, startIndex, count, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static collection<int> pageSortDesc
            (this int[] array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return algorithm.quickSort.RangeSortDesc(array, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static valueType[] getPageSortDesc<valueType>
            (this valueType[] array, func<valueType, int> getKey, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return algorithm.quickSort.GetRangeSortDesc(array, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static collection<int> getPageSortDesc
            (this int[] array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return algorithm.quickSort.GetRangeSortDesc(array, page.SkipCount, page.CurrentPageSize);
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 单向动态数组扩展
    /// </summary>
    public static partial class list
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static collection<int> rangeSortDesc
            (this list<int> list, int skipCount, int getCount)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.RangeSortDesc(list.Unsafer.Array, 0, list.Count, skipCount, getCount);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static collection<int> getRangeSortDesc
            (this list<int> list, int skipCount, int getCount)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.GetRangeSortDesc(list.Unsafer.Array, 0, list.Count, skipCount, getCount);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSortDesc<valueType>
            (this list<valueType> list, func<valueType, int> getKey, int skipCount, int getCount)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.GetRangeSortDesc
                    (list.Unsafer.Array, 0, list.Count, getKey, skipCount, getCount);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static collection<int> rangeSortDesc
            (this list<int> list, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.RangeSortDesc
                    (list.Unsafer.Array, range.SkipCount, count, skipCount, getCount);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static collection<int> getRangeSortDesc
            (this list<int> list, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.GetRangeSortDesc
                    (list.Unsafer.Array, range.SkipCount, count, skipCount, getCount);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSortDesc<valueType>
            (this list<valueType> list, int startIndex, int count, func<valueType, int> getKey
            , int skipCount, int getCount)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.GetRangeSortDesc
                    (list.Unsafer.Array, range.SkipCount, count, getKey, skipCount, getCount);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static collection<int> pageSortDesc
            (this list<int> list, int pageSize, int currentPage)
        {
            array.page page = new array.page(list.count(), pageSize, currentPage);
            int count = page.CurrentPageSize;
            if (count != 0)
            {
                return algorithm.quickSort.RangeSortDesc(list.Unsafer.Array, page.SkipCount, count);
            }
            return null;
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static collection<int> getPageSortDesc
            (this list<int> list, int pageSize, int currentPage)
        {
            array.page page = new array.page(list.count(), pageSize, currentPage);
            int count = page.CurrentPageSize;
            if (count != 0)
            {
                return algorithm.quickSort.GetRangeSortDesc(list.Unsafer.Array, page.SkipCount, count);
            }
            return null;
        }
    }
}
namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 范围排序器(一般用于获取分页)
        /// </summary>
        private unsafe struct ushortRangeSorter
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public ushort* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public ushort* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(ushort* startIndex, ushort* endIndex)
            {
                do
                {
                    ushort leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue > rightValue)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    ushort* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    ushort value = *averageIndex;
                    if (leftValue > value)
                    {
                        if (leftValue > rightValue)
                        {
                            *rightIndex = leftValue;
                            if (value > rightValue) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = value;
                                *averageIndex = value = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = leftValue;
                        }
                    }
                    else
                    {
                        if (value > rightValue)
                        {
                            *rightIndex = value;
                            if (leftValue > rightValue)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = value = leftValue;
                            }
                            else *averageIndex = value = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    do
                    {
                        while (*leftIndex < value) ++leftIndex;
                        while (value < *rightIndex) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static collection<ushort> RangeSort
            (ushort[] values, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (ushort* valueFixed = values)
                {
                    new ushortRangeSorter
                    {
                        SkipCount = valueFixed + range.SkipCount,
                        GetEndIndex = valueFixed + range.EndIndex - 1
                    }.Sort(valueFixed, valueFixed + values.Length - 1);
                }
                return new collection<ushort>(values, range.SkipCount, getCount, true);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static collection<ushort> GetRangeSort
            (ushort[] values, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                ushort[] newValues = new ushort[values.Length];
                Buffer.BlockCopy(values, 0, newValues, 0, values.Length * sizeof(ushort));
                fixed (ushort* newValueFixed = newValues, valueFixed = values)
                {
                    new ushortRangeSorter
                    {
                        SkipCount = newValueFixed + range.SkipCount,
                        GetEndIndex = newValueFixed + range.EndIndex - 1
                    }.Sort(newValueFixed, newValueFixed + values.Length - 1);
                }
                return new collection<ushort>(newValues, range.SkipCount, getCount, true);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static collection<ushort> RangeSort
            (ushort[] values, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    skipCount = range.SkipCount + getRange.SkipCount;
                    fixed (ushort* valueFixed = values)
                    {
                        ushort* skip = valueFixed + skipCount, start = valueFixed + range.SkipCount;
                        new ushortRangeSorter
                        {
                            SkipCount = skip,
                            GetEndIndex = skip + getCount - 1
                        }.Sort(start, start + --count);
                    }
                    return new collection<ushort>(values, skipCount, getCount, true);
                }
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static collection<ushort> GetRangeSort
            (ushort[] values, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    ushort[] newValues = new ushort[count];
                    Buffer.BlockCopy(values, range.SkipCount * sizeof(ushort), newValues, 0, count * sizeof(ushort));
                    fixed (ushort* newValueFixed = newValues, valueFixed = values)
                    {
                        new ushortRangeSorter
                        {
                            SkipCount = newValueFixed + getRange.SkipCount,
                            GetEndIndex = newValueFixed + getRange.SkipCount + getCount - 1
                        }.Sort(newValueFixed, newValueFixed + count - 1);
                    }
                    return new collection<ushort>(newValues, getRange.SkipCount, getCount, true);
                }
            }
            return null;
        }

        /// <summary>
        /// 索引范围排序器
        /// </summary>
        private unsafe struct ushortRangeIndexSorter
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public ushortSortIndex* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public ushortSortIndex* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(ushortSortIndex* startIndex, ushortSortIndex* endIndex)
            {
                do
                {
                    ushortSortIndex leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue.Value > rightValue.Value)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    ushortSortIndex* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    ushortSortIndex indexValue = *averageIndex;
                    if (leftValue.Value > indexValue.Value)
                    {
                        if (leftValue.Value > rightValue.Value)
                        {
                            *rightIndex = leftValue;
                            if (indexValue.Value > rightValue.Value) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = indexValue;
                                *averageIndex = indexValue = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = leftValue;
                        }
                    }
                    else
                    {
                        if (indexValue.Value > rightValue.Value)
                        {
                            *rightIndex = indexValue;
                            if (leftValue.Value > rightValue.Value)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = indexValue = leftValue;
                            }
                            else *averageIndex = indexValue = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    ushort value = indexValue.Value;
                    do
                    {
                        while ((*leftIndex).Value < value) ++leftIndex;
                        while (value < (*rightIndex).Value) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSort<valueType>
            (valueType[] values, func<valueType, ushort> getKey, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                if (values.Length > (config.pub.Default.StreamBufferLength >> 4))
                {
                    ushortSortIndex[] indexs = new ushortSortIndex[values.Length];
                    fixed (ushortSortIndex* fixedIndex = indexs)
                    {
                        return getRangeSort(values, getKey, range.SkipCount, getCount, fixedIndex);
                    }
                }
                else
                {
                    ushortSortIndex* fixedIndex = stackalloc ushortSortIndex[values.Length];
                    return getRangeSort(values, getKey, range.SkipCount, getCount, fixedIndex);
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSort<valueType>
            (valueType[] values, func<valueType, ushort> getKey, int skipCount, int getCount
            , ushortSortIndex* fixedIndex)
        {
            ushortSortIndex* writeIndex = fixedIndex;
            for (int index = 0; index != values.Length; ++index)
            {
                *writeIndex++ = new ushortSortIndex { Value = getKey(values[index]), Index = index };
            }
            return getRangeSort(values, skipCount, getCount, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSort<valueType>
            (valueType[] values, int skipCount, int getCount, ushortSortIndex* fixedIndex)
        {
            new ushortRangeIndexSorter
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + values.Length - 1);
            valueType[] newValues = new valueType[getCount];
            ushortSortIndex* writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="indexs">排序索引</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSort<valueType>
            (valueType[] values, ushortSortIndex[] indexs, int skipCount, int getCount)
        {
            if (values.length() != indexs.length()) log.Default.Throw(log.exceptionType.IndexOutOfRange);
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (ushortSortIndex* fixedIndex = indexs) return getRangeSort(values, skipCount, getCount, fixedIndex);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSort<valueType>
            (valueType[] values, int startIndex, int count, func<valueType, ushort> getKey, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                    if (values.Length > (config.pub.Default.StreamBufferLength >> 4))
                    {
                        ushortSortIndex[] indexs = new ushortSortIndex[count];
                        fixed (ushortSortIndex* fixedIndex = indexs)
                        {
                            return getRangeSort
                                (values, range.SkipCount, count, getKey, getRange.SkipCount, getCount, fixedIndex);
                        }
                    }
                    else
                    {
                        ushortSortIndex* fixedIndex = stackalloc ushortSortIndex[count];
                        return getRangeSort
                            (values, range.SkipCount, count, getKey, getRange.SkipCount, getCount, fixedIndex);
                    }
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSort<valueType>
            (valueType[] values, int startIndex, int count, func<valueType, ushort> getKey, int skipCount, int getCount
            , ushortSortIndex* fixedIndex)
        {
            ushortSortIndex* writeIndex = fixedIndex;
            for (int index = startIndex, endIndex = startIndex + count; index != endIndex; ++index)
            {
                *writeIndex++ = new ushortSortIndex { Value = getKey(values[index]), Index = index };
            }
            new ushortRangeIndexSorter
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + count - 1);
            valueType[] newValues = new valueType[getCount];
            writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static collection<ushort> rangeSort
            (this ushort[] array, int skipCount, int getCount)
        {
            return algorithm.quickSort.RangeSort(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static collection<ushort> getRangeSort
            (this ushort[] array, int skipCount, int getCount)
        {
            return algorithm.quickSort.GetRangeSort(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSort<valueType>
            (this valueType[] array, func<valueType, ushort> getKey, int skipCount, int getCount)
        {
            return algorithm.quickSort.GetRangeSort(array, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static collection<ushort> rangeSort
            (this ushort[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return algorithm.quickSort.RangeSort(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static collection<ushort> getRangeSort
            (this ushort[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return algorithm.quickSort.GetRangeSort(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSort<valueType>
            (this valueType[] array, int startIndex, int count, func<valueType, ushort> getKey, int skipCount, int getCount)
        {
            return algorithm.quickSort.GetRangeSort(array, startIndex, count, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static collection<ushort> pageSort
            (this ushort[] array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return algorithm.quickSort.RangeSort(array, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static valueType[] getPageSort<valueType>
            (this valueType[] array, func<valueType, ushort> getKey, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return algorithm.quickSort.GetRangeSort(array, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static collection<ushort> getPageSort
            (this ushort[] array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return algorithm.quickSort.GetRangeSort(array, page.SkipCount, page.CurrentPageSize);
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 单向动态数组扩展
    /// </summary>
    public static partial class list
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static collection<ushort> rangeSort
            (this list<ushort> list, int skipCount, int getCount)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.RangeSort(list.Unsafer.Array, 0, list.Count, skipCount, getCount);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static collection<ushort> getRangeSort
            (this list<ushort> list, int skipCount, int getCount)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.GetRangeSort(list.Unsafer.Array, 0, list.Count, skipCount, getCount);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSort<valueType>
            (this list<valueType> list, func<valueType, ushort> getKey, int skipCount, int getCount)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.GetRangeSort
                    (list.Unsafer.Array, 0, list.Count, getKey, skipCount, getCount);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static collection<ushort> rangeSort
            (this list<ushort> list, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.RangeSort
                    (list.Unsafer.Array, range.SkipCount, count, skipCount, getCount);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static collection<ushort> getRangeSort
            (this list<ushort> list, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.GetRangeSort
                    (list.Unsafer.Array, range.SkipCount, count, skipCount, getCount);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSort<valueType>
            (this list<valueType> list, int startIndex, int count, func<valueType, ushort> getKey
            , int skipCount, int getCount)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.GetRangeSort
                    (list.Unsafer.Array, range.SkipCount, count, getKey, skipCount, getCount);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static collection<ushort> pageSort
            (this list<ushort> list, int pageSize, int currentPage)
        {
            array.page page = new array.page(list.count(), pageSize, currentPage);
            int count = page.CurrentPageSize;
            if (count != 0)
            {
                return algorithm.quickSort.RangeSort(list.Unsafer.Array, page.SkipCount, count);
            }
            return null;
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static collection<ushort> getPageSort
            (this list<ushort> list, int pageSize, int currentPage)
        {
            array.page page = new array.page(list.count(), pageSize, currentPage);
            int count = page.CurrentPageSize;
            if (count != 0)
            {
                return algorithm.quickSort.GetRangeSort(list.Unsafer.Array, page.SkipCount, count);
            }
            return null;
        }
    }
}
namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 范围排序器(一般用于获取分页)
        /// </summary>
        private unsafe struct ushortRangeSorterDesc
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public ushort* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public ushort* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(ushort* startIndex, ushort* endIndex)
            {
                do
                {
                    ushort leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue < rightValue)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    ushort* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    ushort value = *averageIndex;
                    if (leftValue < value)
                    {
                        if (leftValue < rightValue)
                        {
                            *rightIndex = leftValue;
                            if (value < rightValue) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = value;
                                *averageIndex = value = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = leftValue;
                        }
                    }
                    else
                    {
                        if (value < rightValue)
                        {
                            *rightIndex = value;
                            if (leftValue < rightValue)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = value = leftValue;
                            }
                            else *averageIndex = value = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    do
                    {
                        while (*leftIndex > value) ++leftIndex;
                        while (value > *rightIndex) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static collection<ushort> RangeSortDesc
            (ushort[] values, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (ushort* valueFixed = values)
                {
                    new ushortRangeSorterDesc
                    {
                        SkipCount = valueFixed + range.SkipCount,
                        GetEndIndex = valueFixed + range.EndIndex - 1
                    }.Sort(valueFixed, valueFixed + values.Length - 1);
                }
                return new collection<ushort>(values, range.SkipCount, getCount, true);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static collection<ushort> GetRangeSortDesc
            (ushort[] values, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                ushort[] newValues = new ushort[values.Length];
                Buffer.BlockCopy(values, 0, newValues, 0, values.Length * sizeof(ushort));
                fixed (ushort* newValueFixed = newValues, valueFixed = values)
                {
                    new ushortRangeSorterDesc
                    {
                        SkipCount = newValueFixed + range.SkipCount,
                        GetEndIndex = newValueFixed + range.EndIndex - 1
                    }.Sort(newValueFixed, newValueFixed + values.Length - 1);
                }
                return new collection<ushort>(newValues, range.SkipCount, getCount, true);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static collection<ushort> RangeSortDesc
            (ushort[] values, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    skipCount = range.SkipCount + getRange.SkipCount;
                    fixed (ushort* valueFixed = values)
                    {
                        ushort* skip = valueFixed + skipCount, start = valueFixed + range.SkipCount;
                        new ushortRangeSorterDesc
                        {
                            SkipCount = skip,
                            GetEndIndex = skip + getCount - 1
                        }.Sort(start, start + --count);
                    }
                    return new collection<ushort>(values, skipCount, getCount, true);
                }
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static collection<ushort> GetRangeSortDesc
            (ushort[] values, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    ushort[] newValues = new ushort[count];
                    Buffer.BlockCopy(values, range.SkipCount * sizeof(ushort), newValues, 0, count * sizeof(ushort));
                    fixed (ushort* newValueFixed = newValues, valueFixed = values)
                    {
                        new ushortRangeSorterDesc
                        {
                            SkipCount = newValueFixed + getRange.SkipCount,
                            GetEndIndex = newValueFixed + getRange.SkipCount + getCount - 1
                        }.Sort(newValueFixed, newValueFixed + count - 1);
                    }
                    return new collection<ushort>(newValues, getRange.SkipCount, getCount, true);
                }
            }
            return null;
        }

        /// <summary>
        /// 索引范围排序器
        /// </summary>
        private unsafe struct ushortRangeIndexSorterDesc
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public ushortSortIndex* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public ushortSortIndex* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(ushortSortIndex* startIndex, ushortSortIndex* endIndex)
            {
                do
                {
                    ushortSortIndex leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue.Value < rightValue.Value)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    ushortSortIndex* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    ushortSortIndex indexValue = *averageIndex;
                    if (leftValue.Value < indexValue.Value)
                    {
                        if (leftValue.Value < rightValue.Value)
                        {
                            *rightIndex = leftValue;
                            if (indexValue.Value < rightValue.Value) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = indexValue;
                                *averageIndex = indexValue = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = leftValue;
                        }
                    }
                    else
                    {
                        if (indexValue.Value < rightValue.Value)
                        {
                            *rightIndex = indexValue;
                            if (leftValue.Value < rightValue.Value)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = indexValue = leftValue;
                            }
                            else *averageIndex = indexValue = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    ushort value = indexValue.Value;
                    do
                    {
                        while ((*leftIndex).Value > value) ++leftIndex;
                        while (value > (*rightIndex).Value) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSortDesc<valueType>
            (valueType[] values, func<valueType, ushort> getKey, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                if (values.Length > (config.pub.Default.StreamBufferLength >> 4))
                {
                    ushortSortIndex[] indexs = new ushortSortIndex[values.Length];
                    fixed (ushortSortIndex* fixedIndex = indexs)
                    {
                        return getRangeSortDesc(values, getKey, range.SkipCount, getCount, fixedIndex);
                    }
                }
                else
                {
                    ushortSortIndex* fixedIndex = stackalloc ushortSortIndex[values.Length];
                    return getRangeSortDesc(values, getKey, range.SkipCount, getCount, fixedIndex);
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSortDesc<valueType>
            (valueType[] values, func<valueType, ushort> getKey, int skipCount, int getCount
            , ushortSortIndex* fixedIndex)
        {
            ushortSortIndex* writeIndex = fixedIndex;
            for (int index = 0; index != values.Length; ++index)
            {
                *writeIndex++ = new ushortSortIndex { Value = getKey(values[index]), Index = index };
            }
            return getRangeSortDesc(values, skipCount, getCount, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSortDesc<valueType>
            (valueType[] values, int skipCount, int getCount, ushortSortIndex* fixedIndex)
        {
            new ushortRangeIndexSorterDesc
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + values.Length - 1);
            valueType[] newValues = new valueType[getCount];
            ushortSortIndex* writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="indexs">排序索引</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSortDesc<valueType>
            (valueType[] values, ushortSortIndex[] indexs, int skipCount, int getCount)
        {
            if (values.length() != indexs.length()) log.Default.Throw(log.exceptionType.IndexOutOfRange);
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (ushortSortIndex* fixedIndex = indexs) return getRangeSortDesc(values, skipCount, getCount, fixedIndex);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSortDesc<valueType>
            (valueType[] values, int startIndex, int count, func<valueType, ushort> getKey, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                    if (values.Length > (config.pub.Default.StreamBufferLength >> 4))
                    {
                        ushortSortIndex[] indexs = new ushortSortIndex[count];
                        fixed (ushortSortIndex* fixedIndex = indexs)
                        {
                            return getRangeSortDesc
                                (values, range.SkipCount, count, getKey, getRange.SkipCount, getCount, fixedIndex);
                        }
                    }
                    else
                    {
                        ushortSortIndex* fixedIndex = stackalloc ushortSortIndex[count];
                        return getRangeSortDesc
                            (values, range.SkipCount, count, getKey, getRange.SkipCount, getCount, fixedIndex);
                    }
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSortDesc<valueType>
            (valueType[] values, int startIndex, int count, func<valueType, ushort> getKey, int skipCount, int getCount
            , ushortSortIndex* fixedIndex)
        {
            ushortSortIndex* writeIndex = fixedIndex;
            for (int index = startIndex, endIndex = startIndex + count; index != endIndex; ++index)
            {
                *writeIndex++ = new ushortSortIndex { Value = getKey(values[index]), Index = index };
            }
            new ushortRangeIndexSorterDesc
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + count - 1);
            valueType[] newValues = new valueType[getCount];
            writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static collection<ushort> rangeSortDesc
            (this ushort[] array, int skipCount, int getCount)
        {
            return algorithm.quickSort.RangeSortDesc(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static collection<ushort> getRangeSortDesc
            (this ushort[] array, int skipCount, int getCount)
        {
            return algorithm.quickSort.GetRangeSortDesc(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSortDesc<valueType>
            (this valueType[] array, func<valueType, ushort> getKey, int skipCount, int getCount)
        {
            return algorithm.quickSort.GetRangeSortDesc(array, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static collection<ushort> rangeSortDesc
            (this ushort[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return algorithm.quickSort.RangeSortDesc(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static collection<ushort> getRangeSortDesc
            (this ushort[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return algorithm.quickSort.GetRangeSortDesc(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSortDesc<valueType>
            (this valueType[] array, int startIndex, int count, func<valueType, ushort> getKey, int skipCount, int getCount)
        {
            return algorithm.quickSort.GetRangeSortDesc(array, startIndex, count, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static collection<ushort> pageSortDesc
            (this ushort[] array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return algorithm.quickSort.RangeSortDesc(array, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static valueType[] getPageSortDesc<valueType>
            (this valueType[] array, func<valueType, ushort> getKey, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return algorithm.quickSort.GetRangeSortDesc(array, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static collection<ushort> getPageSortDesc
            (this ushort[] array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return algorithm.quickSort.GetRangeSortDesc(array, page.SkipCount, page.CurrentPageSize);
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 单向动态数组扩展
    /// </summary>
    public static partial class list
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static collection<ushort> rangeSortDesc
            (this list<ushort> list, int skipCount, int getCount)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.RangeSortDesc(list.Unsafer.Array, 0, list.Count, skipCount, getCount);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static collection<ushort> getRangeSortDesc
            (this list<ushort> list, int skipCount, int getCount)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.GetRangeSortDesc(list.Unsafer.Array, 0, list.Count, skipCount, getCount);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSortDesc<valueType>
            (this list<valueType> list, func<valueType, ushort> getKey, int skipCount, int getCount)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.GetRangeSortDesc
                    (list.Unsafer.Array, 0, list.Count, getKey, skipCount, getCount);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static collection<ushort> rangeSortDesc
            (this list<ushort> list, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.RangeSortDesc
                    (list.Unsafer.Array, range.SkipCount, count, skipCount, getCount);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static collection<ushort> getRangeSortDesc
            (this list<ushort> list, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.GetRangeSortDesc
                    (list.Unsafer.Array, range.SkipCount, count, skipCount, getCount);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSortDesc<valueType>
            (this list<valueType> list, int startIndex, int count, func<valueType, ushort> getKey
            , int skipCount, int getCount)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.GetRangeSortDesc
                    (list.Unsafer.Array, range.SkipCount, count, getKey, skipCount, getCount);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static collection<ushort> pageSortDesc
            (this list<ushort> list, int pageSize, int currentPage)
        {
            array.page page = new array.page(list.count(), pageSize, currentPage);
            int count = page.CurrentPageSize;
            if (count != 0)
            {
                return algorithm.quickSort.RangeSortDesc(list.Unsafer.Array, page.SkipCount, count);
            }
            return null;
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static collection<ushort> getPageSortDesc
            (this list<ushort> list, int pageSize, int currentPage)
        {
            array.page page = new array.page(list.count(), pageSize, currentPage);
            int count = page.CurrentPageSize;
            if (count != 0)
            {
                return algorithm.quickSort.GetRangeSortDesc(list.Unsafer.Array, page.SkipCount, count);
            }
            return null;
        }
    }
}
namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 范围排序器(一般用于获取分页)
        /// </summary>
        private unsafe struct shortRangeSorter
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public short* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public short* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(short* startIndex, short* endIndex)
            {
                do
                {
                    short leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue > rightValue)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    short* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    short value = *averageIndex;
                    if (leftValue > value)
                    {
                        if (leftValue > rightValue)
                        {
                            *rightIndex = leftValue;
                            if (value > rightValue) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = value;
                                *averageIndex = value = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = leftValue;
                        }
                    }
                    else
                    {
                        if (value > rightValue)
                        {
                            *rightIndex = value;
                            if (leftValue > rightValue)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = value = leftValue;
                            }
                            else *averageIndex = value = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    do
                    {
                        while (*leftIndex < value) ++leftIndex;
                        while (value < *rightIndex) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static collection<short> RangeSort
            (short[] values, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (short* valueFixed = values)
                {
                    new shortRangeSorter
                    {
                        SkipCount = valueFixed + range.SkipCount,
                        GetEndIndex = valueFixed + range.EndIndex - 1
                    }.Sort(valueFixed, valueFixed + values.Length - 1);
                }
                return new collection<short>(values, range.SkipCount, getCount, true);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static collection<short> GetRangeSort
            (short[] values, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                short[] newValues = new short[values.Length];
                Buffer.BlockCopy(values, 0, newValues, 0, values.Length * sizeof(short));
                fixed (short* newValueFixed = newValues, valueFixed = values)
                {
                    new shortRangeSorter
                    {
                        SkipCount = newValueFixed + range.SkipCount,
                        GetEndIndex = newValueFixed + range.EndIndex - 1
                    }.Sort(newValueFixed, newValueFixed + values.Length - 1);
                }
                return new collection<short>(newValues, range.SkipCount, getCount, true);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static collection<short> RangeSort
            (short[] values, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    skipCount = range.SkipCount + getRange.SkipCount;
                    fixed (short* valueFixed = values)
                    {
                        short* skip = valueFixed + skipCount, start = valueFixed + range.SkipCount;
                        new shortRangeSorter
                        {
                            SkipCount = skip,
                            GetEndIndex = skip + getCount - 1
                        }.Sort(start, start + --count);
                    }
                    return new collection<short>(values, skipCount, getCount, true);
                }
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static collection<short> GetRangeSort
            (short[] values, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    short[] newValues = new short[count];
                    Buffer.BlockCopy(values, range.SkipCount * sizeof(short), newValues, 0, count * sizeof(short));
                    fixed (short* newValueFixed = newValues, valueFixed = values)
                    {
                        new shortRangeSorter
                        {
                            SkipCount = newValueFixed + getRange.SkipCount,
                            GetEndIndex = newValueFixed + getRange.SkipCount + getCount - 1
                        }.Sort(newValueFixed, newValueFixed + count - 1);
                    }
                    return new collection<short>(newValues, getRange.SkipCount, getCount, true);
                }
            }
            return null;
        }

        /// <summary>
        /// 索引范围排序器
        /// </summary>
        private unsafe struct shortRangeIndexSorter
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public shortSortIndex* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public shortSortIndex* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(shortSortIndex* startIndex, shortSortIndex* endIndex)
            {
                do
                {
                    shortSortIndex leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue.Value > rightValue.Value)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    shortSortIndex* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    shortSortIndex indexValue = *averageIndex;
                    if (leftValue.Value > indexValue.Value)
                    {
                        if (leftValue.Value > rightValue.Value)
                        {
                            *rightIndex = leftValue;
                            if (indexValue.Value > rightValue.Value) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = indexValue;
                                *averageIndex = indexValue = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = leftValue;
                        }
                    }
                    else
                    {
                        if (indexValue.Value > rightValue.Value)
                        {
                            *rightIndex = indexValue;
                            if (leftValue.Value > rightValue.Value)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = indexValue = leftValue;
                            }
                            else *averageIndex = indexValue = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    short value = indexValue.Value;
                    do
                    {
                        while ((*leftIndex).Value < value) ++leftIndex;
                        while (value < (*rightIndex).Value) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSort<valueType>
            (valueType[] values, func<valueType, short> getKey, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                if (values.Length > (config.pub.Default.StreamBufferLength >> 4))
                {
                    shortSortIndex[] indexs = new shortSortIndex[values.Length];
                    fixed (shortSortIndex* fixedIndex = indexs)
                    {
                        return getRangeSort(values, getKey, range.SkipCount, getCount, fixedIndex);
                    }
                }
                else
                {
                    shortSortIndex* fixedIndex = stackalloc shortSortIndex[values.Length];
                    return getRangeSort(values, getKey, range.SkipCount, getCount, fixedIndex);
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSort<valueType>
            (valueType[] values, func<valueType, short> getKey, int skipCount, int getCount
            , shortSortIndex* fixedIndex)
        {
            shortSortIndex* writeIndex = fixedIndex;
            for (int index = 0; index != values.Length; ++index)
            {
                *writeIndex++ = new shortSortIndex { Value = getKey(values[index]), Index = index };
            }
            return getRangeSort(values, skipCount, getCount, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSort<valueType>
            (valueType[] values, int skipCount, int getCount, shortSortIndex* fixedIndex)
        {
            new shortRangeIndexSorter
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + values.Length - 1);
            valueType[] newValues = new valueType[getCount];
            shortSortIndex* writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="indexs">排序索引</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSort<valueType>
            (valueType[] values, shortSortIndex[] indexs, int skipCount, int getCount)
        {
            if (values.length() != indexs.length()) log.Default.Throw(log.exceptionType.IndexOutOfRange);
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (shortSortIndex* fixedIndex = indexs) return getRangeSort(values, skipCount, getCount, fixedIndex);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSort<valueType>
            (valueType[] values, int startIndex, int count, func<valueType, short> getKey, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                    if (values.Length > (config.pub.Default.StreamBufferLength >> 4))
                    {
                        shortSortIndex[] indexs = new shortSortIndex[count];
                        fixed (shortSortIndex* fixedIndex = indexs)
                        {
                            return getRangeSort
                                (values, range.SkipCount, count, getKey, getRange.SkipCount, getCount, fixedIndex);
                        }
                    }
                    else
                    {
                        shortSortIndex* fixedIndex = stackalloc shortSortIndex[count];
                        return getRangeSort
                            (values, range.SkipCount, count, getKey, getRange.SkipCount, getCount, fixedIndex);
                    }
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSort<valueType>
            (valueType[] values, int startIndex, int count, func<valueType, short> getKey, int skipCount, int getCount
            , shortSortIndex* fixedIndex)
        {
            shortSortIndex* writeIndex = fixedIndex;
            for (int index = startIndex, endIndex = startIndex + count; index != endIndex; ++index)
            {
                *writeIndex++ = new shortSortIndex { Value = getKey(values[index]), Index = index };
            }
            new shortRangeIndexSorter
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + count - 1);
            valueType[] newValues = new valueType[getCount];
            writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static collection<short> rangeSort
            (this short[] array, int skipCount, int getCount)
        {
            return algorithm.quickSort.RangeSort(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static collection<short> getRangeSort
            (this short[] array, int skipCount, int getCount)
        {
            return algorithm.quickSort.GetRangeSort(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSort<valueType>
            (this valueType[] array, func<valueType, short> getKey, int skipCount, int getCount)
        {
            return algorithm.quickSort.GetRangeSort(array, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static collection<short> rangeSort
            (this short[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return algorithm.quickSort.RangeSort(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static collection<short> getRangeSort
            (this short[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return algorithm.quickSort.GetRangeSort(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSort<valueType>
            (this valueType[] array, int startIndex, int count, func<valueType, short> getKey, int skipCount, int getCount)
        {
            return algorithm.quickSort.GetRangeSort(array, startIndex, count, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static collection<short> pageSort
            (this short[] array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return algorithm.quickSort.RangeSort(array, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static valueType[] getPageSort<valueType>
            (this valueType[] array, func<valueType, short> getKey, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return algorithm.quickSort.GetRangeSort(array, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static collection<short> getPageSort
            (this short[] array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return algorithm.quickSort.GetRangeSort(array, page.SkipCount, page.CurrentPageSize);
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 单向动态数组扩展
    /// </summary>
    public static partial class list
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static collection<short> rangeSort
            (this list<short> list, int skipCount, int getCount)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.RangeSort(list.Unsafer.Array, 0, list.Count, skipCount, getCount);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static collection<short> getRangeSort
            (this list<short> list, int skipCount, int getCount)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.GetRangeSort(list.Unsafer.Array, 0, list.Count, skipCount, getCount);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSort<valueType>
            (this list<valueType> list, func<valueType, short> getKey, int skipCount, int getCount)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.GetRangeSort
                    (list.Unsafer.Array, 0, list.Count, getKey, skipCount, getCount);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static collection<short> rangeSort
            (this list<short> list, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.RangeSort
                    (list.Unsafer.Array, range.SkipCount, count, skipCount, getCount);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static collection<short> getRangeSort
            (this list<short> list, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.GetRangeSort
                    (list.Unsafer.Array, range.SkipCount, count, skipCount, getCount);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSort<valueType>
            (this list<valueType> list, int startIndex, int count, func<valueType, short> getKey
            , int skipCount, int getCount)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.GetRangeSort
                    (list.Unsafer.Array, range.SkipCount, count, getKey, skipCount, getCount);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static collection<short> pageSort
            (this list<short> list, int pageSize, int currentPage)
        {
            array.page page = new array.page(list.count(), pageSize, currentPage);
            int count = page.CurrentPageSize;
            if (count != 0)
            {
                return algorithm.quickSort.RangeSort(list.Unsafer.Array, page.SkipCount, count);
            }
            return null;
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static collection<short> getPageSort
            (this list<short> list, int pageSize, int currentPage)
        {
            array.page page = new array.page(list.count(), pageSize, currentPage);
            int count = page.CurrentPageSize;
            if (count != 0)
            {
                return algorithm.quickSort.GetRangeSort(list.Unsafer.Array, page.SkipCount, count);
            }
            return null;
        }
    }
}
namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 范围排序器(一般用于获取分页)
        /// </summary>
        private unsafe struct shortRangeSorterDesc
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public short* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public short* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(short* startIndex, short* endIndex)
            {
                do
                {
                    short leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue < rightValue)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    short* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    short value = *averageIndex;
                    if (leftValue < value)
                    {
                        if (leftValue < rightValue)
                        {
                            *rightIndex = leftValue;
                            if (value < rightValue) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = value;
                                *averageIndex = value = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = leftValue;
                        }
                    }
                    else
                    {
                        if (value < rightValue)
                        {
                            *rightIndex = value;
                            if (leftValue < rightValue)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = value = leftValue;
                            }
                            else *averageIndex = value = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    do
                    {
                        while (*leftIndex > value) ++leftIndex;
                        while (value > *rightIndex) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static collection<short> RangeSortDesc
            (short[] values, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (short* valueFixed = values)
                {
                    new shortRangeSorterDesc
                    {
                        SkipCount = valueFixed + range.SkipCount,
                        GetEndIndex = valueFixed + range.EndIndex - 1
                    }.Sort(valueFixed, valueFixed + values.Length - 1);
                }
                return new collection<short>(values, range.SkipCount, getCount, true);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static collection<short> GetRangeSortDesc
            (short[] values, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                short[] newValues = new short[values.Length];
                Buffer.BlockCopy(values, 0, newValues, 0, values.Length * sizeof(short));
                fixed (short* newValueFixed = newValues, valueFixed = values)
                {
                    new shortRangeSorterDesc
                    {
                        SkipCount = newValueFixed + range.SkipCount,
                        GetEndIndex = newValueFixed + range.EndIndex - 1
                    }.Sort(newValueFixed, newValueFixed + values.Length - 1);
                }
                return new collection<short>(newValues, range.SkipCount, getCount, true);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static collection<short> RangeSortDesc
            (short[] values, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    skipCount = range.SkipCount + getRange.SkipCount;
                    fixed (short* valueFixed = values)
                    {
                        short* skip = valueFixed + skipCount, start = valueFixed + range.SkipCount;
                        new shortRangeSorterDesc
                        {
                            SkipCount = skip,
                            GetEndIndex = skip + getCount - 1
                        }.Sort(start, start + --count);
                    }
                    return new collection<short>(values, skipCount, getCount, true);
                }
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static collection<short> GetRangeSortDesc
            (short[] values, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    short[] newValues = new short[count];
                    Buffer.BlockCopy(values, range.SkipCount * sizeof(short), newValues, 0, count * sizeof(short));
                    fixed (short* newValueFixed = newValues, valueFixed = values)
                    {
                        new shortRangeSorterDesc
                        {
                            SkipCount = newValueFixed + getRange.SkipCount,
                            GetEndIndex = newValueFixed + getRange.SkipCount + getCount - 1
                        }.Sort(newValueFixed, newValueFixed + count - 1);
                    }
                    return new collection<short>(newValues, getRange.SkipCount, getCount, true);
                }
            }
            return null;
        }

        /// <summary>
        /// 索引范围排序器
        /// </summary>
        private unsafe struct shortRangeIndexSorterDesc
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public shortSortIndex* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public shortSortIndex* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(shortSortIndex* startIndex, shortSortIndex* endIndex)
            {
                do
                {
                    shortSortIndex leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue.Value < rightValue.Value)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    shortSortIndex* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    shortSortIndex indexValue = *averageIndex;
                    if (leftValue.Value < indexValue.Value)
                    {
                        if (leftValue.Value < rightValue.Value)
                        {
                            *rightIndex = leftValue;
                            if (indexValue.Value < rightValue.Value) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = indexValue;
                                *averageIndex = indexValue = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = leftValue;
                        }
                    }
                    else
                    {
                        if (indexValue.Value < rightValue.Value)
                        {
                            *rightIndex = indexValue;
                            if (leftValue.Value < rightValue.Value)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = indexValue = leftValue;
                            }
                            else *averageIndex = indexValue = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    short value = indexValue.Value;
                    do
                    {
                        while ((*leftIndex).Value > value) ++leftIndex;
                        while (value > (*rightIndex).Value) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSortDesc<valueType>
            (valueType[] values, func<valueType, short> getKey, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                if (values.Length > (config.pub.Default.StreamBufferLength >> 4))
                {
                    shortSortIndex[] indexs = new shortSortIndex[values.Length];
                    fixed (shortSortIndex* fixedIndex = indexs)
                    {
                        return getRangeSortDesc(values, getKey, range.SkipCount, getCount, fixedIndex);
                    }
                }
                else
                {
                    shortSortIndex* fixedIndex = stackalloc shortSortIndex[values.Length];
                    return getRangeSortDesc(values, getKey, range.SkipCount, getCount, fixedIndex);
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSortDesc<valueType>
            (valueType[] values, func<valueType, short> getKey, int skipCount, int getCount
            , shortSortIndex* fixedIndex)
        {
            shortSortIndex* writeIndex = fixedIndex;
            for (int index = 0; index != values.Length; ++index)
            {
                *writeIndex++ = new shortSortIndex { Value = getKey(values[index]), Index = index };
            }
            return getRangeSortDesc(values, skipCount, getCount, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSortDesc<valueType>
            (valueType[] values, int skipCount, int getCount, shortSortIndex* fixedIndex)
        {
            new shortRangeIndexSorterDesc
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + values.Length - 1);
            valueType[] newValues = new valueType[getCount];
            shortSortIndex* writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="indexs">排序索引</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSortDesc<valueType>
            (valueType[] values, shortSortIndex[] indexs, int skipCount, int getCount)
        {
            if (values.length() != indexs.length()) log.Default.Throw(log.exceptionType.IndexOutOfRange);
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (shortSortIndex* fixedIndex = indexs) return getRangeSortDesc(values, skipCount, getCount, fixedIndex);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSortDesc<valueType>
            (valueType[] values, int startIndex, int count, func<valueType, short> getKey, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                    if (values.Length > (config.pub.Default.StreamBufferLength >> 4))
                    {
                        shortSortIndex[] indexs = new shortSortIndex[count];
                        fixed (shortSortIndex* fixedIndex = indexs)
                        {
                            return getRangeSortDesc
                                (values, range.SkipCount, count, getKey, getRange.SkipCount, getCount, fixedIndex);
                        }
                    }
                    else
                    {
                        shortSortIndex* fixedIndex = stackalloc shortSortIndex[count];
                        return getRangeSortDesc
                            (values, range.SkipCount, count, getKey, getRange.SkipCount, getCount, fixedIndex);
                    }
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSortDesc<valueType>
            (valueType[] values, int startIndex, int count, func<valueType, short> getKey, int skipCount, int getCount
            , shortSortIndex* fixedIndex)
        {
            shortSortIndex* writeIndex = fixedIndex;
            for (int index = startIndex, endIndex = startIndex + count; index != endIndex; ++index)
            {
                *writeIndex++ = new shortSortIndex { Value = getKey(values[index]), Index = index };
            }
            new shortRangeIndexSorterDesc
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + count - 1);
            valueType[] newValues = new valueType[getCount];
            writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static collection<short> rangeSortDesc
            (this short[] array, int skipCount, int getCount)
        {
            return algorithm.quickSort.RangeSortDesc(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static collection<short> getRangeSortDesc
            (this short[] array, int skipCount, int getCount)
        {
            return algorithm.quickSort.GetRangeSortDesc(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSortDesc<valueType>
            (this valueType[] array, func<valueType, short> getKey, int skipCount, int getCount)
        {
            return algorithm.quickSort.GetRangeSortDesc(array, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static collection<short> rangeSortDesc
            (this short[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return algorithm.quickSort.RangeSortDesc(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static collection<short> getRangeSortDesc
            (this short[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return algorithm.quickSort.GetRangeSortDesc(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSortDesc<valueType>
            (this valueType[] array, int startIndex, int count, func<valueType, short> getKey, int skipCount, int getCount)
        {
            return algorithm.quickSort.GetRangeSortDesc(array, startIndex, count, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static collection<short> pageSortDesc
            (this short[] array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return algorithm.quickSort.RangeSortDesc(array, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static valueType[] getPageSortDesc<valueType>
            (this valueType[] array, func<valueType, short> getKey, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return algorithm.quickSort.GetRangeSortDesc(array, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static collection<short> getPageSortDesc
            (this short[] array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return algorithm.quickSort.GetRangeSortDesc(array, page.SkipCount, page.CurrentPageSize);
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 单向动态数组扩展
    /// </summary>
    public static partial class list
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static collection<short> rangeSortDesc
            (this list<short> list, int skipCount, int getCount)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.RangeSortDesc(list.Unsafer.Array, 0, list.Count, skipCount, getCount);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static collection<short> getRangeSortDesc
            (this list<short> list, int skipCount, int getCount)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.GetRangeSortDesc(list.Unsafer.Array, 0, list.Count, skipCount, getCount);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSortDesc<valueType>
            (this list<valueType> list, func<valueType, short> getKey, int skipCount, int getCount)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.GetRangeSortDesc
                    (list.Unsafer.Array, 0, list.Count, getKey, skipCount, getCount);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static collection<short> rangeSortDesc
            (this list<short> list, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.RangeSortDesc
                    (list.Unsafer.Array, range.SkipCount, count, skipCount, getCount);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static collection<short> getRangeSortDesc
            (this list<short> list, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.GetRangeSortDesc
                    (list.Unsafer.Array, range.SkipCount, count, skipCount, getCount);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSortDesc<valueType>
            (this list<valueType> list, int startIndex, int count, func<valueType, short> getKey
            , int skipCount, int getCount)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.GetRangeSortDesc
                    (list.Unsafer.Array, range.SkipCount, count, getKey, skipCount, getCount);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static collection<short> pageSortDesc
            (this list<short> list, int pageSize, int currentPage)
        {
            array.page page = new array.page(list.count(), pageSize, currentPage);
            int count = page.CurrentPageSize;
            if (count != 0)
            {
                return algorithm.quickSort.RangeSortDesc(list.Unsafer.Array, page.SkipCount, count);
            }
            return null;
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static collection<short> getPageSortDesc
            (this list<short> list, int pageSize, int currentPage)
        {
            array.page page = new array.page(list.count(), pageSize, currentPage);
            int count = page.CurrentPageSize;
            if (count != 0)
            {
                return algorithm.quickSort.GetRangeSortDesc(list.Unsafer.Array, page.SkipCount, count);
            }
            return null;
        }
    }
}
namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 范围排序器(一般用于获取分页)
        /// </summary>
        private unsafe struct byteRangeSorter
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public byte* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public byte* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(byte* startIndex, byte* endIndex)
            {
                do
                {
                    byte leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue > rightValue)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    byte* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    byte value = *averageIndex;
                    if (leftValue > value)
                    {
                        if (leftValue > rightValue)
                        {
                            *rightIndex = leftValue;
                            if (value > rightValue) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = value;
                                *averageIndex = value = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = leftValue;
                        }
                    }
                    else
                    {
                        if (value > rightValue)
                        {
                            *rightIndex = value;
                            if (leftValue > rightValue)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = value = leftValue;
                            }
                            else *averageIndex = value = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    do
                    {
                        while (*leftIndex < value) ++leftIndex;
                        while (value < *rightIndex) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static collection<byte> RangeSort
            (byte[] values, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (byte* valueFixed = values)
                {
                    new byteRangeSorter
                    {
                        SkipCount = valueFixed + range.SkipCount,
                        GetEndIndex = valueFixed + range.EndIndex - 1
                    }.Sort(valueFixed, valueFixed + values.Length - 1);
                }
                return new collection<byte>(values, range.SkipCount, getCount, true);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static collection<byte> GetRangeSort
            (byte[] values, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                byte[] newValues = new byte[values.Length];
                Buffer.BlockCopy(values, 0, newValues, 0, values.Length * sizeof(byte));
                fixed (byte* newValueFixed = newValues, valueFixed = values)
                {
                    new byteRangeSorter
                    {
                        SkipCount = newValueFixed + range.SkipCount,
                        GetEndIndex = newValueFixed + range.EndIndex - 1
                    }.Sort(newValueFixed, newValueFixed + values.Length - 1);
                }
                return new collection<byte>(newValues, range.SkipCount, getCount, true);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static collection<byte> RangeSort
            (byte[] values, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    skipCount = range.SkipCount + getRange.SkipCount;
                    fixed (byte* valueFixed = values)
                    {
                        byte* skip = valueFixed + skipCount, start = valueFixed + range.SkipCount;
                        new byteRangeSorter
                        {
                            SkipCount = skip,
                            GetEndIndex = skip + getCount - 1
                        }.Sort(start, start + --count);
                    }
                    return new collection<byte>(values, skipCount, getCount, true);
                }
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static collection<byte> GetRangeSort
            (byte[] values, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    byte[] newValues = new byte[count];
                    Buffer.BlockCopy(values, range.SkipCount * sizeof(byte), newValues, 0, count * sizeof(byte));
                    fixed (byte* newValueFixed = newValues, valueFixed = values)
                    {
                        new byteRangeSorter
                        {
                            SkipCount = newValueFixed + getRange.SkipCount,
                            GetEndIndex = newValueFixed + getRange.SkipCount + getCount - 1
                        }.Sort(newValueFixed, newValueFixed + count - 1);
                    }
                    return new collection<byte>(newValues, getRange.SkipCount, getCount, true);
                }
            }
            return null;
        }

        /// <summary>
        /// 索引范围排序器
        /// </summary>
        private unsafe struct byteRangeIndexSorter
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public byteSortIndex* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public byteSortIndex* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(byteSortIndex* startIndex, byteSortIndex* endIndex)
            {
                do
                {
                    byteSortIndex leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue.Value > rightValue.Value)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    byteSortIndex* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    byteSortIndex indexValue = *averageIndex;
                    if (leftValue.Value > indexValue.Value)
                    {
                        if (leftValue.Value > rightValue.Value)
                        {
                            *rightIndex = leftValue;
                            if (indexValue.Value > rightValue.Value) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = indexValue;
                                *averageIndex = indexValue = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = leftValue;
                        }
                    }
                    else
                    {
                        if (indexValue.Value > rightValue.Value)
                        {
                            *rightIndex = indexValue;
                            if (leftValue.Value > rightValue.Value)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = indexValue = leftValue;
                            }
                            else *averageIndex = indexValue = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    byte value = indexValue.Value;
                    do
                    {
                        while ((*leftIndex).Value < value) ++leftIndex;
                        while (value < (*rightIndex).Value) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSort<valueType>
            (valueType[] values, func<valueType, byte> getKey, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                if (values.Length > (config.pub.Default.StreamBufferLength >> 4))
                {
                    byteSortIndex[] indexs = new byteSortIndex[values.Length];
                    fixed (byteSortIndex* fixedIndex = indexs)
                    {
                        return getRangeSort(values, getKey, range.SkipCount, getCount, fixedIndex);
                    }
                }
                else
                {
                    byteSortIndex* fixedIndex = stackalloc byteSortIndex[values.Length];
                    return getRangeSort(values, getKey, range.SkipCount, getCount, fixedIndex);
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSort<valueType>
            (valueType[] values, func<valueType, byte> getKey, int skipCount, int getCount
            , byteSortIndex* fixedIndex)
        {
            byteSortIndex* writeIndex = fixedIndex;
            for (int index = 0; index != values.Length; ++index)
            {
                *writeIndex++ = new byteSortIndex { Value = getKey(values[index]), Index = index };
            }
            return getRangeSort(values, skipCount, getCount, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSort<valueType>
            (valueType[] values, int skipCount, int getCount, byteSortIndex* fixedIndex)
        {
            new byteRangeIndexSorter
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + values.Length - 1);
            valueType[] newValues = new valueType[getCount];
            byteSortIndex* writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="indexs">排序索引</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSort<valueType>
            (valueType[] values, byteSortIndex[] indexs, int skipCount, int getCount)
        {
            if (values.length() != indexs.length()) log.Default.Throw(log.exceptionType.IndexOutOfRange);
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (byteSortIndex* fixedIndex = indexs) return getRangeSort(values, skipCount, getCount, fixedIndex);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSort<valueType>
            (valueType[] values, int startIndex, int count, func<valueType, byte> getKey, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                    if (values.Length > (config.pub.Default.StreamBufferLength >> 4))
                    {
                        byteSortIndex[] indexs = new byteSortIndex[count];
                        fixed (byteSortIndex* fixedIndex = indexs)
                        {
                            return getRangeSort
                                (values, range.SkipCount, count, getKey, getRange.SkipCount, getCount, fixedIndex);
                        }
                    }
                    else
                    {
                        byteSortIndex* fixedIndex = stackalloc byteSortIndex[count];
                        return getRangeSort
                            (values, range.SkipCount, count, getKey, getRange.SkipCount, getCount, fixedIndex);
                    }
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSort<valueType>
            (valueType[] values, int startIndex, int count, func<valueType, byte> getKey, int skipCount, int getCount
            , byteSortIndex* fixedIndex)
        {
            byteSortIndex* writeIndex = fixedIndex;
            for (int index = startIndex, endIndex = startIndex + count; index != endIndex; ++index)
            {
                *writeIndex++ = new byteSortIndex { Value = getKey(values[index]), Index = index };
            }
            new byteRangeIndexSorter
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + count - 1);
            valueType[] newValues = new valueType[getCount];
            writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static collection<byte> rangeSort
            (this byte[] array, int skipCount, int getCount)
        {
            return algorithm.quickSort.RangeSort(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static collection<byte> getRangeSort
            (this byte[] array, int skipCount, int getCount)
        {
            return algorithm.quickSort.GetRangeSort(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSort<valueType>
            (this valueType[] array, func<valueType, byte> getKey, int skipCount, int getCount)
        {
            return algorithm.quickSort.GetRangeSort(array, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static collection<byte> rangeSort
            (this byte[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return algorithm.quickSort.RangeSort(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static collection<byte> getRangeSort
            (this byte[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return algorithm.quickSort.GetRangeSort(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSort<valueType>
            (this valueType[] array, int startIndex, int count, func<valueType, byte> getKey, int skipCount, int getCount)
        {
            return algorithm.quickSort.GetRangeSort(array, startIndex, count, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static collection<byte> pageSort
            (this byte[] array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return algorithm.quickSort.RangeSort(array, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static valueType[] getPageSort<valueType>
            (this valueType[] array, func<valueType, byte> getKey, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return algorithm.quickSort.GetRangeSort(array, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static collection<byte> getPageSort
            (this byte[] array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return algorithm.quickSort.GetRangeSort(array, page.SkipCount, page.CurrentPageSize);
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 单向动态数组扩展
    /// </summary>
    public static partial class list
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static collection<byte> rangeSort
            (this list<byte> list, int skipCount, int getCount)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.RangeSort(list.Unsafer.Array, 0, list.Count, skipCount, getCount);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static collection<byte> getRangeSort
            (this list<byte> list, int skipCount, int getCount)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.GetRangeSort(list.Unsafer.Array, 0, list.Count, skipCount, getCount);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSort<valueType>
            (this list<valueType> list, func<valueType, byte> getKey, int skipCount, int getCount)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.GetRangeSort
                    (list.Unsafer.Array, 0, list.Count, getKey, skipCount, getCount);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static collection<byte> rangeSort
            (this list<byte> list, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.RangeSort
                    (list.Unsafer.Array, range.SkipCount, count, skipCount, getCount);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static collection<byte> getRangeSort
            (this list<byte> list, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.GetRangeSort
                    (list.Unsafer.Array, range.SkipCount, count, skipCount, getCount);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSort<valueType>
            (this list<valueType> list, int startIndex, int count, func<valueType, byte> getKey
            , int skipCount, int getCount)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.GetRangeSort
                    (list.Unsafer.Array, range.SkipCount, count, getKey, skipCount, getCount);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static collection<byte> pageSort
            (this list<byte> list, int pageSize, int currentPage)
        {
            array.page page = new array.page(list.count(), pageSize, currentPage);
            int count = page.CurrentPageSize;
            if (count != 0)
            {
                return algorithm.quickSort.RangeSort(list.Unsafer.Array, page.SkipCount, count);
            }
            return null;
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static collection<byte> getPageSort
            (this list<byte> list, int pageSize, int currentPage)
        {
            array.page page = new array.page(list.count(), pageSize, currentPage);
            int count = page.CurrentPageSize;
            if (count != 0)
            {
                return algorithm.quickSort.GetRangeSort(list.Unsafer.Array, page.SkipCount, count);
            }
            return null;
        }
    }
}
namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 范围排序器(一般用于获取分页)
        /// </summary>
        private unsafe struct byteRangeSorterDesc
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public byte* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public byte* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(byte* startIndex, byte* endIndex)
            {
                do
                {
                    byte leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue < rightValue)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    byte* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    byte value = *averageIndex;
                    if (leftValue < value)
                    {
                        if (leftValue < rightValue)
                        {
                            *rightIndex = leftValue;
                            if (value < rightValue) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = value;
                                *averageIndex = value = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = leftValue;
                        }
                    }
                    else
                    {
                        if (value < rightValue)
                        {
                            *rightIndex = value;
                            if (leftValue < rightValue)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = value = leftValue;
                            }
                            else *averageIndex = value = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    do
                    {
                        while (*leftIndex > value) ++leftIndex;
                        while (value > *rightIndex) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static collection<byte> RangeSortDesc
            (byte[] values, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (byte* valueFixed = values)
                {
                    new byteRangeSorterDesc
                    {
                        SkipCount = valueFixed + range.SkipCount,
                        GetEndIndex = valueFixed + range.EndIndex - 1
                    }.Sort(valueFixed, valueFixed + values.Length - 1);
                }
                return new collection<byte>(values, range.SkipCount, getCount, true);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static collection<byte> GetRangeSortDesc
            (byte[] values, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                byte[] newValues = new byte[values.Length];
                Buffer.BlockCopy(values, 0, newValues, 0, values.Length * sizeof(byte));
                fixed (byte* newValueFixed = newValues, valueFixed = values)
                {
                    new byteRangeSorterDesc
                    {
                        SkipCount = newValueFixed + range.SkipCount,
                        GetEndIndex = newValueFixed + range.EndIndex - 1
                    }.Sort(newValueFixed, newValueFixed + values.Length - 1);
                }
                return new collection<byte>(newValues, range.SkipCount, getCount, true);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static collection<byte> RangeSortDesc
            (byte[] values, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    skipCount = range.SkipCount + getRange.SkipCount;
                    fixed (byte* valueFixed = values)
                    {
                        byte* skip = valueFixed + skipCount, start = valueFixed + range.SkipCount;
                        new byteRangeSorterDesc
                        {
                            SkipCount = skip,
                            GetEndIndex = skip + getCount - 1
                        }.Sort(start, start + --count);
                    }
                    return new collection<byte>(values, skipCount, getCount, true);
                }
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static collection<byte> GetRangeSortDesc
            (byte[] values, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    byte[] newValues = new byte[count];
                    Buffer.BlockCopy(values, range.SkipCount * sizeof(byte), newValues, 0, count * sizeof(byte));
                    fixed (byte* newValueFixed = newValues, valueFixed = values)
                    {
                        new byteRangeSorterDesc
                        {
                            SkipCount = newValueFixed + getRange.SkipCount,
                            GetEndIndex = newValueFixed + getRange.SkipCount + getCount - 1
                        }.Sort(newValueFixed, newValueFixed + count - 1);
                    }
                    return new collection<byte>(newValues, getRange.SkipCount, getCount, true);
                }
            }
            return null;
        }

        /// <summary>
        /// 索引范围排序器
        /// </summary>
        private unsafe struct byteRangeIndexSorterDesc
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public byteSortIndex* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public byteSortIndex* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(byteSortIndex* startIndex, byteSortIndex* endIndex)
            {
                do
                {
                    byteSortIndex leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue.Value < rightValue.Value)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    byteSortIndex* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    byteSortIndex indexValue = *averageIndex;
                    if (leftValue.Value < indexValue.Value)
                    {
                        if (leftValue.Value < rightValue.Value)
                        {
                            *rightIndex = leftValue;
                            if (indexValue.Value < rightValue.Value) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = indexValue;
                                *averageIndex = indexValue = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = leftValue;
                        }
                    }
                    else
                    {
                        if (indexValue.Value < rightValue.Value)
                        {
                            *rightIndex = indexValue;
                            if (leftValue.Value < rightValue.Value)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = indexValue = leftValue;
                            }
                            else *averageIndex = indexValue = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    byte value = indexValue.Value;
                    do
                    {
                        while ((*leftIndex).Value > value) ++leftIndex;
                        while (value > (*rightIndex).Value) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSortDesc<valueType>
            (valueType[] values, func<valueType, byte> getKey, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                if (values.Length > (config.pub.Default.StreamBufferLength >> 4))
                {
                    byteSortIndex[] indexs = new byteSortIndex[values.Length];
                    fixed (byteSortIndex* fixedIndex = indexs)
                    {
                        return getRangeSortDesc(values, getKey, range.SkipCount, getCount, fixedIndex);
                    }
                }
                else
                {
                    byteSortIndex* fixedIndex = stackalloc byteSortIndex[values.Length];
                    return getRangeSortDesc(values, getKey, range.SkipCount, getCount, fixedIndex);
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSortDesc<valueType>
            (valueType[] values, func<valueType, byte> getKey, int skipCount, int getCount
            , byteSortIndex* fixedIndex)
        {
            byteSortIndex* writeIndex = fixedIndex;
            for (int index = 0; index != values.Length; ++index)
            {
                *writeIndex++ = new byteSortIndex { Value = getKey(values[index]), Index = index };
            }
            return getRangeSortDesc(values, skipCount, getCount, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSortDesc<valueType>
            (valueType[] values, int skipCount, int getCount, byteSortIndex* fixedIndex)
        {
            new byteRangeIndexSorterDesc
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + values.Length - 1);
            valueType[] newValues = new valueType[getCount];
            byteSortIndex* writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="indexs">排序索引</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSortDesc<valueType>
            (valueType[] values, byteSortIndex[] indexs, int skipCount, int getCount)
        {
            if (values.length() != indexs.length()) log.Default.Throw(log.exceptionType.IndexOutOfRange);
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (byteSortIndex* fixedIndex = indexs) return getRangeSortDesc(values, skipCount, getCount, fixedIndex);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSortDesc<valueType>
            (valueType[] values, int startIndex, int count, func<valueType, byte> getKey, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                    if (values.Length > (config.pub.Default.StreamBufferLength >> 4))
                    {
                        byteSortIndex[] indexs = new byteSortIndex[count];
                        fixed (byteSortIndex* fixedIndex = indexs)
                        {
                            return getRangeSortDesc
                                (values, range.SkipCount, count, getKey, getRange.SkipCount, getCount, fixedIndex);
                        }
                    }
                    else
                    {
                        byteSortIndex* fixedIndex = stackalloc byteSortIndex[count];
                        return getRangeSortDesc
                            (values, range.SkipCount, count, getKey, getRange.SkipCount, getCount, fixedIndex);
                    }
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSortDesc<valueType>
            (valueType[] values, int startIndex, int count, func<valueType, byte> getKey, int skipCount, int getCount
            , byteSortIndex* fixedIndex)
        {
            byteSortIndex* writeIndex = fixedIndex;
            for (int index = startIndex, endIndex = startIndex + count; index != endIndex; ++index)
            {
                *writeIndex++ = new byteSortIndex { Value = getKey(values[index]), Index = index };
            }
            new byteRangeIndexSorterDesc
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + count - 1);
            valueType[] newValues = new valueType[getCount];
            writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static collection<byte> rangeSortDesc
            (this byte[] array, int skipCount, int getCount)
        {
            return algorithm.quickSort.RangeSortDesc(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static collection<byte> getRangeSortDesc
            (this byte[] array, int skipCount, int getCount)
        {
            return algorithm.quickSort.GetRangeSortDesc(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSortDesc<valueType>
            (this valueType[] array, func<valueType, byte> getKey, int skipCount, int getCount)
        {
            return algorithm.quickSort.GetRangeSortDesc(array, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static collection<byte> rangeSortDesc
            (this byte[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return algorithm.quickSort.RangeSortDesc(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static collection<byte> getRangeSortDesc
            (this byte[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return algorithm.quickSort.GetRangeSortDesc(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSortDesc<valueType>
            (this valueType[] array, int startIndex, int count, func<valueType, byte> getKey, int skipCount, int getCount)
        {
            return algorithm.quickSort.GetRangeSortDesc(array, startIndex, count, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static collection<byte> pageSortDesc
            (this byte[] array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return algorithm.quickSort.RangeSortDesc(array, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static valueType[] getPageSortDesc<valueType>
            (this valueType[] array, func<valueType, byte> getKey, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return algorithm.quickSort.GetRangeSortDesc(array, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static collection<byte> getPageSortDesc
            (this byte[] array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return algorithm.quickSort.GetRangeSortDesc(array, page.SkipCount, page.CurrentPageSize);
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 单向动态数组扩展
    /// </summary>
    public static partial class list
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static collection<byte> rangeSortDesc
            (this list<byte> list, int skipCount, int getCount)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.RangeSortDesc(list.Unsafer.Array, 0, list.Count, skipCount, getCount);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static collection<byte> getRangeSortDesc
            (this list<byte> list, int skipCount, int getCount)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.GetRangeSortDesc(list.Unsafer.Array, 0, list.Count, skipCount, getCount);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSortDesc<valueType>
            (this list<valueType> list, func<valueType, byte> getKey, int skipCount, int getCount)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.GetRangeSortDesc
                    (list.Unsafer.Array, 0, list.Count, getKey, skipCount, getCount);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static collection<byte> rangeSortDesc
            (this list<byte> list, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.RangeSortDesc
                    (list.Unsafer.Array, range.SkipCount, count, skipCount, getCount);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static collection<byte> getRangeSortDesc
            (this list<byte> list, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.GetRangeSortDesc
                    (list.Unsafer.Array, range.SkipCount, count, skipCount, getCount);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSortDesc<valueType>
            (this list<valueType> list, int startIndex, int count, func<valueType, byte> getKey
            , int skipCount, int getCount)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.GetRangeSortDesc
                    (list.Unsafer.Array, range.SkipCount, count, getKey, skipCount, getCount);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static collection<byte> pageSortDesc
            (this list<byte> list, int pageSize, int currentPage)
        {
            array.page page = new array.page(list.count(), pageSize, currentPage);
            int count = page.CurrentPageSize;
            if (count != 0)
            {
                return algorithm.quickSort.RangeSortDesc(list.Unsafer.Array, page.SkipCount, count);
            }
            return null;
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static collection<byte> getPageSortDesc
            (this list<byte> list, int pageSize, int currentPage)
        {
            array.page page = new array.page(list.count(), pageSize, currentPage);
            int count = page.CurrentPageSize;
            if (count != 0)
            {
                return algorithm.quickSort.GetRangeSortDesc(list.Unsafer.Array, page.SkipCount, count);
            }
            return null;
        }
    }
}
namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 范围排序器(一般用于获取分页)
        /// </summary>
        private unsafe struct sbyteRangeSorter
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public sbyte* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public sbyte* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(sbyte* startIndex, sbyte* endIndex)
            {
                do
                {
                    sbyte leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue > rightValue)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    sbyte* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    sbyte value = *averageIndex;
                    if (leftValue > value)
                    {
                        if (leftValue > rightValue)
                        {
                            *rightIndex = leftValue;
                            if (value > rightValue) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = value;
                                *averageIndex = value = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = leftValue;
                        }
                    }
                    else
                    {
                        if (value > rightValue)
                        {
                            *rightIndex = value;
                            if (leftValue > rightValue)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = value = leftValue;
                            }
                            else *averageIndex = value = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    do
                    {
                        while (*leftIndex < value) ++leftIndex;
                        while (value < *rightIndex) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static collection<sbyte> RangeSort
            (sbyte[] values, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (sbyte* valueFixed = values)
                {
                    new sbyteRangeSorter
                    {
                        SkipCount = valueFixed + range.SkipCount,
                        GetEndIndex = valueFixed + range.EndIndex - 1
                    }.Sort(valueFixed, valueFixed + values.Length - 1);
                }
                return new collection<sbyte>(values, range.SkipCount, getCount, true);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static collection<sbyte> GetRangeSort
            (sbyte[] values, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                sbyte[] newValues = new sbyte[values.Length];
                Buffer.BlockCopy(values, 0, newValues, 0, values.Length * sizeof(sbyte));
                fixed (sbyte* newValueFixed = newValues, valueFixed = values)
                {
                    new sbyteRangeSorter
                    {
                        SkipCount = newValueFixed + range.SkipCount,
                        GetEndIndex = newValueFixed + range.EndIndex - 1
                    }.Sort(newValueFixed, newValueFixed + values.Length - 1);
                }
                return new collection<sbyte>(newValues, range.SkipCount, getCount, true);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static collection<sbyte> RangeSort
            (sbyte[] values, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    skipCount = range.SkipCount + getRange.SkipCount;
                    fixed (sbyte* valueFixed = values)
                    {
                        sbyte* skip = valueFixed + skipCount, start = valueFixed + range.SkipCount;
                        new sbyteRangeSorter
                        {
                            SkipCount = skip,
                            GetEndIndex = skip + getCount - 1
                        }.Sort(start, start + --count);
                    }
                    return new collection<sbyte>(values, skipCount, getCount, true);
                }
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static collection<sbyte> GetRangeSort
            (sbyte[] values, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    sbyte[] newValues = new sbyte[count];
                    Buffer.BlockCopy(values, range.SkipCount * sizeof(sbyte), newValues, 0, count * sizeof(sbyte));
                    fixed (sbyte* newValueFixed = newValues, valueFixed = values)
                    {
                        new sbyteRangeSorter
                        {
                            SkipCount = newValueFixed + getRange.SkipCount,
                            GetEndIndex = newValueFixed + getRange.SkipCount + getCount - 1
                        }.Sort(newValueFixed, newValueFixed + count - 1);
                    }
                    return new collection<sbyte>(newValues, getRange.SkipCount, getCount, true);
                }
            }
            return null;
        }

        /// <summary>
        /// 索引范围排序器
        /// </summary>
        private unsafe struct sbyteRangeIndexSorter
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public sbyteSortIndex* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public sbyteSortIndex* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(sbyteSortIndex* startIndex, sbyteSortIndex* endIndex)
            {
                do
                {
                    sbyteSortIndex leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue.Value > rightValue.Value)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    sbyteSortIndex* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    sbyteSortIndex indexValue = *averageIndex;
                    if (leftValue.Value > indexValue.Value)
                    {
                        if (leftValue.Value > rightValue.Value)
                        {
                            *rightIndex = leftValue;
                            if (indexValue.Value > rightValue.Value) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = indexValue;
                                *averageIndex = indexValue = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = leftValue;
                        }
                    }
                    else
                    {
                        if (indexValue.Value > rightValue.Value)
                        {
                            *rightIndex = indexValue;
                            if (leftValue.Value > rightValue.Value)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = indexValue = leftValue;
                            }
                            else *averageIndex = indexValue = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    sbyte value = indexValue.Value;
                    do
                    {
                        while ((*leftIndex).Value < value) ++leftIndex;
                        while (value < (*rightIndex).Value) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSort<valueType>
            (valueType[] values, func<valueType, sbyte> getKey, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                if (values.Length > (config.pub.Default.StreamBufferLength >> 4))
                {
                    sbyteSortIndex[] indexs = new sbyteSortIndex[values.Length];
                    fixed (sbyteSortIndex* fixedIndex = indexs)
                    {
                        return getRangeSort(values, getKey, range.SkipCount, getCount, fixedIndex);
                    }
                }
                else
                {
                    sbyteSortIndex* fixedIndex = stackalloc sbyteSortIndex[values.Length];
                    return getRangeSort(values, getKey, range.SkipCount, getCount, fixedIndex);
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSort<valueType>
            (valueType[] values, func<valueType, sbyte> getKey, int skipCount, int getCount
            , sbyteSortIndex* fixedIndex)
        {
            sbyteSortIndex* writeIndex = fixedIndex;
            for (int index = 0; index != values.Length; ++index)
            {
                *writeIndex++ = new sbyteSortIndex { Value = getKey(values[index]), Index = index };
            }
            return getRangeSort(values, skipCount, getCount, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSort<valueType>
            (valueType[] values, int skipCount, int getCount, sbyteSortIndex* fixedIndex)
        {
            new sbyteRangeIndexSorter
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + values.Length - 1);
            valueType[] newValues = new valueType[getCount];
            sbyteSortIndex* writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="indexs">排序索引</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSort<valueType>
            (valueType[] values, sbyteSortIndex[] indexs, int skipCount, int getCount)
        {
            if (values.length() != indexs.length()) log.Default.Throw(log.exceptionType.IndexOutOfRange);
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (sbyteSortIndex* fixedIndex = indexs) return getRangeSort(values, skipCount, getCount, fixedIndex);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSort<valueType>
            (valueType[] values, int startIndex, int count, func<valueType, sbyte> getKey, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                    if (values.Length > (config.pub.Default.StreamBufferLength >> 4))
                    {
                        sbyteSortIndex[] indexs = new sbyteSortIndex[count];
                        fixed (sbyteSortIndex* fixedIndex = indexs)
                        {
                            return getRangeSort
                                (values, range.SkipCount, count, getKey, getRange.SkipCount, getCount, fixedIndex);
                        }
                    }
                    else
                    {
                        sbyteSortIndex* fixedIndex = stackalloc sbyteSortIndex[count];
                        return getRangeSort
                            (values, range.SkipCount, count, getKey, getRange.SkipCount, getCount, fixedIndex);
                    }
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSort<valueType>
            (valueType[] values, int startIndex, int count, func<valueType, sbyte> getKey, int skipCount, int getCount
            , sbyteSortIndex* fixedIndex)
        {
            sbyteSortIndex* writeIndex = fixedIndex;
            for (int index = startIndex, endIndex = startIndex + count; index != endIndex; ++index)
            {
                *writeIndex++ = new sbyteSortIndex { Value = getKey(values[index]), Index = index };
            }
            new sbyteRangeIndexSorter
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + count - 1);
            valueType[] newValues = new valueType[getCount];
            writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static collection<sbyte> rangeSort
            (this sbyte[] array, int skipCount, int getCount)
        {
            return algorithm.quickSort.RangeSort(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static collection<sbyte> getRangeSort
            (this sbyte[] array, int skipCount, int getCount)
        {
            return algorithm.quickSort.GetRangeSort(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSort<valueType>
            (this valueType[] array, func<valueType, sbyte> getKey, int skipCount, int getCount)
        {
            return algorithm.quickSort.GetRangeSort(array, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static collection<sbyte> rangeSort
            (this sbyte[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return algorithm.quickSort.RangeSort(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static collection<sbyte> getRangeSort
            (this sbyte[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return algorithm.quickSort.GetRangeSort(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSort<valueType>
            (this valueType[] array, int startIndex, int count, func<valueType, sbyte> getKey, int skipCount, int getCount)
        {
            return algorithm.quickSort.GetRangeSort(array, startIndex, count, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static collection<sbyte> pageSort
            (this sbyte[] array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return algorithm.quickSort.RangeSort(array, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static valueType[] getPageSort<valueType>
            (this valueType[] array, func<valueType, sbyte> getKey, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return algorithm.quickSort.GetRangeSort(array, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static collection<sbyte> getPageSort
            (this sbyte[] array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return algorithm.quickSort.GetRangeSort(array, page.SkipCount, page.CurrentPageSize);
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 单向动态数组扩展
    /// </summary>
    public static partial class list
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static collection<sbyte> rangeSort
            (this list<sbyte> list, int skipCount, int getCount)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.RangeSort(list.Unsafer.Array, 0, list.Count, skipCount, getCount);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static collection<sbyte> getRangeSort
            (this list<sbyte> list, int skipCount, int getCount)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.GetRangeSort(list.Unsafer.Array, 0, list.Count, skipCount, getCount);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSort<valueType>
            (this list<valueType> list, func<valueType, sbyte> getKey, int skipCount, int getCount)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.GetRangeSort
                    (list.Unsafer.Array, 0, list.Count, getKey, skipCount, getCount);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static collection<sbyte> rangeSort
            (this list<sbyte> list, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.RangeSort
                    (list.Unsafer.Array, range.SkipCount, count, skipCount, getCount);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static collection<sbyte> getRangeSort
            (this list<sbyte> list, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.GetRangeSort
                    (list.Unsafer.Array, range.SkipCount, count, skipCount, getCount);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSort<valueType>
            (this list<valueType> list, int startIndex, int count, func<valueType, sbyte> getKey
            , int skipCount, int getCount)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.GetRangeSort
                    (list.Unsafer.Array, range.SkipCount, count, getKey, skipCount, getCount);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static collection<sbyte> pageSort
            (this list<sbyte> list, int pageSize, int currentPage)
        {
            array.page page = new array.page(list.count(), pageSize, currentPage);
            int count = page.CurrentPageSize;
            if (count != 0)
            {
                return algorithm.quickSort.RangeSort(list.Unsafer.Array, page.SkipCount, count);
            }
            return null;
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static collection<sbyte> getPageSort
            (this list<sbyte> list, int pageSize, int currentPage)
        {
            array.page page = new array.page(list.count(), pageSize, currentPage);
            int count = page.CurrentPageSize;
            if (count != 0)
            {
                return algorithm.quickSort.GetRangeSort(list.Unsafer.Array, page.SkipCount, count);
            }
            return null;
        }
    }
}
namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 范围排序器(一般用于获取分页)
        /// </summary>
        private unsafe struct sbyteRangeSorterDesc
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public sbyte* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public sbyte* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(sbyte* startIndex, sbyte* endIndex)
            {
                do
                {
                    sbyte leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue < rightValue)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    sbyte* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    sbyte value = *averageIndex;
                    if (leftValue < value)
                    {
                        if (leftValue < rightValue)
                        {
                            *rightIndex = leftValue;
                            if (value < rightValue) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = value;
                                *averageIndex = value = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = leftValue;
                        }
                    }
                    else
                    {
                        if (value < rightValue)
                        {
                            *rightIndex = value;
                            if (leftValue < rightValue)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = value = leftValue;
                            }
                            else *averageIndex = value = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    do
                    {
                        while (*leftIndex > value) ++leftIndex;
                        while (value > *rightIndex) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static collection<sbyte> RangeSortDesc
            (sbyte[] values, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (sbyte* valueFixed = values)
                {
                    new sbyteRangeSorterDesc
                    {
                        SkipCount = valueFixed + range.SkipCount,
                        GetEndIndex = valueFixed + range.EndIndex - 1
                    }.Sort(valueFixed, valueFixed + values.Length - 1);
                }
                return new collection<sbyte>(values, range.SkipCount, getCount, true);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static collection<sbyte> GetRangeSortDesc
            (sbyte[] values, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                sbyte[] newValues = new sbyte[values.Length];
                Buffer.BlockCopy(values, 0, newValues, 0, values.Length * sizeof(sbyte));
                fixed (sbyte* newValueFixed = newValues, valueFixed = values)
                {
                    new sbyteRangeSorterDesc
                    {
                        SkipCount = newValueFixed + range.SkipCount,
                        GetEndIndex = newValueFixed + range.EndIndex - 1
                    }.Sort(newValueFixed, newValueFixed + values.Length - 1);
                }
                return new collection<sbyte>(newValues, range.SkipCount, getCount, true);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static collection<sbyte> RangeSortDesc
            (sbyte[] values, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    skipCount = range.SkipCount + getRange.SkipCount;
                    fixed (sbyte* valueFixed = values)
                    {
                        sbyte* skip = valueFixed + skipCount, start = valueFixed + range.SkipCount;
                        new sbyteRangeSorterDesc
                        {
                            SkipCount = skip,
                            GetEndIndex = skip + getCount - 1
                        }.Sort(start, start + --count);
                    }
                    return new collection<sbyte>(values, skipCount, getCount, true);
                }
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static collection<sbyte> GetRangeSortDesc
            (sbyte[] values, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    sbyte[] newValues = new sbyte[count];
                    Buffer.BlockCopy(values, range.SkipCount * sizeof(sbyte), newValues, 0, count * sizeof(sbyte));
                    fixed (sbyte* newValueFixed = newValues, valueFixed = values)
                    {
                        new sbyteRangeSorterDesc
                        {
                            SkipCount = newValueFixed + getRange.SkipCount,
                            GetEndIndex = newValueFixed + getRange.SkipCount + getCount - 1
                        }.Sort(newValueFixed, newValueFixed + count - 1);
                    }
                    return new collection<sbyte>(newValues, getRange.SkipCount, getCount, true);
                }
            }
            return null;
        }

        /// <summary>
        /// 索引范围排序器
        /// </summary>
        private unsafe struct sbyteRangeIndexSorterDesc
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public sbyteSortIndex* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public sbyteSortIndex* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(sbyteSortIndex* startIndex, sbyteSortIndex* endIndex)
            {
                do
                {
                    sbyteSortIndex leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue.Value < rightValue.Value)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    sbyteSortIndex* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    sbyteSortIndex indexValue = *averageIndex;
                    if (leftValue.Value < indexValue.Value)
                    {
                        if (leftValue.Value < rightValue.Value)
                        {
                            *rightIndex = leftValue;
                            if (indexValue.Value < rightValue.Value) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = indexValue;
                                *averageIndex = indexValue = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = leftValue;
                        }
                    }
                    else
                    {
                        if (indexValue.Value < rightValue.Value)
                        {
                            *rightIndex = indexValue;
                            if (leftValue.Value < rightValue.Value)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = indexValue = leftValue;
                            }
                            else *averageIndex = indexValue = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    sbyte value = indexValue.Value;
                    do
                    {
                        while ((*leftIndex).Value > value) ++leftIndex;
                        while (value > (*rightIndex).Value) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSortDesc<valueType>
            (valueType[] values, func<valueType, sbyte> getKey, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                if (values.Length > (config.pub.Default.StreamBufferLength >> 4))
                {
                    sbyteSortIndex[] indexs = new sbyteSortIndex[values.Length];
                    fixed (sbyteSortIndex* fixedIndex = indexs)
                    {
                        return getRangeSortDesc(values, getKey, range.SkipCount, getCount, fixedIndex);
                    }
                }
                else
                {
                    sbyteSortIndex* fixedIndex = stackalloc sbyteSortIndex[values.Length];
                    return getRangeSortDesc(values, getKey, range.SkipCount, getCount, fixedIndex);
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSortDesc<valueType>
            (valueType[] values, func<valueType, sbyte> getKey, int skipCount, int getCount
            , sbyteSortIndex* fixedIndex)
        {
            sbyteSortIndex* writeIndex = fixedIndex;
            for (int index = 0; index != values.Length; ++index)
            {
                *writeIndex++ = new sbyteSortIndex { Value = getKey(values[index]), Index = index };
            }
            return getRangeSortDesc(values, skipCount, getCount, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSortDesc<valueType>
            (valueType[] values, int skipCount, int getCount, sbyteSortIndex* fixedIndex)
        {
            new sbyteRangeIndexSorterDesc
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + values.Length - 1);
            valueType[] newValues = new valueType[getCount];
            sbyteSortIndex* writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="indexs">排序索引</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSortDesc<valueType>
            (valueType[] values, sbyteSortIndex[] indexs, int skipCount, int getCount)
        {
            if (values.length() != indexs.length()) log.Default.Throw(log.exceptionType.IndexOutOfRange);
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (sbyteSortIndex* fixedIndex = indexs) return getRangeSortDesc(values, skipCount, getCount, fixedIndex);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSortDesc<valueType>
            (valueType[] values, int startIndex, int count, func<valueType, sbyte> getKey, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                    if (values.Length > (config.pub.Default.StreamBufferLength >> 4))
                    {
                        sbyteSortIndex[] indexs = new sbyteSortIndex[count];
                        fixed (sbyteSortIndex* fixedIndex = indexs)
                        {
                            return getRangeSortDesc
                                (values, range.SkipCount, count, getKey, getRange.SkipCount, getCount, fixedIndex);
                        }
                    }
                    else
                    {
                        sbyteSortIndex* fixedIndex = stackalloc sbyteSortIndex[count];
                        return getRangeSortDesc
                            (values, range.SkipCount, count, getKey, getRange.SkipCount, getCount, fixedIndex);
                    }
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSortDesc<valueType>
            (valueType[] values, int startIndex, int count, func<valueType, sbyte> getKey, int skipCount, int getCount
            , sbyteSortIndex* fixedIndex)
        {
            sbyteSortIndex* writeIndex = fixedIndex;
            for (int index = startIndex, endIndex = startIndex + count; index != endIndex; ++index)
            {
                *writeIndex++ = new sbyteSortIndex { Value = getKey(values[index]), Index = index };
            }
            new sbyteRangeIndexSorterDesc
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + count - 1);
            valueType[] newValues = new valueType[getCount];
            writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static collection<sbyte> rangeSortDesc
            (this sbyte[] array, int skipCount, int getCount)
        {
            return algorithm.quickSort.RangeSortDesc(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static collection<sbyte> getRangeSortDesc
            (this sbyte[] array, int skipCount, int getCount)
        {
            return algorithm.quickSort.GetRangeSortDesc(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSortDesc<valueType>
            (this valueType[] array, func<valueType, sbyte> getKey, int skipCount, int getCount)
        {
            return algorithm.quickSort.GetRangeSortDesc(array, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static collection<sbyte> rangeSortDesc
            (this sbyte[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return algorithm.quickSort.RangeSortDesc(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static collection<sbyte> getRangeSortDesc
            (this sbyte[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return algorithm.quickSort.GetRangeSortDesc(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSortDesc<valueType>
            (this valueType[] array, int startIndex, int count, func<valueType, sbyte> getKey, int skipCount, int getCount)
        {
            return algorithm.quickSort.GetRangeSortDesc(array, startIndex, count, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static collection<sbyte> pageSortDesc
            (this sbyte[] array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return algorithm.quickSort.RangeSortDesc(array, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static valueType[] getPageSortDesc<valueType>
            (this valueType[] array, func<valueType, sbyte> getKey, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return algorithm.quickSort.GetRangeSortDesc(array, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static collection<sbyte> getPageSortDesc
            (this sbyte[] array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return algorithm.quickSort.GetRangeSortDesc(array, page.SkipCount, page.CurrentPageSize);
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 单向动态数组扩展
    /// </summary>
    public static partial class list
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static collection<sbyte> rangeSortDesc
            (this list<sbyte> list, int skipCount, int getCount)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.RangeSortDesc(list.Unsafer.Array, 0, list.Count, skipCount, getCount);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static collection<sbyte> getRangeSortDesc
            (this list<sbyte> list, int skipCount, int getCount)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.GetRangeSortDesc(list.Unsafer.Array, 0, list.Count, skipCount, getCount);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSortDesc<valueType>
            (this list<valueType> list, func<valueType, sbyte> getKey, int skipCount, int getCount)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.GetRangeSortDesc
                    (list.Unsafer.Array, 0, list.Count, getKey, skipCount, getCount);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static collection<sbyte> rangeSortDesc
            (this list<sbyte> list, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.RangeSortDesc
                    (list.Unsafer.Array, range.SkipCount, count, skipCount, getCount);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static collection<sbyte> getRangeSortDesc
            (this list<sbyte> list, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.GetRangeSortDesc
                    (list.Unsafer.Array, range.SkipCount, count, skipCount, getCount);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSortDesc<valueType>
            (this list<valueType> list, int startIndex, int count, func<valueType, sbyte> getKey
            , int skipCount, int getCount)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.GetRangeSortDesc
                    (list.Unsafer.Array, range.SkipCount, count, getKey, skipCount, getCount);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static collection<sbyte> pageSortDesc
            (this list<sbyte> list, int pageSize, int currentPage)
        {
            array.page page = new array.page(list.count(), pageSize, currentPage);
            int count = page.CurrentPageSize;
            if (count != 0)
            {
                return algorithm.quickSort.RangeSortDesc(list.Unsafer.Array, page.SkipCount, count);
            }
            return null;
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static collection<sbyte> getPageSortDesc
            (this list<sbyte> list, int pageSize, int currentPage)
        {
            array.page page = new array.page(list.count(), pageSize, currentPage);
            int count = page.CurrentPageSize;
            if (count != 0)
            {
                return algorithm.quickSort.GetRangeSortDesc(list.Unsafer.Array, page.SkipCount, count);
            }
            return null;
        }
    }
}
namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 范围排序器(一般用于获取分页)
        /// </summary>
        private unsafe struct doubleRangeSorter
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public double* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public double* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(double* startIndex, double* endIndex)
            {
                do
                {
                    double leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue > rightValue)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    double* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    double value = *averageIndex;
                    if (leftValue > value)
                    {
                        if (leftValue > rightValue)
                        {
                            *rightIndex = leftValue;
                            if (value > rightValue) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = value;
                                *averageIndex = value = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = leftValue;
                        }
                    }
                    else
                    {
                        if (value > rightValue)
                        {
                            *rightIndex = value;
                            if (leftValue > rightValue)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = value = leftValue;
                            }
                            else *averageIndex = value = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    do
                    {
                        while (*leftIndex < value) ++leftIndex;
                        while (value < *rightIndex) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static collection<double> RangeSort
            (double[] values, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (double* valueFixed = values)
                {
                    new doubleRangeSorter
                    {
                        SkipCount = valueFixed + range.SkipCount,
                        GetEndIndex = valueFixed + range.EndIndex - 1
                    }.Sort(valueFixed, valueFixed + values.Length - 1);
                }
                return new collection<double>(values, range.SkipCount, getCount, true);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static collection<double> GetRangeSort
            (double[] values, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                double[] newValues = new double[values.Length];
                Buffer.BlockCopy(values, 0, newValues, 0, values.Length * sizeof(double));
                fixed (double* newValueFixed = newValues, valueFixed = values)
                {
                    new doubleRangeSorter
                    {
                        SkipCount = newValueFixed + range.SkipCount,
                        GetEndIndex = newValueFixed + range.EndIndex - 1
                    }.Sort(newValueFixed, newValueFixed + values.Length - 1);
                }
                return new collection<double>(newValues, range.SkipCount, getCount, true);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static collection<double> RangeSort
            (double[] values, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    skipCount = range.SkipCount + getRange.SkipCount;
                    fixed (double* valueFixed = values)
                    {
                        double* skip = valueFixed + skipCount, start = valueFixed + range.SkipCount;
                        new doubleRangeSorter
                        {
                            SkipCount = skip,
                            GetEndIndex = skip + getCount - 1
                        }.Sort(start, start + --count);
                    }
                    return new collection<double>(values, skipCount, getCount, true);
                }
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static collection<double> GetRangeSort
            (double[] values, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    double[] newValues = new double[count];
                    Buffer.BlockCopy(values, range.SkipCount * sizeof(double), newValues, 0, count * sizeof(double));
                    fixed (double* newValueFixed = newValues, valueFixed = values)
                    {
                        new doubleRangeSorter
                        {
                            SkipCount = newValueFixed + getRange.SkipCount,
                            GetEndIndex = newValueFixed + getRange.SkipCount + getCount - 1
                        }.Sort(newValueFixed, newValueFixed + count - 1);
                    }
                    return new collection<double>(newValues, getRange.SkipCount, getCount, true);
                }
            }
            return null;
        }

        /// <summary>
        /// 索引范围排序器
        /// </summary>
        private unsafe struct doubleRangeIndexSorter
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public doubleSortIndex* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public doubleSortIndex* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(doubleSortIndex* startIndex, doubleSortIndex* endIndex)
            {
                do
                {
                    doubleSortIndex leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue.Value > rightValue.Value)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    doubleSortIndex* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    doubleSortIndex indexValue = *averageIndex;
                    if (leftValue.Value > indexValue.Value)
                    {
                        if (leftValue.Value > rightValue.Value)
                        {
                            *rightIndex = leftValue;
                            if (indexValue.Value > rightValue.Value) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = indexValue;
                                *averageIndex = indexValue = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = leftValue;
                        }
                    }
                    else
                    {
                        if (indexValue.Value > rightValue.Value)
                        {
                            *rightIndex = indexValue;
                            if (leftValue.Value > rightValue.Value)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = indexValue = leftValue;
                            }
                            else *averageIndex = indexValue = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    double value = indexValue.Value;
                    do
                    {
                        while ((*leftIndex).Value < value) ++leftIndex;
                        while (value < (*rightIndex).Value) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSort<valueType>
            (valueType[] values, func<valueType, double> getKey, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                if (values.Length > (config.pub.Default.StreamBufferLength >> 4))
                {
                    doubleSortIndex[] indexs = new doubleSortIndex[values.Length];
                    fixed (doubleSortIndex* fixedIndex = indexs)
                    {
                        return getRangeSort(values, getKey, range.SkipCount, getCount, fixedIndex);
                    }
                }
                else
                {
                    doubleSortIndex* fixedIndex = stackalloc doubleSortIndex[values.Length];
                    return getRangeSort(values, getKey, range.SkipCount, getCount, fixedIndex);
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSort<valueType>
            (valueType[] values, func<valueType, double> getKey, int skipCount, int getCount
            , doubleSortIndex* fixedIndex)
        {
            doubleSortIndex* writeIndex = fixedIndex;
            for (int index = 0; index != values.Length; ++index)
            {
                *writeIndex++ = new doubleSortIndex { Value = getKey(values[index]), Index = index };
            }
            return getRangeSort(values, skipCount, getCount, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSort<valueType>
            (valueType[] values, int skipCount, int getCount, doubleSortIndex* fixedIndex)
        {
            new doubleRangeIndexSorter
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + values.Length - 1);
            valueType[] newValues = new valueType[getCount];
            doubleSortIndex* writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="indexs">排序索引</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSort<valueType>
            (valueType[] values, doubleSortIndex[] indexs, int skipCount, int getCount)
        {
            if (values.length() != indexs.length()) log.Default.Throw(log.exceptionType.IndexOutOfRange);
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (doubleSortIndex* fixedIndex = indexs) return getRangeSort(values, skipCount, getCount, fixedIndex);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSort<valueType>
            (valueType[] values, int startIndex, int count, func<valueType, double> getKey, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                    if (values.Length > (config.pub.Default.StreamBufferLength >> 4))
                    {
                        doubleSortIndex[] indexs = new doubleSortIndex[count];
                        fixed (doubleSortIndex* fixedIndex = indexs)
                        {
                            return getRangeSort
                                (values, range.SkipCount, count, getKey, getRange.SkipCount, getCount, fixedIndex);
                        }
                    }
                    else
                    {
                        doubleSortIndex* fixedIndex = stackalloc doubleSortIndex[count];
                        return getRangeSort
                            (values, range.SkipCount, count, getKey, getRange.SkipCount, getCount, fixedIndex);
                    }
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSort<valueType>
            (valueType[] values, int startIndex, int count, func<valueType, double> getKey, int skipCount, int getCount
            , doubleSortIndex* fixedIndex)
        {
            doubleSortIndex* writeIndex = fixedIndex;
            for (int index = startIndex, endIndex = startIndex + count; index != endIndex; ++index)
            {
                *writeIndex++ = new doubleSortIndex { Value = getKey(values[index]), Index = index };
            }
            new doubleRangeIndexSorter
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + count - 1);
            valueType[] newValues = new valueType[getCount];
            writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static collection<double> rangeSort
            (this double[] array, int skipCount, int getCount)
        {
            return algorithm.quickSort.RangeSort(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static collection<double> getRangeSort
            (this double[] array, int skipCount, int getCount)
        {
            return algorithm.quickSort.GetRangeSort(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSort<valueType>
            (this valueType[] array, func<valueType, double> getKey, int skipCount, int getCount)
        {
            return algorithm.quickSort.GetRangeSort(array, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static collection<double> rangeSort
            (this double[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return algorithm.quickSort.RangeSort(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static collection<double> getRangeSort
            (this double[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return algorithm.quickSort.GetRangeSort(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSort<valueType>
            (this valueType[] array, int startIndex, int count, func<valueType, double> getKey, int skipCount, int getCount)
        {
            return algorithm.quickSort.GetRangeSort(array, startIndex, count, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static collection<double> pageSort
            (this double[] array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return algorithm.quickSort.RangeSort(array, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static valueType[] getPageSort<valueType>
            (this valueType[] array, func<valueType, double> getKey, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return algorithm.quickSort.GetRangeSort(array, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static collection<double> getPageSort
            (this double[] array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return algorithm.quickSort.GetRangeSort(array, page.SkipCount, page.CurrentPageSize);
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 单向动态数组扩展
    /// </summary>
    public static partial class list
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static collection<double> rangeSort
            (this list<double> list, int skipCount, int getCount)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.RangeSort(list.Unsafer.Array, 0, list.Count, skipCount, getCount);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static collection<double> getRangeSort
            (this list<double> list, int skipCount, int getCount)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.GetRangeSort(list.Unsafer.Array, 0, list.Count, skipCount, getCount);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSort<valueType>
            (this list<valueType> list, func<valueType, double> getKey, int skipCount, int getCount)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.GetRangeSort
                    (list.Unsafer.Array, 0, list.Count, getKey, skipCount, getCount);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static collection<double> rangeSort
            (this list<double> list, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.RangeSort
                    (list.Unsafer.Array, range.SkipCount, count, skipCount, getCount);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static collection<double> getRangeSort
            (this list<double> list, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.GetRangeSort
                    (list.Unsafer.Array, range.SkipCount, count, skipCount, getCount);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSort<valueType>
            (this list<valueType> list, int startIndex, int count, func<valueType, double> getKey
            , int skipCount, int getCount)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.GetRangeSort
                    (list.Unsafer.Array, range.SkipCount, count, getKey, skipCount, getCount);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static collection<double> pageSort
            (this list<double> list, int pageSize, int currentPage)
        {
            array.page page = new array.page(list.count(), pageSize, currentPage);
            int count = page.CurrentPageSize;
            if (count != 0)
            {
                return algorithm.quickSort.RangeSort(list.Unsafer.Array, page.SkipCount, count);
            }
            return null;
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static collection<double> getPageSort
            (this list<double> list, int pageSize, int currentPage)
        {
            array.page page = new array.page(list.count(), pageSize, currentPage);
            int count = page.CurrentPageSize;
            if (count != 0)
            {
                return algorithm.quickSort.GetRangeSort(list.Unsafer.Array, page.SkipCount, count);
            }
            return null;
        }
    }
}
namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 范围排序器(一般用于获取分页)
        /// </summary>
        private unsafe struct doubleRangeSorterDesc
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public double* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public double* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(double* startIndex, double* endIndex)
            {
                do
                {
                    double leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue < rightValue)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    double* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    double value = *averageIndex;
                    if (leftValue < value)
                    {
                        if (leftValue < rightValue)
                        {
                            *rightIndex = leftValue;
                            if (value < rightValue) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = value;
                                *averageIndex = value = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = leftValue;
                        }
                    }
                    else
                    {
                        if (value < rightValue)
                        {
                            *rightIndex = value;
                            if (leftValue < rightValue)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = value = leftValue;
                            }
                            else *averageIndex = value = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    do
                    {
                        while (*leftIndex > value) ++leftIndex;
                        while (value > *rightIndex) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static collection<double> RangeSortDesc
            (double[] values, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (double* valueFixed = values)
                {
                    new doubleRangeSorterDesc
                    {
                        SkipCount = valueFixed + range.SkipCount,
                        GetEndIndex = valueFixed + range.EndIndex - 1
                    }.Sort(valueFixed, valueFixed + values.Length - 1);
                }
                return new collection<double>(values, range.SkipCount, getCount, true);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static collection<double> GetRangeSortDesc
            (double[] values, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                double[] newValues = new double[values.Length];
                Buffer.BlockCopy(values, 0, newValues, 0, values.Length * sizeof(double));
                fixed (double* newValueFixed = newValues, valueFixed = values)
                {
                    new doubleRangeSorterDesc
                    {
                        SkipCount = newValueFixed + range.SkipCount,
                        GetEndIndex = newValueFixed + range.EndIndex - 1
                    }.Sort(newValueFixed, newValueFixed + values.Length - 1);
                }
                return new collection<double>(newValues, range.SkipCount, getCount, true);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static collection<double> RangeSortDesc
            (double[] values, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    skipCount = range.SkipCount + getRange.SkipCount;
                    fixed (double* valueFixed = values)
                    {
                        double* skip = valueFixed + skipCount, start = valueFixed + range.SkipCount;
                        new doubleRangeSorterDesc
                        {
                            SkipCount = skip,
                            GetEndIndex = skip + getCount - 1
                        }.Sort(start, start + --count);
                    }
                    return new collection<double>(values, skipCount, getCount, true);
                }
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static collection<double> GetRangeSortDesc
            (double[] values, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    double[] newValues = new double[count];
                    Buffer.BlockCopy(values, range.SkipCount * sizeof(double), newValues, 0, count * sizeof(double));
                    fixed (double* newValueFixed = newValues, valueFixed = values)
                    {
                        new doubleRangeSorterDesc
                        {
                            SkipCount = newValueFixed + getRange.SkipCount,
                            GetEndIndex = newValueFixed + getRange.SkipCount + getCount - 1
                        }.Sort(newValueFixed, newValueFixed + count - 1);
                    }
                    return new collection<double>(newValues, getRange.SkipCount, getCount, true);
                }
            }
            return null;
        }

        /// <summary>
        /// 索引范围排序器
        /// </summary>
        private unsafe struct doubleRangeIndexSorterDesc
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public doubleSortIndex* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public doubleSortIndex* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(doubleSortIndex* startIndex, doubleSortIndex* endIndex)
            {
                do
                {
                    doubleSortIndex leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue.Value < rightValue.Value)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    doubleSortIndex* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    doubleSortIndex indexValue = *averageIndex;
                    if (leftValue.Value < indexValue.Value)
                    {
                        if (leftValue.Value < rightValue.Value)
                        {
                            *rightIndex = leftValue;
                            if (indexValue.Value < rightValue.Value) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = indexValue;
                                *averageIndex = indexValue = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = leftValue;
                        }
                    }
                    else
                    {
                        if (indexValue.Value < rightValue.Value)
                        {
                            *rightIndex = indexValue;
                            if (leftValue.Value < rightValue.Value)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = indexValue = leftValue;
                            }
                            else *averageIndex = indexValue = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    double value = indexValue.Value;
                    do
                    {
                        while ((*leftIndex).Value > value) ++leftIndex;
                        while (value > (*rightIndex).Value) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSortDesc<valueType>
            (valueType[] values, func<valueType, double> getKey, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                if (values.Length > (config.pub.Default.StreamBufferLength >> 4))
                {
                    doubleSortIndex[] indexs = new doubleSortIndex[values.Length];
                    fixed (doubleSortIndex* fixedIndex = indexs)
                    {
                        return getRangeSortDesc(values, getKey, range.SkipCount, getCount, fixedIndex);
                    }
                }
                else
                {
                    doubleSortIndex* fixedIndex = stackalloc doubleSortIndex[values.Length];
                    return getRangeSortDesc(values, getKey, range.SkipCount, getCount, fixedIndex);
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSortDesc<valueType>
            (valueType[] values, func<valueType, double> getKey, int skipCount, int getCount
            , doubleSortIndex* fixedIndex)
        {
            doubleSortIndex* writeIndex = fixedIndex;
            for (int index = 0; index != values.Length; ++index)
            {
                *writeIndex++ = new doubleSortIndex { Value = getKey(values[index]), Index = index };
            }
            return getRangeSortDesc(values, skipCount, getCount, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSortDesc<valueType>
            (valueType[] values, int skipCount, int getCount, doubleSortIndex* fixedIndex)
        {
            new doubleRangeIndexSorterDesc
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + values.Length - 1);
            valueType[] newValues = new valueType[getCount];
            doubleSortIndex* writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="indexs">排序索引</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSortDesc<valueType>
            (valueType[] values, doubleSortIndex[] indexs, int skipCount, int getCount)
        {
            if (values.length() != indexs.length()) log.Default.Throw(log.exceptionType.IndexOutOfRange);
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (doubleSortIndex* fixedIndex = indexs) return getRangeSortDesc(values, skipCount, getCount, fixedIndex);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSortDesc<valueType>
            (valueType[] values, int startIndex, int count, func<valueType, double> getKey, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                    if (values.Length > (config.pub.Default.StreamBufferLength >> 4))
                    {
                        doubleSortIndex[] indexs = new doubleSortIndex[count];
                        fixed (doubleSortIndex* fixedIndex = indexs)
                        {
                            return getRangeSortDesc
                                (values, range.SkipCount, count, getKey, getRange.SkipCount, getCount, fixedIndex);
                        }
                    }
                    else
                    {
                        doubleSortIndex* fixedIndex = stackalloc doubleSortIndex[count];
                        return getRangeSortDesc
                            (values, range.SkipCount, count, getKey, getRange.SkipCount, getCount, fixedIndex);
                    }
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSortDesc<valueType>
            (valueType[] values, int startIndex, int count, func<valueType, double> getKey, int skipCount, int getCount
            , doubleSortIndex* fixedIndex)
        {
            doubleSortIndex* writeIndex = fixedIndex;
            for (int index = startIndex, endIndex = startIndex + count; index != endIndex; ++index)
            {
                *writeIndex++ = new doubleSortIndex { Value = getKey(values[index]), Index = index };
            }
            new doubleRangeIndexSorterDesc
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + count - 1);
            valueType[] newValues = new valueType[getCount];
            writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static collection<double> rangeSortDesc
            (this double[] array, int skipCount, int getCount)
        {
            return algorithm.quickSort.RangeSortDesc(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static collection<double> getRangeSortDesc
            (this double[] array, int skipCount, int getCount)
        {
            return algorithm.quickSort.GetRangeSortDesc(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSortDesc<valueType>
            (this valueType[] array, func<valueType, double> getKey, int skipCount, int getCount)
        {
            return algorithm.quickSort.GetRangeSortDesc(array, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static collection<double> rangeSortDesc
            (this double[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return algorithm.quickSort.RangeSortDesc(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static collection<double> getRangeSortDesc
            (this double[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return algorithm.quickSort.GetRangeSortDesc(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSortDesc<valueType>
            (this valueType[] array, int startIndex, int count, func<valueType, double> getKey, int skipCount, int getCount)
        {
            return algorithm.quickSort.GetRangeSortDesc(array, startIndex, count, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static collection<double> pageSortDesc
            (this double[] array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return algorithm.quickSort.RangeSortDesc(array, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static valueType[] getPageSortDesc<valueType>
            (this valueType[] array, func<valueType, double> getKey, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return algorithm.quickSort.GetRangeSortDesc(array, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static collection<double> getPageSortDesc
            (this double[] array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return algorithm.quickSort.GetRangeSortDesc(array, page.SkipCount, page.CurrentPageSize);
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 单向动态数组扩展
    /// </summary>
    public static partial class list
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static collection<double> rangeSortDesc
            (this list<double> list, int skipCount, int getCount)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.RangeSortDesc(list.Unsafer.Array, 0, list.Count, skipCount, getCount);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static collection<double> getRangeSortDesc
            (this list<double> list, int skipCount, int getCount)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.GetRangeSortDesc(list.Unsafer.Array, 0, list.Count, skipCount, getCount);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSortDesc<valueType>
            (this list<valueType> list, func<valueType, double> getKey, int skipCount, int getCount)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.GetRangeSortDesc
                    (list.Unsafer.Array, 0, list.Count, getKey, skipCount, getCount);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static collection<double> rangeSortDesc
            (this list<double> list, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.RangeSortDesc
                    (list.Unsafer.Array, range.SkipCount, count, skipCount, getCount);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static collection<double> getRangeSortDesc
            (this list<double> list, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.GetRangeSortDesc
                    (list.Unsafer.Array, range.SkipCount, count, skipCount, getCount);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSortDesc<valueType>
            (this list<valueType> list, int startIndex, int count, func<valueType, double> getKey
            , int skipCount, int getCount)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.GetRangeSortDesc
                    (list.Unsafer.Array, range.SkipCount, count, getKey, skipCount, getCount);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static collection<double> pageSortDesc
            (this list<double> list, int pageSize, int currentPage)
        {
            array.page page = new array.page(list.count(), pageSize, currentPage);
            int count = page.CurrentPageSize;
            if (count != 0)
            {
                return algorithm.quickSort.RangeSortDesc(list.Unsafer.Array, page.SkipCount, count);
            }
            return null;
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static collection<double> getPageSortDesc
            (this list<double> list, int pageSize, int currentPage)
        {
            array.page page = new array.page(list.count(), pageSize, currentPage);
            int count = page.CurrentPageSize;
            if (count != 0)
            {
                return algorithm.quickSort.GetRangeSortDesc(list.Unsafer.Array, page.SkipCount, count);
            }
            return null;
        }
    }
}
namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 范围排序器(一般用于获取分页)
        /// </summary>
        private unsafe struct floatRangeSorter
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public float* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public float* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(float* startIndex, float* endIndex)
            {
                do
                {
                    float leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue > rightValue)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    float* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    float value = *averageIndex;
                    if (leftValue > value)
                    {
                        if (leftValue > rightValue)
                        {
                            *rightIndex = leftValue;
                            if (value > rightValue) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = value;
                                *averageIndex = value = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = leftValue;
                        }
                    }
                    else
                    {
                        if (value > rightValue)
                        {
                            *rightIndex = value;
                            if (leftValue > rightValue)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = value = leftValue;
                            }
                            else *averageIndex = value = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    do
                    {
                        while (*leftIndex < value) ++leftIndex;
                        while (value < *rightIndex) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static collection<float> RangeSort
            (float[] values, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (float* valueFixed = values)
                {
                    new floatRangeSorter
                    {
                        SkipCount = valueFixed + range.SkipCount,
                        GetEndIndex = valueFixed + range.EndIndex - 1
                    }.Sort(valueFixed, valueFixed + values.Length - 1);
                }
                return new collection<float>(values, range.SkipCount, getCount, true);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static collection<float> GetRangeSort
            (float[] values, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                float[] newValues = new float[values.Length];
                Buffer.BlockCopy(values, 0, newValues, 0, values.Length * sizeof(float));
                fixed (float* newValueFixed = newValues, valueFixed = values)
                {
                    new floatRangeSorter
                    {
                        SkipCount = newValueFixed + range.SkipCount,
                        GetEndIndex = newValueFixed + range.EndIndex - 1
                    }.Sort(newValueFixed, newValueFixed + values.Length - 1);
                }
                return new collection<float>(newValues, range.SkipCount, getCount, true);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static collection<float> RangeSort
            (float[] values, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    skipCount = range.SkipCount + getRange.SkipCount;
                    fixed (float* valueFixed = values)
                    {
                        float* skip = valueFixed + skipCount, start = valueFixed + range.SkipCount;
                        new floatRangeSorter
                        {
                            SkipCount = skip,
                            GetEndIndex = skip + getCount - 1
                        }.Sort(start, start + --count);
                    }
                    return new collection<float>(values, skipCount, getCount, true);
                }
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static collection<float> GetRangeSort
            (float[] values, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    float[] newValues = new float[count];
                    Buffer.BlockCopy(values, range.SkipCount * sizeof(float), newValues, 0, count * sizeof(float));
                    fixed (float* newValueFixed = newValues, valueFixed = values)
                    {
                        new floatRangeSorter
                        {
                            SkipCount = newValueFixed + getRange.SkipCount,
                            GetEndIndex = newValueFixed + getRange.SkipCount + getCount - 1
                        }.Sort(newValueFixed, newValueFixed + count - 1);
                    }
                    return new collection<float>(newValues, getRange.SkipCount, getCount, true);
                }
            }
            return null;
        }

        /// <summary>
        /// 索引范围排序器
        /// </summary>
        private unsafe struct floatRangeIndexSorter
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public floatSortIndex* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public floatSortIndex* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(floatSortIndex* startIndex, floatSortIndex* endIndex)
            {
                do
                {
                    floatSortIndex leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue.Value > rightValue.Value)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    floatSortIndex* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    floatSortIndex indexValue = *averageIndex;
                    if (leftValue.Value > indexValue.Value)
                    {
                        if (leftValue.Value > rightValue.Value)
                        {
                            *rightIndex = leftValue;
                            if (indexValue.Value > rightValue.Value) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = indexValue;
                                *averageIndex = indexValue = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = leftValue;
                        }
                    }
                    else
                    {
                        if (indexValue.Value > rightValue.Value)
                        {
                            *rightIndex = indexValue;
                            if (leftValue.Value > rightValue.Value)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = indexValue = leftValue;
                            }
                            else *averageIndex = indexValue = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    float value = indexValue.Value;
                    do
                    {
                        while ((*leftIndex).Value < value) ++leftIndex;
                        while (value < (*rightIndex).Value) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSort<valueType>
            (valueType[] values, func<valueType, float> getKey, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                if (values.Length > (config.pub.Default.StreamBufferLength >> 4))
                {
                    floatSortIndex[] indexs = new floatSortIndex[values.Length];
                    fixed (floatSortIndex* fixedIndex = indexs)
                    {
                        return getRangeSort(values, getKey, range.SkipCount, getCount, fixedIndex);
                    }
                }
                else
                {
                    floatSortIndex* fixedIndex = stackalloc floatSortIndex[values.Length];
                    return getRangeSort(values, getKey, range.SkipCount, getCount, fixedIndex);
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSort<valueType>
            (valueType[] values, func<valueType, float> getKey, int skipCount, int getCount
            , floatSortIndex* fixedIndex)
        {
            floatSortIndex* writeIndex = fixedIndex;
            for (int index = 0; index != values.Length; ++index)
            {
                *writeIndex++ = new floatSortIndex { Value = getKey(values[index]), Index = index };
            }
            return getRangeSort(values, skipCount, getCount, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSort<valueType>
            (valueType[] values, int skipCount, int getCount, floatSortIndex* fixedIndex)
        {
            new floatRangeIndexSorter
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + values.Length - 1);
            valueType[] newValues = new valueType[getCount];
            floatSortIndex* writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="indexs">排序索引</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSort<valueType>
            (valueType[] values, floatSortIndex[] indexs, int skipCount, int getCount)
        {
            if (values.length() != indexs.length()) log.Default.Throw(log.exceptionType.IndexOutOfRange);
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (floatSortIndex* fixedIndex = indexs) return getRangeSort(values, skipCount, getCount, fixedIndex);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSort<valueType>
            (valueType[] values, int startIndex, int count, func<valueType, float> getKey, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                    if (values.Length > (config.pub.Default.StreamBufferLength >> 4))
                    {
                        floatSortIndex[] indexs = new floatSortIndex[count];
                        fixed (floatSortIndex* fixedIndex = indexs)
                        {
                            return getRangeSort
                                (values, range.SkipCount, count, getKey, getRange.SkipCount, getCount, fixedIndex);
                        }
                    }
                    else
                    {
                        floatSortIndex* fixedIndex = stackalloc floatSortIndex[count];
                        return getRangeSort
                            (values, range.SkipCount, count, getKey, getRange.SkipCount, getCount, fixedIndex);
                    }
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSort<valueType>
            (valueType[] values, int startIndex, int count, func<valueType, float> getKey, int skipCount, int getCount
            , floatSortIndex* fixedIndex)
        {
            floatSortIndex* writeIndex = fixedIndex;
            for (int index = startIndex, endIndex = startIndex + count; index != endIndex; ++index)
            {
                *writeIndex++ = new floatSortIndex { Value = getKey(values[index]), Index = index };
            }
            new floatRangeIndexSorter
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + count - 1);
            valueType[] newValues = new valueType[getCount];
            writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static collection<float> rangeSort
            (this float[] array, int skipCount, int getCount)
        {
            return algorithm.quickSort.RangeSort(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static collection<float> getRangeSort
            (this float[] array, int skipCount, int getCount)
        {
            return algorithm.quickSort.GetRangeSort(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSort<valueType>
            (this valueType[] array, func<valueType, float> getKey, int skipCount, int getCount)
        {
            return algorithm.quickSort.GetRangeSort(array, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static collection<float> rangeSort
            (this float[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return algorithm.quickSort.RangeSort(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static collection<float> getRangeSort
            (this float[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return algorithm.quickSort.GetRangeSort(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSort<valueType>
            (this valueType[] array, int startIndex, int count, func<valueType, float> getKey, int skipCount, int getCount)
        {
            return algorithm.quickSort.GetRangeSort(array, startIndex, count, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static collection<float> pageSort
            (this float[] array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return algorithm.quickSort.RangeSort(array, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static valueType[] getPageSort<valueType>
            (this valueType[] array, func<valueType, float> getKey, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return algorithm.quickSort.GetRangeSort(array, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static collection<float> getPageSort
            (this float[] array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return algorithm.quickSort.GetRangeSort(array, page.SkipCount, page.CurrentPageSize);
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 单向动态数组扩展
    /// </summary>
    public static partial class list
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static collection<float> rangeSort
            (this list<float> list, int skipCount, int getCount)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.RangeSort(list.Unsafer.Array, 0, list.Count, skipCount, getCount);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static collection<float> getRangeSort
            (this list<float> list, int skipCount, int getCount)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.GetRangeSort(list.Unsafer.Array, 0, list.Count, skipCount, getCount);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSort<valueType>
            (this list<valueType> list, func<valueType, float> getKey, int skipCount, int getCount)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.GetRangeSort
                    (list.Unsafer.Array, 0, list.Count, getKey, skipCount, getCount);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static collection<float> rangeSort
            (this list<float> list, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.RangeSort
                    (list.Unsafer.Array, range.SkipCount, count, skipCount, getCount);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static collection<float> getRangeSort
            (this list<float> list, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.GetRangeSort
                    (list.Unsafer.Array, range.SkipCount, count, skipCount, getCount);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSort<valueType>
            (this list<valueType> list, int startIndex, int count, func<valueType, float> getKey
            , int skipCount, int getCount)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.GetRangeSort
                    (list.Unsafer.Array, range.SkipCount, count, getKey, skipCount, getCount);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static collection<float> pageSort
            (this list<float> list, int pageSize, int currentPage)
        {
            array.page page = new array.page(list.count(), pageSize, currentPage);
            int count = page.CurrentPageSize;
            if (count != 0)
            {
                return algorithm.quickSort.RangeSort(list.Unsafer.Array, page.SkipCount, count);
            }
            return null;
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static collection<float> getPageSort
            (this list<float> list, int pageSize, int currentPage)
        {
            array.page page = new array.page(list.count(), pageSize, currentPage);
            int count = page.CurrentPageSize;
            if (count != 0)
            {
                return algorithm.quickSort.GetRangeSort(list.Unsafer.Array, page.SkipCount, count);
            }
            return null;
        }
    }
}
namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 范围排序器(一般用于获取分页)
        /// </summary>
        private unsafe struct floatRangeSorterDesc
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public float* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public float* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(float* startIndex, float* endIndex)
            {
                do
                {
                    float leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue < rightValue)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    float* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    float value = *averageIndex;
                    if (leftValue < value)
                    {
                        if (leftValue < rightValue)
                        {
                            *rightIndex = leftValue;
                            if (value < rightValue) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = value;
                                *averageIndex = value = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = leftValue;
                        }
                    }
                    else
                    {
                        if (value < rightValue)
                        {
                            *rightIndex = value;
                            if (leftValue < rightValue)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = value = leftValue;
                            }
                            else *averageIndex = value = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    do
                    {
                        while (*leftIndex > value) ++leftIndex;
                        while (value > *rightIndex) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static collection<float> RangeSortDesc
            (float[] values, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (float* valueFixed = values)
                {
                    new floatRangeSorterDesc
                    {
                        SkipCount = valueFixed + range.SkipCount,
                        GetEndIndex = valueFixed + range.EndIndex - 1
                    }.Sort(valueFixed, valueFixed + values.Length - 1);
                }
                return new collection<float>(values, range.SkipCount, getCount, true);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static collection<float> GetRangeSortDesc
            (float[] values, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                float[] newValues = new float[values.Length];
                Buffer.BlockCopy(values, 0, newValues, 0, values.Length * sizeof(float));
                fixed (float* newValueFixed = newValues, valueFixed = values)
                {
                    new floatRangeSorterDesc
                    {
                        SkipCount = newValueFixed + range.SkipCount,
                        GetEndIndex = newValueFixed + range.EndIndex - 1
                    }.Sort(newValueFixed, newValueFixed + values.Length - 1);
                }
                return new collection<float>(newValues, range.SkipCount, getCount, true);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static collection<float> RangeSortDesc
            (float[] values, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    skipCount = range.SkipCount + getRange.SkipCount;
                    fixed (float* valueFixed = values)
                    {
                        float* skip = valueFixed + skipCount, start = valueFixed + range.SkipCount;
                        new floatRangeSorterDesc
                        {
                            SkipCount = skip,
                            GetEndIndex = skip + getCount - 1
                        }.Sort(start, start + --count);
                    }
                    return new collection<float>(values, skipCount, getCount, true);
                }
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static collection<float> GetRangeSortDesc
            (float[] values, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    float[] newValues = new float[count];
                    Buffer.BlockCopy(values, range.SkipCount * sizeof(float), newValues, 0, count * sizeof(float));
                    fixed (float* newValueFixed = newValues, valueFixed = values)
                    {
                        new floatRangeSorterDesc
                        {
                            SkipCount = newValueFixed + getRange.SkipCount,
                            GetEndIndex = newValueFixed + getRange.SkipCount + getCount - 1
                        }.Sort(newValueFixed, newValueFixed + count - 1);
                    }
                    return new collection<float>(newValues, getRange.SkipCount, getCount, true);
                }
            }
            return null;
        }

        /// <summary>
        /// 索引范围排序器
        /// </summary>
        private unsafe struct floatRangeIndexSorterDesc
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public floatSortIndex* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public floatSortIndex* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(floatSortIndex* startIndex, floatSortIndex* endIndex)
            {
                do
                {
                    floatSortIndex leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue.Value < rightValue.Value)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    floatSortIndex* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    floatSortIndex indexValue = *averageIndex;
                    if (leftValue.Value < indexValue.Value)
                    {
                        if (leftValue.Value < rightValue.Value)
                        {
                            *rightIndex = leftValue;
                            if (indexValue.Value < rightValue.Value) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = indexValue;
                                *averageIndex = indexValue = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = leftValue;
                        }
                    }
                    else
                    {
                        if (indexValue.Value < rightValue.Value)
                        {
                            *rightIndex = indexValue;
                            if (leftValue.Value < rightValue.Value)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = indexValue = leftValue;
                            }
                            else *averageIndex = indexValue = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    float value = indexValue.Value;
                    do
                    {
                        while ((*leftIndex).Value > value) ++leftIndex;
                        while (value > (*rightIndex).Value) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSortDesc<valueType>
            (valueType[] values, func<valueType, float> getKey, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                if (values.Length > (config.pub.Default.StreamBufferLength >> 4))
                {
                    floatSortIndex[] indexs = new floatSortIndex[values.Length];
                    fixed (floatSortIndex* fixedIndex = indexs)
                    {
                        return getRangeSortDesc(values, getKey, range.SkipCount, getCount, fixedIndex);
                    }
                }
                else
                {
                    floatSortIndex* fixedIndex = stackalloc floatSortIndex[values.Length];
                    return getRangeSortDesc(values, getKey, range.SkipCount, getCount, fixedIndex);
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSortDesc<valueType>
            (valueType[] values, func<valueType, float> getKey, int skipCount, int getCount
            , floatSortIndex* fixedIndex)
        {
            floatSortIndex* writeIndex = fixedIndex;
            for (int index = 0; index != values.Length; ++index)
            {
                *writeIndex++ = new floatSortIndex { Value = getKey(values[index]), Index = index };
            }
            return getRangeSortDesc(values, skipCount, getCount, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSortDesc<valueType>
            (valueType[] values, int skipCount, int getCount, floatSortIndex* fixedIndex)
        {
            new floatRangeIndexSorterDesc
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + values.Length - 1);
            valueType[] newValues = new valueType[getCount];
            floatSortIndex* writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="indexs">排序索引</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSortDesc<valueType>
            (valueType[] values, floatSortIndex[] indexs, int skipCount, int getCount)
        {
            if (values.length() != indexs.length()) log.Default.Throw(log.exceptionType.IndexOutOfRange);
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (floatSortIndex* fixedIndex = indexs) return getRangeSortDesc(values, skipCount, getCount, fixedIndex);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSortDesc<valueType>
            (valueType[] values, int startIndex, int count, func<valueType, float> getKey, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                    if (values.Length > (config.pub.Default.StreamBufferLength >> 4))
                    {
                        floatSortIndex[] indexs = new floatSortIndex[count];
                        fixed (floatSortIndex* fixedIndex = indexs)
                        {
                            return getRangeSortDesc
                                (values, range.SkipCount, count, getKey, getRange.SkipCount, getCount, fixedIndex);
                        }
                    }
                    else
                    {
                        floatSortIndex* fixedIndex = stackalloc floatSortIndex[count];
                        return getRangeSortDesc
                            (values, range.SkipCount, count, getKey, getRange.SkipCount, getCount, fixedIndex);
                    }
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSortDesc<valueType>
            (valueType[] values, int startIndex, int count, func<valueType, float> getKey, int skipCount, int getCount
            , floatSortIndex* fixedIndex)
        {
            floatSortIndex* writeIndex = fixedIndex;
            for (int index = startIndex, endIndex = startIndex + count; index != endIndex; ++index)
            {
                *writeIndex++ = new floatSortIndex { Value = getKey(values[index]), Index = index };
            }
            new floatRangeIndexSorterDesc
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + count - 1);
            valueType[] newValues = new valueType[getCount];
            writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static collection<float> rangeSortDesc
            (this float[] array, int skipCount, int getCount)
        {
            return algorithm.quickSort.RangeSortDesc(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static collection<float> getRangeSortDesc
            (this float[] array, int skipCount, int getCount)
        {
            return algorithm.quickSort.GetRangeSortDesc(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSortDesc<valueType>
            (this valueType[] array, func<valueType, float> getKey, int skipCount, int getCount)
        {
            return algorithm.quickSort.GetRangeSortDesc(array, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static collection<float> rangeSortDesc
            (this float[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return algorithm.quickSort.RangeSortDesc(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static collection<float> getRangeSortDesc
            (this float[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return algorithm.quickSort.GetRangeSortDesc(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSortDesc<valueType>
            (this valueType[] array, int startIndex, int count, func<valueType, float> getKey, int skipCount, int getCount)
        {
            return algorithm.quickSort.GetRangeSortDesc(array, startIndex, count, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static collection<float> pageSortDesc
            (this float[] array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return algorithm.quickSort.RangeSortDesc(array, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static valueType[] getPageSortDesc<valueType>
            (this valueType[] array, func<valueType, float> getKey, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return algorithm.quickSort.GetRangeSortDesc(array, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static collection<float> getPageSortDesc
            (this float[] array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return algorithm.quickSort.GetRangeSortDesc(array, page.SkipCount, page.CurrentPageSize);
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 单向动态数组扩展
    /// </summary>
    public static partial class list
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static collection<float> rangeSortDesc
            (this list<float> list, int skipCount, int getCount)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.RangeSortDesc(list.Unsafer.Array, 0, list.Count, skipCount, getCount);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static collection<float> getRangeSortDesc
            (this list<float> list, int skipCount, int getCount)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.GetRangeSortDesc(list.Unsafer.Array, 0, list.Count, skipCount, getCount);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSortDesc<valueType>
            (this list<valueType> list, func<valueType, float> getKey, int skipCount, int getCount)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.GetRangeSortDesc
                    (list.Unsafer.Array, 0, list.Count, getKey, skipCount, getCount);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static collection<float> rangeSortDesc
            (this list<float> list, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.RangeSortDesc
                    (list.Unsafer.Array, range.SkipCount, count, skipCount, getCount);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static collection<float> getRangeSortDesc
            (this list<float> list, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.GetRangeSortDesc
                    (list.Unsafer.Array, range.SkipCount, count, skipCount, getCount);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSortDesc<valueType>
            (this list<valueType> list, int startIndex, int count, func<valueType, float> getKey
            , int skipCount, int getCount)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.GetRangeSortDesc
                    (list.Unsafer.Array, range.SkipCount, count, getKey, skipCount, getCount);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static collection<float> pageSortDesc
            (this list<float> list, int pageSize, int currentPage)
        {
            array.page page = new array.page(list.count(), pageSize, currentPage);
            int count = page.CurrentPageSize;
            if (count != 0)
            {
                return algorithm.quickSort.RangeSortDesc(list.Unsafer.Array, page.SkipCount, count);
            }
            return null;
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static collection<float> getPageSortDesc
            (this list<float> list, int pageSize, int currentPage)
        {
            array.page page = new array.page(list.count(), pageSize, currentPage);
            int count = page.CurrentPageSize;
            if (count != 0)
            {
                return algorithm.quickSort.GetRangeSortDesc(list.Unsafer.Array, page.SkipCount, count);
            }
            return null;
        }
    }
}
namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 范围排序器(一般用于获取分页)
        /// </summary>
        private unsafe struct dateTimeRangeSorter
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public DateTime* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public DateTime* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(DateTime* startIndex, DateTime* endIndex)
            {
                do
                {
                    DateTime leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue > rightValue)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    DateTime* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    DateTime value = *averageIndex;
                    if (leftValue > value)
                    {
                        if (leftValue > rightValue)
                        {
                            *rightIndex = leftValue;
                            if (value > rightValue) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = value;
                                *averageIndex = value = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = leftValue;
                        }
                    }
                    else
                    {
                        if (value > rightValue)
                        {
                            *rightIndex = value;
                            if (leftValue > rightValue)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = value = leftValue;
                            }
                            else *averageIndex = value = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    do
                    {
                        while (*leftIndex < value) ++leftIndex;
                        while (value < *rightIndex) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static collection<DateTime> RangeSort
            (DateTime[] values, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (DateTime* valueFixed = values)
                {
                    new dateTimeRangeSorter
                    {
                        SkipCount = valueFixed + range.SkipCount,
                        GetEndIndex = valueFixed + range.EndIndex - 1
                    }.Sort(valueFixed, valueFixed + values.Length - 1);
                }
                return new collection<DateTime>(values, range.SkipCount, getCount, true);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static collection<DateTime> GetRangeSort
            (DateTime[] values, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                DateTime[] newValues = new DateTime[values.Length];
                Buffer.BlockCopy(values, 0, newValues, 0, values.Length * sizeof(DateTime));
                fixed (DateTime* newValueFixed = newValues, valueFixed = values)
                {
                    new dateTimeRangeSorter
                    {
                        SkipCount = newValueFixed + range.SkipCount,
                        GetEndIndex = newValueFixed + range.EndIndex - 1
                    }.Sort(newValueFixed, newValueFixed + values.Length - 1);
                }
                return new collection<DateTime>(newValues, range.SkipCount, getCount, true);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static collection<DateTime> RangeSort
            (DateTime[] values, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    skipCount = range.SkipCount + getRange.SkipCount;
                    fixed (DateTime* valueFixed = values)
                    {
                        DateTime* skip = valueFixed + skipCount, start = valueFixed + range.SkipCount;
                        new dateTimeRangeSorter
                        {
                            SkipCount = skip,
                            GetEndIndex = skip + getCount - 1
                        }.Sort(start, start + --count);
                    }
                    return new collection<DateTime>(values, skipCount, getCount, true);
                }
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static collection<DateTime> GetRangeSort
            (DateTime[] values, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    DateTime[] newValues = new DateTime[count];
                    Buffer.BlockCopy(values, range.SkipCount * sizeof(DateTime), newValues, 0, count * sizeof(DateTime));
                    fixed (DateTime* newValueFixed = newValues, valueFixed = values)
                    {
                        new dateTimeRangeSorter
                        {
                            SkipCount = newValueFixed + getRange.SkipCount,
                            GetEndIndex = newValueFixed + getRange.SkipCount + getCount - 1
                        }.Sort(newValueFixed, newValueFixed + count - 1);
                    }
                    return new collection<DateTime>(newValues, getRange.SkipCount, getCount, true);
                }
            }
            return null;
        }

        /// <summary>
        /// 索引范围排序器
        /// </summary>
        private unsafe struct dateTimeRangeIndexSorter
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public dateTimeSortIndex* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public dateTimeSortIndex* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(dateTimeSortIndex* startIndex, dateTimeSortIndex* endIndex)
            {
                do
                {
                    dateTimeSortIndex leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue.Value > rightValue.Value)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    dateTimeSortIndex* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    dateTimeSortIndex indexValue = *averageIndex;
                    if (leftValue.Value > indexValue.Value)
                    {
                        if (leftValue.Value > rightValue.Value)
                        {
                            *rightIndex = leftValue;
                            if (indexValue.Value > rightValue.Value) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = indexValue;
                                *averageIndex = indexValue = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = leftValue;
                        }
                    }
                    else
                    {
                        if (indexValue.Value > rightValue.Value)
                        {
                            *rightIndex = indexValue;
                            if (leftValue.Value > rightValue.Value)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = indexValue = leftValue;
                            }
                            else *averageIndex = indexValue = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    DateTime value = indexValue.Value;
                    do
                    {
                        while ((*leftIndex).Value < value) ++leftIndex;
                        while (value < (*rightIndex).Value) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSort<valueType>
            (valueType[] values, func<valueType, DateTime> getKey, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                if (values.Length > (config.pub.Default.StreamBufferLength >> 4))
                {
                    dateTimeSortIndex[] indexs = new dateTimeSortIndex[values.Length];
                    fixed (dateTimeSortIndex* fixedIndex = indexs)
                    {
                        return getRangeSort(values, getKey, range.SkipCount, getCount, fixedIndex);
                    }
                }
                else
                {
                    dateTimeSortIndex* fixedIndex = stackalloc dateTimeSortIndex[values.Length];
                    return getRangeSort(values, getKey, range.SkipCount, getCount, fixedIndex);
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSort<valueType>
            (valueType[] values, func<valueType, DateTime> getKey, int skipCount, int getCount
            , dateTimeSortIndex* fixedIndex)
        {
            dateTimeSortIndex* writeIndex = fixedIndex;
            for (int index = 0; index != values.Length; ++index)
            {
                *writeIndex++ = new dateTimeSortIndex { Value = getKey(values[index]), Index = index };
            }
            return getRangeSort(values, skipCount, getCount, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSort<valueType>
            (valueType[] values, int skipCount, int getCount, dateTimeSortIndex* fixedIndex)
        {
            new dateTimeRangeIndexSorter
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + values.Length - 1);
            valueType[] newValues = new valueType[getCount];
            dateTimeSortIndex* writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="indexs">排序索引</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSort<valueType>
            (valueType[] values, dateTimeSortIndex[] indexs, int skipCount, int getCount)
        {
            if (values.length() != indexs.length()) log.Default.Throw(log.exceptionType.IndexOutOfRange);
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (dateTimeSortIndex* fixedIndex = indexs) return getRangeSort(values, skipCount, getCount, fixedIndex);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSort<valueType>
            (valueType[] values, int startIndex, int count, func<valueType, DateTime> getKey, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                    if (values.Length > (config.pub.Default.StreamBufferLength >> 4))
                    {
                        dateTimeSortIndex[] indexs = new dateTimeSortIndex[count];
                        fixed (dateTimeSortIndex* fixedIndex = indexs)
                        {
                            return getRangeSort
                                (values, range.SkipCount, count, getKey, getRange.SkipCount, getCount, fixedIndex);
                        }
                    }
                    else
                    {
                        dateTimeSortIndex* fixedIndex = stackalloc dateTimeSortIndex[count];
                        return getRangeSort
                            (values, range.SkipCount, count, getKey, getRange.SkipCount, getCount, fixedIndex);
                    }
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSort<valueType>
            (valueType[] values, int startIndex, int count, func<valueType, DateTime> getKey, int skipCount, int getCount
            , dateTimeSortIndex* fixedIndex)
        {
            dateTimeSortIndex* writeIndex = fixedIndex;
            for (int index = startIndex, endIndex = startIndex + count; index != endIndex; ++index)
            {
                *writeIndex++ = new dateTimeSortIndex { Value = getKey(values[index]), Index = index };
            }
            new dateTimeRangeIndexSorter
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + count - 1);
            valueType[] newValues = new valueType[getCount];
            writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static collection<DateTime> rangeSort
            (this DateTime[] array, int skipCount, int getCount)
        {
            return algorithm.quickSort.RangeSort(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static collection<DateTime> getRangeSort
            (this DateTime[] array, int skipCount, int getCount)
        {
            return algorithm.quickSort.GetRangeSort(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSort<valueType>
            (this valueType[] array, func<valueType, DateTime> getKey, int skipCount, int getCount)
        {
            return algorithm.quickSort.GetRangeSort(array, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static collection<DateTime> rangeSort
            (this DateTime[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return algorithm.quickSort.RangeSort(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static collection<DateTime> getRangeSort
            (this DateTime[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return algorithm.quickSort.GetRangeSort(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSort<valueType>
            (this valueType[] array, int startIndex, int count, func<valueType, DateTime> getKey, int skipCount, int getCount)
        {
            return algorithm.quickSort.GetRangeSort(array, startIndex, count, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static collection<DateTime> pageSort
            (this DateTime[] array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return algorithm.quickSort.RangeSort(array, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static valueType[] getPageSort<valueType>
            (this valueType[] array, func<valueType, DateTime> getKey, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return algorithm.quickSort.GetRangeSort(array, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static collection<DateTime> getPageSort
            (this DateTime[] array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return algorithm.quickSort.GetRangeSort(array, page.SkipCount, page.CurrentPageSize);
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 单向动态数组扩展
    /// </summary>
    public static partial class list
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static collection<DateTime> rangeSort
            (this list<DateTime> list, int skipCount, int getCount)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.RangeSort(list.Unsafer.Array, 0, list.Count, skipCount, getCount);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static collection<DateTime> getRangeSort
            (this list<DateTime> list, int skipCount, int getCount)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.GetRangeSort(list.Unsafer.Array, 0, list.Count, skipCount, getCount);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSort<valueType>
            (this list<valueType> list, func<valueType, DateTime> getKey, int skipCount, int getCount)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.GetRangeSort
                    (list.Unsafer.Array, 0, list.Count, getKey, skipCount, getCount);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static collection<DateTime> rangeSort
            (this list<DateTime> list, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.RangeSort
                    (list.Unsafer.Array, range.SkipCount, count, skipCount, getCount);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static collection<DateTime> getRangeSort
            (this list<DateTime> list, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.GetRangeSort
                    (list.Unsafer.Array, range.SkipCount, count, skipCount, getCount);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSort<valueType>
            (this list<valueType> list, int startIndex, int count, func<valueType, DateTime> getKey
            , int skipCount, int getCount)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.GetRangeSort
                    (list.Unsafer.Array, range.SkipCount, count, getKey, skipCount, getCount);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static collection<DateTime> pageSort
            (this list<DateTime> list, int pageSize, int currentPage)
        {
            array.page page = new array.page(list.count(), pageSize, currentPage);
            int count = page.CurrentPageSize;
            if (count != 0)
            {
                return algorithm.quickSort.RangeSort(list.Unsafer.Array, page.SkipCount, count);
            }
            return null;
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static collection<DateTime> getPageSort
            (this list<DateTime> list, int pageSize, int currentPage)
        {
            array.page page = new array.page(list.count(), pageSize, currentPage);
            int count = page.CurrentPageSize;
            if (count != 0)
            {
                return algorithm.quickSort.GetRangeSort(list.Unsafer.Array, page.SkipCount, count);
            }
            return null;
        }
    }
}
namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 范围排序器(一般用于获取分页)
        /// </summary>
        private unsafe struct dateTimeRangeSorterDesc
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public DateTime* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public DateTime* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(DateTime* startIndex, DateTime* endIndex)
            {
                do
                {
                    DateTime leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue < rightValue)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    DateTime* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    DateTime value = *averageIndex;
                    if (leftValue < value)
                    {
                        if (leftValue < rightValue)
                        {
                            *rightIndex = leftValue;
                            if (value < rightValue) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = value;
                                *averageIndex = value = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = leftValue;
                        }
                    }
                    else
                    {
                        if (value < rightValue)
                        {
                            *rightIndex = value;
                            if (leftValue < rightValue)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = value = leftValue;
                            }
                            else *averageIndex = value = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    do
                    {
                        while (*leftIndex > value) ++leftIndex;
                        while (value > *rightIndex) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static collection<DateTime> RangeSortDesc
            (DateTime[] values, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (DateTime* valueFixed = values)
                {
                    new dateTimeRangeSorterDesc
                    {
                        SkipCount = valueFixed + range.SkipCount,
                        GetEndIndex = valueFixed + range.EndIndex - 1
                    }.Sort(valueFixed, valueFixed + values.Length - 1);
                }
                return new collection<DateTime>(values, range.SkipCount, getCount, true);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static collection<DateTime> GetRangeSortDesc
            (DateTime[] values, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                DateTime[] newValues = new DateTime[values.Length];
                Buffer.BlockCopy(values, 0, newValues, 0, values.Length * sizeof(DateTime));
                fixed (DateTime* newValueFixed = newValues, valueFixed = values)
                {
                    new dateTimeRangeSorterDesc
                    {
                        SkipCount = newValueFixed + range.SkipCount,
                        GetEndIndex = newValueFixed + range.EndIndex - 1
                    }.Sort(newValueFixed, newValueFixed + values.Length - 1);
                }
                return new collection<DateTime>(newValues, range.SkipCount, getCount, true);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static collection<DateTime> RangeSortDesc
            (DateTime[] values, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    skipCount = range.SkipCount + getRange.SkipCount;
                    fixed (DateTime* valueFixed = values)
                    {
                        DateTime* skip = valueFixed + skipCount, start = valueFixed + range.SkipCount;
                        new dateTimeRangeSorterDesc
                        {
                            SkipCount = skip,
                            GetEndIndex = skip + getCount - 1
                        }.Sort(start, start + --count);
                    }
                    return new collection<DateTime>(values, skipCount, getCount, true);
                }
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static collection<DateTime> GetRangeSortDesc
            (DateTime[] values, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    DateTime[] newValues = new DateTime[count];
                    Buffer.BlockCopy(values, range.SkipCount * sizeof(DateTime), newValues, 0, count * sizeof(DateTime));
                    fixed (DateTime* newValueFixed = newValues, valueFixed = values)
                    {
                        new dateTimeRangeSorterDesc
                        {
                            SkipCount = newValueFixed + getRange.SkipCount,
                            GetEndIndex = newValueFixed + getRange.SkipCount + getCount - 1
                        }.Sort(newValueFixed, newValueFixed + count - 1);
                    }
                    return new collection<DateTime>(newValues, getRange.SkipCount, getCount, true);
                }
            }
            return null;
        }

        /// <summary>
        /// 索引范围排序器
        /// </summary>
        private unsafe struct dateTimeRangeIndexSorterDesc
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public dateTimeSortIndex* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public dateTimeSortIndex* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(dateTimeSortIndex* startIndex, dateTimeSortIndex* endIndex)
            {
                do
                {
                    dateTimeSortIndex leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue.Value < rightValue.Value)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    dateTimeSortIndex* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    dateTimeSortIndex indexValue = *averageIndex;
                    if (leftValue.Value < indexValue.Value)
                    {
                        if (leftValue.Value < rightValue.Value)
                        {
                            *rightIndex = leftValue;
                            if (indexValue.Value < rightValue.Value) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = indexValue;
                                *averageIndex = indexValue = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = leftValue;
                        }
                    }
                    else
                    {
                        if (indexValue.Value < rightValue.Value)
                        {
                            *rightIndex = indexValue;
                            if (leftValue.Value < rightValue.Value)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = indexValue = leftValue;
                            }
                            else *averageIndex = indexValue = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    DateTime value = indexValue.Value;
                    do
                    {
                        while ((*leftIndex).Value > value) ++leftIndex;
                        while (value > (*rightIndex).Value) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSortDesc<valueType>
            (valueType[] values, func<valueType, DateTime> getKey, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                if (values.Length > (config.pub.Default.StreamBufferLength >> 4))
                {
                    dateTimeSortIndex[] indexs = new dateTimeSortIndex[values.Length];
                    fixed (dateTimeSortIndex* fixedIndex = indexs)
                    {
                        return getRangeSortDesc(values, getKey, range.SkipCount, getCount, fixedIndex);
                    }
                }
                else
                {
                    dateTimeSortIndex* fixedIndex = stackalloc dateTimeSortIndex[values.Length];
                    return getRangeSortDesc(values, getKey, range.SkipCount, getCount, fixedIndex);
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSortDesc<valueType>
            (valueType[] values, func<valueType, DateTime> getKey, int skipCount, int getCount
            , dateTimeSortIndex* fixedIndex)
        {
            dateTimeSortIndex* writeIndex = fixedIndex;
            for (int index = 0; index != values.Length; ++index)
            {
                *writeIndex++ = new dateTimeSortIndex { Value = getKey(values[index]), Index = index };
            }
            return getRangeSortDesc(values, skipCount, getCount, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSortDesc<valueType>
            (valueType[] values, int skipCount, int getCount, dateTimeSortIndex* fixedIndex)
        {
            new dateTimeRangeIndexSorterDesc
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + values.Length - 1);
            valueType[] newValues = new valueType[getCount];
            dateTimeSortIndex* writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="indexs">排序索引</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSortDesc<valueType>
            (valueType[] values, dateTimeSortIndex[] indexs, int skipCount, int getCount)
        {
            if (values.length() != indexs.length()) log.Default.Throw(log.exceptionType.IndexOutOfRange);
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (dateTimeSortIndex* fixedIndex = indexs) return getRangeSortDesc(values, skipCount, getCount, fixedIndex);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSortDesc<valueType>
            (valueType[] values, int startIndex, int count, func<valueType, DateTime> getKey, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    if (getKey == null) log.Default.Throw(log.exceptionType.Null);
                    if (values.Length > (config.pub.Default.StreamBufferLength >> 4))
                    {
                        dateTimeSortIndex[] indexs = new dateTimeSortIndex[count];
                        fixed (dateTimeSortIndex* fixedIndex = indexs)
                        {
                            return getRangeSortDesc
                                (values, range.SkipCount, count, getKey, getRange.SkipCount, getCount, fixedIndex);
                        }
                    }
                    else
                    {
                        dateTimeSortIndex* fixedIndex = stackalloc dateTimeSortIndex[count];
                        return getRangeSortDesc
                            (values, range.SkipCount, count, getKey, getRange.SkipCount, getCount, fixedIndex);
                    }
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSortDesc<valueType>
            (valueType[] values, int startIndex, int count, func<valueType, DateTime> getKey, int skipCount, int getCount
            , dateTimeSortIndex* fixedIndex)
        {
            dateTimeSortIndex* writeIndex = fixedIndex;
            for (int index = startIndex, endIndex = startIndex + count; index != endIndex; ++index)
            {
                *writeIndex++ = new dateTimeSortIndex { Value = getKey(values[index]), Index = index };
            }
            new dateTimeRangeIndexSorterDesc
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + count - 1);
            valueType[] newValues = new valueType[getCount];
            writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class array
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static collection<DateTime> rangeSortDesc
            (this DateTime[] array, int skipCount, int getCount)
        {
            return algorithm.quickSort.RangeSortDesc(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static collection<DateTime> getRangeSortDesc
            (this DateTime[] array, int skipCount, int getCount)
        {
            return algorithm.quickSort.GetRangeSortDesc(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSortDesc<valueType>
            (this valueType[] array, func<valueType, DateTime> getKey, int skipCount, int getCount)
        {
            return algorithm.quickSort.GetRangeSortDesc(array, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static collection<DateTime> rangeSortDesc
            (this DateTime[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return algorithm.quickSort.RangeSortDesc(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static collection<DateTime> getRangeSortDesc
            (this DateTime[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return algorithm.quickSort.GetRangeSortDesc(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSortDesc<valueType>
            (this valueType[] array, int startIndex, int count, func<valueType, DateTime> getKey, int skipCount, int getCount)
        {
            return algorithm.quickSort.GetRangeSortDesc(array, startIndex, count, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static collection<DateTime> pageSortDesc
            (this DateTime[] array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return algorithm.quickSort.RangeSortDesc(array, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static valueType[] getPageSortDesc<valueType>
            (this valueType[] array, func<valueType, DateTime> getKey, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return algorithm.quickSort.GetRangeSortDesc(array, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static collection<DateTime> getPageSortDesc
            (this DateTime[] array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return algorithm.quickSort.GetRangeSortDesc(array, page.SkipCount, page.CurrentPageSize);
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 单向动态数组扩展
    /// </summary>
    public static partial class list
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static collection<DateTime> rangeSortDesc
            (this list<DateTime> list, int skipCount, int getCount)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.RangeSortDesc(list.Unsafer.Array, 0, list.Count, skipCount, getCount);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static collection<DateTime> getRangeSortDesc
            (this list<DateTime> list, int skipCount, int getCount)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.GetRangeSortDesc(list.Unsafer.Array, 0, list.Count, skipCount, getCount);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSortDesc<valueType>
            (this list<valueType> list, func<valueType, DateTime> getKey, int skipCount, int getCount)
        {
            if (list.count() != 0)
            {
                return algorithm.quickSort.GetRangeSortDesc
                    (list.Unsafer.Array, 0, list.Count, getKey, skipCount, getCount);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static collection<DateTime> rangeSortDesc
            (this list<DateTime> list, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.RangeSortDesc
                    (list.Unsafer.Array, range.SkipCount, count, skipCount, getCount);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static collection<DateTime> getRangeSortDesc
            (this list<DateTime> list, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.GetRangeSortDesc
                    (list.Unsafer.Array, range.SkipCount, count, skipCount, getCount);
            }
            return null;
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSortDesc<valueType>
            (this list<valueType> list, int startIndex, int count, func<valueType, DateTime> getKey
            , int skipCount, int getCount)
        {
            array.range range = new array.range(list.count(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                return algorithm.quickSort.GetRangeSortDesc
                    (list.Unsafer.Array, range.SkipCount, count, getKey, skipCount, getCount);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static collection<DateTime> pageSortDesc
            (this list<DateTime> list, int pageSize, int currentPage)
        {
            array.page page = new array.page(list.count(), pageSize, currentPage);
            int count = page.CurrentPageSize;
            if (count != 0)
            {
                return algorithm.quickSort.RangeSortDesc(list.Unsafer.Array, page.SkipCount, count);
            }
            return null;
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="list">待排序单向动态数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static collection<DateTime> getPageSortDesc
            (this list<DateTime> list, int pageSize, int currentPage)
        {
            array.page page = new array.page(list.count(), pageSize, currentPage);
            int count = page.CurrentPageSize;
            if (count != 0)
            {
                return algorithm.quickSort.GetRangeSortDesc(list.Unsafer.Array, page.SkipCount, count);
            }
            return null;
        }
    }
}
namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 排序索引
        /// </summary>
        public struct longSortIndex
        {
            /// <summary>
            /// 数值
            /// </summary>
            public long Value;
            /// <summary>
            /// 位置索引
            /// </summary>
            public int Index;

            /// <summary>
            /// 根据数组获取排序索引
            /// </summary>
            /// <typeparam name="valueType">数组类型</typeparam>
            /// <param name="values">数组</param>
            /// <param name="getValue">数据排序值获取器</param>
            /// <returns>排序索引</returns>
            public unsafe static longSortIndex[] Get<valueType>(valueType[] values, func<valueType, long> getValue)
            {
                if (values.length() != 0)
                {
                    if (getValue == null) log.Default.Throw(log.exceptionType.Null);
                    longSortIndex[] indexs = new longSortIndex[values.Length];
                    fixed (longSortIndex* indexFixed = indexs)
                    {
                        longSortIndex* write = indexFixed;
                        for (int index = 0; index != values.Length; ++index)
                        {
                            (*write).Value = getValue(values[index]);
                            (*write).Index = index;
                            ++write;
                        }
                    }
                    return indexs;
                }
                return nullValue<longSortIndex>.Array;
            }
        }
    }
}
namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 排序索引
        /// </summary>
        public struct uintSortIndex
        {
            /// <summary>
            /// 数值
            /// </summary>
            public uint Value;
            /// <summary>
            /// 位置索引
            /// </summary>
            public int Index;

            /// <summary>
            /// 根据数组获取排序索引
            /// </summary>
            /// <typeparam name="valueType">数组类型</typeparam>
            /// <param name="values">数组</param>
            /// <param name="getValue">数据排序值获取器</param>
            /// <returns>排序索引</returns>
            public unsafe static uintSortIndex[] Get<valueType>(valueType[] values, func<valueType, uint> getValue)
            {
                if (values.length() != 0)
                {
                    if (getValue == null) log.Default.Throw(log.exceptionType.Null);
                    uintSortIndex[] indexs = new uintSortIndex[values.Length];
                    fixed (uintSortIndex* indexFixed = indexs)
                    {
                        uintSortIndex* write = indexFixed;
                        for (int index = 0; index != values.Length; ++index)
                        {
                            (*write).Value = getValue(values[index]);
                            (*write).Index = index;
                            ++write;
                        }
                    }
                    return indexs;
                }
                return nullValue<uintSortIndex>.Array;
            }
        }
    }
}
namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 排序索引
        /// </summary>
        public struct intSortIndex
        {
            /// <summary>
            /// 数值
            /// </summary>
            public int Value;
            /// <summary>
            /// 位置索引
            /// </summary>
            public int Index;

            /// <summary>
            /// 根据数组获取排序索引
            /// </summary>
            /// <typeparam name="valueType">数组类型</typeparam>
            /// <param name="values">数组</param>
            /// <param name="getValue">数据排序值获取器</param>
            /// <returns>排序索引</returns>
            public unsafe static intSortIndex[] Get<valueType>(valueType[] values, func<valueType, int> getValue)
            {
                if (values.length() != 0)
                {
                    if (getValue == null) log.Default.Throw(log.exceptionType.Null);
                    intSortIndex[] indexs = new intSortIndex[values.Length];
                    fixed (intSortIndex* indexFixed = indexs)
                    {
                        intSortIndex* write = indexFixed;
                        for (int index = 0; index != values.Length; ++index)
                        {
                            (*write).Value = getValue(values[index]);
                            (*write).Index = index;
                            ++write;
                        }
                    }
                    return indexs;
                }
                return nullValue<intSortIndex>.Array;
            }
        }
    }
}
namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 排序索引
        /// </summary>
        public struct ushortSortIndex
        {
            /// <summary>
            /// 数值
            /// </summary>
            public ushort Value;
            /// <summary>
            /// 位置索引
            /// </summary>
            public int Index;

            /// <summary>
            /// 根据数组获取排序索引
            /// </summary>
            /// <typeparam name="valueType">数组类型</typeparam>
            /// <param name="values">数组</param>
            /// <param name="getValue">数据排序值获取器</param>
            /// <returns>排序索引</returns>
            public unsafe static ushortSortIndex[] Get<valueType>(valueType[] values, func<valueType, ushort> getValue)
            {
                if (values.length() != 0)
                {
                    if (getValue == null) log.Default.Throw(log.exceptionType.Null);
                    ushortSortIndex[] indexs = new ushortSortIndex[values.Length];
                    fixed (ushortSortIndex* indexFixed = indexs)
                    {
                        ushortSortIndex* write = indexFixed;
                        for (int index = 0; index != values.Length; ++index)
                        {
                            (*write).Value = getValue(values[index]);
                            (*write).Index = index;
                            ++write;
                        }
                    }
                    return indexs;
                }
                return nullValue<ushortSortIndex>.Array;
            }
        }
    }
}
namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 排序索引
        /// </summary>
        public struct shortSortIndex
        {
            /// <summary>
            /// 数值
            /// </summary>
            public short Value;
            /// <summary>
            /// 位置索引
            /// </summary>
            public int Index;

            /// <summary>
            /// 根据数组获取排序索引
            /// </summary>
            /// <typeparam name="valueType">数组类型</typeparam>
            /// <param name="values">数组</param>
            /// <param name="getValue">数据排序值获取器</param>
            /// <returns>排序索引</returns>
            public unsafe static shortSortIndex[] Get<valueType>(valueType[] values, func<valueType, short> getValue)
            {
                if (values.length() != 0)
                {
                    if (getValue == null) log.Default.Throw(log.exceptionType.Null);
                    shortSortIndex[] indexs = new shortSortIndex[values.Length];
                    fixed (shortSortIndex* indexFixed = indexs)
                    {
                        shortSortIndex* write = indexFixed;
                        for (int index = 0; index != values.Length; ++index)
                        {
                            (*write).Value = getValue(values[index]);
                            (*write).Index = index;
                            ++write;
                        }
                    }
                    return indexs;
                }
                return nullValue<shortSortIndex>.Array;
            }
        }
    }
}
namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 排序索引
        /// </summary>
        public struct byteSortIndex
        {
            /// <summary>
            /// 数值
            /// </summary>
            public byte Value;
            /// <summary>
            /// 位置索引
            /// </summary>
            public int Index;

            /// <summary>
            /// 根据数组获取排序索引
            /// </summary>
            /// <typeparam name="valueType">数组类型</typeparam>
            /// <param name="values">数组</param>
            /// <param name="getValue">数据排序值获取器</param>
            /// <returns>排序索引</returns>
            public unsafe static byteSortIndex[] Get<valueType>(valueType[] values, func<valueType, byte> getValue)
            {
                if (values.length() != 0)
                {
                    if (getValue == null) log.Default.Throw(log.exceptionType.Null);
                    byteSortIndex[] indexs = new byteSortIndex[values.Length];
                    fixed (byteSortIndex* indexFixed = indexs)
                    {
                        byteSortIndex* write = indexFixed;
                        for (int index = 0; index != values.Length; ++index)
                        {
                            (*write).Value = getValue(values[index]);
                            (*write).Index = index;
                            ++write;
                        }
                    }
                    return indexs;
                }
                return nullValue<byteSortIndex>.Array;
            }
        }
    }
}
namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 排序索引
        /// </summary>
        public struct sbyteSortIndex
        {
            /// <summary>
            /// 数值
            /// </summary>
            public sbyte Value;
            /// <summary>
            /// 位置索引
            /// </summary>
            public int Index;

            /// <summary>
            /// 根据数组获取排序索引
            /// </summary>
            /// <typeparam name="valueType">数组类型</typeparam>
            /// <param name="values">数组</param>
            /// <param name="getValue">数据排序值获取器</param>
            /// <returns>排序索引</returns>
            public unsafe static sbyteSortIndex[] Get<valueType>(valueType[] values, func<valueType, sbyte> getValue)
            {
                if (values.length() != 0)
                {
                    if (getValue == null) log.Default.Throw(log.exceptionType.Null);
                    sbyteSortIndex[] indexs = new sbyteSortIndex[values.Length];
                    fixed (sbyteSortIndex* indexFixed = indexs)
                    {
                        sbyteSortIndex* write = indexFixed;
                        for (int index = 0; index != values.Length; ++index)
                        {
                            (*write).Value = getValue(values[index]);
                            (*write).Index = index;
                            ++write;
                        }
                    }
                    return indexs;
                }
                return nullValue<sbyteSortIndex>.Array;
            }
        }
    }
}
namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 排序索引
        /// </summary>
        public struct doubleSortIndex
        {
            /// <summary>
            /// 数值
            /// </summary>
            public double Value;
            /// <summary>
            /// 位置索引
            /// </summary>
            public int Index;

            /// <summary>
            /// 根据数组获取排序索引
            /// </summary>
            /// <typeparam name="valueType">数组类型</typeparam>
            /// <param name="values">数组</param>
            /// <param name="getValue">数据排序值获取器</param>
            /// <returns>排序索引</returns>
            public unsafe static doubleSortIndex[] Get<valueType>(valueType[] values, func<valueType, double> getValue)
            {
                if (values.length() != 0)
                {
                    if (getValue == null) log.Default.Throw(log.exceptionType.Null);
                    doubleSortIndex[] indexs = new doubleSortIndex[values.Length];
                    fixed (doubleSortIndex* indexFixed = indexs)
                    {
                        doubleSortIndex* write = indexFixed;
                        for (int index = 0; index != values.Length; ++index)
                        {
                            (*write).Value = getValue(values[index]);
                            (*write).Index = index;
                            ++write;
                        }
                    }
                    return indexs;
                }
                return nullValue<doubleSortIndex>.Array;
            }
        }
    }
}
namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 排序索引
        /// </summary>
        public struct floatSortIndex
        {
            /// <summary>
            /// 数值
            /// </summary>
            public float Value;
            /// <summary>
            /// 位置索引
            /// </summary>
            public int Index;

            /// <summary>
            /// 根据数组获取排序索引
            /// </summary>
            /// <typeparam name="valueType">数组类型</typeparam>
            /// <param name="values">数组</param>
            /// <param name="getValue">数据排序值获取器</param>
            /// <returns>排序索引</returns>
            public unsafe static floatSortIndex[] Get<valueType>(valueType[] values, func<valueType, float> getValue)
            {
                if (values.length() != 0)
                {
                    if (getValue == null) log.Default.Throw(log.exceptionType.Null);
                    floatSortIndex[] indexs = new floatSortIndex[values.Length];
                    fixed (floatSortIndex* indexFixed = indexs)
                    {
                        floatSortIndex* write = indexFixed;
                        for (int index = 0; index != values.Length; ++index)
                        {
                            (*write).Value = getValue(values[index]);
                            (*write).Index = index;
                            ++write;
                        }
                    }
                    return indexs;
                }
                return nullValue<floatSortIndex>.Array;
            }
        }
    }
}
namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 排序索引
        /// </summary>
        public struct dateTimeSortIndex
        {
            /// <summary>
            /// 数值
            /// </summary>
            public DateTime Value;
            /// <summary>
            /// 位置索引
            /// </summary>
            public int Index;

            /// <summary>
            /// 根据数组获取排序索引
            /// </summary>
            /// <typeparam name="valueType">数组类型</typeparam>
            /// <param name="values">数组</param>
            /// <param name="getValue">数据排序值获取器</param>
            /// <returns>排序索引</returns>
            public unsafe static dateTimeSortIndex[] Get<valueType>(valueType[] values, func<valueType, DateTime> getValue)
            {
                if (values.length() != 0)
                {
                    if (getValue == null) log.Default.Throw(log.exceptionType.Null);
                    dateTimeSortIndex[] indexs = new dateTimeSortIndex[values.Length];
                    fixed (dateTimeSortIndex* indexFixed = indexs)
                    {
                        dateTimeSortIndex* write = indexFixed;
                        for (int index = 0; index != values.Length; ++index)
                        {
                            (*write).Value = getValue(values[index]);
                            (*write).Index = index;
                            ++write;
                        }
                    }
                    return indexs;
                }
                return nullValue<dateTimeSortIndex>.Array;
            }
        }
    }
}
namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static list<ulong> GetTopDesc(ulong[] values, int count)
        {
            if (values == null) return null;
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, count);
                    else return getRemoveTopDesc(values, count);
                }
                ulong[] newValues = new ulong[values.Length];
                Array.Copy(values, 0, newValues, 0, values.Length);
                return new list<ulong>(newValues, true);
            }
            return null;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static list<ulong> TopDesc(ulong[] values, int count)
        {
            if (values == null) return null;
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, count);
                    else return getRemoveTopDesc(values, count);
                }
                return new list<ulong>(values, true);
            }
            return null;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static list<ulong> getTopDesc(ulong[] values, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            ulong[] newValues = new ulong[length];
            fixed (ulong* newValueFixed = newValues, valueFixed = values)
            {
                ulong* readIndex = valueFixed + values.Length - length;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), newValues, 0, length * sizeof(ulong));
                //unsafer.memory.Copy(readIndex, newValueFixed, length * sizeof(ulong));
                ulong* writeStat = newValueFixed + count, writeEnd = newValueFixed + --length, writeIndex = writeStat;
                ulongRangeSorterDesc sort
                    = new ulongRangeSorterDesc
                    {
                        SkipCount = writeStat - 1, 
                        GetEndIndex = writeStat - 1
                    };
                sort.Sort(newValueFixed, writeEnd);
                for (ulong maxValue = *sort.SkipCount; readIndex != valueFixed; )
                {
                    if (*--readIndex > maxValue)
                    {
                        *writeIndex = *readIndex;
                        if (writeIndex == writeEnd)
                        {
                            sort.Sort(newValueFixed, writeEnd);
                            writeIndex = writeStat;
                            maxValue = *sort.SkipCount;
                        }
                        else ++writeIndex;
                    }
                }
                if (writeIndex != writeStat) sort.Sort(newValueFixed, --writeIndex);
            }
            return newValues.left(count);
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static list<ulong> getRemoveTopDesc
            (ulong[] values, int count)
        {
            ulong[] newValues = new ulong[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            ulong[] removeValues = new ulong[length];
            fixed (ulong* newValueFixed = newValues, removeFixed = removeValues, valueFixed = values)
            {
                int copyCount = length - count, copyLength = copyCount * sizeof(ulong);
                ulong* readIndex = valueFixed + values.Length - length, removeStart = removeFixed + copyCount;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), removeValues, 0, length * sizeof(ulong));
                //unsafer.memory.Copy(readIndex, removeFixed, length * sizeof(ulong));
                ulong* removeEnd = removeFixed + --length, removeIndex = removeStart, writeIndex = newValueFixed + copyCount;
                ulongRangeSorterDesc sort
                    = new ulongRangeSorterDesc
                    {
                        SkipCount = removeStart,
                        GetEndIndex = removeStart
                    };
                sort.Sort(removeFixed, removeEnd);
                Buffer.BlockCopy(removeValues, 0, newValues, 0, copyLength);
                //unsafer.memory.Copy(removeFixed, newValueFixed, copyLength);
                for (ulong maxValue = *removeStart; readIndex != valueFixed; )
                {
                    if (*--readIndex >= maxValue) *writeIndex++ = *readIndex;
                    else
                    {
                        *--removeIndex = *readIndex;
                        if (removeIndex == removeFixed)
                        {
                            sort.Sort(removeFixed, removeEnd);
                            removeIndex = removeStart;
                            maxValue = *removeStart;
                            Buffer.BlockCopy(removeValues, 0, newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), copyLength);
                            //unsafer.memory.Copy(removeFixed, writeIndex, copyLength);
                            writeIndex += copyCount;
                        }
                    }
                }
                if (removeIndex != removeStart)
                {
                    sort.Sort(removeIndex, removeEnd);
                    Buffer.BlockCopy(removeValues, (int)((byte*)removeIndex - (byte*)removeFixed), newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), (int)((byte*)removeStart - (byte*)removeIndex));
                    //unsafer.memory.Copy(removeIndex, writeIndex, (int)(removeStart - removeIndex) * sizeof(ulong));
                }
            }
            return new list<ulong>(newValues, true);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static valueType[] GetTopDesc<valueType>
            (valueType[] values, func<valueType, ulong> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, getKey, count);
                    else return getRemoveTopDesc(values, getKey, count);
                }
                return values.copy();
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static valueType[] TopDesc<valueType>
            (valueType[] values, func<valueType, ulong> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, getKey, count);
                    else return getRemoveTopDesc(values, getKey, count);
                }
                return values.notNull();
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getTopDesc<valueType>
            (valueType[] values, func<valueType, ulong> getKey, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            if (length > (config.pub.Default.StreamBufferLength >> 4))
            {
                ulongSortIndex[] indexs = new ulongSortIndex[length];
                fixed (ulongSortIndex* indexFixed = indexs)
                {
                    return getTopDesc(values, getKey, count, length, indexFixed);
                }
            }
            else
            {
                ulongSortIndex* indexFixed = stackalloc ulongSortIndex[length];
                return getTopDesc(values, getKey, count, length, indexFixed);
            }
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getTopDesc<valueType>
            (valueType[] values, func<valueType, ulong> getKey, int count, int length
            , ulongSortIndex* indexFixed)
        {
            ulongSortIndex* writeEnd = indexFixed;
            int index = 0;
            while (index != length)
            {
                *writeEnd++ = new ulongSortIndex { Value = getKey(values[index]), Index = index };
                ++index;
            }
            ulongSortIndex* writeStat = indexFixed + count, writeIndex = writeStat;
            ulongRangeIndexSorterDesc sort
                = new ulongRangeIndexSorterDesc
                {
                    SkipCount = writeStat - 1,
                    GetEndIndex = writeStat - 1
                };
            sort.Sort(indexFixed, --writeEnd);
            for (ulong maxValue = (*sort.SkipCount).Value; index != values.Length; ++index)
            {
                ulong value = getKey(values[index]);
                if (value > maxValue)
                {
                    *writeIndex = new ulongSortIndex { Value = value, Index = index };
                    if (writeIndex == writeEnd)
                    {
                        sort.Sort(indexFixed, writeEnd);
                        writeIndex = writeStat;
                        maxValue = (*sort.SkipCount).Value;
                    }
                    else ++writeIndex;
                }
            }
            if (writeIndex != writeStat) sort.Sort(indexFixed, --writeIndex);
            valueType[] newValues = new valueType[count];
            for (writeIndex = indexFixed, index = 0; index != count; ++index)
            {
                newValues[index] = values[(*writeIndex++).Index];
            }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getRemoveTopDesc<valueType>
            (valueType[] values, func<valueType, ulong> getKey, int count)
        {
            valueType[] newValues = new valueType[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            if (length > (config.pub.Default.StreamBufferLength >> 4))
            {
                ulongSortIndex[] removeValues = new ulongSortIndex[length];
                fixed (ulongSortIndex* removeFixed = removeValues)
                {
                    removeTopDesc(values, getKey, count, newValues, length, removeFixed);
                }
            }
            else
            {
                ulongSortIndex* removeFixed = stackalloc  ulongSortIndex[length];
                removeTopDesc(values, getKey, count, newValues, length, removeFixed);
            }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="newValues">目标数据数组</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        private unsafe static void removeTopDesc<valueType>
            (valueType[] values, func<valueType, ulong> getKey, int count, valueType[] newValues, int length
            , ulongSortIndex* removeFixed)
        {
            int index = 0, writeIndex = 0;
            ulongSortIndex* removeEnd = removeFixed;
            while (index != length)
            {
                *removeEnd++ = new ulongSortIndex { Value = getKey(values[index]), Index = index };
                ++index;
            }
            ulongSortIndex* removeStart = removeFixed + (count = length - count), removeIndex = removeFixed;
            ulongRangeIndexSorterDesc sort
                = new ulongRangeIndexSorterDesc
                {
                    SkipCount = removeStart, 
                    GetEndIndex = removeStart
                };
            sort.Sort(removeFixed, --removeEnd);
            while (writeIndex != count) newValues[writeIndex++] = values[(*removeIndex++).Index];
            for (ulong maxValue = (*removeStart).Value; index != values.Length; ++index)
            {
                ulong value = getKey(values[index]);
                if (value >= maxValue) newValues[writeIndex++] = values[index];
                else
                {
                    *--removeIndex = new ulongSortIndex { Value = value, Index = index };
                    if (removeIndex == removeFixed)
                    {
                        sort.Sort(removeFixed, removeEnd);
                        for (removeIndex = removeFixed; removeIndex != removeStart; newValues[writeIndex++] = values[(*removeIndex++).Index]) ;
                        maxValue = (*removeStart).Value;
                    }
                }
            }
            if (removeIndex != removeStart)
            {
                sort.Sort(removeIndex, removeEnd);
                while (removeIndex != removeStart) newValues[writeIndex++] = values[(*removeIndex++).Index];
            }
        }
    }
}
namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static list<long> GetTop(long[] values, int count)
        {
            if (values == null) return null;
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTop(values, count);
                    else return getRemoveTop(values, count);
                }
                long[] newValues = new long[values.Length];
                Array.Copy(values, 0, newValues, 0, values.Length);
                return new list<long>(newValues, true);
            }
            return null;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static list<long> Top(long[] values, int count)
        {
            if (values == null) return null;
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTop(values, count);
                    else return getRemoveTop(values, count);
                }
                return new list<long>(values, true);
            }
            return null;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static list<long> getTop(long[] values, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            long[] newValues = new long[length];
            fixed (long* newValueFixed = newValues, valueFixed = values)
            {
                long* readIndex = valueFixed + values.Length - length;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), newValues, 0, length * sizeof(long));
                //unsafer.memory.Copy(readIndex, newValueFixed, length * sizeof(long));
                long* writeStat = newValueFixed + count, writeEnd = newValueFixed + --length, writeIndex = writeStat;
                longRangeSorter sort
                    = new longRangeSorter
                    {
                        SkipCount = writeStat - 1, 
                        GetEndIndex = writeStat - 1
                    };
                sort.Sort(newValueFixed, writeEnd);
                for (long maxValue = *sort.SkipCount; readIndex != valueFixed; )
                {
                    if (*--readIndex < maxValue)
                    {
                        *writeIndex = *readIndex;
                        if (writeIndex == writeEnd)
                        {
                            sort.Sort(newValueFixed, writeEnd);
                            writeIndex = writeStat;
                            maxValue = *sort.SkipCount;
                        }
                        else ++writeIndex;
                    }
                }
                if (writeIndex != writeStat) sort.Sort(newValueFixed, --writeIndex);
            }
            return newValues.left(count);
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static list<long> getRemoveTop
            (long[] values, int count)
        {
            long[] newValues = new long[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            long[] removeValues = new long[length];
            fixed (long* newValueFixed = newValues, removeFixed = removeValues, valueFixed = values)
            {
                int copyCount = length - count, copyLength = copyCount * sizeof(long);
                long* readIndex = valueFixed + values.Length - length, removeStart = removeFixed + copyCount;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), removeValues, 0, length * sizeof(long));
                //unsafer.memory.Copy(readIndex, removeFixed, length * sizeof(long));
                long* removeEnd = removeFixed + --length, removeIndex = removeStart, writeIndex = newValueFixed + copyCount;
                longRangeSorter sort
                    = new longRangeSorter
                    {
                        SkipCount = removeStart,
                        GetEndIndex = removeStart
                    };
                sort.Sort(removeFixed, removeEnd);
                Buffer.BlockCopy(removeValues, 0, newValues, 0, copyLength);
                //unsafer.memory.Copy(removeFixed, newValueFixed, copyLength);
                for (long maxValue = *removeStart; readIndex != valueFixed; )
                {
                    if (*--readIndex <= maxValue) *writeIndex++ = *readIndex;
                    else
                    {
                        *--removeIndex = *readIndex;
                        if (removeIndex == removeFixed)
                        {
                            sort.Sort(removeFixed, removeEnd);
                            removeIndex = removeStart;
                            maxValue = *removeStart;
                            Buffer.BlockCopy(removeValues, 0, newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), copyLength);
                            //unsafer.memory.Copy(removeFixed, writeIndex, copyLength);
                            writeIndex += copyCount;
                        }
                    }
                }
                if (removeIndex != removeStart)
                {
                    sort.Sort(removeIndex, removeEnd);
                    Buffer.BlockCopy(removeValues, (int)((byte*)removeIndex - (byte*)removeFixed), newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), (int)((byte*)removeStart - (byte*)removeIndex));
                    //unsafer.memory.Copy(removeIndex, writeIndex, (int)(removeStart - removeIndex) * sizeof(long));
                }
            }
            return new list<long>(newValues, true);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static valueType[] GetTop<valueType>
            (valueType[] values, func<valueType, long> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTop(values, getKey, count);
                    else return getRemoveTop(values, getKey, count);
                }
                return values.copy();
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static valueType[] Top<valueType>
            (valueType[] values, func<valueType, long> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTop(values, getKey, count);
                    else return getRemoveTop(values, getKey, count);
                }
                return values.notNull();
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getTop<valueType>
            (valueType[] values, func<valueType, long> getKey, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            if (length > (config.pub.Default.StreamBufferLength >> 4))
            {
                longSortIndex[] indexs = new longSortIndex[length];
                fixed (longSortIndex* indexFixed = indexs)
                {
                    return getTop(values, getKey, count, length, indexFixed);
                }
            }
            else
            {
                longSortIndex* indexFixed = stackalloc longSortIndex[length];
                return getTop(values, getKey, count, length, indexFixed);
            }
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getTop<valueType>
            (valueType[] values, func<valueType, long> getKey, int count, int length
            , longSortIndex* indexFixed)
        {
            longSortIndex* writeEnd = indexFixed;
            int index = 0;
            while (index != length)
            {
                *writeEnd++ = new longSortIndex { Value = getKey(values[index]), Index = index };
                ++index;
            }
            longSortIndex* writeStat = indexFixed + count, writeIndex = writeStat;
            longRangeIndexSorter sort
                = new longRangeIndexSorter
                {
                    SkipCount = writeStat - 1,
                    GetEndIndex = writeStat - 1
                };
            sort.Sort(indexFixed, --writeEnd);
            for (long maxValue = (*sort.SkipCount).Value; index != values.Length; ++index)
            {
                long value = getKey(values[index]);
                if (value < maxValue)
                {
                    *writeIndex = new longSortIndex { Value = value, Index = index };
                    if (writeIndex == writeEnd)
                    {
                        sort.Sort(indexFixed, writeEnd);
                        writeIndex = writeStat;
                        maxValue = (*sort.SkipCount).Value;
                    }
                    else ++writeIndex;
                }
            }
            if (writeIndex != writeStat) sort.Sort(indexFixed, --writeIndex);
            valueType[] newValues = new valueType[count];
            for (writeIndex = indexFixed, index = 0; index != count; ++index)
            {
                newValues[index] = values[(*writeIndex++).Index];
            }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getRemoveTop<valueType>
            (valueType[] values, func<valueType, long> getKey, int count)
        {
            valueType[] newValues = new valueType[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            if (length > (config.pub.Default.StreamBufferLength >> 4))
            {
                longSortIndex[] removeValues = new longSortIndex[length];
                fixed (longSortIndex* removeFixed = removeValues)
                {
                    removeTop(values, getKey, count, newValues, length, removeFixed);
                }
            }
            else
            {
                longSortIndex* removeFixed = stackalloc  longSortIndex[length];
                removeTop(values, getKey, count, newValues, length, removeFixed);
            }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="newValues">目标数据数组</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        private unsafe static void removeTop<valueType>
            (valueType[] values, func<valueType, long> getKey, int count, valueType[] newValues, int length
            , longSortIndex* removeFixed)
        {
            int index = 0, writeIndex = 0;
            longSortIndex* removeEnd = removeFixed;
            while (index != length)
            {
                *removeEnd++ = new longSortIndex { Value = getKey(values[index]), Index = index };
                ++index;
            }
            longSortIndex* removeStart = removeFixed + (count = length - count), removeIndex = removeFixed;
            longRangeIndexSorter sort
                = new longRangeIndexSorter
                {
                    SkipCount = removeStart, 
                    GetEndIndex = removeStart
                };
            sort.Sort(removeFixed, --removeEnd);
            while (writeIndex != count) newValues[writeIndex++] = values[(*removeIndex++).Index];
            for (long maxValue = (*removeStart).Value; index != values.Length; ++index)
            {
                long value = getKey(values[index]);
                if (value <= maxValue) newValues[writeIndex++] = values[index];
                else
                {
                    *--removeIndex = new longSortIndex { Value = value, Index = index };
                    if (removeIndex == removeFixed)
                    {
                        sort.Sort(removeFixed, removeEnd);
                        for (removeIndex = removeFixed; removeIndex != removeStart; newValues[writeIndex++] = values[(*removeIndex++).Index]) ;
                        maxValue = (*removeStart).Value;
                    }
                }
            }
            if (removeIndex != removeStart)
            {
                sort.Sort(removeIndex, removeEnd);
                while (removeIndex != removeStart) newValues[writeIndex++] = values[(*removeIndex++).Index];
            }
        }
    }
}
namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static list<long> GetTopDesc(long[] values, int count)
        {
            if (values == null) return null;
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, count);
                    else return getRemoveTopDesc(values, count);
                }
                long[] newValues = new long[values.Length];
                Array.Copy(values, 0, newValues, 0, values.Length);
                return new list<long>(newValues, true);
            }
            return null;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static list<long> TopDesc(long[] values, int count)
        {
            if (values == null) return null;
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, count);
                    else return getRemoveTopDesc(values, count);
                }
                return new list<long>(values, true);
            }
            return null;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static list<long> getTopDesc(long[] values, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            long[] newValues = new long[length];
            fixed (long* newValueFixed = newValues, valueFixed = values)
            {
                long* readIndex = valueFixed + values.Length - length;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), newValues, 0, length * sizeof(long));
                //unsafer.memory.Copy(readIndex, newValueFixed, length * sizeof(long));
                long* writeStat = newValueFixed + count, writeEnd = newValueFixed + --length, writeIndex = writeStat;
                longRangeSorterDesc sort
                    = new longRangeSorterDesc
                    {
                        SkipCount = writeStat - 1, 
                        GetEndIndex = writeStat - 1
                    };
                sort.Sort(newValueFixed, writeEnd);
                for (long maxValue = *sort.SkipCount; readIndex != valueFixed; )
                {
                    if (*--readIndex > maxValue)
                    {
                        *writeIndex = *readIndex;
                        if (writeIndex == writeEnd)
                        {
                            sort.Sort(newValueFixed, writeEnd);
                            writeIndex = writeStat;
                            maxValue = *sort.SkipCount;
                        }
                        else ++writeIndex;
                    }
                }
                if (writeIndex != writeStat) sort.Sort(newValueFixed, --writeIndex);
            }
            return newValues.left(count);
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static list<long> getRemoveTopDesc
            (long[] values, int count)
        {
            long[] newValues = new long[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            long[] removeValues = new long[length];
            fixed (long* newValueFixed = newValues, removeFixed = removeValues, valueFixed = values)
            {
                int copyCount = length - count, copyLength = copyCount * sizeof(long);
                long* readIndex = valueFixed + values.Length - length, removeStart = removeFixed + copyCount;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), removeValues, 0, length * sizeof(long));
                //unsafer.memory.Copy(readIndex, removeFixed, length * sizeof(long));
                long* removeEnd = removeFixed + --length, removeIndex = removeStart, writeIndex = newValueFixed + copyCount;
                longRangeSorterDesc sort
                    = new longRangeSorterDesc
                    {
                        SkipCount = removeStart,
                        GetEndIndex = removeStart
                    };
                sort.Sort(removeFixed, removeEnd);
                Buffer.BlockCopy(removeValues, 0, newValues, 0, copyLength);
                //unsafer.memory.Copy(removeFixed, newValueFixed, copyLength);
                for (long maxValue = *removeStart; readIndex != valueFixed; )
                {
                    if (*--readIndex >= maxValue) *writeIndex++ = *readIndex;
                    else
                    {
                        *--removeIndex = *readIndex;
                        if (removeIndex == removeFixed)
                        {
                            sort.Sort(removeFixed, removeEnd);
                            removeIndex = removeStart;
                            maxValue = *removeStart;
                            Buffer.BlockCopy(removeValues, 0, newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), copyLength);
                            //unsafer.memory.Copy(removeFixed, writeIndex, copyLength);
                            writeIndex += copyCount;
                        }
                    }
                }
                if (removeIndex != removeStart)
                {
                    sort.Sort(removeIndex, removeEnd);
                    Buffer.BlockCopy(removeValues, (int)((byte*)removeIndex - (byte*)removeFixed), newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), (int)((byte*)removeStart - (byte*)removeIndex));
                    //unsafer.memory.Copy(removeIndex, writeIndex, (int)(removeStart - removeIndex) * sizeof(long));
                }
            }
            return new list<long>(newValues, true);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static valueType[] GetTopDesc<valueType>
            (valueType[] values, func<valueType, long> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, getKey, count);
                    else return getRemoveTopDesc(values, getKey, count);
                }
                return values.copy();
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static valueType[] TopDesc<valueType>
            (valueType[] values, func<valueType, long> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, getKey, count);
                    else return getRemoveTopDesc(values, getKey, count);
                }
                return values.notNull();
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getTopDesc<valueType>
            (valueType[] values, func<valueType, long> getKey, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            if (length > (config.pub.Default.StreamBufferLength >> 4))
            {
                longSortIndex[] indexs = new longSortIndex[length];
                fixed (longSortIndex* indexFixed = indexs)
                {
                    return getTopDesc(values, getKey, count, length, indexFixed);
                }
            }
            else
            {
                longSortIndex* indexFixed = stackalloc longSortIndex[length];
                return getTopDesc(values, getKey, count, length, indexFixed);
            }
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getTopDesc<valueType>
            (valueType[] values, func<valueType, long> getKey, int count, int length
            , longSortIndex* indexFixed)
        {
            longSortIndex* writeEnd = indexFixed;
            int index = 0;
            while (index != length)
            {
                *writeEnd++ = new longSortIndex { Value = getKey(values[index]), Index = index };
                ++index;
            }
            longSortIndex* writeStat = indexFixed + count, writeIndex = writeStat;
            longRangeIndexSorterDesc sort
                = new longRangeIndexSorterDesc
                {
                    SkipCount = writeStat - 1,
                    GetEndIndex = writeStat - 1
                };
            sort.Sort(indexFixed, --writeEnd);
            for (long maxValue = (*sort.SkipCount).Value; index != values.Length; ++index)
            {
                long value = getKey(values[index]);
                if (value > maxValue)
                {
                    *writeIndex = new longSortIndex { Value = value, Index = index };
                    if (writeIndex == writeEnd)
                    {
                        sort.Sort(indexFixed, writeEnd);
                        writeIndex = writeStat;
                        maxValue = (*sort.SkipCount).Value;
                    }
                    else ++writeIndex;
                }
            }
            if (writeIndex != writeStat) sort.Sort(indexFixed, --writeIndex);
            valueType[] newValues = new valueType[count];
            for (writeIndex = indexFixed, index = 0; index != count; ++index)
            {
                newValues[index] = values[(*writeIndex++).Index];
            }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getRemoveTopDesc<valueType>
            (valueType[] values, func<valueType, long> getKey, int count)
        {
            valueType[] newValues = new valueType[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            if (length > (config.pub.Default.StreamBufferLength >> 4))
            {
                longSortIndex[] removeValues = new longSortIndex[length];
                fixed (longSortIndex* removeFixed = removeValues)
                {
                    removeTopDesc(values, getKey, count, newValues, length, removeFixed);
                }
            }
            else
            {
                longSortIndex* removeFixed = stackalloc  longSortIndex[length];
                removeTopDesc(values, getKey, count, newValues, length, removeFixed);
            }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="newValues">目标数据数组</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        private unsafe static void removeTopDesc<valueType>
            (valueType[] values, func<valueType, long> getKey, int count, valueType[] newValues, int length
            , longSortIndex* removeFixed)
        {
            int index = 0, writeIndex = 0;
            longSortIndex* removeEnd = removeFixed;
            while (index != length)
            {
                *removeEnd++ = new longSortIndex { Value = getKey(values[index]), Index = index };
                ++index;
            }
            longSortIndex* removeStart = removeFixed + (count = length - count), removeIndex = removeFixed;
            longRangeIndexSorterDesc sort
                = new longRangeIndexSorterDesc
                {
                    SkipCount = removeStart, 
                    GetEndIndex = removeStart
                };
            sort.Sort(removeFixed, --removeEnd);
            while (writeIndex != count) newValues[writeIndex++] = values[(*removeIndex++).Index];
            for (long maxValue = (*removeStart).Value; index != values.Length; ++index)
            {
                long value = getKey(values[index]);
                if (value >= maxValue) newValues[writeIndex++] = values[index];
                else
                {
                    *--removeIndex = new longSortIndex { Value = value, Index = index };
                    if (removeIndex == removeFixed)
                    {
                        sort.Sort(removeFixed, removeEnd);
                        for (removeIndex = removeFixed; removeIndex != removeStart; newValues[writeIndex++] = values[(*removeIndex++).Index]) ;
                        maxValue = (*removeStart).Value;
                    }
                }
            }
            if (removeIndex != removeStart)
            {
                sort.Sort(removeIndex, removeEnd);
                while (removeIndex != removeStart) newValues[writeIndex++] = values[(*removeIndex++).Index];
            }
        }
    }
}
namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static list<uint> GetTop(uint[] values, int count)
        {
            if (values == null) return null;
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTop(values, count);
                    else return getRemoveTop(values, count);
                }
                uint[] newValues = new uint[values.Length];
                Array.Copy(values, 0, newValues, 0, values.Length);
                return new list<uint>(newValues, true);
            }
            return null;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static list<uint> Top(uint[] values, int count)
        {
            if (values == null) return null;
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTop(values, count);
                    else return getRemoveTop(values, count);
                }
                return new list<uint>(values, true);
            }
            return null;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static list<uint> getTop(uint[] values, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            uint[] newValues = new uint[length];
            fixed (uint* newValueFixed = newValues, valueFixed = values)
            {
                uint* readIndex = valueFixed + values.Length - length;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), newValues, 0, length * sizeof(uint));
                //unsafer.memory.Copy(readIndex, newValueFixed, length * sizeof(uint));
                uint* writeStat = newValueFixed + count, writeEnd = newValueFixed + --length, writeIndex = writeStat;
                uintRangeSorter sort
                    = new uintRangeSorter
                    {
                        SkipCount = writeStat - 1, 
                        GetEndIndex = writeStat - 1
                    };
                sort.Sort(newValueFixed, writeEnd);
                for (uint maxValue = *sort.SkipCount; readIndex != valueFixed; )
                {
                    if (*--readIndex < maxValue)
                    {
                        *writeIndex = *readIndex;
                        if (writeIndex == writeEnd)
                        {
                            sort.Sort(newValueFixed, writeEnd);
                            writeIndex = writeStat;
                            maxValue = *sort.SkipCount;
                        }
                        else ++writeIndex;
                    }
                }
                if (writeIndex != writeStat) sort.Sort(newValueFixed, --writeIndex);
            }
            return newValues.left(count);
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static list<uint> getRemoveTop
            (uint[] values, int count)
        {
            uint[] newValues = new uint[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            uint[] removeValues = new uint[length];
            fixed (uint* newValueFixed = newValues, removeFixed = removeValues, valueFixed = values)
            {
                int copyCount = length - count, copyLength = copyCount * sizeof(uint);
                uint* readIndex = valueFixed + values.Length - length, removeStart = removeFixed + copyCount;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), removeValues, 0, length * sizeof(uint));
                //unsafer.memory.Copy(readIndex, removeFixed, length * sizeof(uint));
                uint* removeEnd = removeFixed + --length, removeIndex = removeStart, writeIndex = newValueFixed + copyCount;
                uintRangeSorter sort
                    = new uintRangeSorter
                    {
                        SkipCount = removeStart,
                        GetEndIndex = removeStart
                    };
                sort.Sort(removeFixed, removeEnd);
                Buffer.BlockCopy(removeValues, 0, newValues, 0, copyLength);
                //unsafer.memory.Copy(removeFixed, newValueFixed, copyLength);
                for (uint maxValue = *removeStart; readIndex != valueFixed; )
                {
                    if (*--readIndex <= maxValue) *writeIndex++ = *readIndex;
                    else
                    {
                        *--removeIndex = *readIndex;
                        if (removeIndex == removeFixed)
                        {
                            sort.Sort(removeFixed, removeEnd);
                            removeIndex = removeStart;
                            maxValue = *removeStart;
                            Buffer.BlockCopy(removeValues, 0, newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), copyLength);
                            //unsafer.memory.Copy(removeFixed, writeIndex, copyLength);
                            writeIndex += copyCount;
                        }
                    }
                }
                if (removeIndex != removeStart)
                {
                    sort.Sort(removeIndex, removeEnd);
                    Buffer.BlockCopy(removeValues, (int)((byte*)removeIndex - (byte*)removeFixed), newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), (int)((byte*)removeStart - (byte*)removeIndex));
                    //unsafer.memory.Copy(removeIndex, writeIndex, (int)(removeStart - removeIndex) * sizeof(uint));
                }
            }
            return new list<uint>(newValues, true);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static valueType[] GetTop<valueType>
            (valueType[] values, func<valueType, uint> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTop(values, getKey, count);
                    else return getRemoveTop(values, getKey, count);
                }
                return values.copy();
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static valueType[] Top<valueType>
            (valueType[] values, func<valueType, uint> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTop(values, getKey, count);
                    else return getRemoveTop(values, getKey, count);
                }
                return values.notNull();
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getTop<valueType>
            (valueType[] values, func<valueType, uint> getKey, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            if (length > (config.pub.Default.StreamBufferLength >> 4))
            {
                uintSortIndex[] indexs = new uintSortIndex[length];
                fixed (uintSortIndex* indexFixed = indexs)
                {
                    return getTop(values, getKey, count, length, indexFixed);
                }
            }
            else
            {
                uintSortIndex* indexFixed = stackalloc uintSortIndex[length];
                return getTop(values, getKey, count, length, indexFixed);
            }
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getTop<valueType>
            (valueType[] values, func<valueType, uint> getKey, int count, int length
            , uintSortIndex* indexFixed)
        {
            uintSortIndex* writeEnd = indexFixed;
            int index = 0;
            while (index != length)
            {
                *writeEnd++ = new uintSortIndex { Value = getKey(values[index]), Index = index };
                ++index;
            }
            uintSortIndex* writeStat = indexFixed + count, writeIndex = writeStat;
            uintRangeIndexSorter sort
                = new uintRangeIndexSorter
                {
                    SkipCount = writeStat - 1,
                    GetEndIndex = writeStat - 1
                };
            sort.Sort(indexFixed, --writeEnd);
            for (uint maxValue = (*sort.SkipCount).Value; index != values.Length; ++index)
            {
                uint value = getKey(values[index]);
                if (value < maxValue)
                {
                    *writeIndex = new uintSortIndex { Value = value, Index = index };
                    if (writeIndex == writeEnd)
                    {
                        sort.Sort(indexFixed, writeEnd);
                        writeIndex = writeStat;
                        maxValue = (*sort.SkipCount).Value;
                    }
                    else ++writeIndex;
                }
            }
            if (writeIndex != writeStat) sort.Sort(indexFixed, --writeIndex);
            valueType[] newValues = new valueType[count];
            for (writeIndex = indexFixed, index = 0; index != count; ++index)
            {
                newValues[index] = values[(*writeIndex++).Index];
            }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getRemoveTop<valueType>
            (valueType[] values, func<valueType, uint> getKey, int count)
        {
            valueType[] newValues = new valueType[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            if (length > (config.pub.Default.StreamBufferLength >> 4))
            {
                uintSortIndex[] removeValues = new uintSortIndex[length];
                fixed (uintSortIndex* removeFixed = removeValues)
                {
                    removeTop(values, getKey, count, newValues, length, removeFixed);
                }
            }
            else
            {
                uintSortIndex* removeFixed = stackalloc  uintSortIndex[length];
                removeTop(values, getKey, count, newValues, length, removeFixed);
            }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="newValues">目标数据数组</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        private unsafe static void removeTop<valueType>
            (valueType[] values, func<valueType, uint> getKey, int count, valueType[] newValues, int length
            , uintSortIndex* removeFixed)
        {
            int index = 0, writeIndex = 0;
            uintSortIndex* removeEnd = removeFixed;
            while (index != length)
            {
                *removeEnd++ = new uintSortIndex { Value = getKey(values[index]), Index = index };
                ++index;
            }
            uintSortIndex* removeStart = removeFixed + (count = length - count), removeIndex = removeFixed;
            uintRangeIndexSorter sort
                = new uintRangeIndexSorter
                {
                    SkipCount = removeStart, 
                    GetEndIndex = removeStart
                };
            sort.Sort(removeFixed, --removeEnd);
            while (writeIndex != count) newValues[writeIndex++] = values[(*removeIndex++).Index];
            for (uint maxValue = (*removeStart).Value; index != values.Length; ++index)
            {
                uint value = getKey(values[index]);
                if (value <= maxValue) newValues[writeIndex++] = values[index];
                else
                {
                    *--removeIndex = new uintSortIndex { Value = value, Index = index };
                    if (removeIndex == removeFixed)
                    {
                        sort.Sort(removeFixed, removeEnd);
                        for (removeIndex = removeFixed; removeIndex != removeStart; newValues[writeIndex++] = values[(*removeIndex++).Index]) ;
                        maxValue = (*removeStart).Value;
                    }
                }
            }
            if (removeIndex != removeStart)
            {
                sort.Sort(removeIndex, removeEnd);
                while (removeIndex != removeStart) newValues[writeIndex++] = values[(*removeIndex++).Index];
            }
        }
    }
}
namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static list<uint> GetTopDesc(uint[] values, int count)
        {
            if (values == null) return null;
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, count);
                    else return getRemoveTopDesc(values, count);
                }
                uint[] newValues = new uint[values.Length];
                Array.Copy(values, 0, newValues, 0, values.Length);
                return new list<uint>(newValues, true);
            }
            return null;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static list<uint> TopDesc(uint[] values, int count)
        {
            if (values == null) return null;
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, count);
                    else return getRemoveTopDesc(values, count);
                }
                return new list<uint>(values, true);
            }
            return null;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static list<uint> getTopDesc(uint[] values, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            uint[] newValues = new uint[length];
            fixed (uint* newValueFixed = newValues, valueFixed = values)
            {
                uint* readIndex = valueFixed + values.Length - length;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), newValues, 0, length * sizeof(uint));
                //unsafer.memory.Copy(readIndex, newValueFixed, length * sizeof(uint));
                uint* writeStat = newValueFixed + count, writeEnd = newValueFixed + --length, writeIndex = writeStat;
                uintRangeSorterDesc sort
                    = new uintRangeSorterDesc
                    {
                        SkipCount = writeStat - 1, 
                        GetEndIndex = writeStat - 1
                    };
                sort.Sort(newValueFixed, writeEnd);
                for (uint maxValue = *sort.SkipCount; readIndex != valueFixed; )
                {
                    if (*--readIndex > maxValue)
                    {
                        *writeIndex = *readIndex;
                        if (writeIndex == writeEnd)
                        {
                            sort.Sort(newValueFixed, writeEnd);
                            writeIndex = writeStat;
                            maxValue = *sort.SkipCount;
                        }
                        else ++writeIndex;
                    }
                }
                if (writeIndex != writeStat) sort.Sort(newValueFixed, --writeIndex);
            }
            return newValues.left(count);
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static list<uint> getRemoveTopDesc
            (uint[] values, int count)
        {
            uint[] newValues = new uint[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            uint[] removeValues = new uint[length];
            fixed (uint* newValueFixed = newValues, removeFixed = removeValues, valueFixed = values)
            {
                int copyCount = length - count, copyLength = copyCount * sizeof(uint);
                uint* readIndex = valueFixed + values.Length - length, removeStart = removeFixed + copyCount;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), removeValues, 0, length * sizeof(uint));
                //unsafer.memory.Copy(readIndex, removeFixed, length * sizeof(uint));
                uint* removeEnd = removeFixed + --length, removeIndex = removeStart, writeIndex = newValueFixed + copyCount;
                uintRangeSorterDesc sort
                    = new uintRangeSorterDesc
                    {
                        SkipCount = removeStart,
                        GetEndIndex = removeStart
                    };
                sort.Sort(removeFixed, removeEnd);
                Buffer.BlockCopy(removeValues, 0, newValues, 0, copyLength);
                //unsafer.memory.Copy(removeFixed, newValueFixed, copyLength);
                for (uint maxValue = *removeStart; readIndex != valueFixed; )
                {
                    if (*--readIndex >= maxValue) *writeIndex++ = *readIndex;
                    else
                    {
                        *--removeIndex = *readIndex;
                        if (removeIndex == removeFixed)
                        {
                            sort.Sort(removeFixed, removeEnd);
                            removeIndex = removeStart;
                            maxValue = *removeStart;
                            Buffer.BlockCopy(removeValues, 0, newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), copyLength);
                            //unsafer.memory.Copy(removeFixed, writeIndex, copyLength);
                            writeIndex += copyCount;
                        }
                    }
                }
                if (removeIndex != removeStart)
                {
                    sort.Sort(removeIndex, removeEnd);
                    Buffer.BlockCopy(removeValues, (int)((byte*)removeIndex - (byte*)removeFixed), newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), (int)((byte*)removeStart - (byte*)removeIndex));
                    //unsafer.memory.Copy(removeIndex, writeIndex, (int)(removeStart - removeIndex) * sizeof(uint));
                }
            }
            return new list<uint>(newValues, true);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static valueType[] GetTopDesc<valueType>
            (valueType[] values, func<valueType, uint> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, getKey, count);
                    else return getRemoveTopDesc(values, getKey, count);
                }
                return values.copy();
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static valueType[] TopDesc<valueType>
            (valueType[] values, func<valueType, uint> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, getKey, count);
                    else return getRemoveTopDesc(values, getKey, count);
                }
                return values.notNull();
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getTopDesc<valueType>
            (valueType[] values, func<valueType, uint> getKey, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            if (length > (config.pub.Default.StreamBufferLength >> 4))
            {
                uintSortIndex[] indexs = new uintSortIndex[length];
                fixed (uintSortIndex* indexFixed = indexs)
                {
                    return getTopDesc(values, getKey, count, length, indexFixed);
                }
            }
            else
            {
                uintSortIndex* indexFixed = stackalloc uintSortIndex[length];
                return getTopDesc(values, getKey, count, length, indexFixed);
            }
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getTopDesc<valueType>
            (valueType[] values, func<valueType, uint> getKey, int count, int length
            , uintSortIndex* indexFixed)
        {
            uintSortIndex* writeEnd = indexFixed;
            int index = 0;
            while (index != length)
            {
                *writeEnd++ = new uintSortIndex { Value = getKey(values[index]), Index = index };
                ++index;
            }
            uintSortIndex* writeStat = indexFixed + count, writeIndex = writeStat;
            uintRangeIndexSorterDesc sort
                = new uintRangeIndexSorterDesc
                {
                    SkipCount = writeStat - 1,
                    GetEndIndex = writeStat - 1
                };
            sort.Sort(indexFixed, --writeEnd);
            for (uint maxValue = (*sort.SkipCount).Value; index != values.Length; ++index)
            {
                uint value = getKey(values[index]);
                if (value > maxValue)
                {
                    *writeIndex = new uintSortIndex { Value = value, Index = index };
                    if (writeIndex == writeEnd)
                    {
                        sort.Sort(indexFixed, writeEnd);
                        writeIndex = writeStat;
                        maxValue = (*sort.SkipCount).Value;
                    }
                    else ++writeIndex;
                }
            }
            if (writeIndex != writeStat) sort.Sort(indexFixed, --writeIndex);
            valueType[] newValues = new valueType[count];
            for (writeIndex = indexFixed, index = 0; index != count; ++index)
            {
                newValues[index] = values[(*writeIndex++).Index];
            }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getRemoveTopDesc<valueType>
            (valueType[] values, func<valueType, uint> getKey, int count)
        {
            valueType[] newValues = new valueType[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            if (length > (config.pub.Default.StreamBufferLength >> 4))
            {
                uintSortIndex[] removeValues = new uintSortIndex[length];
                fixed (uintSortIndex* removeFixed = removeValues)
                {
                    removeTopDesc(values, getKey, count, newValues, length, removeFixed);
                }
            }
            else
            {
                uintSortIndex* removeFixed = stackalloc  uintSortIndex[length];
                removeTopDesc(values, getKey, count, newValues, length, removeFixed);
            }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="newValues">目标数据数组</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        private unsafe static void removeTopDesc<valueType>
            (valueType[] values, func<valueType, uint> getKey, int count, valueType[] newValues, int length
            , uintSortIndex* removeFixed)
        {
            int index = 0, writeIndex = 0;
            uintSortIndex* removeEnd = removeFixed;
            while (index != length)
            {
                *removeEnd++ = new uintSortIndex { Value = getKey(values[index]), Index = index };
                ++index;
            }
            uintSortIndex* removeStart = removeFixed + (count = length - count), removeIndex = removeFixed;
            uintRangeIndexSorterDesc sort
                = new uintRangeIndexSorterDesc
                {
                    SkipCount = removeStart, 
                    GetEndIndex = removeStart
                };
            sort.Sort(removeFixed, --removeEnd);
            while (writeIndex != count) newValues[writeIndex++] = values[(*removeIndex++).Index];
            for (uint maxValue = (*removeStart).Value; index != values.Length; ++index)
            {
                uint value = getKey(values[index]);
                if (value >= maxValue) newValues[writeIndex++] = values[index];
                else
                {
                    *--removeIndex = new uintSortIndex { Value = value, Index = index };
                    if (removeIndex == removeFixed)
                    {
                        sort.Sort(removeFixed, removeEnd);
                        for (removeIndex = removeFixed; removeIndex != removeStart; newValues[writeIndex++] = values[(*removeIndex++).Index]) ;
                        maxValue = (*removeStart).Value;
                    }
                }
            }
            if (removeIndex != removeStart)
            {
                sort.Sort(removeIndex, removeEnd);
                while (removeIndex != removeStart) newValues[writeIndex++] = values[(*removeIndex++).Index];
            }
        }
    }
}
namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static list<int> GetTop(int[] values, int count)
        {
            if (values == null) return null;
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTop(values, count);
                    else return getRemoveTop(values, count);
                }
                int[] newValues = new int[values.Length];
                Array.Copy(values, 0, newValues, 0, values.Length);
                return new list<int>(newValues, true);
            }
            return null;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static list<int> Top(int[] values, int count)
        {
            if (values == null) return null;
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTop(values, count);
                    else return getRemoveTop(values, count);
                }
                return new list<int>(values, true);
            }
            return null;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static list<int> getTop(int[] values, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            int[] newValues = new int[length];
            fixed (int* newValueFixed = newValues, valueFixed = values)
            {
                int* readIndex = valueFixed + values.Length - length;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), newValues, 0, length * sizeof(int));
                //unsafer.memory.Copy(readIndex, newValueFixed, length * sizeof(int));
                int* writeStat = newValueFixed + count, writeEnd = newValueFixed + --length, writeIndex = writeStat;
                intRangeSorter sort
                    = new intRangeSorter
                    {
                        SkipCount = writeStat - 1, 
                        GetEndIndex = writeStat - 1
                    };
                sort.Sort(newValueFixed, writeEnd);
                for (int maxValue = *sort.SkipCount; readIndex != valueFixed; )
                {
                    if (*--readIndex < maxValue)
                    {
                        *writeIndex = *readIndex;
                        if (writeIndex == writeEnd)
                        {
                            sort.Sort(newValueFixed, writeEnd);
                            writeIndex = writeStat;
                            maxValue = *sort.SkipCount;
                        }
                        else ++writeIndex;
                    }
                }
                if (writeIndex != writeStat) sort.Sort(newValueFixed, --writeIndex);
            }
            return newValues.left(count);
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static list<int> getRemoveTop
            (int[] values, int count)
        {
            int[] newValues = new int[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            int[] removeValues = new int[length];
            fixed (int* newValueFixed = newValues, removeFixed = removeValues, valueFixed = values)
            {
                int copyCount = length - count, copyLength = copyCount * sizeof(int);
                int* readIndex = valueFixed + values.Length - length, removeStart = removeFixed + copyCount;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), removeValues, 0, length * sizeof(int));
                //unsafer.memory.Copy(readIndex, removeFixed, length * sizeof(int));
                int* removeEnd = removeFixed + --length, removeIndex = removeStart, writeIndex = newValueFixed + copyCount;
                intRangeSorter sort
                    = new intRangeSorter
                    {
                        SkipCount = removeStart,
                        GetEndIndex = removeStart
                    };
                sort.Sort(removeFixed, removeEnd);
                Buffer.BlockCopy(removeValues, 0, newValues, 0, copyLength);
                //unsafer.memory.Copy(removeFixed, newValueFixed, copyLength);
                for (int maxValue = *removeStart; readIndex != valueFixed; )
                {
                    if (*--readIndex <= maxValue) *writeIndex++ = *readIndex;
                    else
                    {
                        *--removeIndex = *readIndex;
                        if (removeIndex == removeFixed)
                        {
                            sort.Sort(removeFixed, removeEnd);
                            removeIndex = removeStart;
                            maxValue = *removeStart;
                            Buffer.BlockCopy(removeValues, 0, newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), copyLength);
                            //unsafer.memory.Copy(removeFixed, writeIndex, copyLength);
                            writeIndex += copyCount;
                        }
                    }
                }
                if (removeIndex != removeStart)
                {
                    sort.Sort(removeIndex, removeEnd);
                    Buffer.BlockCopy(removeValues, (int)((byte*)removeIndex - (byte*)removeFixed), newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), (int)((byte*)removeStart - (byte*)removeIndex));
                    //unsafer.memory.Copy(removeIndex, writeIndex, (int)(removeStart - removeIndex) * sizeof(int));
                }
            }
            return new list<int>(newValues, true);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static valueType[] GetTop<valueType>
            (valueType[] values, func<valueType, int> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTop(values, getKey, count);
                    else return getRemoveTop(values, getKey, count);
                }
                return values.copy();
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static valueType[] Top<valueType>
            (valueType[] values, func<valueType, int> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTop(values, getKey, count);
                    else return getRemoveTop(values, getKey, count);
                }
                return values.notNull();
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getTop<valueType>
            (valueType[] values, func<valueType, int> getKey, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            if (length > (config.pub.Default.StreamBufferLength >> 4))
            {
                intSortIndex[] indexs = new intSortIndex[length];
                fixed (intSortIndex* indexFixed = indexs)
                {
                    return getTop(values, getKey, count, length, indexFixed);
                }
            }
            else
            {
                intSortIndex* indexFixed = stackalloc intSortIndex[length];
                return getTop(values, getKey, count, length, indexFixed);
            }
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getTop<valueType>
            (valueType[] values, func<valueType, int> getKey, int count, int length
            , intSortIndex* indexFixed)
        {
            intSortIndex* writeEnd = indexFixed;
            int index = 0;
            while (index != length)
            {
                *writeEnd++ = new intSortIndex { Value = getKey(values[index]), Index = index };
                ++index;
            }
            intSortIndex* writeStat = indexFixed + count, writeIndex = writeStat;
            intRangeIndexSorter sort
                = new intRangeIndexSorter
                {
                    SkipCount = writeStat - 1,
                    GetEndIndex = writeStat - 1
                };
            sort.Sort(indexFixed, --writeEnd);
            for (int maxValue = (*sort.SkipCount).Value; index != values.Length; ++index)
            {
                int value = getKey(values[index]);
                if (value < maxValue)
                {
                    *writeIndex = new intSortIndex { Value = value, Index = index };
                    if (writeIndex == writeEnd)
                    {
                        sort.Sort(indexFixed, writeEnd);
                        writeIndex = writeStat;
                        maxValue = (*sort.SkipCount).Value;
                    }
                    else ++writeIndex;
                }
            }
            if (writeIndex != writeStat) sort.Sort(indexFixed, --writeIndex);
            valueType[] newValues = new valueType[count];
            for (writeIndex = indexFixed, index = 0; index != count; ++index)
            {
                newValues[index] = values[(*writeIndex++).Index];
            }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getRemoveTop<valueType>
            (valueType[] values, func<valueType, int> getKey, int count)
        {
            valueType[] newValues = new valueType[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            if (length > (config.pub.Default.StreamBufferLength >> 4))
            {
                intSortIndex[] removeValues = new intSortIndex[length];
                fixed (intSortIndex* removeFixed = removeValues)
                {
                    removeTop(values, getKey, count, newValues, length, removeFixed);
                }
            }
            else
            {
                intSortIndex* removeFixed = stackalloc  intSortIndex[length];
                removeTop(values, getKey, count, newValues, length, removeFixed);
            }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="newValues">目标数据数组</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        private unsafe static void removeTop<valueType>
            (valueType[] values, func<valueType, int> getKey, int count, valueType[] newValues, int length
            , intSortIndex* removeFixed)
        {
            int index = 0, writeIndex = 0;
            intSortIndex* removeEnd = removeFixed;
            while (index != length)
            {
                *removeEnd++ = new intSortIndex { Value = getKey(values[index]), Index = index };
                ++index;
            }
            intSortIndex* removeStart = removeFixed + (count = length - count), removeIndex = removeFixed;
            intRangeIndexSorter sort
                = new intRangeIndexSorter
                {
                    SkipCount = removeStart, 
                    GetEndIndex = removeStart
                };
            sort.Sort(removeFixed, --removeEnd);
            while (writeIndex != count) newValues[writeIndex++] = values[(*removeIndex++).Index];
            for (int maxValue = (*removeStart).Value; index != values.Length; ++index)
            {
                int value = getKey(values[index]);
                if (value <= maxValue) newValues[writeIndex++] = values[index];
                else
                {
                    *--removeIndex = new intSortIndex { Value = value, Index = index };
                    if (removeIndex == removeFixed)
                    {
                        sort.Sort(removeFixed, removeEnd);
                        for (removeIndex = removeFixed; removeIndex != removeStart; newValues[writeIndex++] = values[(*removeIndex++).Index]) ;
                        maxValue = (*removeStart).Value;
                    }
                }
            }
            if (removeIndex != removeStart)
            {
                sort.Sort(removeIndex, removeEnd);
                while (removeIndex != removeStart) newValues[writeIndex++] = values[(*removeIndex++).Index];
            }
        }
    }
}
namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static list<int> GetTopDesc(int[] values, int count)
        {
            if (values == null) return null;
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, count);
                    else return getRemoveTopDesc(values, count);
                }
                int[] newValues = new int[values.Length];
                Array.Copy(values, 0, newValues, 0, values.Length);
                return new list<int>(newValues, true);
            }
            return null;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static list<int> TopDesc(int[] values, int count)
        {
            if (values == null) return null;
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, count);
                    else return getRemoveTopDesc(values, count);
                }
                return new list<int>(values, true);
            }
            return null;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static list<int> getTopDesc(int[] values, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            int[] newValues = new int[length];
            fixed (int* newValueFixed = newValues, valueFixed = values)
            {
                int* readIndex = valueFixed + values.Length - length;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), newValues, 0, length * sizeof(int));
                //unsafer.memory.Copy(readIndex, newValueFixed, length * sizeof(int));
                int* writeStat = newValueFixed + count, writeEnd = newValueFixed + --length, writeIndex = writeStat;
                intRangeSorterDesc sort
                    = new intRangeSorterDesc
                    {
                        SkipCount = writeStat - 1, 
                        GetEndIndex = writeStat - 1
                    };
                sort.Sort(newValueFixed, writeEnd);
                for (int maxValue = *sort.SkipCount; readIndex != valueFixed; )
                {
                    if (*--readIndex > maxValue)
                    {
                        *writeIndex = *readIndex;
                        if (writeIndex == writeEnd)
                        {
                            sort.Sort(newValueFixed, writeEnd);
                            writeIndex = writeStat;
                            maxValue = *sort.SkipCount;
                        }
                        else ++writeIndex;
                    }
                }
                if (writeIndex != writeStat) sort.Sort(newValueFixed, --writeIndex);
            }
            return newValues.left(count);
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static list<int> getRemoveTopDesc
            (int[] values, int count)
        {
            int[] newValues = new int[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            int[] removeValues = new int[length];
            fixed (int* newValueFixed = newValues, removeFixed = removeValues, valueFixed = values)
            {
                int copyCount = length - count, copyLength = copyCount * sizeof(int);
                int* readIndex = valueFixed + values.Length - length, removeStart = removeFixed + copyCount;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), removeValues, 0, length * sizeof(int));
                //unsafer.memory.Copy(readIndex, removeFixed, length * sizeof(int));
                int* removeEnd = removeFixed + --length, removeIndex = removeStart, writeIndex = newValueFixed + copyCount;
                intRangeSorterDesc sort
                    = new intRangeSorterDesc
                    {
                        SkipCount = removeStart,
                        GetEndIndex = removeStart
                    };
                sort.Sort(removeFixed, removeEnd);
                Buffer.BlockCopy(removeValues, 0, newValues, 0, copyLength);
                //unsafer.memory.Copy(removeFixed, newValueFixed, copyLength);
                for (int maxValue = *removeStart; readIndex != valueFixed; )
                {
                    if (*--readIndex >= maxValue) *writeIndex++ = *readIndex;
                    else
                    {
                        *--removeIndex = *readIndex;
                        if (removeIndex == removeFixed)
                        {
                            sort.Sort(removeFixed, removeEnd);
                            removeIndex = removeStart;
                            maxValue = *removeStart;
                            Buffer.BlockCopy(removeValues, 0, newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), copyLength);
                            //unsafer.memory.Copy(removeFixed, writeIndex, copyLength);
                            writeIndex += copyCount;
                        }
                    }
                }
                if (removeIndex != removeStart)
                {
                    sort.Sort(removeIndex, removeEnd);
                    Buffer.BlockCopy(removeValues, (int)((byte*)removeIndex - (byte*)removeFixed), newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), (int)((byte*)removeStart - (byte*)removeIndex));
                    //unsafer.memory.Copy(removeIndex, writeIndex, (int)(removeStart - removeIndex) * sizeof(int));
                }
            }
            return new list<int>(newValues, true);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static valueType[] GetTopDesc<valueType>
            (valueType[] values, func<valueType, int> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, getKey, count);
                    else return getRemoveTopDesc(values, getKey, count);
                }
                return values.copy();
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static valueType[] TopDesc<valueType>
            (valueType[] values, func<valueType, int> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, getKey, count);
                    else return getRemoveTopDesc(values, getKey, count);
                }
                return values.notNull();
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getTopDesc<valueType>
            (valueType[] values, func<valueType, int> getKey, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            if (length > (config.pub.Default.StreamBufferLength >> 4))
            {
                intSortIndex[] indexs = new intSortIndex[length];
                fixed (intSortIndex* indexFixed = indexs)
                {
                    return getTopDesc(values, getKey, count, length, indexFixed);
                }
            }
            else
            {
                intSortIndex* indexFixed = stackalloc intSortIndex[length];
                return getTopDesc(values, getKey, count, length, indexFixed);
            }
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getTopDesc<valueType>
            (valueType[] values, func<valueType, int> getKey, int count, int length
            , intSortIndex* indexFixed)
        {
            intSortIndex* writeEnd = indexFixed;
            int index = 0;
            while (index != length)
            {
                *writeEnd++ = new intSortIndex { Value = getKey(values[index]), Index = index };
                ++index;
            }
            intSortIndex* writeStat = indexFixed + count, writeIndex = writeStat;
            intRangeIndexSorterDesc sort
                = new intRangeIndexSorterDesc
                {
                    SkipCount = writeStat - 1,
                    GetEndIndex = writeStat - 1
                };
            sort.Sort(indexFixed, --writeEnd);
            for (int maxValue = (*sort.SkipCount).Value; index != values.Length; ++index)
            {
                int value = getKey(values[index]);
                if (value > maxValue)
                {
                    *writeIndex = new intSortIndex { Value = value, Index = index };
                    if (writeIndex == writeEnd)
                    {
                        sort.Sort(indexFixed, writeEnd);
                        writeIndex = writeStat;
                        maxValue = (*sort.SkipCount).Value;
                    }
                    else ++writeIndex;
                }
            }
            if (writeIndex != writeStat) sort.Sort(indexFixed, --writeIndex);
            valueType[] newValues = new valueType[count];
            for (writeIndex = indexFixed, index = 0; index != count; ++index)
            {
                newValues[index] = values[(*writeIndex++).Index];
            }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getRemoveTopDesc<valueType>
            (valueType[] values, func<valueType, int> getKey, int count)
        {
            valueType[] newValues = new valueType[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            if (length > (config.pub.Default.StreamBufferLength >> 4))
            {
                intSortIndex[] removeValues = new intSortIndex[length];
                fixed (intSortIndex* removeFixed = removeValues)
                {
                    removeTopDesc(values, getKey, count, newValues, length, removeFixed);
                }
            }
            else
            {
                intSortIndex* removeFixed = stackalloc  intSortIndex[length];
                removeTopDesc(values, getKey, count, newValues, length, removeFixed);
            }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="newValues">目标数据数组</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        private unsafe static void removeTopDesc<valueType>
            (valueType[] values, func<valueType, int> getKey, int count, valueType[] newValues, int length
            , intSortIndex* removeFixed)
        {
            int index = 0, writeIndex = 0;
            intSortIndex* removeEnd = removeFixed;
            while (index != length)
            {
                *removeEnd++ = new intSortIndex { Value = getKey(values[index]), Index = index };
                ++index;
            }
            intSortIndex* removeStart = removeFixed + (count = length - count), removeIndex = removeFixed;
            intRangeIndexSorterDesc sort
                = new intRangeIndexSorterDesc
                {
                    SkipCount = removeStart, 
                    GetEndIndex = removeStart
                };
            sort.Sort(removeFixed, --removeEnd);
            while (writeIndex != count) newValues[writeIndex++] = values[(*removeIndex++).Index];
            for (int maxValue = (*removeStart).Value; index != values.Length; ++index)
            {
                int value = getKey(values[index]);
                if (value >= maxValue) newValues[writeIndex++] = values[index];
                else
                {
                    *--removeIndex = new intSortIndex { Value = value, Index = index };
                    if (removeIndex == removeFixed)
                    {
                        sort.Sort(removeFixed, removeEnd);
                        for (removeIndex = removeFixed; removeIndex != removeStart; newValues[writeIndex++] = values[(*removeIndex++).Index]) ;
                        maxValue = (*removeStart).Value;
                    }
                }
            }
            if (removeIndex != removeStart)
            {
                sort.Sort(removeIndex, removeEnd);
                while (removeIndex != removeStart) newValues[writeIndex++] = values[(*removeIndex++).Index];
            }
        }
    }
}
namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static list<ushort> GetTop(ushort[] values, int count)
        {
            if (values == null) return null;
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTop(values, count);
                    else return getRemoveTop(values, count);
                }
                ushort[] newValues = new ushort[values.Length];
                Array.Copy(values, 0, newValues, 0, values.Length);
                return new list<ushort>(newValues, true);
            }
            return null;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static list<ushort> Top(ushort[] values, int count)
        {
            if (values == null) return null;
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTop(values, count);
                    else return getRemoveTop(values, count);
                }
                return new list<ushort>(values, true);
            }
            return null;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static list<ushort> getTop(ushort[] values, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            ushort[] newValues = new ushort[length];
            fixed (ushort* newValueFixed = newValues, valueFixed = values)
            {
                ushort* readIndex = valueFixed + values.Length - length;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), newValues, 0, length * sizeof(ushort));
                //unsafer.memory.Copy(readIndex, newValueFixed, length * sizeof(ushort));
                ushort* writeStat = newValueFixed + count, writeEnd = newValueFixed + --length, writeIndex = writeStat;
                ushortRangeSorter sort
                    = new ushortRangeSorter
                    {
                        SkipCount = writeStat - 1, 
                        GetEndIndex = writeStat - 1
                    };
                sort.Sort(newValueFixed, writeEnd);
                for (ushort maxValue = *sort.SkipCount; readIndex != valueFixed; )
                {
                    if (*--readIndex < maxValue)
                    {
                        *writeIndex = *readIndex;
                        if (writeIndex == writeEnd)
                        {
                            sort.Sort(newValueFixed, writeEnd);
                            writeIndex = writeStat;
                            maxValue = *sort.SkipCount;
                        }
                        else ++writeIndex;
                    }
                }
                if (writeIndex != writeStat) sort.Sort(newValueFixed, --writeIndex);
            }
            return newValues.left(count);
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static list<ushort> getRemoveTop
            (ushort[] values, int count)
        {
            ushort[] newValues = new ushort[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            ushort[] removeValues = new ushort[length];
            fixed (ushort* newValueFixed = newValues, removeFixed = removeValues, valueFixed = values)
            {
                int copyCount = length - count, copyLength = copyCount * sizeof(ushort);
                ushort* readIndex = valueFixed + values.Length - length, removeStart = removeFixed + copyCount;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), removeValues, 0, length * sizeof(ushort));
                //unsafer.memory.Copy(readIndex, removeFixed, length * sizeof(ushort));
                ushort* removeEnd = removeFixed + --length, removeIndex = removeStart, writeIndex = newValueFixed + copyCount;
                ushortRangeSorter sort
                    = new ushortRangeSorter
                    {
                        SkipCount = removeStart,
                        GetEndIndex = removeStart
                    };
                sort.Sort(removeFixed, removeEnd);
                Buffer.BlockCopy(removeValues, 0, newValues, 0, copyLength);
                //unsafer.memory.Copy(removeFixed, newValueFixed, copyLength);
                for (ushort maxValue = *removeStart; readIndex != valueFixed; )
                {
                    if (*--readIndex <= maxValue) *writeIndex++ = *readIndex;
                    else
                    {
                        *--removeIndex = *readIndex;
                        if (removeIndex == removeFixed)
                        {
                            sort.Sort(removeFixed, removeEnd);
                            removeIndex = removeStart;
                            maxValue = *removeStart;
                            Buffer.BlockCopy(removeValues, 0, newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), copyLength);
                            //unsafer.memory.Copy(removeFixed, writeIndex, copyLength);
                            writeIndex += copyCount;
                        }
                    }
                }
                if (removeIndex != removeStart)
                {
                    sort.Sort(removeIndex, removeEnd);
                    Buffer.BlockCopy(removeValues, (int)((byte*)removeIndex - (byte*)removeFixed), newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), (int)((byte*)removeStart - (byte*)removeIndex));
                    //unsafer.memory.Copy(removeIndex, writeIndex, (int)(removeStart - removeIndex) * sizeof(ushort));
                }
            }
            return new list<ushort>(newValues, true);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static valueType[] GetTop<valueType>
            (valueType[] values, func<valueType, ushort> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTop(values, getKey, count);
                    else return getRemoveTop(values, getKey, count);
                }
                return values.copy();
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static valueType[] Top<valueType>
            (valueType[] values, func<valueType, ushort> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTop(values, getKey, count);
                    else return getRemoveTop(values, getKey, count);
                }
                return values.notNull();
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getTop<valueType>
            (valueType[] values, func<valueType, ushort> getKey, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            if (length > (config.pub.Default.StreamBufferLength >> 4))
            {
                ushortSortIndex[] indexs = new ushortSortIndex[length];
                fixed (ushortSortIndex* indexFixed = indexs)
                {
                    return getTop(values, getKey, count, length, indexFixed);
                }
            }
            else
            {
                ushortSortIndex* indexFixed = stackalloc ushortSortIndex[length];
                return getTop(values, getKey, count, length, indexFixed);
            }
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getTop<valueType>
            (valueType[] values, func<valueType, ushort> getKey, int count, int length
            , ushortSortIndex* indexFixed)
        {
            ushortSortIndex* writeEnd = indexFixed;
            int index = 0;
            while (index != length)
            {
                *writeEnd++ = new ushortSortIndex { Value = getKey(values[index]), Index = index };
                ++index;
            }
            ushortSortIndex* writeStat = indexFixed + count, writeIndex = writeStat;
            ushortRangeIndexSorter sort
                = new ushortRangeIndexSorter
                {
                    SkipCount = writeStat - 1,
                    GetEndIndex = writeStat - 1
                };
            sort.Sort(indexFixed, --writeEnd);
            for (ushort maxValue = (*sort.SkipCount).Value; index != values.Length; ++index)
            {
                ushort value = getKey(values[index]);
                if (value < maxValue)
                {
                    *writeIndex = new ushortSortIndex { Value = value, Index = index };
                    if (writeIndex == writeEnd)
                    {
                        sort.Sort(indexFixed, writeEnd);
                        writeIndex = writeStat;
                        maxValue = (*sort.SkipCount).Value;
                    }
                    else ++writeIndex;
                }
            }
            if (writeIndex != writeStat) sort.Sort(indexFixed, --writeIndex);
            valueType[] newValues = new valueType[count];
            for (writeIndex = indexFixed, index = 0; index != count; ++index)
            {
                newValues[index] = values[(*writeIndex++).Index];
            }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getRemoveTop<valueType>
            (valueType[] values, func<valueType, ushort> getKey, int count)
        {
            valueType[] newValues = new valueType[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            if (length > (config.pub.Default.StreamBufferLength >> 4))
            {
                ushortSortIndex[] removeValues = new ushortSortIndex[length];
                fixed (ushortSortIndex* removeFixed = removeValues)
                {
                    removeTop(values, getKey, count, newValues, length, removeFixed);
                }
            }
            else
            {
                ushortSortIndex* removeFixed = stackalloc  ushortSortIndex[length];
                removeTop(values, getKey, count, newValues, length, removeFixed);
            }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="newValues">目标数据数组</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        private unsafe static void removeTop<valueType>
            (valueType[] values, func<valueType, ushort> getKey, int count, valueType[] newValues, int length
            , ushortSortIndex* removeFixed)
        {
            int index = 0, writeIndex = 0;
            ushortSortIndex* removeEnd = removeFixed;
            while (index != length)
            {
                *removeEnd++ = new ushortSortIndex { Value = getKey(values[index]), Index = index };
                ++index;
            }
            ushortSortIndex* removeStart = removeFixed + (count = length - count), removeIndex = removeFixed;
            ushortRangeIndexSorter sort
                = new ushortRangeIndexSorter
                {
                    SkipCount = removeStart, 
                    GetEndIndex = removeStart
                };
            sort.Sort(removeFixed, --removeEnd);
            while (writeIndex != count) newValues[writeIndex++] = values[(*removeIndex++).Index];
            for (ushort maxValue = (*removeStart).Value; index != values.Length; ++index)
            {
                ushort value = getKey(values[index]);
                if (value <= maxValue) newValues[writeIndex++] = values[index];
                else
                {
                    *--removeIndex = new ushortSortIndex { Value = value, Index = index };
                    if (removeIndex == removeFixed)
                    {
                        sort.Sort(removeFixed, removeEnd);
                        for (removeIndex = removeFixed; removeIndex != removeStart; newValues[writeIndex++] = values[(*removeIndex++).Index]) ;
                        maxValue = (*removeStart).Value;
                    }
                }
            }
            if (removeIndex != removeStart)
            {
                sort.Sort(removeIndex, removeEnd);
                while (removeIndex != removeStart) newValues[writeIndex++] = values[(*removeIndex++).Index];
            }
        }
    }
}
namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static list<ushort> GetTopDesc(ushort[] values, int count)
        {
            if (values == null) return null;
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, count);
                    else return getRemoveTopDesc(values, count);
                }
                ushort[] newValues = new ushort[values.Length];
                Array.Copy(values, 0, newValues, 0, values.Length);
                return new list<ushort>(newValues, true);
            }
            return null;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static list<ushort> TopDesc(ushort[] values, int count)
        {
            if (values == null) return null;
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, count);
                    else return getRemoveTopDesc(values, count);
                }
                return new list<ushort>(values, true);
            }
            return null;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static list<ushort> getTopDesc(ushort[] values, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            ushort[] newValues = new ushort[length];
            fixed (ushort* newValueFixed = newValues, valueFixed = values)
            {
                ushort* readIndex = valueFixed + values.Length - length;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), newValues, 0, length * sizeof(ushort));
                //unsafer.memory.Copy(readIndex, newValueFixed, length * sizeof(ushort));
                ushort* writeStat = newValueFixed + count, writeEnd = newValueFixed + --length, writeIndex = writeStat;
                ushortRangeSorterDesc sort
                    = new ushortRangeSorterDesc
                    {
                        SkipCount = writeStat - 1, 
                        GetEndIndex = writeStat - 1
                    };
                sort.Sort(newValueFixed, writeEnd);
                for (ushort maxValue = *sort.SkipCount; readIndex != valueFixed; )
                {
                    if (*--readIndex > maxValue)
                    {
                        *writeIndex = *readIndex;
                        if (writeIndex == writeEnd)
                        {
                            sort.Sort(newValueFixed, writeEnd);
                            writeIndex = writeStat;
                            maxValue = *sort.SkipCount;
                        }
                        else ++writeIndex;
                    }
                }
                if (writeIndex != writeStat) sort.Sort(newValueFixed, --writeIndex);
            }
            return newValues.left(count);
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static list<ushort> getRemoveTopDesc
            (ushort[] values, int count)
        {
            ushort[] newValues = new ushort[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            ushort[] removeValues = new ushort[length];
            fixed (ushort* newValueFixed = newValues, removeFixed = removeValues, valueFixed = values)
            {
                int copyCount = length - count, copyLength = copyCount * sizeof(ushort);
                ushort* readIndex = valueFixed + values.Length - length, removeStart = removeFixed + copyCount;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), removeValues, 0, length * sizeof(ushort));
                //unsafer.memory.Copy(readIndex, removeFixed, length * sizeof(ushort));
                ushort* removeEnd = removeFixed + --length, removeIndex = removeStart, writeIndex = newValueFixed + copyCount;
                ushortRangeSorterDesc sort
                    = new ushortRangeSorterDesc
                    {
                        SkipCount = removeStart,
                        GetEndIndex = removeStart
                    };
                sort.Sort(removeFixed, removeEnd);
                Buffer.BlockCopy(removeValues, 0, newValues, 0, copyLength);
                //unsafer.memory.Copy(removeFixed, newValueFixed, copyLength);
                for (ushort maxValue = *removeStart; readIndex != valueFixed; )
                {
                    if (*--readIndex >= maxValue) *writeIndex++ = *readIndex;
                    else
                    {
                        *--removeIndex = *readIndex;
                        if (removeIndex == removeFixed)
                        {
                            sort.Sort(removeFixed, removeEnd);
                            removeIndex = removeStart;
                            maxValue = *removeStart;
                            Buffer.BlockCopy(removeValues, 0, newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), copyLength);
                            //unsafer.memory.Copy(removeFixed, writeIndex, copyLength);
                            writeIndex += copyCount;
                        }
                    }
                }
                if (removeIndex != removeStart)
                {
                    sort.Sort(removeIndex, removeEnd);
                    Buffer.BlockCopy(removeValues, (int)((byte*)removeIndex - (byte*)removeFixed), newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), (int)((byte*)removeStart - (byte*)removeIndex));
                    //unsafer.memory.Copy(removeIndex, writeIndex, (int)(removeStart - removeIndex) * sizeof(ushort));
                }
            }
            return new list<ushort>(newValues, true);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static valueType[] GetTopDesc<valueType>
            (valueType[] values, func<valueType, ushort> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, getKey, count);
                    else return getRemoveTopDesc(values, getKey, count);
                }
                return values.copy();
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static valueType[] TopDesc<valueType>
            (valueType[] values, func<valueType, ushort> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, getKey, count);
                    else return getRemoveTopDesc(values, getKey, count);
                }
                return values.notNull();
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getTopDesc<valueType>
            (valueType[] values, func<valueType, ushort> getKey, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            if (length > (config.pub.Default.StreamBufferLength >> 4))
            {
                ushortSortIndex[] indexs = new ushortSortIndex[length];
                fixed (ushortSortIndex* indexFixed = indexs)
                {
                    return getTopDesc(values, getKey, count, length, indexFixed);
                }
            }
            else
            {
                ushortSortIndex* indexFixed = stackalloc ushortSortIndex[length];
                return getTopDesc(values, getKey, count, length, indexFixed);
            }
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getTopDesc<valueType>
            (valueType[] values, func<valueType, ushort> getKey, int count, int length
            , ushortSortIndex* indexFixed)
        {
            ushortSortIndex* writeEnd = indexFixed;
            int index = 0;
            while (index != length)
            {
                *writeEnd++ = new ushortSortIndex { Value = getKey(values[index]), Index = index };
                ++index;
            }
            ushortSortIndex* writeStat = indexFixed + count, writeIndex = writeStat;
            ushortRangeIndexSorterDesc sort
                = new ushortRangeIndexSorterDesc
                {
                    SkipCount = writeStat - 1,
                    GetEndIndex = writeStat - 1
                };
            sort.Sort(indexFixed, --writeEnd);
            for (ushort maxValue = (*sort.SkipCount).Value; index != values.Length; ++index)
            {
                ushort value = getKey(values[index]);
                if (value > maxValue)
                {
                    *writeIndex = new ushortSortIndex { Value = value, Index = index };
                    if (writeIndex == writeEnd)
                    {
                        sort.Sort(indexFixed, writeEnd);
                        writeIndex = writeStat;
                        maxValue = (*sort.SkipCount).Value;
                    }
                    else ++writeIndex;
                }
            }
            if (writeIndex != writeStat) sort.Sort(indexFixed, --writeIndex);
            valueType[] newValues = new valueType[count];
            for (writeIndex = indexFixed, index = 0; index != count; ++index)
            {
                newValues[index] = values[(*writeIndex++).Index];
            }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getRemoveTopDesc<valueType>
            (valueType[] values, func<valueType, ushort> getKey, int count)
        {
            valueType[] newValues = new valueType[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            if (length > (config.pub.Default.StreamBufferLength >> 4))
            {
                ushortSortIndex[] removeValues = new ushortSortIndex[length];
                fixed (ushortSortIndex* removeFixed = removeValues)
                {
                    removeTopDesc(values, getKey, count, newValues, length, removeFixed);
                }
            }
            else
            {
                ushortSortIndex* removeFixed = stackalloc  ushortSortIndex[length];
                removeTopDesc(values, getKey, count, newValues, length, removeFixed);
            }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="newValues">目标数据数组</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        private unsafe static void removeTopDesc<valueType>
            (valueType[] values, func<valueType, ushort> getKey, int count, valueType[] newValues, int length
            , ushortSortIndex* removeFixed)
        {
            int index = 0, writeIndex = 0;
            ushortSortIndex* removeEnd = removeFixed;
            while (index != length)
            {
                *removeEnd++ = new ushortSortIndex { Value = getKey(values[index]), Index = index };
                ++index;
            }
            ushortSortIndex* removeStart = removeFixed + (count = length - count), removeIndex = removeFixed;
            ushortRangeIndexSorterDesc sort
                = new ushortRangeIndexSorterDesc
                {
                    SkipCount = removeStart, 
                    GetEndIndex = removeStart
                };
            sort.Sort(removeFixed, --removeEnd);
            while (writeIndex != count) newValues[writeIndex++] = values[(*removeIndex++).Index];
            for (ushort maxValue = (*removeStart).Value; index != values.Length; ++index)
            {
                ushort value = getKey(values[index]);
                if (value >= maxValue) newValues[writeIndex++] = values[index];
                else
                {
                    *--removeIndex = new ushortSortIndex { Value = value, Index = index };
                    if (removeIndex == removeFixed)
                    {
                        sort.Sort(removeFixed, removeEnd);
                        for (removeIndex = removeFixed; removeIndex != removeStart; newValues[writeIndex++] = values[(*removeIndex++).Index]) ;
                        maxValue = (*removeStart).Value;
                    }
                }
            }
            if (removeIndex != removeStart)
            {
                sort.Sort(removeIndex, removeEnd);
                while (removeIndex != removeStart) newValues[writeIndex++] = values[(*removeIndex++).Index];
            }
        }
    }
}
namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static list<short> GetTop(short[] values, int count)
        {
            if (values == null) return null;
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTop(values, count);
                    else return getRemoveTop(values, count);
                }
                short[] newValues = new short[values.Length];
                Array.Copy(values, 0, newValues, 0, values.Length);
                return new list<short>(newValues, true);
            }
            return null;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static list<short> Top(short[] values, int count)
        {
            if (values == null) return null;
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTop(values, count);
                    else return getRemoveTop(values, count);
                }
                return new list<short>(values, true);
            }
            return null;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static list<short> getTop(short[] values, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            short[] newValues = new short[length];
            fixed (short* newValueFixed = newValues, valueFixed = values)
            {
                short* readIndex = valueFixed + values.Length - length;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), newValues, 0, length * sizeof(short));
                //unsafer.memory.Copy(readIndex, newValueFixed, length * sizeof(short));
                short* writeStat = newValueFixed + count, writeEnd = newValueFixed + --length, writeIndex = writeStat;
                shortRangeSorter sort
                    = new shortRangeSorter
                    {
                        SkipCount = writeStat - 1, 
                        GetEndIndex = writeStat - 1
                    };
                sort.Sort(newValueFixed, writeEnd);
                for (short maxValue = *sort.SkipCount; readIndex != valueFixed; )
                {
                    if (*--readIndex < maxValue)
                    {
                        *writeIndex = *readIndex;
                        if (writeIndex == writeEnd)
                        {
                            sort.Sort(newValueFixed, writeEnd);
                            writeIndex = writeStat;
                            maxValue = *sort.SkipCount;
                        }
                        else ++writeIndex;
                    }
                }
                if (writeIndex != writeStat) sort.Sort(newValueFixed, --writeIndex);
            }
            return newValues.left(count);
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static list<short> getRemoveTop
            (short[] values, int count)
        {
            short[] newValues = new short[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            short[] removeValues = new short[length];
            fixed (short* newValueFixed = newValues, removeFixed = removeValues, valueFixed = values)
            {
                int copyCount = length - count, copyLength = copyCount * sizeof(short);
                short* readIndex = valueFixed + values.Length - length, removeStart = removeFixed + copyCount;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), removeValues, 0, length * sizeof(short));
                //unsafer.memory.Copy(readIndex, removeFixed, length * sizeof(short));
                short* removeEnd = removeFixed + --length, removeIndex = removeStart, writeIndex = newValueFixed + copyCount;
                shortRangeSorter sort
                    = new shortRangeSorter
                    {
                        SkipCount = removeStart,
                        GetEndIndex = removeStart
                    };
                sort.Sort(removeFixed, removeEnd);
                Buffer.BlockCopy(removeValues, 0, newValues, 0, copyLength);
                //unsafer.memory.Copy(removeFixed, newValueFixed, copyLength);
                for (short maxValue = *removeStart; readIndex != valueFixed; )
                {
                    if (*--readIndex <= maxValue) *writeIndex++ = *readIndex;
                    else
                    {
                        *--removeIndex = *readIndex;
                        if (removeIndex == removeFixed)
                        {
                            sort.Sort(removeFixed, removeEnd);
                            removeIndex = removeStart;
                            maxValue = *removeStart;
                            Buffer.BlockCopy(removeValues, 0, newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), copyLength);
                            //unsafer.memory.Copy(removeFixed, writeIndex, copyLength);
                            writeIndex += copyCount;
                        }
                    }
                }
                if (removeIndex != removeStart)
                {
                    sort.Sort(removeIndex, removeEnd);
                    Buffer.BlockCopy(removeValues, (int)((byte*)removeIndex - (byte*)removeFixed), newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), (int)((byte*)removeStart - (byte*)removeIndex));
                    //unsafer.memory.Copy(removeIndex, writeIndex, (int)(removeStart - removeIndex) * sizeof(short));
                }
            }
            return new list<short>(newValues, true);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static valueType[] GetTop<valueType>
            (valueType[] values, func<valueType, short> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTop(values, getKey, count);
                    else return getRemoveTop(values, getKey, count);
                }
                return values.copy();
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static valueType[] Top<valueType>
            (valueType[] values, func<valueType, short> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTop(values, getKey, count);
                    else return getRemoveTop(values, getKey, count);
                }
                return values.notNull();
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getTop<valueType>
            (valueType[] values, func<valueType, short> getKey, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            if (length > (config.pub.Default.StreamBufferLength >> 4))
            {
                shortSortIndex[] indexs = new shortSortIndex[length];
                fixed (shortSortIndex* indexFixed = indexs)
                {
                    return getTop(values, getKey, count, length, indexFixed);
                }
            }
            else
            {
                shortSortIndex* indexFixed = stackalloc shortSortIndex[length];
                return getTop(values, getKey, count, length, indexFixed);
            }
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getTop<valueType>
            (valueType[] values, func<valueType, short> getKey, int count, int length
            , shortSortIndex* indexFixed)
        {
            shortSortIndex* writeEnd = indexFixed;
            int index = 0;
            while (index != length)
            {
                *writeEnd++ = new shortSortIndex { Value = getKey(values[index]), Index = index };
                ++index;
            }
            shortSortIndex* writeStat = indexFixed + count, writeIndex = writeStat;
            shortRangeIndexSorter sort
                = new shortRangeIndexSorter
                {
                    SkipCount = writeStat - 1,
                    GetEndIndex = writeStat - 1
                };
            sort.Sort(indexFixed, --writeEnd);
            for (short maxValue = (*sort.SkipCount).Value; index != values.Length; ++index)
            {
                short value = getKey(values[index]);
                if (value < maxValue)
                {
                    *writeIndex = new shortSortIndex { Value = value, Index = index };
                    if (writeIndex == writeEnd)
                    {
                        sort.Sort(indexFixed, writeEnd);
                        writeIndex = writeStat;
                        maxValue = (*sort.SkipCount).Value;
                    }
                    else ++writeIndex;
                }
            }
            if (writeIndex != writeStat) sort.Sort(indexFixed, --writeIndex);
            valueType[] newValues = new valueType[count];
            for (writeIndex = indexFixed, index = 0; index != count; ++index)
            {
                newValues[index] = values[(*writeIndex++).Index];
            }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getRemoveTop<valueType>
            (valueType[] values, func<valueType, short> getKey, int count)
        {
            valueType[] newValues = new valueType[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            if (length > (config.pub.Default.StreamBufferLength >> 4))
            {
                shortSortIndex[] removeValues = new shortSortIndex[length];
                fixed (shortSortIndex* removeFixed = removeValues)
                {
                    removeTop(values, getKey, count, newValues, length, removeFixed);
                }
            }
            else
            {
                shortSortIndex* removeFixed = stackalloc  shortSortIndex[length];
                removeTop(values, getKey, count, newValues, length, removeFixed);
            }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="newValues">目标数据数组</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        private unsafe static void removeTop<valueType>
            (valueType[] values, func<valueType, short> getKey, int count, valueType[] newValues, int length
            , shortSortIndex* removeFixed)
        {
            int index = 0, writeIndex = 0;
            shortSortIndex* removeEnd = removeFixed;
            while (index != length)
            {
                *removeEnd++ = new shortSortIndex { Value = getKey(values[index]), Index = index };
                ++index;
            }
            shortSortIndex* removeStart = removeFixed + (count = length - count), removeIndex = removeFixed;
            shortRangeIndexSorter sort
                = new shortRangeIndexSorter
                {
                    SkipCount = removeStart, 
                    GetEndIndex = removeStart
                };
            sort.Sort(removeFixed, --removeEnd);
            while (writeIndex != count) newValues[writeIndex++] = values[(*removeIndex++).Index];
            for (short maxValue = (*removeStart).Value; index != values.Length; ++index)
            {
                short value = getKey(values[index]);
                if (value <= maxValue) newValues[writeIndex++] = values[index];
                else
                {
                    *--removeIndex = new shortSortIndex { Value = value, Index = index };
                    if (removeIndex == removeFixed)
                    {
                        sort.Sort(removeFixed, removeEnd);
                        for (removeIndex = removeFixed; removeIndex != removeStart; newValues[writeIndex++] = values[(*removeIndex++).Index]) ;
                        maxValue = (*removeStart).Value;
                    }
                }
            }
            if (removeIndex != removeStart)
            {
                sort.Sort(removeIndex, removeEnd);
                while (removeIndex != removeStart) newValues[writeIndex++] = values[(*removeIndex++).Index];
            }
        }
    }
}
namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static list<short> GetTopDesc(short[] values, int count)
        {
            if (values == null) return null;
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, count);
                    else return getRemoveTopDesc(values, count);
                }
                short[] newValues = new short[values.Length];
                Array.Copy(values, 0, newValues, 0, values.Length);
                return new list<short>(newValues, true);
            }
            return null;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static list<short> TopDesc(short[] values, int count)
        {
            if (values == null) return null;
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, count);
                    else return getRemoveTopDesc(values, count);
                }
                return new list<short>(values, true);
            }
            return null;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static list<short> getTopDesc(short[] values, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            short[] newValues = new short[length];
            fixed (short* newValueFixed = newValues, valueFixed = values)
            {
                short* readIndex = valueFixed + values.Length - length;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), newValues, 0, length * sizeof(short));
                //unsafer.memory.Copy(readIndex, newValueFixed, length * sizeof(short));
                short* writeStat = newValueFixed + count, writeEnd = newValueFixed + --length, writeIndex = writeStat;
                shortRangeSorterDesc sort
                    = new shortRangeSorterDesc
                    {
                        SkipCount = writeStat - 1, 
                        GetEndIndex = writeStat - 1
                    };
                sort.Sort(newValueFixed, writeEnd);
                for (short maxValue = *sort.SkipCount; readIndex != valueFixed; )
                {
                    if (*--readIndex > maxValue)
                    {
                        *writeIndex = *readIndex;
                        if (writeIndex == writeEnd)
                        {
                            sort.Sort(newValueFixed, writeEnd);
                            writeIndex = writeStat;
                            maxValue = *sort.SkipCount;
                        }
                        else ++writeIndex;
                    }
                }
                if (writeIndex != writeStat) sort.Sort(newValueFixed, --writeIndex);
            }
            return newValues.left(count);
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static list<short> getRemoveTopDesc
            (short[] values, int count)
        {
            short[] newValues = new short[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            short[] removeValues = new short[length];
            fixed (short* newValueFixed = newValues, removeFixed = removeValues, valueFixed = values)
            {
                int copyCount = length - count, copyLength = copyCount * sizeof(short);
                short* readIndex = valueFixed + values.Length - length, removeStart = removeFixed + copyCount;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), removeValues, 0, length * sizeof(short));
                //unsafer.memory.Copy(readIndex, removeFixed, length * sizeof(short));
                short* removeEnd = removeFixed + --length, removeIndex = removeStart, writeIndex = newValueFixed + copyCount;
                shortRangeSorterDesc sort
                    = new shortRangeSorterDesc
                    {
                        SkipCount = removeStart,
                        GetEndIndex = removeStart
                    };
                sort.Sort(removeFixed, removeEnd);
                Buffer.BlockCopy(removeValues, 0, newValues, 0, copyLength);
                //unsafer.memory.Copy(removeFixed, newValueFixed, copyLength);
                for (short maxValue = *removeStart; readIndex != valueFixed; )
                {
                    if (*--readIndex >= maxValue) *writeIndex++ = *readIndex;
                    else
                    {
                        *--removeIndex = *readIndex;
                        if (removeIndex == removeFixed)
                        {
                            sort.Sort(removeFixed, removeEnd);
                            removeIndex = removeStart;
                            maxValue = *removeStart;
                            Buffer.BlockCopy(removeValues, 0, newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), copyLength);
                            //unsafer.memory.Copy(removeFixed, writeIndex, copyLength);
                            writeIndex += copyCount;
                        }
                    }
                }
                if (removeIndex != removeStart)
                {
                    sort.Sort(removeIndex, removeEnd);
                    Buffer.BlockCopy(removeValues, (int)((byte*)removeIndex - (byte*)removeFixed), newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), (int)((byte*)removeStart - (byte*)removeIndex));
                    //unsafer.memory.Copy(removeIndex, writeIndex, (int)(removeStart - removeIndex) * sizeof(short));
                }
            }
            return new list<short>(newValues, true);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static valueType[] GetTopDesc<valueType>
            (valueType[] values, func<valueType, short> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, getKey, count);
                    else return getRemoveTopDesc(values, getKey, count);
                }
                return values.copy();
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static valueType[] TopDesc<valueType>
            (valueType[] values, func<valueType, short> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, getKey, count);
                    else return getRemoveTopDesc(values, getKey, count);
                }
                return values.notNull();
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getTopDesc<valueType>
            (valueType[] values, func<valueType, short> getKey, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            if (length > (config.pub.Default.StreamBufferLength >> 4))
            {
                shortSortIndex[] indexs = new shortSortIndex[length];
                fixed (shortSortIndex* indexFixed = indexs)
                {
                    return getTopDesc(values, getKey, count, length, indexFixed);
                }
            }
            else
            {
                shortSortIndex* indexFixed = stackalloc shortSortIndex[length];
                return getTopDesc(values, getKey, count, length, indexFixed);
            }
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getTopDesc<valueType>
            (valueType[] values, func<valueType, short> getKey, int count, int length
            , shortSortIndex* indexFixed)
        {
            shortSortIndex* writeEnd = indexFixed;
            int index = 0;
            while (index != length)
            {
                *writeEnd++ = new shortSortIndex { Value = getKey(values[index]), Index = index };
                ++index;
            }
            shortSortIndex* writeStat = indexFixed + count, writeIndex = writeStat;
            shortRangeIndexSorterDesc sort
                = new shortRangeIndexSorterDesc
                {
                    SkipCount = writeStat - 1,
                    GetEndIndex = writeStat - 1
                };
            sort.Sort(indexFixed, --writeEnd);
            for (short maxValue = (*sort.SkipCount).Value; index != values.Length; ++index)
            {
                short value = getKey(values[index]);
                if (value > maxValue)
                {
                    *writeIndex = new shortSortIndex { Value = value, Index = index };
                    if (writeIndex == writeEnd)
                    {
                        sort.Sort(indexFixed, writeEnd);
                        writeIndex = writeStat;
                        maxValue = (*sort.SkipCount).Value;
                    }
                    else ++writeIndex;
                }
            }
            if (writeIndex != writeStat) sort.Sort(indexFixed, --writeIndex);
            valueType[] newValues = new valueType[count];
            for (writeIndex = indexFixed, index = 0; index != count; ++index)
            {
                newValues[index] = values[(*writeIndex++).Index];
            }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getRemoveTopDesc<valueType>
            (valueType[] values, func<valueType, short> getKey, int count)
        {
            valueType[] newValues = new valueType[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            if (length > (config.pub.Default.StreamBufferLength >> 4))
            {
                shortSortIndex[] removeValues = new shortSortIndex[length];
                fixed (shortSortIndex* removeFixed = removeValues)
                {
                    removeTopDesc(values, getKey, count, newValues, length, removeFixed);
                }
            }
            else
            {
                shortSortIndex* removeFixed = stackalloc  shortSortIndex[length];
                removeTopDesc(values, getKey, count, newValues, length, removeFixed);
            }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="newValues">目标数据数组</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        private unsafe static void removeTopDesc<valueType>
            (valueType[] values, func<valueType, short> getKey, int count, valueType[] newValues, int length
            , shortSortIndex* removeFixed)
        {
            int index = 0, writeIndex = 0;
            shortSortIndex* removeEnd = removeFixed;
            while (index != length)
            {
                *removeEnd++ = new shortSortIndex { Value = getKey(values[index]), Index = index };
                ++index;
            }
            shortSortIndex* removeStart = removeFixed + (count = length - count), removeIndex = removeFixed;
            shortRangeIndexSorterDesc sort
                = new shortRangeIndexSorterDesc
                {
                    SkipCount = removeStart, 
                    GetEndIndex = removeStart
                };
            sort.Sort(removeFixed, --removeEnd);
            while (writeIndex != count) newValues[writeIndex++] = values[(*removeIndex++).Index];
            for (short maxValue = (*removeStart).Value; index != values.Length; ++index)
            {
                short value = getKey(values[index]);
                if (value >= maxValue) newValues[writeIndex++] = values[index];
                else
                {
                    *--removeIndex = new shortSortIndex { Value = value, Index = index };
                    if (removeIndex == removeFixed)
                    {
                        sort.Sort(removeFixed, removeEnd);
                        for (removeIndex = removeFixed; removeIndex != removeStart; newValues[writeIndex++] = values[(*removeIndex++).Index]) ;
                        maxValue = (*removeStart).Value;
                    }
                }
            }
            if (removeIndex != removeStart)
            {
                sort.Sort(removeIndex, removeEnd);
                while (removeIndex != removeStart) newValues[writeIndex++] = values[(*removeIndex++).Index];
            }
        }
    }
}
namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static list<byte> GetTop(byte[] values, int count)
        {
            if (values == null) return null;
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTop(values, count);
                    else return getRemoveTop(values, count);
                }
                byte[] newValues = new byte[values.Length];
                Array.Copy(values, 0, newValues, 0, values.Length);
                return new list<byte>(newValues, true);
            }
            return null;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static list<byte> Top(byte[] values, int count)
        {
            if (values == null) return null;
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTop(values, count);
                    else return getRemoveTop(values, count);
                }
                return new list<byte>(values, true);
            }
            return null;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static list<byte> getTop(byte[] values, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            byte[] newValues = new byte[length];
            fixed (byte* newValueFixed = newValues, valueFixed = values)
            {
                byte* readIndex = valueFixed + values.Length - length;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), newValues, 0, length * sizeof(byte));
                //unsafer.memory.Copy(readIndex, newValueFixed, length * sizeof(byte));
                byte* writeStat = newValueFixed + count, writeEnd = newValueFixed + --length, writeIndex = writeStat;
                byteRangeSorter sort
                    = new byteRangeSorter
                    {
                        SkipCount = writeStat - 1, 
                        GetEndIndex = writeStat - 1
                    };
                sort.Sort(newValueFixed, writeEnd);
                for (byte maxValue = *sort.SkipCount; readIndex != valueFixed; )
                {
                    if (*--readIndex < maxValue)
                    {
                        *writeIndex = *readIndex;
                        if (writeIndex == writeEnd)
                        {
                            sort.Sort(newValueFixed, writeEnd);
                            writeIndex = writeStat;
                            maxValue = *sort.SkipCount;
                        }
                        else ++writeIndex;
                    }
                }
                if (writeIndex != writeStat) sort.Sort(newValueFixed, --writeIndex);
            }
            return newValues.left(count);
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static list<byte> getRemoveTop
            (byte[] values, int count)
        {
            byte[] newValues = new byte[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            byte[] removeValues = new byte[length];
            fixed (byte* newValueFixed = newValues, removeFixed = removeValues, valueFixed = values)
            {
                int copyCount = length - count, copyLength = copyCount * sizeof(byte);
                byte* readIndex = valueFixed + values.Length - length, removeStart = removeFixed + copyCount;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), removeValues, 0, length * sizeof(byte));
                //unsafer.memory.Copy(readIndex, removeFixed, length * sizeof(byte));
                byte* removeEnd = removeFixed + --length, removeIndex = removeStart, writeIndex = newValueFixed + copyCount;
                byteRangeSorter sort
                    = new byteRangeSorter
                    {
                        SkipCount = removeStart,
                        GetEndIndex = removeStart
                    };
                sort.Sort(removeFixed, removeEnd);
                Buffer.BlockCopy(removeValues, 0, newValues, 0, copyLength);
                //unsafer.memory.Copy(removeFixed, newValueFixed, copyLength);
                for (byte maxValue = *removeStart; readIndex != valueFixed; )
                {
                    if (*--readIndex <= maxValue) *writeIndex++ = *readIndex;
                    else
                    {
                        *--removeIndex = *readIndex;
                        if (removeIndex == removeFixed)
                        {
                            sort.Sort(removeFixed, removeEnd);
                            removeIndex = removeStart;
                            maxValue = *removeStart;
                            Buffer.BlockCopy(removeValues, 0, newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), copyLength);
                            //unsafer.memory.Copy(removeFixed, writeIndex, copyLength);
                            writeIndex += copyCount;
                        }
                    }
                }
                if (removeIndex != removeStart)
                {
                    sort.Sort(removeIndex, removeEnd);
                    Buffer.BlockCopy(removeValues, (int)((byte*)removeIndex - (byte*)removeFixed), newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), (int)((byte*)removeStart - (byte*)removeIndex));
                    //unsafer.memory.Copy(removeIndex, writeIndex, (int)(removeStart - removeIndex) * sizeof(byte));
                }
            }
            return new list<byte>(newValues, true);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static valueType[] GetTop<valueType>
            (valueType[] values, func<valueType, byte> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTop(values, getKey, count);
                    else return getRemoveTop(values, getKey, count);
                }
                return values.copy();
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static valueType[] Top<valueType>
            (valueType[] values, func<valueType, byte> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTop(values, getKey, count);
                    else return getRemoveTop(values, getKey, count);
                }
                return values.notNull();
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getTop<valueType>
            (valueType[] values, func<valueType, byte> getKey, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            if (length > (config.pub.Default.StreamBufferLength >> 4))
            {
                byteSortIndex[] indexs = new byteSortIndex[length];
                fixed (byteSortIndex* indexFixed = indexs)
                {
                    return getTop(values, getKey, count, length, indexFixed);
                }
            }
            else
            {
                byteSortIndex* indexFixed = stackalloc byteSortIndex[length];
                return getTop(values, getKey, count, length, indexFixed);
            }
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getTop<valueType>
            (valueType[] values, func<valueType, byte> getKey, int count, int length
            , byteSortIndex* indexFixed)
        {
            byteSortIndex* writeEnd = indexFixed;
            int index = 0;
            while (index != length)
            {
                *writeEnd++ = new byteSortIndex { Value = getKey(values[index]), Index = index };
                ++index;
            }
            byteSortIndex* writeStat = indexFixed + count, writeIndex = writeStat;
            byteRangeIndexSorter sort
                = new byteRangeIndexSorter
                {
                    SkipCount = writeStat - 1,
                    GetEndIndex = writeStat - 1
                };
            sort.Sort(indexFixed, --writeEnd);
            for (byte maxValue = (*sort.SkipCount).Value; index != values.Length; ++index)
            {
                byte value = getKey(values[index]);
                if (value < maxValue)
                {
                    *writeIndex = new byteSortIndex { Value = value, Index = index };
                    if (writeIndex == writeEnd)
                    {
                        sort.Sort(indexFixed, writeEnd);
                        writeIndex = writeStat;
                        maxValue = (*sort.SkipCount).Value;
                    }
                    else ++writeIndex;
                }
            }
            if (writeIndex != writeStat) sort.Sort(indexFixed, --writeIndex);
            valueType[] newValues = new valueType[count];
            for (writeIndex = indexFixed, index = 0; index != count; ++index)
            {
                newValues[index] = values[(*writeIndex++).Index];
            }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getRemoveTop<valueType>
            (valueType[] values, func<valueType, byte> getKey, int count)
        {
            valueType[] newValues = new valueType[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            if (length > (config.pub.Default.StreamBufferLength >> 4))
            {
                byteSortIndex[] removeValues = new byteSortIndex[length];
                fixed (byteSortIndex* removeFixed = removeValues)
                {
                    removeTop(values, getKey, count, newValues, length, removeFixed);
                }
            }
            else
            {
                byteSortIndex* removeFixed = stackalloc  byteSortIndex[length];
                removeTop(values, getKey, count, newValues, length, removeFixed);
            }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="newValues">目标数据数组</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        private unsafe static void removeTop<valueType>
            (valueType[] values, func<valueType, byte> getKey, int count, valueType[] newValues, int length
            , byteSortIndex* removeFixed)
        {
            int index = 0, writeIndex = 0;
            byteSortIndex* removeEnd = removeFixed;
            while (index != length)
            {
                *removeEnd++ = new byteSortIndex { Value = getKey(values[index]), Index = index };
                ++index;
            }
            byteSortIndex* removeStart = removeFixed + (count = length - count), removeIndex = removeFixed;
            byteRangeIndexSorter sort
                = new byteRangeIndexSorter
                {
                    SkipCount = removeStart, 
                    GetEndIndex = removeStart
                };
            sort.Sort(removeFixed, --removeEnd);
            while (writeIndex != count) newValues[writeIndex++] = values[(*removeIndex++).Index];
            for (byte maxValue = (*removeStart).Value; index != values.Length; ++index)
            {
                byte value = getKey(values[index]);
                if (value <= maxValue) newValues[writeIndex++] = values[index];
                else
                {
                    *--removeIndex = new byteSortIndex { Value = value, Index = index };
                    if (removeIndex == removeFixed)
                    {
                        sort.Sort(removeFixed, removeEnd);
                        for (removeIndex = removeFixed; removeIndex != removeStart; newValues[writeIndex++] = values[(*removeIndex++).Index]) ;
                        maxValue = (*removeStart).Value;
                    }
                }
            }
            if (removeIndex != removeStart)
            {
                sort.Sort(removeIndex, removeEnd);
                while (removeIndex != removeStart) newValues[writeIndex++] = values[(*removeIndex++).Index];
            }
        }
    }
}
namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static list<byte> GetTopDesc(byte[] values, int count)
        {
            if (values == null) return null;
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, count);
                    else return getRemoveTopDesc(values, count);
                }
                byte[] newValues = new byte[values.Length];
                Array.Copy(values, 0, newValues, 0, values.Length);
                return new list<byte>(newValues, true);
            }
            return null;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static list<byte> TopDesc(byte[] values, int count)
        {
            if (values == null) return null;
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, count);
                    else return getRemoveTopDesc(values, count);
                }
                return new list<byte>(values, true);
            }
            return null;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static list<byte> getTopDesc(byte[] values, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            byte[] newValues = new byte[length];
            fixed (byte* newValueFixed = newValues, valueFixed = values)
            {
                byte* readIndex = valueFixed + values.Length - length;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), newValues, 0, length * sizeof(byte));
                //unsafer.memory.Copy(readIndex, newValueFixed, length * sizeof(byte));
                byte* writeStat = newValueFixed + count, writeEnd = newValueFixed + --length, writeIndex = writeStat;
                byteRangeSorterDesc sort
                    = new byteRangeSorterDesc
                    {
                        SkipCount = writeStat - 1, 
                        GetEndIndex = writeStat - 1
                    };
                sort.Sort(newValueFixed, writeEnd);
                for (byte maxValue = *sort.SkipCount; readIndex != valueFixed; )
                {
                    if (*--readIndex > maxValue)
                    {
                        *writeIndex = *readIndex;
                        if (writeIndex == writeEnd)
                        {
                            sort.Sort(newValueFixed, writeEnd);
                            writeIndex = writeStat;
                            maxValue = *sort.SkipCount;
                        }
                        else ++writeIndex;
                    }
                }
                if (writeIndex != writeStat) sort.Sort(newValueFixed, --writeIndex);
            }
            return newValues.left(count);
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static list<byte> getRemoveTopDesc
            (byte[] values, int count)
        {
            byte[] newValues = new byte[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            byte[] removeValues = new byte[length];
            fixed (byte* newValueFixed = newValues, removeFixed = removeValues, valueFixed = values)
            {
                int copyCount = length - count, copyLength = copyCount * sizeof(byte);
                byte* readIndex = valueFixed + values.Length - length, removeStart = removeFixed + copyCount;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), removeValues, 0, length * sizeof(byte));
                //unsafer.memory.Copy(readIndex, removeFixed, length * sizeof(byte));
                byte* removeEnd = removeFixed + --length, removeIndex = removeStart, writeIndex = newValueFixed + copyCount;
                byteRangeSorterDesc sort
                    = new byteRangeSorterDesc
                    {
                        SkipCount = removeStart,
                        GetEndIndex = removeStart
                    };
                sort.Sort(removeFixed, removeEnd);
                Buffer.BlockCopy(removeValues, 0, newValues, 0, copyLength);
                //unsafer.memory.Copy(removeFixed, newValueFixed, copyLength);
                for (byte maxValue = *removeStart; readIndex != valueFixed; )
                {
                    if (*--readIndex >= maxValue) *writeIndex++ = *readIndex;
                    else
                    {
                        *--removeIndex = *readIndex;
                        if (removeIndex == removeFixed)
                        {
                            sort.Sort(removeFixed, removeEnd);
                            removeIndex = removeStart;
                            maxValue = *removeStart;
                            Buffer.BlockCopy(removeValues, 0, newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), copyLength);
                            //unsafer.memory.Copy(removeFixed, writeIndex, copyLength);
                            writeIndex += copyCount;
                        }
                    }
                }
                if (removeIndex != removeStart)
                {
                    sort.Sort(removeIndex, removeEnd);
                    Buffer.BlockCopy(removeValues, (int)((byte*)removeIndex - (byte*)removeFixed), newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), (int)((byte*)removeStart - (byte*)removeIndex));
                    //unsafer.memory.Copy(removeIndex, writeIndex, (int)(removeStart - removeIndex) * sizeof(byte));
                }
            }
            return new list<byte>(newValues, true);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static valueType[] GetTopDesc<valueType>
            (valueType[] values, func<valueType, byte> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, getKey, count);
                    else return getRemoveTopDesc(values, getKey, count);
                }
                return values.copy();
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static valueType[] TopDesc<valueType>
            (valueType[] values, func<valueType, byte> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, getKey, count);
                    else return getRemoveTopDesc(values, getKey, count);
                }
                return values.notNull();
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getTopDesc<valueType>
            (valueType[] values, func<valueType, byte> getKey, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            if (length > (config.pub.Default.StreamBufferLength >> 4))
            {
                byteSortIndex[] indexs = new byteSortIndex[length];
                fixed (byteSortIndex* indexFixed = indexs)
                {
                    return getTopDesc(values, getKey, count, length, indexFixed);
                }
            }
            else
            {
                byteSortIndex* indexFixed = stackalloc byteSortIndex[length];
                return getTopDesc(values, getKey, count, length, indexFixed);
            }
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getTopDesc<valueType>
            (valueType[] values, func<valueType, byte> getKey, int count, int length
            , byteSortIndex* indexFixed)
        {
            byteSortIndex* writeEnd = indexFixed;
            int index = 0;
            while (index != length)
            {
                *writeEnd++ = new byteSortIndex { Value = getKey(values[index]), Index = index };
                ++index;
            }
            byteSortIndex* writeStat = indexFixed + count, writeIndex = writeStat;
            byteRangeIndexSorterDesc sort
                = new byteRangeIndexSorterDesc
                {
                    SkipCount = writeStat - 1,
                    GetEndIndex = writeStat - 1
                };
            sort.Sort(indexFixed, --writeEnd);
            for (byte maxValue = (*sort.SkipCount).Value; index != values.Length; ++index)
            {
                byte value = getKey(values[index]);
                if (value > maxValue)
                {
                    *writeIndex = new byteSortIndex { Value = value, Index = index };
                    if (writeIndex == writeEnd)
                    {
                        sort.Sort(indexFixed, writeEnd);
                        writeIndex = writeStat;
                        maxValue = (*sort.SkipCount).Value;
                    }
                    else ++writeIndex;
                }
            }
            if (writeIndex != writeStat) sort.Sort(indexFixed, --writeIndex);
            valueType[] newValues = new valueType[count];
            for (writeIndex = indexFixed, index = 0; index != count; ++index)
            {
                newValues[index] = values[(*writeIndex++).Index];
            }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getRemoveTopDesc<valueType>
            (valueType[] values, func<valueType, byte> getKey, int count)
        {
            valueType[] newValues = new valueType[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            if (length > (config.pub.Default.StreamBufferLength >> 4))
            {
                byteSortIndex[] removeValues = new byteSortIndex[length];
                fixed (byteSortIndex* removeFixed = removeValues)
                {
                    removeTopDesc(values, getKey, count, newValues, length, removeFixed);
                }
            }
            else
            {
                byteSortIndex* removeFixed = stackalloc  byteSortIndex[length];
                removeTopDesc(values, getKey, count, newValues, length, removeFixed);
            }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="newValues">目标数据数组</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        private unsafe static void removeTopDesc<valueType>
            (valueType[] values, func<valueType, byte> getKey, int count, valueType[] newValues, int length
            , byteSortIndex* removeFixed)
        {
            int index = 0, writeIndex = 0;
            byteSortIndex* removeEnd = removeFixed;
            while (index != length)
            {
                *removeEnd++ = new byteSortIndex { Value = getKey(values[index]), Index = index };
                ++index;
            }
            byteSortIndex* removeStart = removeFixed + (count = length - count), removeIndex = removeFixed;
            byteRangeIndexSorterDesc sort
                = new byteRangeIndexSorterDesc
                {
                    SkipCount = removeStart, 
                    GetEndIndex = removeStart
                };
            sort.Sort(removeFixed, --removeEnd);
            while (writeIndex != count) newValues[writeIndex++] = values[(*removeIndex++).Index];
            for (byte maxValue = (*removeStart).Value; index != values.Length; ++index)
            {
                byte value = getKey(values[index]);
                if (value >= maxValue) newValues[writeIndex++] = values[index];
                else
                {
                    *--removeIndex = new byteSortIndex { Value = value, Index = index };
                    if (removeIndex == removeFixed)
                    {
                        sort.Sort(removeFixed, removeEnd);
                        for (removeIndex = removeFixed; removeIndex != removeStart; newValues[writeIndex++] = values[(*removeIndex++).Index]) ;
                        maxValue = (*removeStart).Value;
                    }
                }
            }
            if (removeIndex != removeStart)
            {
                sort.Sort(removeIndex, removeEnd);
                while (removeIndex != removeStart) newValues[writeIndex++] = values[(*removeIndex++).Index];
            }
        }
    }
}
namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static list<sbyte> GetTop(sbyte[] values, int count)
        {
            if (values == null) return null;
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTop(values, count);
                    else return getRemoveTop(values, count);
                }
                sbyte[] newValues = new sbyte[values.Length];
                Array.Copy(values, 0, newValues, 0, values.Length);
                return new list<sbyte>(newValues, true);
            }
            return null;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static list<sbyte> Top(sbyte[] values, int count)
        {
            if (values == null) return null;
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTop(values, count);
                    else return getRemoveTop(values, count);
                }
                return new list<sbyte>(values, true);
            }
            return null;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static list<sbyte> getTop(sbyte[] values, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            sbyte[] newValues = new sbyte[length];
            fixed (sbyte* newValueFixed = newValues, valueFixed = values)
            {
                sbyte* readIndex = valueFixed + values.Length - length;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), newValues, 0, length * sizeof(sbyte));
                //unsafer.memory.Copy(readIndex, newValueFixed, length * sizeof(sbyte));
                sbyte* writeStat = newValueFixed + count, writeEnd = newValueFixed + --length, writeIndex = writeStat;
                sbyteRangeSorter sort
                    = new sbyteRangeSorter
                    {
                        SkipCount = writeStat - 1, 
                        GetEndIndex = writeStat - 1
                    };
                sort.Sort(newValueFixed, writeEnd);
                for (sbyte maxValue = *sort.SkipCount; readIndex != valueFixed; )
                {
                    if (*--readIndex < maxValue)
                    {
                        *writeIndex = *readIndex;
                        if (writeIndex == writeEnd)
                        {
                            sort.Sort(newValueFixed, writeEnd);
                            writeIndex = writeStat;
                            maxValue = *sort.SkipCount;
                        }
                        else ++writeIndex;
                    }
                }
                if (writeIndex != writeStat) sort.Sort(newValueFixed, --writeIndex);
            }
            return newValues.left(count);
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static list<sbyte> getRemoveTop
            (sbyte[] values, int count)
        {
            sbyte[] newValues = new sbyte[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            sbyte[] removeValues = new sbyte[length];
            fixed (sbyte* newValueFixed = newValues, removeFixed = removeValues, valueFixed = values)
            {
                int copyCount = length - count, copyLength = copyCount * sizeof(sbyte);
                sbyte* readIndex = valueFixed + values.Length - length, removeStart = removeFixed + copyCount;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), removeValues, 0, length * sizeof(sbyte));
                //unsafer.memory.Copy(readIndex, removeFixed, length * sizeof(sbyte));
                sbyte* removeEnd = removeFixed + --length, removeIndex = removeStart, writeIndex = newValueFixed + copyCount;
                sbyteRangeSorter sort
                    = new sbyteRangeSorter
                    {
                        SkipCount = removeStart,
                        GetEndIndex = removeStart
                    };
                sort.Sort(removeFixed, removeEnd);
                Buffer.BlockCopy(removeValues, 0, newValues, 0, copyLength);
                //unsafer.memory.Copy(removeFixed, newValueFixed, copyLength);
                for (sbyte maxValue = *removeStart; readIndex != valueFixed; )
                {
                    if (*--readIndex <= maxValue) *writeIndex++ = *readIndex;
                    else
                    {
                        *--removeIndex = *readIndex;
                        if (removeIndex == removeFixed)
                        {
                            sort.Sort(removeFixed, removeEnd);
                            removeIndex = removeStart;
                            maxValue = *removeStart;
                            Buffer.BlockCopy(removeValues, 0, newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), copyLength);
                            //unsafer.memory.Copy(removeFixed, writeIndex, copyLength);
                            writeIndex += copyCount;
                        }
                    }
                }
                if (removeIndex != removeStart)
                {
                    sort.Sort(removeIndex, removeEnd);
                    Buffer.BlockCopy(removeValues, (int)((byte*)removeIndex - (byte*)removeFixed), newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), (int)((byte*)removeStart - (byte*)removeIndex));
                    //unsafer.memory.Copy(removeIndex, writeIndex, (int)(removeStart - removeIndex) * sizeof(sbyte));
                }
            }
            return new list<sbyte>(newValues, true);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static valueType[] GetTop<valueType>
            (valueType[] values, func<valueType, sbyte> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTop(values, getKey, count);
                    else return getRemoveTop(values, getKey, count);
                }
                return values.copy();
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static valueType[] Top<valueType>
            (valueType[] values, func<valueType, sbyte> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTop(values, getKey, count);
                    else return getRemoveTop(values, getKey, count);
                }
                return values.notNull();
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getTop<valueType>
            (valueType[] values, func<valueType, sbyte> getKey, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            if (length > (config.pub.Default.StreamBufferLength >> 4))
            {
                sbyteSortIndex[] indexs = new sbyteSortIndex[length];
                fixed (sbyteSortIndex* indexFixed = indexs)
                {
                    return getTop(values, getKey, count, length, indexFixed);
                }
            }
            else
            {
                sbyteSortIndex* indexFixed = stackalloc sbyteSortIndex[length];
                return getTop(values, getKey, count, length, indexFixed);
            }
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getTop<valueType>
            (valueType[] values, func<valueType, sbyte> getKey, int count, int length
            , sbyteSortIndex* indexFixed)
        {
            sbyteSortIndex* writeEnd = indexFixed;
            int index = 0;
            while (index != length)
            {
                *writeEnd++ = new sbyteSortIndex { Value = getKey(values[index]), Index = index };
                ++index;
            }
            sbyteSortIndex* writeStat = indexFixed + count, writeIndex = writeStat;
            sbyteRangeIndexSorter sort
                = new sbyteRangeIndexSorter
                {
                    SkipCount = writeStat - 1,
                    GetEndIndex = writeStat - 1
                };
            sort.Sort(indexFixed, --writeEnd);
            for (sbyte maxValue = (*sort.SkipCount).Value; index != values.Length; ++index)
            {
                sbyte value = getKey(values[index]);
                if (value < maxValue)
                {
                    *writeIndex = new sbyteSortIndex { Value = value, Index = index };
                    if (writeIndex == writeEnd)
                    {
                        sort.Sort(indexFixed, writeEnd);
                        writeIndex = writeStat;
                        maxValue = (*sort.SkipCount).Value;
                    }
                    else ++writeIndex;
                }
            }
            if (writeIndex != writeStat) sort.Sort(indexFixed, --writeIndex);
            valueType[] newValues = new valueType[count];
            for (writeIndex = indexFixed, index = 0; index != count; ++index)
            {
                newValues[index] = values[(*writeIndex++).Index];
            }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getRemoveTop<valueType>
            (valueType[] values, func<valueType, sbyte> getKey, int count)
        {
            valueType[] newValues = new valueType[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            if (length > (config.pub.Default.StreamBufferLength >> 4))
            {
                sbyteSortIndex[] removeValues = new sbyteSortIndex[length];
                fixed (sbyteSortIndex* removeFixed = removeValues)
                {
                    removeTop(values, getKey, count, newValues, length, removeFixed);
                }
            }
            else
            {
                sbyteSortIndex* removeFixed = stackalloc  sbyteSortIndex[length];
                removeTop(values, getKey, count, newValues, length, removeFixed);
            }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="newValues">目标数据数组</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        private unsafe static void removeTop<valueType>
            (valueType[] values, func<valueType, sbyte> getKey, int count, valueType[] newValues, int length
            , sbyteSortIndex* removeFixed)
        {
            int index = 0, writeIndex = 0;
            sbyteSortIndex* removeEnd = removeFixed;
            while (index != length)
            {
                *removeEnd++ = new sbyteSortIndex { Value = getKey(values[index]), Index = index };
                ++index;
            }
            sbyteSortIndex* removeStart = removeFixed + (count = length - count), removeIndex = removeFixed;
            sbyteRangeIndexSorter sort
                = new sbyteRangeIndexSorter
                {
                    SkipCount = removeStart, 
                    GetEndIndex = removeStart
                };
            sort.Sort(removeFixed, --removeEnd);
            while (writeIndex != count) newValues[writeIndex++] = values[(*removeIndex++).Index];
            for (sbyte maxValue = (*removeStart).Value; index != values.Length; ++index)
            {
                sbyte value = getKey(values[index]);
                if (value <= maxValue) newValues[writeIndex++] = values[index];
                else
                {
                    *--removeIndex = new sbyteSortIndex { Value = value, Index = index };
                    if (removeIndex == removeFixed)
                    {
                        sort.Sort(removeFixed, removeEnd);
                        for (removeIndex = removeFixed; removeIndex != removeStart; newValues[writeIndex++] = values[(*removeIndex++).Index]) ;
                        maxValue = (*removeStart).Value;
                    }
                }
            }
            if (removeIndex != removeStart)
            {
                sort.Sort(removeIndex, removeEnd);
                while (removeIndex != removeStart) newValues[writeIndex++] = values[(*removeIndex++).Index];
            }
        }
    }
}
namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static list<sbyte> GetTopDesc(sbyte[] values, int count)
        {
            if (values == null) return null;
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, count);
                    else return getRemoveTopDesc(values, count);
                }
                sbyte[] newValues = new sbyte[values.Length];
                Array.Copy(values, 0, newValues, 0, values.Length);
                return new list<sbyte>(newValues, true);
            }
            return null;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static list<sbyte> TopDesc(sbyte[] values, int count)
        {
            if (values == null) return null;
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, count);
                    else return getRemoveTopDesc(values, count);
                }
                return new list<sbyte>(values, true);
            }
            return null;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static list<sbyte> getTopDesc(sbyte[] values, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            sbyte[] newValues = new sbyte[length];
            fixed (sbyte* newValueFixed = newValues, valueFixed = values)
            {
                sbyte* readIndex = valueFixed + values.Length - length;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), newValues, 0, length * sizeof(sbyte));
                //unsafer.memory.Copy(readIndex, newValueFixed, length * sizeof(sbyte));
                sbyte* writeStat = newValueFixed + count, writeEnd = newValueFixed + --length, writeIndex = writeStat;
                sbyteRangeSorterDesc sort
                    = new sbyteRangeSorterDesc
                    {
                        SkipCount = writeStat - 1, 
                        GetEndIndex = writeStat - 1
                    };
                sort.Sort(newValueFixed, writeEnd);
                for (sbyte maxValue = *sort.SkipCount; readIndex != valueFixed; )
                {
                    if (*--readIndex > maxValue)
                    {
                        *writeIndex = *readIndex;
                        if (writeIndex == writeEnd)
                        {
                            sort.Sort(newValueFixed, writeEnd);
                            writeIndex = writeStat;
                            maxValue = *sort.SkipCount;
                        }
                        else ++writeIndex;
                    }
                }
                if (writeIndex != writeStat) sort.Sort(newValueFixed, --writeIndex);
            }
            return newValues.left(count);
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static list<sbyte> getRemoveTopDesc
            (sbyte[] values, int count)
        {
            sbyte[] newValues = new sbyte[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            sbyte[] removeValues = new sbyte[length];
            fixed (sbyte* newValueFixed = newValues, removeFixed = removeValues, valueFixed = values)
            {
                int copyCount = length - count, copyLength = copyCount * sizeof(sbyte);
                sbyte* readIndex = valueFixed + values.Length - length, removeStart = removeFixed + copyCount;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), removeValues, 0, length * sizeof(sbyte));
                //unsafer.memory.Copy(readIndex, removeFixed, length * sizeof(sbyte));
                sbyte* removeEnd = removeFixed + --length, removeIndex = removeStart, writeIndex = newValueFixed + copyCount;
                sbyteRangeSorterDesc sort
                    = new sbyteRangeSorterDesc
                    {
                        SkipCount = removeStart,
                        GetEndIndex = removeStart
                    };
                sort.Sort(removeFixed, removeEnd);
                Buffer.BlockCopy(removeValues, 0, newValues, 0, copyLength);
                //unsafer.memory.Copy(removeFixed, newValueFixed, copyLength);
                for (sbyte maxValue = *removeStart; readIndex != valueFixed; )
                {
                    if (*--readIndex >= maxValue) *writeIndex++ = *readIndex;
                    else
                    {
                        *--removeIndex = *readIndex;
                        if (removeIndex == removeFixed)
                        {
                            sort.Sort(removeFixed, removeEnd);
                            removeIndex = removeStart;
                            maxValue = *removeStart;
                            Buffer.BlockCopy(removeValues, 0, newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), copyLength);
                            //unsafer.memory.Copy(removeFixed, writeIndex, copyLength);
                            writeIndex += copyCount;
                        }
                    }
                }
                if (removeIndex != removeStart)
                {
                    sort.Sort(removeIndex, removeEnd);
                    Buffer.BlockCopy(removeValues, (int)((byte*)removeIndex - (byte*)removeFixed), newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), (int)((byte*)removeStart - (byte*)removeIndex));
                    //unsafer.memory.Copy(removeIndex, writeIndex, (int)(removeStart - removeIndex) * sizeof(sbyte));
                }
            }
            return new list<sbyte>(newValues, true);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static valueType[] GetTopDesc<valueType>
            (valueType[] values, func<valueType, sbyte> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, getKey, count);
                    else return getRemoveTopDesc(values, getKey, count);
                }
                return values.copy();
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static valueType[] TopDesc<valueType>
            (valueType[] values, func<valueType, sbyte> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, getKey, count);
                    else return getRemoveTopDesc(values, getKey, count);
                }
                return values.notNull();
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getTopDesc<valueType>
            (valueType[] values, func<valueType, sbyte> getKey, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            if (length > (config.pub.Default.StreamBufferLength >> 4))
            {
                sbyteSortIndex[] indexs = new sbyteSortIndex[length];
                fixed (sbyteSortIndex* indexFixed = indexs)
                {
                    return getTopDesc(values, getKey, count, length, indexFixed);
                }
            }
            else
            {
                sbyteSortIndex* indexFixed = stackalloc sbyteSortIndex[length];
                return getTopDesc(values, getKey, count, length, indexFixed);
            }
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getTopDesc<valueType>
            (valueType[] values, func<valueType, sbyte> getKey, int count, int length
            , sbyteSortIndex* indexFixed)
        {
            sbyteSortIndex* writeEnd = indexFixed;
            int index = 0;
            while (index != length)
            {
                *writeEnd++ = new sbyteSortIndex { Value = getKey(values[index]), Index = index };
                ++index;
            }
            sbyteSortIndex* writeStat = indexFixed + count, writeIndex = writeStat;
            sbyteRangeIndexSorterDesc sort
                = new sbyteRangeIndexSorterDesc
                {
                    SkipCount = writeStat - 1,
                    GetEndIndex = writeStat - 1
                };
            sort.Sort(indexFixed, --writeEnd);
            for (sbyte maxValue = (*sort.SkipCount).Value; index != values.Length; ++index)
            {
                sbyte value = getKey(values[index]);
                if (value > maxValue)
                {
                    *writeIndex = new sbyteSortIndex { Value = value, Index = index };
                    if (writeIndex == writeEnd)
                    {
                        sort.Sort(indexFixed, writeEnd);
                        writeIndex = writeStat;
                        maxValue = (*sort.SkipCount).Value;
                    }
                    else ++writeIndex;
                }
            }
            if (writeIndex != writeStat) sort.Sort(indexFixed, --writeIndex);
            valueType[] newValues = new valueType[count];
            for (writeIndex = indexFixed, index = 0; index != count; ++index)
            {
                newValues[index] = values[(*writeIndex++).Index];
            }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getRemoveTopDesc<valueType>
            (valueType[] values, func<valueType, sbyte> getKey, int count)
        {
            valueType[] newValues = new valueType[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            if (length > (config.pub.Default.StreamBufferLength >> 4))
            {
                sbyteSortIndex[] removeValues = new sbyteSortIndex[length];
                fixed (sbyteSortIndex* removeFixed = removeValues)
                {
                    removeTopDesc(values, getKey, count, newValues, length, removeFixed);
                }
            }
            else
            {
                sbyteSortIndex* removeFixed = stackalloc  sbyteSortIndex[length];
                removeTopDesc(values, getKey, count, newValues, length, removeFixed);
            }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="newValues">目标数据数组</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        private unsafe static void removeTopDesc<valueType>
            (valueType[] values, func<valueType, sbyte> getKey, int count, valueType[] newValues, int length
            , sbyteSortIndex* removeFixed)
        {
            int index = 0, writeIndex = 0;
            sbyteSortIndex* removeEnd = removeFixed;
            while (index != length)
            {
                *removeEnd++ = new sbyteSortIndex { Value = getKey(values[index]), Index = index };
                ++index;
            }
            sbyteSortIndex* removeStart = removeFixed + (count = length - count), removeIndex = removeFixed;
            sbyteRangeIndexSorterDesc sort
                = new sbyteRangeIndexSorterDesc
                {
                    SkipCount = removeStart, 
                    GetEndIndex = removeStart
                };
            sort.Sort(removeFixed, --removeEnd);
            while (writeIndex != count) newValues[writeIndex++] = values[(*removeIndex++).Index];
            for (sbyte maxValue = (*removeStart).Value; index != values.Length; ++index)
            {
                sbyte value = getKey(values[index]);
                if (value >= maxValue) newValues[writeIndex++] = values[index];
                else
                {
                    *--removeIndex = new sbyteSortIndex { Value = value, Index = index };
                    if (removeIndex == removeFixed)
                    {
                        sort.Sort(removeFixed, removeEnd);
                        for (removeIndex = removeFixed; removeIndex != removeStart; newValues[writeIndex++] = values[(*removeIndex++).Index]) ;
                        maxValue = (*removeStart).Value;
                    }
                }
            }
            if (removeIndex != removeStart)
            {
                sort.Sort(removeIndex, removeEnd);
                while (removeIndex != removeStart) newValues[writeIndex++] = values[(*removeIndex++).Index];
            }
        }
    }
}
namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static list<double> GetTop(double[] values, int count)
        {
            if (values == null) return null;
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTop(values, count);
                    else return getRemoveTop(values, count);
                }
                double[] newValues = new double[values.Length];
                Array.Copy(values, 0, newValues, 0, values.Length);
                return new list<double>(newValues, true);
            }
            return null;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static list<double> Top(double[] values, int count)
        {
            if (values == null) return null;
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTop(values, count);
                    else return getRemoveTop(values, count);
                }
                return new list<double>(values, true);
            }
            return null;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static list<double> getTop(double[] values, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            double[] newValues = new double[length];
            fixed (double* newValueFixed = newValues, valueFixed = values)
            {
                double* readIndex = valueFixed + values.Length - length;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), newValues, 0, length * sizeof(double));
                //unsafer.memory.Copy(readIndex, newValueFixed, length * sizeof(double));
                double* writeStat = newValueFixed + count, writeEnd = newValueFixed + --length, writeIndex = writeStat;
                doubleRangeSorter sort
                    = new doubleRangeSorter
                    {
                        SkipCount = writeStat - 1, 
                        GetEndIndex = writeStat - 1
                    };
                sort.Sort(newValueFixed, writeEnd);
                for (double maxValue = *sort.SkipCount; readIndex != valueFixed; )
                {
                    if (*--readIndex < maxValue)
                    {
                        *writeIndex = *readIndex;
                        if (writeIndex == writeEnd)
                        {
                            sort.Sort(newValueFixed, writeEnd);
                            writeIndex = writeStat;
                            maxValue = *sort.SkipCount;
                        }
                        else ++writeIndex;
                    }
                }
                if (writeIndex != writeStat) sort.Sort(newValueFixed, --writeIndex);
            }
            return newValues.left(count);
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static list<double> getRemoveTop
            (double[] values, int count)
        {
            double[] newValues = new double[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            double[] removeValues = new double[length];
            fixed (double* newValueFixed = newValues, removeFixed = removeValues, valueFixed = values)
            {
                int copyCount = length - count, copyLength = copyCount * sizeof(double);
                double* readIndex = valueFixed + values.Length - length, removeStart = removeFixed + copyCount;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), removeValues, 0, length * sizeof(double));
                //unsafer.memory.Copy(readIndex, removeFixed, length * sizeof(double));
                double* removeEnd = removeFixed + --length, removeIndex = removeStart, writeIndex = newValueFixed + copyCount;
                doubleRangeSorter sort
                    = new doubleRangeSorter
                    {
                        SkipCount = removeStart,
                        GetEndIndex = removeStart
                    };
                sort.Sort(removeFixed, removeEnd);
                Buffer.BlockCopy(removeValues, 0, newValues, 0, copyLength);
                //unsafer.memory.Copy(removeFixed, newValueFixed, copyLength);
                for (double maxValue = *removeStart; readIndex != valueFixed; )
                {
                    if (*--readIndex <= maxValue) *writeIndex++ = *readIndex;
                    else
                    {
                        *--removeIndex = *readIndex;
                        if (removeIndex == removeFixed)
                        {
                            sort.Sort(removeFixed, removeEnd);
                            removeIndex = removeStart;
                            maxValue = *removeStart;
                            Buffer.BlockCopy(removeValues, 0, newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), copyLength);
                            //unsafer.memory.Copy(removeFixed, writeIndex, copyLength);
                            writeIndex += copyCount;
                        }
                    }
                }
                if (removeIndex != removeStart)
                {
                    sort.Sort(removeIndex, removeEnd);
                    Buffer.BlockCopy(removeValues, (int)((byte*)removeIndex - (byte*)removeFixed), newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), (int)((byte*)removeStart - (byte*)removeIndex));
                    //unsafer.memory.Copy(removeIndex, writeIndex, (int)(removeStart - removeIndex) * sizeof(double));
                }
            }
            return new list<double>(newValues, true);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static valueType[] GetTop<valueType>
            (valueType[] values, func<valueType, double> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTop(values, getKey, count);
                    else return getRemoveTop(values, getKey, count);
                }
                return values.copy();
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static valueType[] Top<valueType>
            (valueType[] values, func<valueType, double> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTop(values, getKey, count);
                    else return getRemoveTop(values, getKey, count);
                }
                return values.notNull();
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getTop<valueType>
            (valueType[] values, func<valueType, double> getKey, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            if (length > (config.pub.Default.StreamBufferLength >> 4))
            {
                doubleSortIndex[] indexs = new doubleSortIndex[length];
                fixed (doubleSortIndex* indexFixed = indexs)
                {
                    return getTop(values, getKey, count, length, indexFixed);
                }
            }
            else
            {
                doubleSortIndex* indexFixed = stackalloc doubleSortIndex[length];
                return getTop(values, getKey, count, length, indexFixed);
            }
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getTop<valueType>
            (valueType[] values, func<valueType, double> getKey, int count, int length
            , doubleSortIndex* indexFixed)
        {
            doubleSortIndex* writeEnd = indexFixed;
            int index = 0;
            while (index != length)
            {
                *writeEnd++ = new doubleSortIndex { Value = getKey(values[index]), Index = index };
                ++index;
            }
            doubleSortIndex* writeStat = indexFixed + count, writeIndex = writeStat;
            doubleRangeIndexSorter sort
                = new doubleRangeIndexSorter
                {
                    SkipCount = writeStat - 1,
                    GetEndIndex = writeStat - 1
                };
            sort.Sort(indexFixed, --writeEnd);
            for (double maxValue = (*sort.SkipCount).Value; index != values.Length; ++index)
            {
                double value = getKey(values[index]);
                if (value < maxValue)
                {
                    *writeIndex = new doubleSortIndex { Value = value, Index = index };
                    if (writeIndex == writeEnd)
                    {
                        sort.Sort(indexFixed, writeEnd);
                        writeIndex = writeStat;
                        maxValue = (*sort.SkipCount).Value;
                    }
                    else ++writeIndex;
                }
            }
            if (writeIndex != writeStat) sort.Sort(indexFixed, --writeIndex);
            valueType[] newValues = new valueType[count];
            for (writeIndex = indexFixed, index = 0; index != count; ++index)
            {
                newValues[index] = values[(*writeIndex++).Index];
            }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getRemoveTop<valueType>
            (valueType[] values, func<valueType, double> getKey, int count)
        {
            valueType[] newValues = new valueType[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            if (length > (config.pub.Default.StreamBufferLength >> 4))
            {
                doubleSortIndex[] removeValues = new doubleSortIndex[length];
                fixed (doubleSortIndex* removeFixed = removeValues)
                {
                    removeTop(values, getKey, count, newValues, length, removeFixed);
                }
            }
            else
            {
                doubleSortIndex* removeFixed = stackalloc  doubleSortIndex[length];
                removeTop(values, getKey, count, newValues, length, removeFixed);
            }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="newValues">目标数据数组</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        private unsafe static void removeTop<valueType>
            (valueType[] values, func<valueType, double> getKey, int count, valueType[] newValues, int length
            , doubleSortIndex* removeFixed)
        {
            int index = 0, writeIndex = 0;
            doubleSortIndex* removeEnd = removeFixed;
            while (index != length)
            {
                *removeEnd++ = new doubleSortIndex { Value = getKey(values[index]), Index = index };
                ++index;
            }
            doubleSortIndex* removeStart = removeFixed + (count = length - count), removeIndex = removeFixed;
            doubleRangeIndexSorter sort
                = new doubleRangeIndexSorter
                {
                    SkipCount = removeStart, 
                    GetEndIndex = removeStart
                };
            sort.Sort(removeFixed, --removeEnd);
            while (writeIndex != count) newValues[writeIndex++] = values[(*removeIndex++).Index];
            for (double maxValue = (*removeStart).Value; index != values.Length; ++index)
            {
                double value = getKey(values[index]);
                if (value <= maxValue) newValues[writeIndex++] = values[index];
                else
                {
                    *--removeIndex = new doubleSortIndex { Value = value, Index = index };
                    if (removeIndex == removeFixed)
                    {
                        sort.Sort(removeFixed, removeEnd);
                        for (removeIndex = removeFixed; removeIndex != removeStart; newValues[writeIndex++] = values[(*removeIndex++).Index]) ;
                        maxValue = (*removeStart).Value;
                    }
                }
            }
            if (removeIndex != removeStart)
            {
                sort.Sort(removeIndex, removeEnd);
                while (removeIndex != removeStart) newValues[writeIndex++] = values[(*removeIndex++).Index];
            }
        }
    }
}
namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static list<double> GetTopDesc(double[] values, int count)
        {
            if (values == null) return null;
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, count);
                    else return getRemoveTopDesc(values, count);
                }
                double[] newValues = new double[values.Length];
                Array.Copy(values, 0, newValues, 0, values.Length);
                return new list<double>(newValues, true);
            }
            return null;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static list<double> TopDesc(double[] values, int count)
        {
            if (values == null) return null;
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, count);
                    else return getRemoveTopDesc(values, count);
                }
                return new list<double>(values, true);
            }
            return null;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static list<double> getTopDesc(double[] values, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            double[] newValues = new double[length];
            fixed (double* newValueFixed = newValues, valueFixed = values)
            {
                double* readIndex = valueFixed + values.Length - length;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), newValues, 0, length * sizeof(double));
                //unsafer.memory.Copy(readIndex, newValueFixed, length * sizeof(double));
                double* writeStat = newValueFixed + count, writeEnd = newValueFixed + --length, writeIndex = writeStat;
                doubleRangeSorterDesc sort
                    = new doubleRangeSorterDesc
                    {
                        SkipCount = writeStat - 1, 
                        GetEndIndex = writeStat - 1
                    };
                sort.Sort(newValueFixed, writeEnd);
                for (double maxValue = *sort.SkipCount; readIndex != valueFixed; )
                {
                    if (*--readIndex > maxValue)
                    {
                        *writeIndex = *readIndex;
                        if (writeIndex == writeEnd)
                        {
                            sort.Sort(newValueFixed, writeEnd);
                            writeIndex = writeStat;
                            maxValue = *sort.SkipCount;
                        }
                        else ++writeIndex;
                    }
                }
                if (writeIndex != writeStat) sort.Sort(newValueFixed, --writeIndex);
            }
            return newValues.left(count);
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static list<double> getRemoveTopDesc
            (double[] values, int count)
        {
            double[] newValues = new double[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            double[] removeValues = new double[length];
            fixed (double* newValueFixed = newValues, removeFixed = removeValues, valueFixed = values)
            {
                int copyCount = length - count, copyLength = copyCount * sizeof(double);
                double* readIndex = valueFixed + values.Length - length, removeStart = removeFixed + copyCount;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), removeValues, 0, length * sizeof(double));
                //unsafer.memory.Copy(readIndex, removeFixed, length * sizeof(double));
                double* removeEnd = removeFixed + --length, removeIndex = removeStart, writeIndex = newValueFixed + copyCount;
                doubleRangeSorterDesc sort
                    = new doubleRangeSorterDesc
                    {
                        SkipCount = removeStart,
                        GetEndIndex = removeStart
                    };
                sort.Sort(removeFixed, removeEnd);
                Buffer.BlockCopy(removeValues, 0, newValues, 0, copyLength);
                //unsafer.memory.Copy(removeFixed, newValueFixed, copyLength);
                for (double maxValue = *removeStart; readIndex != valueFixed; )
                {
                    if (*--readIndex >= maxValue) *writeIndex++ = *readIndex;
                    else
                    {
                        *--removeIndex = *readIndex;
                        if (removeIndex == removeFixed)
                        {
                            sort.Sort(removeFixed, removeEnd);
                            removeIndex = removeStart;
                            maxValue = *removeStart;
                            Buffer.BlockCopy(removeValues, 0, newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), copyLength);
                            //unsafer.memory.Copy(removeFixed, writeIndex, copyLength);
                            writeIndex += copyCount;
                        }
                    }
                }
                if (removeIndex != removeStart)
                {
                    sort.Sort(removeIndex, removeEnd);
                    Buffer.BlockCopy(removeValues, (int)((byte*)removeIndex - (byte*)removeFixed), newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), (int)((byte*)removeStart - (byte*)removeIndex));
                    //unsafer.memory.Copy(removeIndex, writeIndex, (int)(removeStart - removeIndex) * sizeof(double));
                }
            }
            return new list<double>(newValues, true);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static valueType[] GetTopDesc<valueType>
            (valueType[] values, func<valueType, double> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, getKey, count);
                    else return getRemoveTopDesc(values, getKey, count);
                }
                return values.copy();
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static valueType[] TopDesc<valueType>
            (valueType[] values, func<valueType, double> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, getKey, count);
                    else return getRemoveTopDesc(values, getKey, count);
                }
                return values.notNull();
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getTopDesc<valueType>
            (valueType[] values, func<valueType, double> getKey, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            if (length > (config.pub.Default.StreamBufferLength >> 4))
            {
                doubleSortIndex[] indexs = new doubleSortIndex[length];
                fixed (doubleSortIndex* indexFixed = indexs)
                {
                    return getTopDesc(values, getKey, count, length, indexFixed);
                }
            }
            else
            {
                doubleSortIndex* indexFixed = stackalloc doubleSortIndex[length];
                return getTopDesc(values, getKey, count, length, indexFixed);
            }
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getTopDesc<valueType>
            (valueType[] values, func<valueType, double> getKey, int count, int length
            , doubleSortIndex* indexFixed)
        {
            doubleSortIndex* writeEnd = indexFixed;
            int index = 0;
            while (index != length)
            {
                *writeEnd++ = new doubleSortIndex { Value = getKey(values[index]), Index = index };
                ++index;
            }
            doubleSortIndex* writeStat = indexFixed + count, writeIndex = writeStat;
            doubleRangeIndexSorterDesc sort
                = new doubleRangeIndexSorterDesc
                {
                    SkipCount = writeStat - 1,
                    GetEndIndex = writeStat - 1
                };
            sort.Sort(indexFixed, --writeEnd);
            for (double maxValue = (*sort.SkipCount).Value; index != values.Length; ++index)
            {
                double value = getKey(values[index]);
                if (value > maxValue)
                {
                    *writeIndex = new doubleSortIndex { Value = value, Index = index };
                    if (writeIndex == writeEnd)
                    {
                        sort.Sort(indexFixed, writeEnd);
                        writeIndex = writeStat;
                        maxValue = (*sort.SkipCount).Value;
                    }
                    else ++writeIndex;
                }
            }
            if (writeIndex != writeStat) sort.Sort(indexFixed, --writeIndex);
            valueType[] newValues = new valueType[count];
            for (writeIndex = indexFixed, index = 0; index != count; ++index)
            {
                newValues[index] = values[(*writeIndex++).Index];
            }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getRemoveTopDesc<valueType>
            (valueType[] values, func<valueType, double> getKey, int count)
        {
            valueType[] newValues = new valueType[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            if (length > (config.pub.Default.StreamBufferLength >> 4))
            {
                doubleSortIndex[] removeValues = new doubleSortIndex[length];
                fixed (doubleSortIndex* removeFixed = removeValues)
                {
                    removeTopDesc(values, getKey, count, newValues, length, removeFixed);
                }
            }
            else
            {
                doubleSortIndex* removeFixed = stackalloc  doubleSortIndex[length];
                removeTopDesc(values, getKey, count, newValues, length, removeFixed);
            }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="newValues">目标数据数组</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        private unsafe static void removeTopDesc<valueType>
            (valueType[] values, func<valueType, double> getKey, int count, valueType[] newValues, int length
            , doubleSortIndex* removeFixed)
        {
            int index = 0, writeIndex = 0;
            doubleSortIndex* removeEnd = removeFixed;
            while (index != length)
            {
                *removeEnd++ = new doubleSortIndex { Value = getKey(values[index]), Index = index };
                ++index;
            }
            doubleSortIndex* removeStart = removeFixed + (count = length - count), removeIndex = removeFixed;
            doubleRangeIndexSorterDesc sort
                = new doubleRangeIndexSorterDesc
                {
                    SkipCount = removeStart, 
                    GetEndIndex = removeStart
                };
            sort.Sort(removeFixed, --removeEnd);
            while (writeIndex != count) newValues[writeIndex++] = values[(*removeIndex++).Index];
            for (double maxValue = (*removeStart).Value; index != values.Length; ++index)
            {
                double value = getKey(values[index]);
                if (value >= maxValue) newValues[writeIndex++] = values[index];
                else
                {
                    *--removeIndex = new doubleSortIndex { Value = value, Index = index };
                    if (removeIndex == removeFixed)
                    {
                        sort.Sort(removeFixed, removeEnd);
                        for (removeIndex = removeFixed; removeIndex != removeStart; newValues[writeIndex++] = values[(*removeIndex++).Index]) ;
                        maxValue = (*removeStart).Value;
                    }
                }
            }
            if (removeIndex != removeStart)
            {
                sort.Sort(removeIndex, removeEnd);
                while (removeIndex != removeStart) newValues[writeIndex++] = values[(*removeIndex++).Index];
            }
        }
    }
}
namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static list<float> GetTop(float[] values, int count)
        {
            if (values == null) return null;
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTop(values, count);
                    else return getRemoveTop(values, count);
                }
                float[] newValues = new float[values.Length];
                Array.Copy(values, 0, newValues, 0, values.Length);
                return new list<float>(newValues, true);
            }
            return null;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static list<float> Top(float[] values, int count)
        {
            if (values == null) return null;
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTop(values, count);
                    else return getRemoveTop(values, count);
                }
                return new list<float>(values, true);
            }
            return null;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static list<float> getTop(float[] values, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            float[] newValues = new float[length];
            fixed (float* newValueFixed = newValues, valueFixed = values)
            {
                float* readIndex = valueFixed + values.Length - length;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), newValues, 0, length * sizeof(float));
                //unsafer.memory.Copy(readIndex, newValueFixed, length * sizeof(float));
                float* writeStat = newValueFixed + count, writeEnd = newValueFixed + --length, writeIndex = writeStat;
                floatRangeSorter sort
                    = new floatRangeSorter
                    {
                        SkipCount = writeStat - 1, 
                        GetEndIndex = writeStat - 1
                    };
                sort.Sort(newValueFixed, writeEnd);
                for (float maxValue = *sort.SkipCount; readIndex != valueFixed; )
                {
                    if (*--readIndex < maxValue)
                    {
                        *writeIndex = *readIndex;
                        if (writeIndex == writeEnd)
                        {
                            sort.Sort(newValueFixed, writeEnd);
                            writeIndex = writeStat;
                            maxValue = *sort.SkipCount;
                        }
                        else ++writeIndex;
                    }
                }
                if (writeIndex != writeStat) sort.Sort(newValueFixed, --writeIndex);
            }
            return newValues.left(count);
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static list<float> getRemoveTop
            (float[] values, int count)
        {
            float[] newValues = new float[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            float[] removeValues = new float[length];
            fixed (float* newValueFixed = newValues, removeFixed = removeValues, valueFixed = values)
            {
                int copyCount = length - count, copyLength = copyCount * sizeof(float);
                float* readIndex = valueFixed + values.Length - length, removeStart = removeFixed + copyCount;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), removeValues, 0, length * sizeof(float));
                //unsafer.memory.Copy(readIndex, removeFixed, length * sizeof(float));
                float* removeEnd = removeFixed + --length, removeIndex = removeStart, writeIndex = newValueFixed + copyCount;
                floatRangeSorter sort
                    = new floatRangeSorter
                    {
                        SkipCount = removeStart,
                        GetEndIndex = removeStart
                    };
                sort.Sort(removeFixed, removeEnd);
                Buffer.BlockCopy(removeValues, 0, newValues, 0, copyLength);
                //unsafer.memory.Copy(removeFixed, newValueFixed, copyLength);
                for (float maxValue = *removeStart; readIndex != valueFixed; )
                {
                    if (*--readIndex <= maxValue) *writeIndex++ = *readIndex;
                    else
                    {
                        *--removeIndex = *readIndex;
                        if (removeIndex == removeFixed)
                        {
                            sort.Sort(removeFixed, removeEnd);
                            removeIndex = removeStart;
                            maxValue = *removeStart;
                            Buffer.BlockCopy(removeValues, 0, newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), copyLength);
                            //unsafer.memory.Copy(removeFixed, writeIndex, copyLength);
                            writeIndex += copyCount;
                        }
                    }
                }
                if (removeIndex != removeStart)
                {
                    sort.Sort(removeIndex, removeEnd);
                    Buffer.BlockCopy(removeValues, (int)((byte*)removeIndex - (byte*)removeFixed), newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), (int)((byte*)removeStart - (byte*)removeIndex));
                    //unsafer.memory.Copy(removeIndex, writeIndex, (int)(removeStart - removeIndex) * sizeof(float));
                }
            }
            return new list<float>(newValues, true);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static valueType[] GetTop<valueType>
            (valueType[] values, func<valueType, float> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTop(values, getKey, count);
                    else return getRemoveTop(values, getKey, count);
                }
                return values.copy();
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static valueType[] Top<valueType>
            (valueType[] values, func<valueType, float> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTop(values, getKey, count);
                    else return getRemoveTop(values, getKey, count);
                }
                return values.notNull();
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getTop<valueType>
            (valueType[] values, func<valueType, float> getKey, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            if (length > (config.pub.Default.StreamBufferLength >> 4))
            {
                floatSortIndex[] indexs = new floatSortIndex[length];
                fixed (floatSortIndex* indexFixed = indexs)
                {
                    return getTop(values, getKey, count, length, indexFixed);
                }
            }
            else
            {
                floatSortIndex* indexFixed = stackalloc floatSortIndex[length];
                return getTop(values, getKey, count, length, indexFixed);
            }
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getTop<valueType>
            (valueType[] values, func<valueType, float> getKey, int count, int length
            , floatSortIndex* indexFixed)
        {
            floatSortIndex* writeEnd = indexFixed;
            int index = 0;
            while (index != length)
            {
                *writeEnd++ = new floatSortIndex { Value = getKey(values[index]), Index = index };
                ++index;
            }
            floatSortIndex* writeStat = indexFixed + count, writeIndex = writeStat;
            floatRangeIndexSorter sort
                = new floatRangeIndexSorter
                {
                    SkipCount = writeStat - 1,
                    GetEndIndex = writeStat - 1
                };
            sort.Sort(indexFixed, --writeEnd);
            for (float maxValue = (*sort.SkipCount).Value; index != values.Length; ++index)
            {
                float value = getKey(values[index]);
                if (value < maxValue)
                {
                    *writeIndex = new floatSortIndex { Value = value, Index = index };
                    if (writeIndex == writeEnd)
                    {
                        sort.Sort(indexFixed, writeEnd);
                        writeIndex = writeStat;
                        maxValue = (*sort.SkipCount).Value;
                    }
                    else ++writeIndex;
                }
            }
            if (writeIndex != writeStat) sort.Sort(indexFixed, --writeIndex);
            valueType[] newValues = new valueType[count];
            for (writeIndex = indexFixed, index = 0; index != count; ++index)
            {
                newValues[index] = values[(*writeIndex++).Index];
            }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getRemoveTop<valueType>
            (valueType[] values, func<valueType, float> getKey, int count)
        {
            valueType[] newValues = new valueType[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            if (length > (config.pub.Default.StreamBufferLength >> 4))
            {
                floatSortIndex[] removeValues = new floatSortIndex[length];
                fixed (floatSortIndex* removeFixed = removeValues)
                {
                    removeTop(values, getKey, count, newValues, length, removeFixed);
                }
            }
            else
            {
                floatSortIndex* removeFixed = stackalloc  floatSortIndex[length];
                removeTop(values, getKey, count, newValues, length, removeFixed);
            }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="newValues">目标数据数组</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        private unsafe static void removeTop<valueType>
            (valueType[] values, func<valueType, float> getKey, int count, valueType[] newValues, int length
            , floatSortIndex* removeFixed)
        {
            int index = 0, writeIndex = 0;
            floatSortIndex* removeEnd = removeFixed;
            while (index != length)
            {
                *removeEnd++ = new floatSortIndex { Value = getKey(values[index]), Index = index };
                ++index;
            }
            floatSortIndex* removeStart = removeFixed + (count = length - count), removeIndex = removeFixed;
            floatRangeIndexSorter sort
                = new floatRangeIndexSorter
                {
                    SkipCount = removeStart, 
                    GetEndIndex = removeStart
                };
            sort.Sort(removeFixed, --removeEnd);
            while (writeIndex != count) newValues[writeIndex++] = values[(*removeIndex++).Index];
            for (float maxValue = (*removeStart).Value; index != values.Length; ++index)
            {
                float value = getKey(values[index]);
                if (value <= maxValue) newValues[writeIndex++] = values[index];
                else
                {
                    *--removeIndex = new floatSortIndex { Value = value, Index = index };
                    if (removeIndex == removeFixed)
                    {
                        sort.Sort(removeFixed, removeEnd);
                        for (removeIndex = removeFixed; removeIndex != removeStart; newValues[writeIndex++] = values[(*removeIndex++).Index]) ;
                        maxValue = (*removeStart).Value;
                    }
                }
            }
            if (removeIndex != removeStart)
            {
                sort.Sort(removeIndex, removeEnd);
                while (removeIndex != removeStart) newValues[writeIndex++] = values[(*removeIndex++).Index];
            }
        }
    }
}
namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static list<float> GetTopDesc(float[] values, int count)
        {
            if (values == null) return null;
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, count);
                    else return getRemoveTopDesc(values, count);
                }
                float[] newValues = new float[values.Length];
                Array.Copy(values, 0, newValues, 0, values.Length);
                return new list<float>(newValues, true);
            }
            return null;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static list<float> TopDesc(float[] values, int count)
        {
            if (values == null) return null;
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, count);
                    else return getRemoveTopDesc(values, count);
                }
                return new list<float>(values, true);
            }
            return null;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static list<float> getTopDesc(float[] values, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            float[] newValues = new float[length];
            fixed (float* newValueFixed = newValues, valueFixed = values)
            {
                float* readIndex = valueFixed + values.Length - length;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), newValues, 0, length * sizeof(float));
                //unsafer.memory.Copy(readIndex, newValueFixed, length * sizeof(float));
                float* writeStat = newValueFixed + count, writeEnd = newValueFixed + --length, writeIndex = writeStat;
                floatRangeSorterDesc sort
                    = new floatRangeSorterDesc
                    {
                        SkipCount = writeStat - 1, 
                        GetEndIndex = writeStat - 1
                    };
                sort.Sort(newValueFixed, writeEnd);
                for (float maxValue = *sort.SkipCount; readIndex != valueFixed; )
                {
                    if (*--readIndex > maxValue)
                    {
                        *writeIndex = *readIndex;
                        if (writeIndex == writeEnd)
                        {
                            sort.Sort(newValueFixed, writeEnd);
                            writeIndex = writeStat;
                            maxValue = *sort.SkipCount;
                        }
                        else ++writeIndex;
                    }
                }
                if (writeIndex != writeStat) sort.Sort(newValueFixed, --writeIndex);
            }
            return newValues.left(count);
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static list<float> getRemoveTopDesc
            (float[] values, int count)
        {
            float[] newValues = new float[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            float[] removeValues = new float[length];
            fixed (float* newValueFixed = newValues, removeFixed = removeValues, valueFixed = values)
            {
                int copyCount = length - count, copyLength = copyCount * sizeof(float);
                float* readIndex = valueFixed + values.Length - length, removeStart = removeFixed + copyCount;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), removeValues, 0, length * sizeof(float));
                //unsafer.memory.Copy(readIndex, removeFixed, length * sizeof(float));
                float* removeEnd = removeFixed + --length, removeIndex = removeStart, writeIndex = newValueFixed + copyCount;
                floatRangeSorterDesc sort
                    = new floatRangeSorterDesc
                    {
                        SkipCount = removeStart,
                        GetEndIndex = removeStart
                    };
                sort.Sort(removeFixed, removeEnd);
                Buffer.BlockCopy(removeValues, 0, newValues, 0, copyLength);
                //unsafer.memory.Copy(removeFixed, newValueFixed, copyLength);
                for (float maxValue = *removeStart; readIndex != valueFixed; )
                {
                    if (*--readIndex >= maxValue) *writeIndex++ = *readIndex;
                    else
                    {
                        *--removeIndex = *readIndex;
                        if (removeIndex == removeFixed)
                        {
                            sort.Sort(removeFixed, removeEnd);
                            removeIndex = removeStart;
                            maxValue = *removeStart;
                            Buffer.BlockCopy(removeValues, 0, newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), copyLength);
                            //unsafer.memory.Copy(removeFixed, writeIndex, copyLength);
                            writeIndex += copyCount;
                        }
                    }
                }
                if (removeIndex != removeStart)
                {
                    sort.Sort(removeIndex, removeEnd);
                    Buffer.BlockCopy(removeValues, (int)((byte*)removeIndex - (byte*)removeFixed), newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), (int)((byte*)removeStart - (byte*)removeIndex));
                    //unsafer.memory.Copy(removeIndex, writeIndex, (int)(removeStart - removeIndex) * sizeof(float));
                }
            }
            return new list<float>(newValues, true);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static valueType[] GetTopDesc<valueType>
            (valueType[] values, func<valueType, float> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, getKey, count);
                    else return getRemoveTopDesc(values, getKey, count);
                }
                return values.copy();
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static valueType[] TopDesc<valueType>
            (valueType[] values, func<valueType, float> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, getKey, count);
                    else return getRemoveTopDesc(values, getKey, count);
                }
                return values.notNull();
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getTopDesc<valueType>
            (valueType[] values, func<valueType, float> getKey, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            if (length > (config.pub.Default.StreamBufferLength >> 4))
            {
                floatSortIndex[] indexs = new floatSortIndex[length];
                fixed (floatSortIndex* indexFixed = indexs)
                {
                    return getTopDesc(values, getKey, count, length, indexFixed);
                }
            }
            else
            {
                floatSortIndex* indexFixed = stackalloc floatSortIndex[length];
                return getTopDesc(values, getKey, count, length, indexFixed);
            }
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getTopDesc<valueType>
            (valueType[] values, func<valueType, float> getKey, int count, int length
            , floatSortIndex* indexFixed)
        {
            floatSortIndex* writeEnd = indexFixed;
            int index = 0;
            while (index != length)
            {
                *writeEnd++ = new floatSortIndex { Value = getKey(values[index]), Index = index };
                ++index;
            }
            floatSortIndex* writeStat = indexFixed + count, writeIndex = writeStat;
            floatRangeIndexSorterDesc sort
                = new floatRangeIndexSorterDesc
                {
                    SkipCount = writeStat - 1,
                    GetEndIndex = writeStat - 1
                };
            sort.Sort(indexFixed, --writeEnd);
            for (float maxValue = (*sort.SkipCount).Value; index != values.Length; ++index)
            {
                float value = getKey(values[index]);
                if (value > maxValue)
                {
                    *writeIndex = new floatSortIndex { Value = value, Index = index };
                    if (writeIndex == writeEnd)
                    {
                        sort.Sort(indexFixed, writeEnd);
                        writeIndex = writeStat;
                        maxValue = (*sort.SkipCount).Value;
                    }
                    else ++writeIndex;
                }
            }
            if (writeIndex != writeStat) sort.Sort(indexFixed, --writeIndex);
            valueType[] newValues = new valueType[count];
            for (writeIndex = indexFixed, index = 0; index != count; ++index)
            {
                newValues[index] = values[(*writeIndex++).Index];
            }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getRemoveTopDesc<valueType>
            (valueType[] values, func<valueType, float> getKey, int count)
        {
            valueType[] newValues = new valueType[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            if (length > (config.pub.Default.StreamBufferLength >> 4))
            {
                floatSortIndex[] removeValues = new floatSortIndex[length];
                fixed (floatSortIndex* removeFixed = removeValues)
                {
                    removeTopDesc(values, getKey, count, newValues, length, removeFixed);
                }
            }
            else
            {
                floatSortIndex* removeFixed = stackalloc  floatSortIndex[length];
                removeTopDesc(values, getKey, count, newValues, length, removeFixed);
            }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="newValues">目标数据数组</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        private unsafe static void removeTopDesc<valueType>
            (valueType[] values, func<valueType, float> getKey, int count, valueType[] newValues, int length
            , floatSortIndex* removeFixed)
        {
            int index = 0, writeIndex = 0;
            floatSortIndex* removeEnd = removeFixed;
            while (index != length)
            {
                *removeEnd++ = new floatSortIndex { Value = getKey(values[index]), Index = index };
                ++index;
            }
            floatSortIndex* removeStart = removeFixed + (count = length - count), removeIndex = removeFixed;
            floatRangeIndexSorterDesc sort
                = new floatRangeIndexSorterDesc
                {
                    SkipCount = removeStart, 
                    GetEndIndex = removeStart
                };
            sort.Sort(removeFixed, --removeEnd);
            while (writeIndex != count) newValues[writeIndex++] = values[(*removeIndex++).Index];
            for (float maxValue = (*removeStart).Value; index != values.Length; ++index)
            {
                float value = getKey(values[index]);
                if (value >= maxValue) newValues[writeIndex++] = values[index];
                else
                {
                    *--removeIndex = new floatSortIndex { Value = value, Index = index };
                    if (removeIndex == removeFixed)
                    {
                        sort.Sort(removeFixed, removeEnd);
                        for (removeIndex = removeFixed; removeIndex != removeStart; newValues[writeIndex++] = values[(*removeIndex++).Index]) ;
                        maxValue = (*removeStart).Value;
                    }
                }
            }
            if (removeIndex != removeStart)
            {
                sort.Sort(removeIndex, removeEnd);
                while (removeIndex != removeStart) newValues[writeIndex++] = values[(*removeIndex++).Index];
            }
        }
    }
}
namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static list<DateTime> GetTop(DateTime[] values, int count)
        {
            if (values == null) return null;
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTop(values, count);
                    else return getRemoveTop(values, count);
                }
                DateTime[] newValues = new DateTime[values.Length];
                Array.Copy(values, 0, newValues, 0, values.Length);
                return new list<DateTime>(newValues, true);
            }
            return null;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static list<DateTime> Top(DateTime[] values, int count)
        {
            if (values == null) return null;
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTop(values, count);
                    else return getRemoveTop(values, count);
                }
                return new list<DateTime>(values, true);
            }
            return null;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static list<DateTime> getTop(DateTime[] values, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            DateTime[] newValues = new DateTime[length];
            fixed (DateTime* newValueFixed = newValues, valueFixed = values)
            {
                DateTime* readIndex = valueFixed + values.Length - length;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), newValues, 0, length * sizeof(DateTime));
                //unsafer.memory.Copy(readIndex, newValueFixed, length * sizeof(DateTime));
                DateTime* writeStat = newValueFixed + count, writeEnd = newValueFixed + --length, writeIndex = writeStat;
                dateTimeRangeSorter sort
                    = new dateTimeRangeSorter
                    {
                        SkipCount = writeStat - 1, 
                        GetEndIndex = writeStat - 1
                    };
                sort.Sort(newValueFixed, writeEnd);
                for (DateTime maxValue = *sort.SkipCount; readIndex != valueFixed; )
                {
                    if (*--readIndex < maxValue)
                    {
                        *writeIndex = *readIndex;
                        if (writeIndex == writeEnd)
                        {
                            sort.Sort(newValueFixed, writeEnd);
                            writeIndex = writeStat;
                            maxValue = *sort.SkipCount;
                        }
                        else ++writeIndex;
                    }
                }
                if (writeIndex != writeStat) sort.Sort(newValueFixed, --writeIndex);
            }
            return newValues.left(count);
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static list<DateTime> getRemoveTop
            (DateTime[] values, int count)
        {
            DateTime[] newValues = new DateTime[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            DateTime[] removeValues = new DateTime[length];
            fixed (DateTime* newValueFixed = newValues, removeFixed = removeValues, valueFixed = values)
            {
                int copyCount = length - count, copyLength = copyCount * sizeof(DateTime);
                DateTime* readIndex = valueFixed + values.Length - length, removeStart = removeFixed + copyCount;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), removeValues, 0, length * sizeof(DateTime));
                //unsafer.memory.Copy(readIndex, removeFixed, length * sizeof(DateTime));
                DateTime* removeEnd = removeFixed + --length, removeIndex = removeStart, writeIndex = newValueFixed + copyCount;
                dateTimeRangeSorter sort
                    = new dateTimeRangeSorter
                    {
                        SkipCount = removeStart,
                        GetEndIndex = removeStart
                    };
                sort.Sort(removeFixed, removeEnd);
                Buffer.BlockCopy(removeValues, 0, newValues, 0, copyLength);
                //unsafer.memory.Copy(removeFixed, newValueFixed, copyLength);
                for (DateTime maxValue = *removeStart; readIndex != valueFixed; )
                {
                    if (*--readIndex <= maxValue) *writeIndex++ = *readIndex;
                    else
                    {
                        *--removeIndex = *readIndex;
                        if (removeIndex == removeFixed)
                        {
                            sort.Sort(removeFixed, removeEnd);
                            removeIndex = removeStart;
                            maxValue = *removeStart;
                            Buffer.BlockCopy(removeValues, 0, newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), copyLength);
                            //unsafer.memory.Copy(removeFixed, writeIndex, copyLength);
                            writeIndex += copyCount;
                        }
                    }
                }
                if (removeIndex != removeStart)
                {
                    sort.Sort(removeIndex, removeEnd);
                    Buffer.BlockCopy(removeValues, (int)((byte*)removeIndex - (byte*)removeFixed), newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), (int)((byte*)removeStart - (byte*)removeIndex));
                    //unsafer.memory.Copy(removeIndex, writeIndex, (int)(removeStart - removeIndex) * sizeof(DateTime));
                }
            }
            return new list<DateTime>(newValues, true);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static valueType[] GetTop<valueType>
            (valueType[] values, func<valueType, DateTime> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTop(values, getKey, count);
                    else return getRemoveTop(values, getKey, count);
                }
                return values.copy();
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static valueType[] Top<valueType>
            (valueType[] values, func<valueType, DateTime> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTop(values, getKey, count);
                    else return getRemoveTop(values, getKey, count);
                }
                return values.notNull();
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getTop<valueType>
            (valueType[] values, func<valueType, DateTime> getKey, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            if (length > (config.pub.Default.StreamBufferLength >> 4))
            {
                dateTimeSortIndex[] indexs = new dateTimeSortIndex[length];
                fixed (dateTimeSortIndex* indexFixed = indexs)
                {
                    return getTop(values, getKey, count, length, indexFixed);
                }
            }
            else
            {
                dateTimeSortIndex* indexFixed = stackalloc dateTimeSortIndex[length];
                return getTop(values, getKey, count, length, indexFixed);
            }
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getTop<valueType>
            (valueType[] values, func<valueType, DateTime> getKey, int count, int length
            , dateTimeSortIndex* indexFixed)
        {
            dateTimeSortIndex* writeEnd = indexFixed;
            int index = 0;
            while (index != length)
            {
                *writeEnd++ = new dateTimeSortIndex { Value = getKey(values[index]), Index = index };
                ++index;
            }
            dateTimeSortIndex* writeStat = indexFixed + count, writeIndex = writeStat;
            dateTimeRangeIndexSorter sort
                = new dateTimeRangeIndexSorter
                {
                    SkipCount = writeStat - 1,
                    GetEndIndex = writeStat - 1
                };
            sort.Sort(indexFixed, --writeEnd);
            for (DateTime maxValue = (*sort.SkipCount).Value; index != values.Length; ++index)
            {
                DateTime value = getKey(values[index]);
                if (value < maxValue)
                {
                    *writeIndex = new dateTimeSortIndex { Value = value, Index = index };
                    if (writeIndex == writeEnd)
                    {
                        sort.Sort(indexFixed, writeEnd);
                        writeIndex = writeStat;
                        maxValue = (*sort.SkipCount).Value;
                    }
                    else ++writeIndex;
                }
            }
            if (writeIndex != writeStat) sort.Sort(indexFixed, --writeIndex);
            valueType[] newValues = new valueType[count];
            for (writeIndex = indexFixed, index = 0; index != count; ++index)
            {
                newValues[index] = values[(*writeIndex++).Index];
            }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getRemoveTop<valueType>
            (valueType[] values, func<valueType, DateTime> getKey, int count)
        {
            valueType[] newValues = new valueType[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            if (length > (config.pub.Default.StreamBufferLength >> 4))
            {
                dateTimeSortIndex[] removeValues = new dateTimeSortIndex[length];
                fixed (dateTimeSortIndex* removeFixed = removeValues)
                {
                    removeTop(values, getKey, count, newValues, length, removeFixed);
                }
            }
            else
            {
                dateTimeSortIndex* removeFixed = stackalloc  dateTimeSortIndex[length];
                removeTop(values, getKey, count, newValues, length, removeFixed);
            }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="newValues">目标数据数组</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        private unsafe static void removeTop<valueType>
            (valueType[] values, func<valueType, DateTime> getKey, int count, valueType[] newValues, int length
            , dateTimeSortIndex* removeFixed)
        {
            int index = 0, writeIndex = 0;
            dateTimeSortIndex* removeEnd = removeFixed;
            while (index != length)
            {
                *removeEnd++ = new dateTimeSortIndex { Value = getKey(values[index]), Index = index };
                ++index;
            }
            dateTimeSortIndex* removeStart = removeFixed + (count = length - count), removeIndex = removeFixed;
            dateTimeRangeIndexSorter sort
                = new dateTimeRangeIndexSorter
                {
                    SkipCount = removeStart, 
                    GetEndIndex = removeStart
                };
            sort.Sort(removeFixed, --removeEnd);
            while (writeIndex != count) newValues[writeIndex++] = values[(*removeIndex++).Index];
            for (DateTime maxValue = (*removeStart).Value; index != values.Length; ++index)
            {
                DateTime value = getKey(values[index]);
                if (value <= maxValue) newValues[writeIndex++] = values[index];
                else
                {
                    *--removeIndex = new dateTimeSortIndex { Value = value, Index = index };
                    if (removeIndex == removeFixed)
                    {
                        sort.Sort(removeFixed, removeEnd);
                        for (removeIndex = removeFixed; removeIndex != removeStart; newValues[writeIndex++] = values[(*removeIndex++).Index]) ;
                        maxValue = (*removeStart).Value;
                    }
                }
            }
            if (removeIndex != removeStart)
            {
                sort.Sort(removeIndex, removeEnd);
                while (removeIndex != removeStart) newValues[writeIndex++] = values[(*removeIndex++).Index];
            }
        }
    }
}
namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static list<DateTime> GetTopDesc(DateTime[] values, int count)
        {
            if (values == null) return null;
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, count);
                    else return getRemoveTopDesc(values, count);
                }
                DateTime[] newValues = new DateTime[values.Length];
                Array.Copy(values, 0, newValues, 0, values.Length);
                return new list<DateTime>(newValues, true);
            }
            return null;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static list<DateTime> TopDesc(DateTime[] values, int count)
        {
            if (values == null) return null;
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, count);
                    else return getRemoveTopDesc(values, count);
                }
                return new list<DateTime>(values, true);
            }
            return null;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static list<DateTime> getTopDesc(DateTime[] values, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            DateTime[] newValues = new DateTime[length];
            fixed (DateTime* newValueFixed = newValues, valueFixed = values)
            {
                DateTime* readIndex = valueFixed + values.Length - length;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), newValues, 0, length * sizeof(DateTime));
                //unsafer.memory.Copy(readIndex, newValueFixed, length * sizeof(DateTime));
                DateTime* writeStat = newValueFixed + count, writeEnd = newValueFixed + --length, writeIndex = writeStat;
                dateTimeRangeSorterDesc sort
                    = new dateTimeRangeSorterDesc
                    {
                        SkipCount = writeStat - 1, 
                        GetEndIndex = writeStat - 1
                    };
                sort.Sort(newValueFixed, writeEnd);
                for (DateTime maxValue = *sort.SkipCount; readIndex != valueFixed; )
                {
                    if (*--readIndex > maxValue)
                    {
                        *writeIndex = *readIndex;
                        if (writeIndex == writeEnd)
                        {
                            sort.Sort(newValueFixed, writeEnd);
                            writeIndex = writeStat;
                            maxValue = *sort.SkipCount;
                        }
                        else ++writeIndex;
                    }
                }
                if (writeIndex != writeStat) sort.Sort(newValueFixed, --writeIndex);
            }
            return newValues.left(count);
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static list<DateTime> getRemoveTopDesc
            (DateTime[] values, int count)
        {
            DateTime[] newValues = new DateTime[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            DateTime[] removeValues = new DateTime[length];
            fixed (DateTime* newValueFixed = newValues, removeFixed = removeValues, valueFixed = values)
            {
                int copyCount = length - count, copyLength = copyCount * sizeof(DateTime);
                DateTime* readIndex = valueFixed + values.Length - length, removeStart = removeFixed + copyCount;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), removeValues, 0, length * sizeof(DateTime));
                //unsafer.memory.Copy(readIndex, removeFixed, length * sizeof(DateTime));
                DateTime* removeEnd = removeFixed + --length, removeIndex = removeStart, writeIndex = newValueFixed + copyCount;
                dateTimeRangeSorterDesc sort
                    = new dateTimeRangeSorterDesc
                    {
                        SkipCount = removeStart,
                        GetEndIndex = removeStart
                    };
                sort.Sort(removeFixed, removeEnd);
                Buffer.BlockCopy(removeValues, 0, newValues, 0, copyLength);
                //unsafer.memory.Copy(removeFixed, newValueFixed, copyLength);
                for (DateTime maxValue = *removeStart; readIndex != valueFixed; )
                {
                    if (*--readIndex >= maxValue) *writeIndex++ = *readIndex;
                    else
                    {
                        *--removeIndex = *readIndex;
                        if (removeIndex == removeFixed)
                        {
                            sort.Sort(removeFixed, removeEnd);
                            removeIndex = removeStart;
                            maxValue = *removeStart;
                            Buffer.BlockCopy(removeValues, 0, newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), copyLength);
                            //unsafer.memory.Copy(removeFixed, writeIndex, copyLength);
                            writeIndex += copyCount;
                        }
                    }
                }
                if (removeIndex != removeStart)
                {
                    sort.Sort(removeIndex, removeEnd);
                    Buffer.BlockCopy(removeValues, (int)((byte*)removeIndex - (byte*)removeFixed), newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), (int)((byte*)removeStart - (byte*)removeIndex));
                    //unsafer.memory.Copy(removeIndex, writeIndex, (int)(removeStart - removeIndex) * sizeof(DateTime));
                }
            }
            return new list<DateTime>(newValues, true);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static valueType[] GetTopDesc<valueType>
            (valueType[] values, func<valueType, DateTime> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, getKey, count);
                    else return getRemoveTopDesc(values, getKey, count);
                }
                return values.copy();
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static valueType[] TopDesc<valueType>
            (valueType[] values, func<valueType, DateTime> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, getKey, count);
                    else return getRemoveTopDesc(values, getKey, count);
                }
                return values.notNull();
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getTopDesc<valueType>
            (valueType[] values, func<valueType, DateTime> getKey, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            if (length > (config.pub.Default.StreamBufferLength >> 4))
            {
                dateTimeSortIndex[] indexs = new dateTimeSortIndex[length];
                fixed (dateTimeSortIndex* indexFixed = indexs)
                {
                    return getTopDesc(values, getKey, count, length, indexFixed);
                }
            }
            else
            {
                dateTimeSortIndex* indexFixed = stackalloc dateTimeSortIndex[length];
                return getTopDesc(values, getKey, count, length, indexFixed);
            }
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getTopDesc<valueType>
            (valueType[] values, func<valueType, DateTime> getKey, int count, int length
            , dateTimeSortIndex* indexFixed)
        {
            dateTimeSortIndex* writeEnd = indexFixed;
            int index = 0;
            while (index != length)
            {
                *writeEnd++ = new dateTimeSortIndex { Value = getKey(values[index]), Index = index };
                ++index;
            }
            dateTimeSortIndex* writeStat = indexFixed + count, writeIndex = writeStat;
            dateTimeRangeIndexSorterDesc sort
                = new dateTimeRangeIndexSorterDesc
                {
                    SkipCount = writeStat - 1,
                    GetEndIndex = writeStat - 1
                };
            sort.Sort(indexFixed, --writeEnd);
            for (DateTime maxValue = (*sort.SkipCount).Value; index != values.Length; ++index)
            {
                DateTime value = getKey(values[index]);
                if (value > maxValue)
                {
                    *writeIndex = new dateTimeSortIndex { Value = value, Index = index };
                    if (writeIndex == writeEnd)
                    {
                        sort.Sort(indexFixed, writeEnd);
                        writeIndex = writeStat;
                        maxValue = (*sort.SkipCount).Value;
                    }
                    else ++writeIndex;
                }
            }
            if (writeIndex != writeStat) sort.Sort(indexFixed, --writeIndex);
            valueType[] newValues = new valueType[count];
            for (writeIndex = indexFixed, index = 0; index != count; ++index)
            {
                newValues[index] = values[(*writeIndex++).Index];
            }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getRemoveTopDesc<valueType>
            (valueType[] values, func<valueType, DateTime> getKey, int count)
        {
            valueType[] newValues = new valueType[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            if (length > (config.pub.Default.StreamBufferLength >> 4))
            {
                dateTimeSortIndex[] removeValues = new dateTimeSortIndex[length];
                fixed (dateTimeSortIndex* removeFixed = removeValues)
                {
                    removeTopDesc(values, getKey, count, newValues, length, removeFixed);
                }
            }
            else
            {
                dateTimeSortIndex* removeFixed = stackalloc  dateTimeSortIndex[length];
                removeTopDesc(values, getKey, count, newValues, length, removeFixed);
            }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="newValues">目标数据数组</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        private unsafe static void removeTopDesc<valueType>
            (valueType[] values, func<valueType, DateTime> getKey, int count, valueType[] newValues, int length
            , dateTimeSortIndex* removeFixed)
        {
            int index = 0, writeIndex = 0;
            dateTimeSortIndex* removeEnd = removeFixed;
            while (index != length)
            {
                *removeEnd++ = new dateTimeSortIndex { Value = getKey(values[index]), Index = index };
                ++index;
            }
            dateTimeSortIndex* removeStart = removeFixed + (count = length - count), removeIndex = removeFixed;
            dateTimeRangeIndexSorterDesc sort
                = new dateTimeRangeIndexSorterDesc
                {
                    SkipCount = removeStart, 
                    GetEndIndex = removeStart
                };
            sort.Sort(removeFixed, --removeEnd);
            while (writeIndex != count) newValues[writeIndex++] = values[(*removeIndex++).Index];
            for (DateTime maxValue = (*removeStart).Value; index != values.Length; ++index)
            {
                DateTime value = getKey(values[index]);
                if (value >= maxValue) newValues[writeIndex++] = values[index];
                else
                {
                    *--removeIndex = new dateTimeSortIndex { Value = value, Index = index };
                    if (removeIndex == removeFixed)
                    {
                        sort.Sort(removeFixed, removeEnd);
                        for (removeIndex = removeFixed; removeIndex != removeStart; newValues[writeIndex++] = values[(*removeIndex++).Index]) ;
                        maxValue = (*removeStart).Value;
                    }
                }
            }
            if (removeIndex != removeStart)
            {
                sort.Sort(removeIndex, removeEnd);
                while (removeIndex != removeStart) newValues[writeIndex++] = values[(*removeIndex++).Index];
            }
        }
    }
}namespace fastCSharp.setup
{
        public partial struct remoteType
        {

            /// <summary>
            /// 成员位图
            /// </summary>
            public struct memberMap : fastCSharp.setup.cSharp.IMemberMap<memberMap>
            {
                /// <summary>
                /// 成员位图
                /// </summary>
                private uint map;
                /// <summary>
                /// 成员位图
                /// </summary>
                /// <param name="members">成员集合</param>
                public memberMap(params member[] members)
                {
                    map = 0;
                    foreach (member member in members) SetMember((int)member);
                }
                /// <summary>
                /// 成员位图
                /// </summary>
                /// <returns>成员位图</returns>
                public memberMap Copy()
                {
                    return new memberMap { map = map };
                }
                /// <summary>
                /// 是否默认全部成员有效
                /// </summary>
                public bool IsDefault
                {
                    get { return map == 0; }
                }
                /// <summary>
                /// 序列化字节长度
                /// </summary>
                public int SerializeSize
                {
                    get
                    {
                        return sizeof(uint);
                    }
                }
                /// <summary>
                /// 设置成员索引,忽略默认成员
                /// </summary>
                /// <param name="memberIndex">成员索引</param>
                public void SetMember(int memberIndex)
                {
                    map |= 1U << (int)memberIndex;
                }
                /// <summary>
                /// 清除成员索引,忽略默认成员
                /// </summary>
                /// <param name="memberIndex">成员索引</param>
                public void ClearMember(int memberIndex)
                {
                    map &= uint.MaxValue ^ (1U << (int)memberIndex);
                }
                /// <summary>
                /// 设置成员,忽略默认成员
                /// </summary>
                /// <param name="member">成员</param>
                public void SetMember(member member)
                {
                    SetMember((int)member);
                }
                /// <summary>
                /// 清除成员,忽略默认成员
                /// </summary>
                /// <param name="memberIndex">成员</param>
                public void ClearMember(member member)
                {
                    ClearMember((int)member);
                }
                /// <summary>
                /// 成员交集运算,忽略默认成员
                /// </summary>
                /// <param name="memberMap">成员位图</param>
                public void And(memberMap memberMap)
                {
                    map &= memberMap.map;
                }
                /// <summary>
                /// 成员异或运算,忽略默认成员
                /// </summary>
                /// <param name="memberMap">成员位图</param>
                public void Xor(memberMap memberMap)
                {
                    map ^= memberMap.map;
                }
                /// <summary>
                /// 成员并集运算,忽略默认成员
                /// </summary>
                /// <param name="memberMap">成员位图</param>
                public void Or(memberMap memberMap)
                {
                    map |= memberMap.map;
                }
                /// <summary>
                /// 判断成员索引是否有效
                /// </summary>
                /// <param name="memberIndex">成员索引</param>
                /// <returns>成员索引是否有效</returns>
                public bool IsMember(int memberIndex)
                {
                    return map == 0 || (map & (1 << memberIndex)) != 0;
                }
                /// <summary>
                /// 判断成员是否有效
                /// </summary>
                /// <param name="member">成员</param>
                /// <returns>成员是否有效</returns>
                public bool IsMember(member member)
                {
                    return IsMember((int)member);
                }
                /// <summary>
                /// 序列化
                /// </summary>
                /// <param name="stream">数据流</param>
                public void Serialize(memoryStream stream)
                {
                    stream.Write(map);
                }
                /// <summary>
                /// 序列化
                /// </summary>
                /// <param name="stream">数据流</param>
                public void Serialize(System.IO.Stream stream)
                {
                    stream.Write(BitConverter.GetBytes(map), 0, sizeof(uint));
                }
                /// <summary>
                /// 反序列化
                /// </summary>
                /// <param name="data">数据</param>
                /// <returns>结束位置</returns>
                public unsafe byte* DeSerialize(byte* data)
                {
                    map = *(uint*)data;
                    return data + sizeof(uint);
                }
                /// <summary>
                /// 成员获取器
                /// </summary>
                /// <returns>成员获取器</returns>
                public fastCSharp.setup.cSharp.IMemberInfo MemberInfo
                {
                    get { return new memberInfo(); }
                }
            }


            /// <summary>
            /// 成员
            /// </summary>
            public enum member
            {
                [fastCSharp.setup.cSharp.member(Type = typeof(string))]
                assemblyName = 0,
                [fastCSharp.setup.cSharp.member(Type = typeof(string))]
                name = 1,
                [fastCSharp.setup.cSharp.member(Type = typeof(System.Type))]
                Type = 2,
            }
            /// <summary>
            /// 成员信息获取器
            /// </summary>
            private struct memberInfo : fastCSharp.setup.cSharp.IMemberInfo
            {
                /// <summary>
                /// 获取成员名称
                /// </summary>
                /// <param name="memberIndex">成员索引</param>
                /// <returns>成员名称</returns>
                public string GetName(int memberIndex)
                {
                    return ((member)memberIndex).ToString();
                }
                /// <summary>
                /// 获取成员类型
                /// </summary>
                /// <param name="memberIndex">成员索引</param>
                /// <returns>成员类型</returns>
                public Type GetType(int memberIndex)
                {
                    return fastCSharp.Enum<member, fastCSharp.setup.cSharp.member>.Array(memberIndex).Type;
                }
                /// <summary>
                /// 所有成员数量
                /// </summary>
                public int MemberCount
                {
                    get
                    {
                        return 2 + 1;
                    }
                }
            }
        }
}namespace fastCSharp.setup
{
        public partial struct remoteType : fastCSharp.setup.cSharp.ICopy<fastCSharp.setup.remoteType, fastCSharp.setup.remoteType/**/.memberMap>
        {
            
            /// <summary>
            /// 成员复制
            /// </summary>
            /// <param name="value">被复制对象</param>
            /// <param name="memberMap">复制成员位图</param>
            public void CopyFrom(fastCSharp.setup.remoteType value, fastCSharp.setup.remoteType/**/.memberMap memberMap = default(fastCSharp.setup.remoteType/**/.memberMap))
            {
                if (memberMap.IsDefault)
                {
                    this.assemblyName = value.assemblyName;
                    this.name = value.name;
                }
                else
                {
                    if (memberMap.IsMember(0)) this.assemblyName = value.assemblyName;
                    if (memberMap.IsMember(1)) this.name = value.name;
                }
            }
            /// <summary>
            /// 浅复制对象
            /// </summary>
            /// <returns>复制的对象</returns>
            public fastCSharp.setup.remoteType CopyMember()
            {
                return (fastCSharp.setup.remoteType)MemberwiseClone();
            }
        }
}namespace fastCSharp.setup
{
        public partial struct remoteType : 
            fastCSharp.setup.cSharp.serialize.ISerialize<fastCSharp.setup.remoteType/**/.memberMap>, fastCSharp.setup.cSharp.serialize.IStreamSerialize<fastCSharp.setup.remoteType/**/.memberMap> 
        {
            /// <summary>
            /// 序列化
            /// </summary>
            unsafe class serializer : fastCSharp.setup.cSharp.serialize.dataSerializer
            {
                /// <summary>
                /// 序列化
                /// </summary>
                /// <param name="stream">序列化流</param>
                /// <param name="memberMap">成员位图接口</param>
                public serializer(memoryStream stream, fastCSharp.setup.cSharp.IMemberMap memberMap) : base(stream, memberMap) { }
                /// <summary>
                /// 序列化
                /// </summary>
                /// <param name="parentSerializer">序列化</param>
                /// <param name="memberMap">成员位图接口</param>
                public serializer(fastCSharp.setup.cSharp.serialize.dataSerializer parentSerializer)
                    : base(parentSerializer, default(fastCSharp.setup.remoteType/**/.memberMap)) { }
                /// <summary>
                /// 对象序列化
                /// </summary>
                /// <param name="value">对象</param>
                public void Serialize(fastCSharp.setup.remoteType value)
                {
                    {
                        versionMemerMap(0);
                        serialize(value);
                    }
                }
                /// <summary>
                /// 对象序列化
                /// </summary>
                /// <param name="value">对象</param>
                private void serialize(fastCSharp.setup.remoteType value)
                {
                    memoryStream.unsafer unsafeStream = dataStream.Unsafer;
                    int length = memberMap.SerializeSize;
                    dataStream.PrepLength(length + 8);
                    fixed (byte* dataFixed = dataStream.Array)
                    {
                        write = dataFixed + dataStream.Length;
                        fixedMap nullMap = new fixedMap(write);
                        fastCSharp.unsafer.memory.Fill(write, (uint)0, length >> 2);
                        write += length;
                        if (memberMap.IsDefault)
                        {
                            if (value.assemblyName == null) nullMap.Set(0);
                            if (value.name == null) nullMap.Set(1);
                        }
                        else
                        {
                            if (memberMap.IsMember(0))
                            {
                            if (value.assemblyName == null) nullMap.Set(0);
                            }
                            if (memberMap.IsMember(1))
                            {
                            if (value.name == null) nullMap.Set(1);
                            }
                        }
                        unsafeStream.AddLength(((int)(write - dataFixed - dataStream.Length) + 3) & (int.MaxValue - 3));
                    }
                    if (memberMap.IsDefault)
                    {
                        serializeString(value.assemblyName);
                        serializeString(value.name);
                    }
                    else
                    {
                        if (memberMap.IsMember(0))
                        {
                        serializeString(value.assemblyName);
                        }
                        if (memberMap.IsMember(1))
                        {
                        serializeString(value.name);
                        }
                    }
                }
            }
            /// <summary>
            /// 对象序列化
            /// </summary>
            /// <returns>序列化数据</returns>
            public byte[] Serialize()
            {
                using (memoryStream stream = new memoryStream())
                {
                    Serialize(stream, default(fastCSharp.setup.remoteType/**/.memberMap));
                    return stream.ToArray();
                }
            }
            /// <summary>
            /// 对象序列化
            /// </summary>
            /// <param name="stream">数据流</param>
            public void Serialize(memoryStream stream)
            {
                Serialize(stream, default(fastCSharp.setup.remoteType/**/.memberMap));
            }
            /// <summary>
            /// 对象序列化
            /// </summary>
            /// <param name="stream">数据流</param>
            /// <param name="memberMap">成员位图接口</param>
            public void Serialize(memoryStream stream, fastCSharp.setup.remoteType/**/.memberMap memberMap)
            {
                serializer serializer = new serializer(stream, memberMap);
                serializer.Serialize(this);
                serializer.Finally();
            }
            /// <summary>
            /// 对象序列化
            /// </summary>
            /// <param name="serializer">对象序列化器</param>
            public void Serialize(fastCSharp.setup.cSharp.serialize.dataSerializer parentSerializer)
            {
                new serializer(parentSerializer).Serialize(this);
            }
            /// <summary>
            /// 序列化
            /// </summary>
            unsafe class streamSerializer : fastCSharp.setup.cSharp.serialize.streamSerializer
            {
                /// <summary>
                /// 序列化
                /// </summary>
                /// <param name="stream">序列化流</param>
                /// <param name="memberMap">成员位图接口</param>
                public streamSerializer(System.IO.Stream stream, fastCSharp.setup.cSharp.IMemberMap memberMap)
                    : base(stream, memberMap, 8) { }
                /// <summary>
                /// 序列化
                /// </summary>
                /// <param name="parentSerializer">对象序列化器</param>
                public streamSerializer(fastCSharp.setup.cSharp.serialize.streamSerializer parentSerializer)
                    : base(parentSerializer, default(fastCSharp.setup.remoteType/**/.memberMap), 8) { }
                /// <summary>
                /// 对象序列化
                /// </summary>
                /// <param name="value">对象</param>
                public void Serialize(fastCSharp.setup.remoteType value)
                {
                    {
                        fixed (byte* dataFixed = valueData)
                        {
                            dataPoint = dataFixed;
                            versionMemerMap(0);
                            serialize(value);
                        }
                    }
                }
                /// <summary>
                /// 对象序列化
                /// </summary>
                /// <param name="value">对象</param>
                private void serialize(fastCSharp.setup.remoteType value)
                {
                    int length = memberMap.SerializeSize;
                    fixedMap nullMap = new fixedMap(dataPoint);
                    fastCSharp.unsafer.memory.Fill(dataPoint, (uint)0, length >> 2);
                    write = dataPoint + length;
                    if (memberMap.IsDefault)
                    {
                            if (value.assemblyName == null) nullMap.Set(0);
                            if (value.name == null) nullMap.Set(1);
                    }
                    else
                    {
                        if (memberMap.IsMember(0))
                        {
                            if (value.assemblyName == null) nullMap.Set(0);
                        }
                        if (memberMap.IsMember(1))
                        {
                            if (value.name == null) nullMap.Set(1);
                        }
                    }
                    #region Attribute.IsTestCase
                    if ((length = (int)(write - dataPoint) & 3) != 0)
                    {
                        while (length++ != 4) *write++ = 0;
                    }
                    #endregion Attribute.IsTestCase
                    dataStream.Write(valueData, 0, ((int)(write - dataPoint) + 3) & (int.MaxValue - 3));
                    if (memberMap.IsDefault)
                    {
                        serializeString(value.assemblyName);
                        serializeString(value.name);
                    }
                    else
                    {
                        if (memberMap.IsMember(0))
                        {
                        serializeString(value.assemblyName);
                        }
                        if (memberMap.IsMember(1))
                        {
                        serializeString(value.name);
                        }
                    }
                }
            }
            /// <summary>
            /// 对象序列化
            /// </summary>
            /// <param name="stream">数据流</param>
            public void Serialize(System.IO.Stream stream)
            {
                Serialize(stream, default(fastCSharp.setup.remoteType/**/.memberMap));
            }
            /// <summary>
            /// 对象序列化
            /// </summary>
            /// <param name="stream">数据流</param>
            /// <param name="memberMap">成员位图接口</param>
            public void Serialize(System.IO.Stream stream, fastCSharp.setup.remoteType/**/.memberMap memberMap)
            {
                streamSerializer streamSerializer = new streamSerializer(stream, memberMap);
                streamSerializer.Serialize(this);
                streamSerializer.Finally();
            }
            /// <summary>
            /// 对象序列化
            /// </summary>
            /// <param name="parentSerializer">对象序列化器</param>
            public void Serialize(fastCSharp.setup.cSharp.serialize.streamSerializer parentSerializer)
            {
                new streamSerializer(parentSerializer).Serialize(this);
            }
            /// <summary>
            /// 对象反序列化
            /// </summary>
            unsafe class deSerializer : fastCSharp.setup.cSharp.serialize.deSerializer
            {
                /// <summary>
                /// 成员位图接口
                /// </summary>
                public fastCSharp.setup.remoteType/**/.memberMap MemberMap;
                /// <summary>
                /// 对象反序列化
                /// </summary>
                /// <param name="data">序列化数据</param>
                public deSerializer(byte[] data) : base(data) { }
                /// <summary>
                /// 对象反序列化
                /// </summary>
                /// <param name="parentDeSerializer">对象反序列化器</param>
                public deSerializer(fastCSharp.setup.cSharp.serialize.deSerializer parentDeSerializer)
                    : base(parentDeSerializer) { }
                /// <summary>
                /// 反序列化
                /// </summary>
                /// <param name="value">反序列化目标对象</param>
                /// <param name="startIndex">数据起始位置</param>
                /// <returns>数据对象</returns>
                public fastCSharp.setup.remoteType DeSerialize(fastCSharp.setup.remoteType value, int startIndex)
                {
                    fixed (byte* dataFixed = data)
                    {
                        this.dataFixed = dataFixed;
                        dataStart = read = dataFixed + startIndex;
                        dataVersion = *(int*)read;
                        if (dataVersion != (int)fastCSharp.setup.cSharp.serializeVersion.serialize)
                        {
                            fastCSharp.log.Default.Throw("序列化格式版本号不匹配 fastCSharp.setup.cSharp.serializeVersion.serialize[" + ((int)fastCSharp.setup.cSharp.serializeVersion.serialize).toString() + "] != " + dataVersion.toString(), true, false);
                        }
                        dataVersion = *(int*)(read += sizeof(int));
                        {
                            versionMemberMap();
                            value = DeSerializeData(value);
                            checkEnd();
                            return value;
                        }
                    }
                }
                /// <summary>
                /// 版本号+成员位图接口
                /// </summary>
                protected override void versionMemberMap()
                {
                    if (dataVersion != 0)
                    {
                        fastCSharp.log.Default.Throw("序列化版本号错误 0 != " + dataVersion.toString(), true, false);
                    }
                    read = MemberMap.DeSerialize(read += sizeof(int));
                }
                /// <summary>
                /// 反序列化
                /// </summary>
                /// <param name="value">反序列化目标对象</param>
                /// <returns>数据对象</returns>
                public fastCSharp.setup.remoteType DeSerialize(fastCSharp.setup.remoteType value)
                {
                    dataVersion = *(int*)read;
                    versionMemberMap();
                    return DeSerializeData(value);
                }
                /// <summary>
                /// 反序列化
                /// </summary>
                /// <param name="value">反序列化目标对象</param>
                /// <returns>数据对象</returns>
                public fastCSharp.setup.remoteType DeSerializeData(fastCSharp.setup.remoteType value)
                {
                    fixedMap nullMap = new fixedMap(read);
                    read += MemberMap.SerializeSize;
                    if (MemberMap.IsDefault)
                    {
                        if (nullMap.Get(0)) value.assemblyName = default(string);
                        if (nullMap.Get(1)) value.name = default(string);
                    }
                    else
                    {
                        if (MemberMap.IsMember(0))
                        {
                        if (nullMap.Get(0)) value.assemblyName = default(string);
                        }
                        if (MemberMap.IsMember(1))
                        {
                        if (nullMap.Get(1)) value.name = default(string);
                        }
                    }
                    int length = (int)(read - nullMap.Map);
                    if ((length & 3) != 0) read += -length & 3;
                    if (MemberMap.IsDefault)
                    {
                        if (!nullMap.Get(0))
                        {
                            value.assemblyName = getString();
                        }
                        if (!nullMap.Get(1))
                        {
                            value.name = getString();
                        }
                    }
                    else
                    {
                        if (MemberMap.IsMember(0))
                        {
                        if (!nullMap.Get(0))
                        {
                            value.assemblyName = getString();
                        }
                        }
                        if (MemberMap.IsMember(1))
                        {
                        if (!nullMap.Get(1))
                        {
                            value.name = getString();
                        }
                        }
                    }
                    return value;
                }
            }
            /// <summary>
            /// 反序列化
            /// </summary>
            /// <param name="data">序列化数据</param>
            public bool DeSerialize(byte[] data)
            {
                return DeSerialize(data, 0, out deSerializer.OutEndIndex);
            }
            /// <summary>
            /// 反序列化
            /// </summary>
            /// <param name="data">序列化数据</param>
            /// <param name="startIndex">起始位置</param>
            /// <param name="endIndex">结束位置</param>
            public bool DeSerialize(byte[] data, int startIndex, out int endIndex)
            {
                deSerializer deSerializer = new deSerializer(data);
                fastCSharp.setup.remoteType value = deSerializer.DeSerialize(this, startIndex);
                
                CopyFrom(value);
                endIndex = deSerializer.EndIndex;
                return endIndex <= data.Length;
            }
            /// <summary>
            /// 反序列化
            /// </summary>
            /// <param name="parentDeSerializer">对象反序列化器</param>
            public unsafe void DeSerialize(fastCSharp.setup.cSharp.serialize.deSerializer parentDeSerializer)
            {
                deSerializer deSerializer = new deSerializer(parentDeSerializer);
                
                fastCSharp.setup.remoteType value = deSerializer.DeSerialize(this);
                
                CopyFrom(value);
                parentDeSerializer.SetRead(deSerializer);
            }
        }
}namespace fastCSharp.setup
{
    public partial class tcpRegister
    {
        partial struct clientId
        {

            /// <summary>
            /// 成员位图
            /// </summary>
            public struct memberMap : fastCSharp.setup.cSharp.IMemberMap<memberMap>
            {
                /// <summary>
                /// 成员位图
                /// </summary>
                private uint map;
                /// <summary>
                /// 成员位图
                /// </summary>
                /// <param name="members">成员集合</param>
                public memberMap(params member[] members)
                {
                    map = 0;
                    foreach (member member in members) SetMember((int)member);
                }
                /// <summary>
                /// 成员位图
                /// </summary>
                /// <returns>成员位图</returns>
                public memberMap Copy()
                {
                    return new memberMap { map = map };
                }
                /// <summary>
                /// 是否默认全部成员有效
                /// </summary>
                public bool IsDefault
                {
                    get { return map == 0; }
                }
                /// <summary>
                /// 序列化字节长度
                /// </summary>
                public int SerializeSize
                {
                    get
                    {
                        return sizeof(uint);
                    }
                }
                /// <summary>
                /// 设置成员索引,忽略默认成员
                /// </summary>
                /// <param name="memberIndex">成员索引</param>
                public void SetMember(int memberIndex)
                {
                    map |= 1U << (int)memberIndex;
                }
                /// <summary>
                /// 清除成员索引,忽略默认成员
                /// </summary>
                /// <param name="memberIndex">成员索引</param>
                public void ClearMember(int memberIndex)
                {
                    map &= uint.MaxValue ^ (1U << (int)memberIndex);
                }
                /// <summary>
                /// 设置成员,忽略默认成员
                /// </summary>
                /// <param name="member">成员</param>
                public void SetMember(member member)
                {
                    SetMember((int)member);
                }
                /// <summary>
                /// 清除成员,忽略默认成员
                /// </summary>
                /// <param name="memberIndex">成员</param>
                public void ClearMember(member member)
                {
                    ClearMember((int)member);
                }
                /// <summary>
                /// 成员交集运算,忽略默认成员
                /// </summary>
                /// <param name="memberMap">成员位图</param>
                public void And(memberMap memberMap)
                {
                    map &= memberMap.map;
                }
                /// <summary>
                /// 成员异或运算,忽略默认成员
                /// </summary>
                /// <param name="memberMap">成员位图</param>
                public void Xor(memberMap memberMap)
                {
                    map ^= memberMap.map;
                }
                /// <summary>
                /// 成员并集运算,忽略默认成员
                /// </summary>
                /// <param name="memberMap">成员位图</param>
                public void Or(memberMap memberMap)
                {
                    map |= memberMap.map;
                }
                /// <summary>
                /// 判断成员索引是否有效
                /// </summary>
                /// <param name="memberIndex">成员索引</param>
                /// <returns>成员索引是否有效</returns>
                public bool IsMember(int memberIndex)
                {
                    return map == 0 || (map & (1 << memberIndex)) != 0;
                }
                /// <summary>
                /// 判断成员是否有效
                /// </summary>
                /// <param name="member">成员</param>
                /// <returns>成员是否有效</returns>
                public bool IsMember(member member)
                {
                    return IsMember((int)member);
                }
                /// <summary>
                /// 序列化
                /// </summary>
                /// <param name="stream">数据流</param>
                public void Serialize(memoryStream stream)
                {
                    stream.Write(map);
                }
                /// <summary>
                /// 序列化
                /// </summary>
                /// <param name="stream">数据流</param>
                public void Serialize(System.IO.Stream stream)
                {
                    stream.Write(BitConverter.GetBytes(map), 0, sizeof(uint));
                }
                /// <summary>
                /// 反序列化
                /// </summary>
                /// <param name="data">数据</param>
                /// <returns>结束位置</returns>
                public unsafe byte* DeSerialize(byte* data)
                {
                    map = *(uint*)data;
                    return data + sizeof(uint);
                }
                /// <summary>
                /// 成员获取器
                /// </summary>
                /// <returns>成员获取器</returns>
                public fastCSharp.setup.cSharp.IMemberInfo MemberInfo
                {
                    get { return new memberInfo(); }
                }
            }


            /// <summary>
            /// 成员
            /// </summary>
            public enum member
            {
                [fastCSharp.setup.cSharp.member(Type = typeof(long))]
                Tick = 0,
                [fastCSharp.setup.cSharp.member(Type = typeof(int))]
                Identity = 1,
                [fastCSharp.setup.cSharp.member(Type = typeof(int))]
                Version = 2,
            }
            /// <summary>
            /// 成员信息获取器
            /// </summary>
            private struct memberInfo : fastCSharp.setup.cSharp.IMemberInfo
            {
                /// <summary>
                /// 获取成员名称
                /// </summary>
                /// <param name="memberIndex">成员索引</param>
                /// <returns>成员名称</returns>
                public string GetName(int memberIndex)
                {
                    return ((member)memberIndex).ToString();
                }
                /// <summary>
                /// 获取成员类型
                /// </summary>
                /// <param name="memberIndex">成员索引</param>
                /// <returns>成员类型</returns>
                public Type GetType(int memberIndex)
                {
                    return fastCSharp.Enum<member, fastCSharp.setup.cSharp.member>.Array(memberIndex).Type;
                }
                /// <summary>
                /// 所有成员数量
                /// </summary>
                public int MemberCount
                {
                    get
                    {
                        return 2 + 1;
                    }
                }
            }
        }
    }
}namespace fastCSharp.setup
{
    public partial class tcpRegister
    {
        partial struct clientId : fastCSharp.setup.cSharp.ICopy<fastCSharp.setup.tcpRegister.clientId, fastCSharp.setup.tcpRegister.clientId/**/.memberMap>
        {
            
            /// <summary>
            /// 成员复制
            /// </summary>
            /// <param name="value">被复制对象</param>
            /// <param name="memberMap">复制成员位图</param>
            public void CopyFrom(fastCSharp.setup.tcpRegister.clientId value, fastCSharp.setup.tcpRegister.clientId/**/.memberMap memberMap = default(fastCSharp.setup.tcpRegister.clientId/**/.memberMap))
            {
                if (memberMap.IsDefault)
                {
                    this.Tick = value.Tick;
                    this.Identity = value.Identity;
                    this.Version = value.Version;
                }
                else
                {
                    if (memberMap.IsMember(0)) this.Tick = value.Tick;
                    if (memberMap.IsMember(1)) this.Identity = value.Identity;
                    if (memberMap.IsMember(2)) this.Version = value.Version;
                }
            }
            /// <summary>
            /// 浅复制对象
            /// </summary>
            /// <returns>复制的对象</returns>
            public fastCSharp.setup.tcpRegister.clientId CopyMember()
            {
                return (fastCSharp.setup.tcpRegister.clientId)MemberwiseClone();
            }
        }
    }
}namespace fastCSharp.setup
{
    public partial class tcpRegister
    {
        partial struct clientId : 
            fastCSharp.setup.cSharp.serialize.ISerialize<fastCSharp.setup.tcpRegister.clientId/**/.memberMap>
        {
            /// <summary>
            /// 序列化
            /// </summary>
            unsafe class serializer : fastCSharp.setup.cSharp.serialize.dataSerializer
            {
                /// <summary>
                /// 序列化
                /// </summary>
                /// <param name="stream">序列化流</param>
                /// <param name="memberMap">成员位图接口</param>
                public serializer(memoryStream stream, fastCSharp.setup.cSharp.IMemberMap memberMap) : base(stream, memberMap) { }
                /// <summary>
                /// 序列化
                /// </summary>
                /// <param name="parentSerializer">序列化</param>
                /// <param name="memberMap">成员位图接口</param>
                public serializer(fastCSharp.setup.cSharp.serialize.dataSerializer parentSerializer)
                    : base(parentSerializer, default(fastCSharp.setup.tcpRegister.clientId/**/.memberMap)) { }
                /// <summary>
                /// 对象序列化
                /// </summary>
                /// <param name="value">对象</param>
                public void Serialize(fastCSharp.setup.tcpRegister.clientId value)
                {
                    {
                        versionMemerMap(0);
                        serialize(value);
                    }
                }
                /// <summary>
                /// 对象序列化
                /// </summary>
                /// <param name="value">对象</param>
                private void serialize(fastCSharp.setup.tcpRegister.clientId value)
                {
                    memoryStream.unsafer unsafeStream = dataStream.Unsafer;
                    int length = memberMap.SerializeSize;
                    dataStream.PrepLength(length + 16);
                    fixed (byte* dataFixed = dataStream.Array)
                    {
                        write = dataFixed + dataStream.Length;
                        fixedMap nullMap = new fixedMap(write);
                        fastCSharp.unsafer.memory.Fill(write, (uint)0, length >> 2);
                        write += length;
                        if (memberMap.IsDefault)
                        {
                            {
                                *(long*)write = (long)value.Tick;
                                write += sizeof(long);
                            }
                            {
                                *(int*)write = (int)value.Identity;
                                write += sizeof(int);
                            }
                            {
                                *(int*)write = (int)value.Version;
                                write += sizeof(int);
                            }
                        }
                        else
                        {
                            if (memberMap.IsMember(0))
                            {
                            {
                                *(long*)write = (long)value.Tick;
                                write += sizeof(long);
                            }
                            }
                            if (memberMap.IsMember(1))
                            {
                            {
                                *(int*)write = (int)value.Identity;
                                write += sizeof(int);
                            }
                            }
                            if (memberMap.IsMember(2))
                            {
                            {
                                *(int*)write = (int)value.Version;
                                write += sizeof(int);
                            }
                            }
                        }
                        unsafeStream.AddLength(((int)(write - dataFixed - dataStream.Length) + 3) & (int.MaxValue - 3));
                    }
                    if (memberMap.IsDefault)
                    {
                    }
                    else
                    {
                    }
                }
            }
            /// <summary>
            /// 对象序列化
            /// </summary>
            /// <returns>序列化数据</returns>
            public byte[] Serialize()
            {
                using (memoryStream stream = new memoryStream())
                {
                    Serialize(stream, default(fastCSharp.setup.tcpRegister.clientId/**/.memberMap));
                    return stream.ToArray();
                }
            }
            /// <summary>
            /// 对象序列化
            /// </summary>
            /// <param name="stream">数据流</param>
            public void Serialize(memoryStream stream)
            {
                Serialize(stream, default(fastCSharp.setup.tcpRegister.clientId/**/.memberMap));
            }
            /// <summary>
            /// 对象序列化
            /// </summary>
            /// <param name="stream">数据流</param>
            /// <param name="memberMap">成员位图接口</param>
            public void Serialize(memoryStream stream, fastCSharp.setup.tcpRegister.clientId/**/.memberMap memberMap)
            {
                serializer serializer = new serializer(stream, memberMap);
                serializer.Serialize(this);
                serializer.Finally();
            }
            /// <summary>
            /// 对象序列化
            /// </summary>
            /// <param name="serializer">对象序列化器</param>
            public void Serialize(fastCSharp.setup.cSharp.serialize.dataSerializer parentSerializer)
            {
                new serializer(parentSerializer).Serialize(this);
            }
            /// <summary>
            /// 对象反序列化
            /// </summary>
            unsafe class deSerializer : fastCSharp.setup.cSharp.serialize.deSerializer
            {
                /// <summary>
                /// 成员位图接口
                /// </summary>
                public fastCSharp.setup.tcpRegister.clientId/**/.memberMap MemberMap;
                /// <summary>
                /// 对象反序列化
                /// </summary>
                /// <param name="data">序列化数据</param>
                public deSerializer(byte[] data) : base(data) { }
                /// <summary>
                /// 对象反序列化
                /// </summary>
                /// <param name="parentDeSerializer">对象反序列化器</param>
                public deSerializer(fastCSharp.setup.cSharp.serialize.deSerializer parentDeSerializer)
                    : base(parentDeSerializer) { }
                /// <summary>
                /// 反序列化
                /// </summary>
                /// <param name="value">反序列化目标对象</param>
                /// <param name="startIndex">数据起始位置</param>
                /// <returns>数据对象</returns>
                public fastCSharp.setup.tcpRegister.clientId DeSerialize(fastCSharp.setup.tcpRegister.clientId value, int startIndex)
                {
                    fixed (byte* dataFixed = data)
                    {
                        this.dataFixed = dataFixed;
                        dataStart = read = dataFixed + startIndex;
                        dataVersion = *(int*)read;
                        if (dataVersion != (int)fastCSharp.setup.cSharp.serializeVersion.serialize)
                        {
                            fastCSharp.log.Default.Throw("序列化格式版本号不匹配 fastCSharp.setup.cSharp.serializeVersion.serialize[" + ((int)fastCSharp.setup.cSharp.serializeVersion.serialize).toString() + "] != " + dataVersion.toString(), true, false);
                        }
                        dataVersion = *(int*)(read += sizeof(int));
                        {
                            versionMemberMap();
                            value = DeSerializeData(value);
                            checkEnd();
                            return value;
                        }
                    }
                }
                /// <summary>
                /// 版本号+成员位图接口
                /// </summary>
                protected override void versionMemberMap()
                {
                    if (dataVersion != 0)
                    {
                        fastCSharp.log.Default.Throw("序列化版本号错误 0 != " + dataVersion.toString(), true, false);
                    }
                    read = MemberMap.DeSerialize(read += sizeof(int));
                }
                /// <summary>
                /// 反序列化
                /// </summary>
                /// <param name="value">反序列化目标对象</param>
                /// <returns>数据对象</returns>
                public fastCSharp.setup.tcpRegister.clientId DeSerialize(fastCSharp.setup.tcpRegister.clientId value)
                {
                    dataVersion = *(int*)read;
                    versionMemberMap();
                    return DeSerializeData(value);
                }
                /// <summary>
                /// 反序列化
                /// </summary>
                /// <param name="value">反序列化目标对象</param>
                /// <returns>数据对象</returns>
                public fastCSharp.setup.tcpRegister.clientId DeSerializeData(fastCSharp.setup.tcpRegister.clientId value)
                {
                    fixedMap nullMap = new fixedMap(read);
                    read += MemberMap.SerializeSize;
                    if (MemberMap.IsDefault)
                    {
                        {
                            value.Tick = (*(long*)read);
                            read += sizeof(long);
                        }
                        {
                            value.Identity = (*(int*)read);
                            read += sizeof(int);
                        }
                        {
                            value.Version = (*(int*)read);
                            read += sizeof(int);
                        }
                    }
                    else
                    {
                        if (MemberMap.IsMember(0))
                        {
                        {
                            value.Tick = (*(long*)read);
                            read += sizeof(long);
                        }
                        }
                        if (MemberMap.IsMember(1))
                        {
                        {
                            value.Identity = (*(int*)read);
                            read += sizeof(int);
                        }
                        }
                        if (MemberMap.IsMember(2))
                        {
                        {
                            value.Version = (*(int*)read);
                            read += sizeof(int);
                        }
                        }
                    }
                    int length = (int)(read - nullMap.Map);
                    if ((length & 3) != 0) read += -length & 3;
                    if (MemberMap.IsDefault)
                    {
                    }
                    else
                    {
                    }
                    return value;
                }
            }
            /// <summary>
            /// 反序列化
            /// </summary>
            /// <param name="data">序列化数据</param>
            public bool DeSerialize(byte[] data)
            {
                return DeSerialize(data, 0, out deSerializer.OutEndIndex);
            }
            /// <summary>
            /// 反序列化
            /// </summary>
            /// <param name="data">序列化数据</param>
            /// <param name="startIndex">起始位置</param>
            /// <param name="endIndex">结束位置</param>
            public bool DeSerialize(byte[] data, int startIndex, out int endIndex)
            {
                deSerializer deSerializer = new deSerializer(data);
                fastCSharp.setup.tcpRegister.clientId value = deSerializer.DeSerialize(this, startIndex);
                
                CopyFrom(value);
                endIndex = deSerializer.EndIndex;
                return endIndex <= data.Length;
            }
            /// <summary>
            /// 反序列化
            /// </summary>
            /// <param name="parentDeSerializer">对象反序列化器</param>
            public unsafe void DeSerialize(fastCSharp.setup.cSharp.serialize.deSerializer parentDeSerializer)
            {
                deSerializer deSerializer = new deSerializer(parentDeSerializer);
                
                fastCSharp.setup.tcpRegister.clientId value = deSerializer.DeSerialize(this);
                
                CopyFrom(value);
                parentDeSerializer.SetRead(deSerializer);
            }
        }
    }
}namespace fastCSharp.setup
{
    public partial class tcpRegister
    {
        partial struct host
        {

            /// <summary>
            /// 成员位图
            /// </summary>
            public struct memberMap : fastCSharp.setup.cSharp.IMemberMap<memberMap>
            {
                /// <summary>
                /// 成员位图
                /// </summary>
                private uint map;
                /// <summary>
                /// 成员位图
                /// </summary>
                /// <param name="members">成员集合</param>
                public memberMap(params member[] members)
                {
                    map = 0;
                    foreach (member member in members) SetMember((int)member);
                }
                /// <summary>
                /// 成员位图
                /// </summary>
                /// <returns>成员位图</returns>
                public memberMap Copy()
                {
                    return new memberMap { map = map };
                }
                /// <summary>
                /// 是否默认全部成员有效
                /// </summary>
                public bool IsDefault
                {
                    get { return map == 0; }
                }
                /// <summary>
                /// 序列化字节长度
                /// </summary>
                public int SerializeSize
                {
                    get
                    {
                        return sizeof(uint);
                    }
                }
                /// <summary>
                /// 设置成员索引,忽略默认成员
                /// </summary>
                /// <param name="memberIndex">成员索引</param>
                public void SetMember(int memberIndex)
                {
                    map |= 1U << (int)memberIndex;
                }
                /// <summary>
                /// 清除成员索引,忽略默认成员
                /// </summary>
                /// <param name="memberIndex">成员索引</param>
                public void ClearMember(int memberIndex)
                {
                    map &= uint.MaxValue ^ (1U << (int)memberIndex);
                }
                /// <summary>
                /// 设置成员,忽略默认成员
                /// </summary>
                /// <param name="member">成员</param>
                public void SetMember(member member)
                {
                    SetMember((int)member);
                }
                /// <summary>
                /// 清除成员,忽略默认成员
                /// </summary>
                /// <param name="memberIndex">成员</param>
                public void ClearMember(member member)
                {
                    ClearMember((int)member);
                }
                /// <summary>
                /// 成员交集运算,忽略默认成员
                /// </summary>
                /// <param name="memberMap">成员位图</param>
                public void And(memberMap memberMap)
                {
                    map &= memberMap.map;
                }
                /// <summary>
                /// 成员异或运算,忽略默认成员
                /// </summary>
                /// <param name="memberMap">成员位图</param>
                public void Xor(memberMap memberMap)
                {
                    map ^= memberMap.map;
                }
                /// <summary>
                /// 成员并集运算,忽略默认成员
                /// </summary>
                /// <param name="memberMap">成员位图</param>
                public void Or(memberMap memberMap)
                {
                    map |= memberMap.map;
                }
                /// <summary>
                /// 判断成员索引是否有效
                /// </summary>
                /// <param name="memberIndex">成员索引</param>
                /// <returns>成员索引是否有效</returns>
                public bool IsMember(int memberIndex)
                {
                    return map == 0 || (map & (1 << memberIndex)) != 0;
                }
                /// <summary>
                /// 判断成员是否有效
                /// </summary>
                /// <param name="member">成员</param>
                /// <returns>成员是否有效</returns>
                public bool IsMember(member member)
                {
                    return IsMember((int)member);
                }
                /// <summary>
                /// 序列化
                /// </summary>
                /// <param name="stream">数据流</param>
                public void Serialize(memoryStream stream)
                {
                    stream.Write(map);
                }
                /// <summary>
                /// 序列化
                /// </summary>
                /// <param name="stream">数据流</param>
                public void Serialize(System.IO.Stream stream)
                {
                    stream.Write(BitConverter.GetBytes(map), 0, sizeof(uint));
                }
                /// <summary>
                /// 反序列化
                /// </summary>
                /// <param name="data">数据</param>
                /// <returns>结束位置</returns>
                public unsafe byte* DeSerialize(byte* data)
                {
                    map = *(uint*)data;
                    return data + sizeof(uint);
                }
                /// <summary>
                /// 成员获取器
                /// </summary>
                /// <returns>成员获取器</returns>
                public fastCSharp.setup.cSharp.IMemberInfo MemberInfo
                {
                    get { return new memberInfo(); }
                }
            }


            /// <summary>
            /// 成员
            /// </summary>
            public enum member
            {
                [fastCSharp.setup.cSharp.member(Type = typeof(string))]
                Host = 0,
                [fastCSharp.setup.cSharp.member(Type = typeof(int))]
                Port = 1,
            }
            /// <summary>
            /// 成员信息获取器
            /// </summary>
            private struct memberInfo : fastCSharp.setup.cSharp.IMemberInfo
            {
                /// <summary>
                /// 获取成员名称
                /// </summary>
                /// <param name="memberIndex">成员索引</param>
                /// <returns>成员名称</returns>
                public string GetName(int memberIndex)
                {
                    return ((member)memberIndex).ToString();
                }
                /// <summary>
                /// 获取成员类型
                /// </summary>
                /// <param name="memberIndex">成员索引</param>
                /// <returns>成员类型</returns>
                public Type GetType(int memberIndex)
                {
                    return fastCSharp.Enum<member, fastCSharp.setup.cSharp.member>.Array(memberIndex).Type;
                }
                /// <summary>
                /// 所有成员数量
                /// </summary>
                public int MemberCount
                {
                    get
                    {
                        return 1 + 1;
                    }
                }
            }
        }
    }
}namespace fastCSharp.setup
{
    public partial class tcpRegister
    {
        partial struct host : fastCSharp.setup.cSharp.ICopy<fastCSharp.setup.tcpRegister.host, fastCSharp.setup.tcpRegister.host/**/.memberMap>
        {
            
            /// <summary>
            /// 成员复制
            /// </summary>
            /// <param name="value">被复制对象</param>
            /// <param name="memberMap">复制成员位图</param>
            public void CopyFrom(fastCSharp.setup.tcpRegister.host value, fastCSharp.setup.tcpRegister.host/**/.memberMap memberMap = default(fastCSharp.setup.tcpRegister.host/**/.memberMap))
            {
                if (memberMap.IsDefault)
                {
                    this.Host = value.Host;
                    this.Port = value.Port;
                }
                else
                {
                    if (memberMap.IsMember(0)) this.Host = value.Host;
                    if (memberMap.IsMember(1)) this.Port = value.Port;
                }
            }
            /// <summary>
            /// 浅复制对象
            /// </summary>
            /// <returns>复制的对象</returns>
            public fastCSharp.setup.tcpRegister.host CopyMember()
            {
                return (fastCSharp.setup.tcpRegister.host)MemberwiseClone();
            }
        }
    }
}namespace fastCSharp.setup
{
    public partial class tcpRegister
    {
        partial struct host : 
            fastCSharp.setup.cSharp.serialize.ISerialize<fastCSharp.setup.tcpRegister.host/**/.memberMap>
        {
            /// <summary>
            /// 序列化
            /// </summary>
            unsafe class serializer : fastCSharp.setup.cSharp.serialize.dataSerializer
            {
                /// <summary>
                /// 序列化
                /// </summary>
                /// <param name="stream">序列化流</param>
                /// <param name="memberMap">成员位图接口</param>
                public serializer(memoryStream stream, fastCSharp.setup.cSharp.IMemberMap memberMap) : base(stream, memberMap) { }
                /// <summary>
                /// 序列化
                /// </summary>
                /// <param name="parentSerializer">序列化</param>
                /// <param name="memberMap">成员位图接口</param>
                public serializer(fastCSharp.setup.cSharp.serialize.dataSerializer parentSerializer)
                    : base(parentSerializer, default(fastCSharp.setup.tcpRegister.host/**/.memberMap)) { }
                /// <summary>
                /// 对象序列化
                /// </summary>
                /// <param name="value">对象</param>
                public void Serialize(fastCSharp.setup.tcpRegister.host value)
                {
                    {
                        versionMemerMap(0);
                        serialize(value);
                    }
                }
                /// <summary>
                /// 对象序列化
                /// </summary>
                /// <param name="value">对象</param>
                private void serialize(fastCSharp.setup.tcpRegister.host value)
                {
                    memoryStream.unsafer unsafeStream = dataStream.Unsafer;
                    int length = memberMap.SerializeSize;
                    dataStream.PrepLength(length + 8);
                    fixed (byte* dataFixed = dataStream.Array)
                    {
                        write = dataFixed + dataStream.Length;
                        fixedMap nullMap = new fixedMap(write);
                        fastCSharp.unsafer.memory.Fill(write, (uint)0, length >> 2);
                        write += length;
                        if (memberMap.IsDefault)
                        {
                            if (value.Host == null) nullMap.Set(0);
                            {
                                *(int*)write = (int)value.Port;
                                write += sizeof(int);
                            }
                        }
                        else
                        {
                            if (memberMap.IsMember(0))
                            {
                            if (value.Host == null) nullMap.Set(0);
                            }
                            if (memberMap.IsMember(1))
                            {
                            {
                                *(int*)write = (int)value.Port;
                                write += sizeof(int);
                            }
                            }
                        }
                        unsafeStream.AddLength(((int)(write - dataFixed - dataStream.Length) + 3) & (int.MaxValue - 3));
                    }
                    if (memberMap.IsDefault)
                    {
                        serializeString(value.Host);
                    }
                    else
                    {
                        if (memberMap.IsMember(0))
                        {
                        serializeString(value.Host);
                        }
                    }
                }
            }
            /// <summary>
            /// 对象序列化
            /// </summary>
            /// <returns>序列化数据</returns>
            public byte[] Serialize()
            {
                using (memoryStream stream = new memoryStream())
                {
                    Serialize(stream, default(fastCSharp.setup.tcpRegister.host/**/.memberMap));
                    return stream.ToArray();
                }
            }
            /// <summary>
            /// 对象序列化
            /// </summary>
            /// <param name="stream">数据流</param>
            public void Serialize(memoryStream stream)
            {
                Serialize(stream, default(fastCSharp.setup.tcpRegister.host/**/.memberMap));
            }
            /// <summary>
            /// 对象序列化
            /// </summary>
            /// <param name="stream">数据流</param>
            /// <param name="memberMap">成员位图接口</param>
            public void Serialize(memoryStream stream, fastCSharp.setup.tcpRegister.host/**/.memberMap memberMap)
            {
                serializer serializer = new serializer(stream, memberMap);
                serializer.Serialize(this);
                serializer.Finally();
            }
            /// <summary>
            /// 对象序列化
            /// </summary>
            /// <param name="serializer">对象序列化器</param>
            public void Serialize(fastCSharp.setup.cSharp.serialize.dataSerializer parentSerializer)
            {
                new serializer(parentSerializer).Serialize(this);
            }
            /// <summary>
            /// 对象反序列化
            /// </summary>
            unsafe class deSerializer : fastCSharp.setup.cSharp.serialize.deSerializer
            {
                /// <summary>
                /// 成员位图接口
                /// </summary>
                public fastCSharp.setup.tcpRegister.host/**/.memberMap MemberMap;
                /// <summary>
                /// 对象反序列化
                /// </summary>
                /// <param name="data">序列化数据</param>
                public deSerializer(byte[] data) : base(data) { }
                /// <summary>
                /// 对象反序列化
                /// </summary>
                /// <param name="parentDeSerializer">对象反序列化器</param>
                public deSerializer(fastCSharp.setup.cSharp.serialize.deSerializer parentDeSerializer)
                    : base(parentDeSerializer) { }
                /// <summary>
                /// 反序列化
                /// </summary>
                /// <param name="value">反序列化目标对象</param>
                /// <param name="startIndex">数据起始位置</param>
                /// <returns>数据对象</returns>
                public fastCSharp.setup.tcpRegister.host DeSerialize(fastCSharp.setup.tcpRegister.host value, int startIndex)
                {
                    fixed (byte* dataFixed = data)
                    {
                        this.dataFixed = dataFixed;
                        dataStart = read = dataFixed + startIndex;
                        dataVersion = *(int*)read;
                        if (dataVersion != (int)fastCSharp.setup.cSharp.serializeVersion.serialize)
                        {
                            fastCSharp.log.Default.Throw("序列化格式版本号不匹配 fastCSharp.setup.cSharp.serializeVersion.serialize[" + ((int)fastCSharp.setup.cSharp.serializeVersion.serialize).toString() + "] != " + dataVersion.toString(), true, false);
                        }
                        dataVersion = *(int*)(read += sizeof(int));
                        {
                            versionMemberMap();
                            value = DeSerializeData(value);
                            checkEnd();
                            return value;
                        }
                    }
                }
                /// <summary>
                /// 版本号+成员位图接口
                /// </summary>
                protected override void versionMemberMap()
                {
                    if (dataVersion != 0)
                    {
                        fastCSharp.log.Default.Throw("序列化版本号错误 0 != " + dataVersion.toString(), true, false);
                    }
                    read = MemberMap.DeSerialize(read += sizeof(int));
                }
                /// <summary>
                /// 反序列化
                /// </summary>
                /// <param name="value">反序列化目标对象</param>
                /// <returns>数据对象</returns>
                public fastCSharp.setup.tcpRegister.host DeSerialize(fastCSharp.setup.tcpRegister.host value)
                {
                    dataVersion = *(int*)read;
                    versionMemberMap();
                    return DeSerializeData(value);
                }
                /// <summary>
                /// 反序列化
                /// </summary>
                /// <param name="value">反序列化目标对象</param>
                /// <returns>数据对象</returns>
                public fastCSharp.setup.tcpRegister.host DeSerializeData(fastCSharp.setup.tcpRegister.host value)
                {
                    fixedMap nullMap = new fixedMap(read);
                    read += MemberMap.SerializeSize;
                    if (MemberMap.IsDefault)
                    {
                        if (nullMap.Get(0)) value.Host = default(string);
                        {
                            value.Port = (*(int*)read);
                            read += sizeof(int);
                        }
                    }
                    else
                    {
                        if (MemberMap.IsMember(0))
                        {
                        if (nullMap.Get(0)) value.Host = default(string);
                        }
                        if (MemberMap.IsMember(1))
                        {
                        {
                            value.Port = (*(int*)read);
                            read += sizeof(int);
                        }
                        }
                    }
                    int length = (int)(read - nullMap.Map);
                    if ((length & 3) != 0) read += -length & 3;
                    if (MemberMap.IsDefault)
                    {
                        if (!nullMap.Get(0))
                        {
                            value.Host = getString();
                        }
                    }
                    else
                    {
                        if (MemberMap.IsMember(0))
                        {
                        if (!nullMap.Get(0))
                        {
                            value.Host = getString();
                        }
                        }
                    }
                    return value;
                }
            }
            /// <summary>
            /// 反序列化
            /// </summary>
            /// <param name="data">序列化数据</param>
            public bool DeSerialize(byte[] data)
            {
                return DeSerialize(data, 0, out deSerializer.OutEndIndex);
            }
            /// <summary>
            /// 反序列化
            /// </summary>
            /// <param name="data">序列化数据</param>
            /// <param name="startIndex">起始位置</param>
            /// <param name="endIndex">结束位置</param>
            public bool DeSerialize(byte[] data, int startIndex, out int endIndex)
            {
                deSerializer deSerializer = new deSerializer(data);
                fastCSharp.setup.tcpRegister.host value = deSerializer.DeSerialize(this, startIndex);
                
                CopyFrom(value);
                endIndex = deSerializer.EndIndex;
                return endIndex <= data.Length;
            }
            /// <summary>
            /// 反序列化
            /// </summary>
            /// <param name="parentDeSerializer">对象反序列化器</param>
            public unsafe void DeSerialize(fastCSharp.setup.cSharp.serialize.deSerializer parentDeSerializer)
            {
                deSerializer deSerializer = new deSerializer(parentDeSerializer);
                
                fastCSharp.setup.tcpRegister.host value = deSerializer.DeSerialize(this);
                
                CopyFrom(value);
                parentDeSerializer.SetRead(deSerializer);
            }
        }
    }
}namespace fastCSharp.setup
{
    public partial class tcpRegister
    {
        partial struct services
        {

            /// <summary>
            /// 成员位图
            /// </summary>
            public struct memberMap : fastCSharp.setup.cSharp.IMemberMap<memberMap>
            {
                /// <summary>
                /// 成员位图
                /// </summary>
                private uint map;
                /// <summary>
                /// 成员位图
                /// </summary>
                /// <param name="members">成员集合</param>
                public memberMap(params member[] members)
                {
                    map = 0;
                    foreach (member member in members) SetMember((int)member);
                }
                /// <summary>
                /// 成员位图
                /// </summary>
                /// <returns>成员位图</returns>
                public memberMap Copy()
                {
                    return new memberMap { map = map };
                }
                /// <summary>
                /// 是否默认全部成员有效
                /// </summary>
                public bool IsDefault
                {
                    get { return map == 0; }
                }
                /// <summary>
                /// 序列化字节长度
                /// </summary>
                public int SerializeSize
                {
                    get
                    {
                        return sizeof(uint);
                    }
                }
                /// <summary>
                /// 设置成员索引,忽略默认成员
                /// </summary>
                /// <param name="memberIndex">成员索引</param>
                public void SetMember(int memberIndex)
                {
                    map |= 1U << (int)memberIndex;
                }
                /// <summary>
                /// 清除成员索引,忽略默认成员
                /// </summary>
                /// <param name="memberIndex">成员索引</param>
                public void ClearMember(int memberIndex)
                {
                    map &= uint.MaxValue ^ (1U << (int)memberIndex);
                }
                /// <summary>
                /// 设置成员,忽略默认成员
                /// </summary>
                /// <param name="member">成员</param>
                public void SetMember(member member)
                {
                    SetMember((int)member);
                }
                /// <summary>
                /// 清除成员,忽略默认成员
                /// </summary>
                /// <param name="memberIndex">成员</param>
                public void ClearMember(member member)
                {
                    ClearMember((int)member);
                }
                /// <summary>
                /// 成员交集运算,忽略默认成员
                /// </summary>
                /// <param name="memberMap">成员位图</param>
                public void And(memberMap memberMap)
                {
                    map &= memberMap.map;
                }
                /// <summary>
                /// 成员异或运算,忽略默认成员
                /// </summary>
                /// <param name="memberMap">成员位图</param>
                public void Xor(memberMap memberMap)
                {
                    map ^= memberMap.map;
                }
                /// <summary>
                /// 成员并集运算,忽略默认成员
                /// </summary>
                /// <param name="memberMap">成员位图</param>
                public void Or(memberMap memberMap)
                {
                    map |= memberMap.map;
                }
                /// <summary>
                /// 判断成员索引是否有效
                /// </summary>
                /// <param name="memberIndex">成员索引</param>
                /// <returns>成员索引是否有效</returns>
                public bool IsMember(int memberIndex)
                {
                    return map == 0 || (map & (1 << memberIndex)) != 0;
                }
                /// <summary>
                /// 判断成员是否有效
                /// </summary>
                /// <param name="member">成员</param>
                /// <returns>成员是否有效</returns>
                public bool IsMember(member member)
                {
                    return IsMember((int)member);
                }
                /// <summary>
                /// 序列化
                /// </summary>
                /// <param name="stream">数据流</param>
                public void Serialize(memoryStream stream)
                {
                    stream.Write(map);
                }
                /// <summary>
                /// 序列化
                /// </summary>
                /// <param name="stream">数据流</param>
                public void Serialize(System.IO.Stream stream)
                {
                    stream.Write(BitConverter.GetBytes(map), 0, sizeof(uint));
                }
                /// <summary>
                /// 反序列化
                /// </summary>
                /// <param name="data">数据</param>
                /// <returns>结束位置</returns>
                public unsafe byte* DeSerialize(byte* data)
                {
                    map = *(uint*)data;
                    return data + sizeof(uint);
                }
                /// <summary>
                /// 成员获取器
                /// </summary>
                /// <returns>成员获取器</returns>
                public fastCSharp.setup.cSharp.IMemberInfo MemberInfo
                {
                    get { return new memberInfo(); }
                }
            }


            /// <summary>
            /// 成员
            /// </summary>
            public enum member
            {
                [fastCSharp.setup.cSharp.member(Type = typeof(string))]
                Name = 0,
                [fastCSharp.setup.cSharp.member(Type = typeof(fastCSharp.setup.tcpRegister.host[]))]
                Hosts = 1,
                [fastCSharp.setup.cSharp.member(Type = typeof(bool))]
                IsSingle = 2,
            }
            /// <summary>
            /// 成员信息获取器
            /// </summary>
            private struct memberInfo : fastCSharp.setup.cSharp.IMemberInfo
            {
                /// <summary>
                /// 获取成员名称
                /// </summary>
                /// <param name="memberIndex">成员索引</param>
                /// <returns>成员名称</returns>
                public string GetName(int memberIndex)
                {
                    return ((member)memberIndex).ToString();
                }
                /// <summary>
                /// 获取成员类型
                /// </summary>
                /// <param name="memberIndex">成员索引</param>
                /// <returns>成员类型</returns>
                public Type GetType(int memberIndex)
                {
                    return fastCSharp.Enum<member, fastCSharp.setup.cSharp.member>.Array(memberIndex).Type;
                }
                /// <summary>
                /// 所有成员数量
                /// </summary>
                public int MemberCount
                {
                    get
                    {
                        return 2 + 1;
                    }
                }
            }
        }
    }
}namespace fastCSharp.setup
{
    public partial class tcpRegister
    {
        partial struct services : fastCSharp.setup.cSharp.ICopy<fastCSharp.setup.tcpRegister.services, fastCSharp.setup.tcpRegister.services/**/.memberMap>
        {
            
            /// <summary>
            /// 成员复制
            /// </summary>
            /// <param name="value">被复制对象</param>
            /// <param name="memberMap">复制成员位图</param>
            public void CopyFrom(fastCSharp.setup.tcpRegister.services value, fastCSharp.setup.tcpRegister.services/**/.memberMap memberMap = default(fastCSharp.setup.tcpRegister.services/**/.memberMap))
            {
                if (memberMap.IsDefault)
                {
                    this.Name = value.Name;
                    this.Hosts = value.Hosts;
                    this.IsSingle = value.IsSingle;
                }
                else
                {
                    if (memberMap.IsMember(0)) this.Name = value.Name;
                    if (memberMap.IsMember(1)) this.Hosts = value.Hosts;
                    if (memberMap.IsMember(2)) this.IsSingle = value.IsSingle;
                }
            }
            /// <summary>
            /// 浅复制对象
            /// </summary>
            /// <returns>复制的对象</returns>
            public fastCSharp.setup.tcpRegister.services CopyMember()
            {
                return (fastCSharp.setup.tcpRegister.services)MemberwiseClone();
            }
        }
    }
}namespace fastCSharp.setup
{
    public partial class tcpRegister
    {
        partial struct services : 
            fastCSharp.setup.cSharp.serialize.ISerialize<fastCSharp.setup.tcpRegister.services/**/.memberMap>
        {
            /// <summary>
            /// 序列化
            /// </summary>
            unsafe class serializer : fastCSharp.setup.cSharp.serialize.dataSerializer
            {
                /// <summary>
                /// 序列化
                /// </summary>
                /// <param name="stream">序列化流</param>
                /// <param name="memberMap">成员位图接口</param>
                public serializer(memoryStream stream, fastCSharp.setup.cSharp.IMemberMap memberMap) : base(stream, memberMap) { }
                /// <summary>
                /// 序列化
                /// </summary>
                /// <param name="parentSerializer">序列化</param>
                /// <param name="memberMap">成员位图接口</param>
                public serializer(fastCSharp.setup.cSharp.serialize.dataSerializer parentSerializer)
                    : base(parentSerializer, default(fastCSharp.setup.tcpRegister.services/**/.memberMap)) { }
                /// <summary>
                /// 对象序列化
                /// </summary>
                /// <param name="value">对象</param>
                public void Serialize(fastCSharp.setup.tcpRegister.services value)
                {
                    {
                        versionMemerMap(0);
                        serialize(value);
                    }
                }
                /// <summary>
                /// 对象序列化
                /// </summary>
                /// <param name="value">对象</param>
                private void serialize(fastCSharp.setup.tcpRegister.services value)
                {
                    memoryStream.unsafer unsafeStream = dataStream.Unsafer;
                    int length = memberMap.SerializeSize;
                    dataStream.PrepLength(length + 12);
                    fixed (byte* dataFixed = dataStream.Array)
                    {
                        write = dataFixed + dataStream.Length;
                        fixedMap nullMap = new fixedMap(write);
                        fastCSharp.unsafer.memory.Fill(write, (uint)0, length >> 2);
                        write += length;
                        if (memberMap.IsDefault)
                        {
                            if (value.Name == null) nullMap.Set(0);
                            if (value.Hosts == null) nullMap.Set(1);
                            {
                                *(bool*)write = (bool)value.IsSingle;
                                write += sizeof(bool);
                            }
                        }
                        else
                        {
                            if (memberMap.IsMember(0))
                            {
                            if (value.Name == null) nullMap.Set(0);
                            }
                            if (memberMap.IsMember(1))
                            {
                            if (value.Hosts == null) nullMap.Set(1);
                            }
                            if (memberMap.IsMember(2))
                            {
                            {
                                *(bool*)write = (bool)value.IsSingle;
                                write += sizeof(bool);
                            }
                            }
                        }
                        unsafeStream.AddLength(((int)(write - dataFixed - dataStream.Length) + 3) & (int.MaxValue - 3));
                    }
                    if (memberMap.IsDefault)
                    {
                        serializeString(value.Name);
                        {
                            fastCSharp.setup.tcpRegister.host[] enumerable = value.Hosts;
                            if (checkPoint(enumerable))
                            {
                                fastCSharp.setup.tcpRegister.host[] array = enumerable;
                                iSerializeArrayNotNullNoPoint(array);

                            }
                        }
                    }
                    else
                    {
                        if (memberMap.IsMember(0))
                        {
                        serializeString(value.Name);
                        }
                        if (memberMap.IsMember(1))
                        {
                        {
                            fastCSharp.setup.tcpRegister.host[] enumerable = value.Hosts;
                            if (checkPoint(enumerable))
                            {
                                fastCSharp.setup.tcpRegister.host[] array = enumerable;
                                iSerializeArrayNotNullNoPoint(array);

                            }
                        }
                        }
                    }
                }
            }
            /// <summary>
            /// 对象序列化
            /// </summary>
            /// <returns>序列化数据</returns>
            public byte[] Serialize()
            {
                using (memoryStream stream = new memoryStream())
                {
                    Serialize(stream, default(fastCSharp.setup.tcpRegister.services/**/.memberMap));
                    return stream.ToArray();
                }
            }
            /// <summary>
            /// 对象序列化
            /// </summary>
            /// <param name="stream">数据流</param>
            public void Serialize(memoryStream stream)
            {
                Serialize(stream, default(fastCSharp.setup.tcpRegister.services/**/.memberMap));
            }
            /// <summary>
            /// 对象序列化
            /// </summary>
            /// <param name="stream">数据流</param>
            /// <param name="memberMap">成员位图接口</param>
            public void Serialize(memoryStream stream, fastCSharp.setup.tcpRegister.services/**/.memberMap memberMap)
            {
                serializer serializer = new serializer(stream, memberMap);
                serializer.Serialize(this);
                serializer.Finally();
            }
            /// <summary>
            /// 对象序列化
            /// </summary>
            /// <param name="serializer">对象序列化器</param>
            public void Serialize(fastCSharp.setup.cSharp.serialize.dataSerializer parentSerializer)
            {
                new serializer(parentSerializer).Serialize(this);
            }
            /// <summary>
            /// 对象反序列化
            /// </summary>
            unsafe class deSerializer : fastCSharp.setup.cSharp.serialize.deSerializer
            {
                /// <summary>
                /// 成员位图接口
                /// </summary>
                public fastCSharp.setup.tcpRegister.services/**/.memberMap MemberMap;
                /// <summary>
                /// 对象反序列化
                /// </summary>
                /// <param name="data">序列化数据</param>
                public deSerializer(byte[] data) : base(data) { }
                /// <summary>
                /// 对象反序列化
                /// </summary>
                /// <param name="parentDeSerializer">对象反序列化器</param>
                public deSerializer(fastCSharp.setup.cSharp.serialize.deSerializer parentDeSerializer)
                    : base(parentDeSerializer) { }
                /// <summary>
                /// 反序列化
                /// </summary>
                /// <param name="value">反序列化目标对象</param>
                /// <param name="startIndex">数据起始位置</param>
                /// <returns>数据对象</returns>
                public fastCSharp.setup.tcpRegister.services DeSerialize(fastCSharp.setup.tcpRegister.services value, int startIndex)
                {
                    fixed (byte* dataFixed = data)
                    {
                        this.dataFixed = dataFixed;
                        dataStart = read = dataFixed + startIndex;
                        dataVersion = *(int*)read;
                        if (dataVersion != (int)fastCSharp.setup.cSharp.serializeVersion.serialize)
                        {
                            fastCSharp.log.Default.Throw("序列化格式版本号不匹配 fastCSharp.setup.cSharp.serializeVersion.serialize[" + ((int)fastCSharp.setup.cSharp.serializeVersion.serialize).toString() + "] != " + dataVersion.toString(), true, false);
                        }
                        dataVersion = *(int*)(read += sizeof(int));
                        {
                            versionMemberMap();
                            value = DeSerializeData(value);
                            checkEnd();
                            return value;
                        }
                    }
                }
                /// <summary>
                /// 版本号+成员位图接口
                /// </summary>
                protected override void versionMemberMap()
                {
                    if (dataVersion != 0)
                    {
                        fastCSharp.log.Default.Throw("序列化版本号错误 0 != " + dataVersion.toString(), true, false);
                    }
                    read = MemberMap.DeSerialize(read += sizeof(int));
                }
                /// <summary>
                /// 反序列化
                /// </summary>
                /// <param name="value">反序列化目标对象</param>
                /// <returns>数据对象</returns>
                public fastCSharp.setup.tcpRegister.services DeSerialize(fastCSharp.setup.tcpRegister.services value)
                {
                    dataVersion = *(int*)read;
                    versionMemberMap();
                    return DeSerializeData(value);
                }
                /// <summary>
                /// 反序列化
                /// </summary>
                /// <param name="value">反序列化目标对象</param>
                /// <returns>数据对象</returns>
                public fastCSharp.setup.tcpRegister.services DeSerializeData(fastCSharp.setup.tcpRegister.services value)
                {
                    fixedMap nullMap = new fixedMap(read);
                    read += MemberMap.SerializeSize;
                    if (MemberMap.IsDefault)
                    {
                        if (nullMap.Get(0)) value.Name = default(string);
                        if (nullMap.Get(1)) value.Hosts = default(fastCSharp.setup.tcpRegister.host[]);
                        {
                            value.IsSingle = (*(bool*)read);
                            read += sizeof(bool);
                        }
                    }
                    else
                    {
                        if (MemberMap.IsMember(0))
                        {
                        if (nullMap.Get(0)) value.Name = default(string);
                        }
                        if (MemberMap.IsMember(1))
                        {
                        if (nullMap.Get(1)) value.Hosts = default(fastCSharp.setup.tcpRegister.host[]);
                        }
                        if (MemberMap.IsMember(2))
                        {
                        {
                            value.IsSingle = (*(bool*)read);
                            read += sizeof(bool);
                        }
                        }
                    }
                    int length = (int)(read - nullMap.Map);
                    if ((length & 3) != 0) read += -length & 3;
                    if (MemberMap.IsDefault)
                    {
                        if (!nullMap.Get(0))
                        {
                            value.Name = getString();
                        }
                        if (!nullMap.Get(1))
                        {
                            {
                                object reference = getPoint();
                                if (reference != null) value.Hosts = (fastCSharp.setup.tcpRegister.host[])reference;
                                else
                                {
                                    length = *(int*)read;
                                    fastCSharp.setup.tcpRegister.host[] enumerable = new fastCSharp.setup.tcpRegister.host[length];
                                    points.Add(-(int)(read - dataStart), enumerable);
                                    read += sizeof(int);
                                    fastCSharp.setup.tcpRegister.host[] array = new fastCSharp.setup.tcpRegister.host[length];
                                    iSerializeArrayNotNullNoPoint(array);

                                    Array.Copy(array, 0, enumerable, 0, array.Length);
                                    value.Hosts = enumerable;
                                }
                            }
                        }
                    }
                    else
                    {
                        if (MemberMap.IsMember(0))
                        {
                        if (!nullMap.Get(0))
                        {
                            value.Name = getString();
                        }
                        }
                        if (MemberMap.IsMember(1))
                        {
                        if (!nullMap.Get(1))
                        {
                            {
                                object reference = getPoint();
                                if (reference != null) value.Hosts = (fastCSharp.setup.tcpRegister.host[])reference;
                                else
                                {
                                    length = *(int*)read;
                                    fastCSharp.setup.tcpRegister.host[] enumerable = new fastCSharp.setup.tcpRegister.host[length];
                                    points.Add(-(int)(read - dataStart), enumerable);
                                    read += sizeof(int);
                                    fastCSharp.setup.tcpRegister.host[] array = new fastCSharp.setup.tcpRegister.host[length];
                                    iSerializeArrayNotNullNoPoint(array);

                                    Array.Copy(array, 0, enumerable, 0, array.Length);
                                    value.Hosts = enumerable;
                                }
                            }
                        }
                        }
                    }
                    return value;
                }
            }
            /// <summary>
            /// 反序列化
            /// </summary>
            /// <param name="data">序列化数据</param>
            public bool DeSerialize(byte[] data)
            {
                return DeSerialize(data, 0, out deSerializer.OutEndIndex);
            }
            /// <summary>
            /// 反序列化
            /// </summary>
            /// <param name="data">序列化数据</param>
            /// <param name="startIndex">起始位置</param>
            /// <param name="endIndex">结束位置</param>
            public bool DeSerialize(byte[] data, int startIndex, out int endIndex)
            {
                deSerializer deSerializer = new deSerializer(data);
                fastCSharp.setup.tcpRegister.services value = deSerializer.DeSerialize(this, startIndex);
                
                CopyFrom(value);
                endIndex = deSerializer.EndIndex;
                return endIndex <= data.Length;
            }
            /// <summary>
            /// 反序列化
            /// </summary>
            /// <param name="parentDeSerializer">对象反序列化器</param>
            public unsafe void DeSerialize(fastCSharp.setup.cSharp.serialize.deSerializer parentDeSerializer)
            {
                deSerializer deSerializer = new deSerializer(parentDeSerializer);
                
                fastCSharp.setup.tcpRegister.services value = deSerializer.DeSerialize(this);
                
                CopyFrom(value);
                parentDeSerializer.SetRead(deSerializer);
            }
        }
    }
}namespace fastCSharp.setup
{
    public partial class tcpRegister
    {
        partial struct registerResult
        {

            /// <summary>
            /// 成员位图
            /// </summary>
            public struct memberMap : fastCSharp.setup.cSharp.IMemberMap<memberMap>
            {
                /// <summary>
                /// 成员位图
                /// </summary>
                private uint map;
                /// <summary>
                /// 成员位图
                /// </summary>
                /// <param name="members">成员集合</param>
                public memberMap(params member[] members)
                {
                    map = 0;
                    foreach (member member in members) SetMember((int)member);
                }
                /// <summary>
                /// 成员位图
                /// </summary>
                /// <returns>成员位图</returns>
                public memberMap Copy()
                {
                    return new memberMap { map = map };
                }
                /// <summary>
                /// 是否默认全部成员有效
                /// </summary>
                public bool IsDefault
                {
                    get { return map == 0; }
                }
                /// <summary>
                /// 序列化字节长度
                /// </summary>
                public int SerializeSize
                {
                    get
                    {
                        return sizeof(uint);
                    }
                }
                /// <summary>
                /// 设置成员索引,忽略默认成员
                /// </summary>
                /// <param name="memberIndex">成员索引</param>
                public void SetMember(int memberIndex)
                {
                    map |= 1U << (int)memberIndex;
                }
                /// <summary>
                /// 清除成员索引,忽略默认成员
                /// </summary>
                /// <param name="memberIndex">成员索引</param>
                public void ClearMember(int memberIndex)
                {
                    map &= uint.MaxValue ^ (1U << (int)memberIndex);
                }
                /// <summary>
                /// 设置成员,忽略默认成员
                /// </summary>
                /// <param name="member">成员</param>
                public void SetMember(member member)
                {
                    SetMember((int)member);
                }
                /// <summary>
                /// 清除成员,忽略默认成员
                /// </summary>
                /// <param name="memberIndex">成员</param>
                public void ClearMember(member member)
                {
                    ClearMember((int)member);
                }
                /// <summary>
                /// 成员交集运算,忽略默认成员
                /// </summary>
                /// <param name="memberMap">成员位图</param>
                public void And(memberMap memberMap)
                {
                    map &= memberMap.map;
                }
                /// <summary>
                /// 成员异或运算,忽略默认成员
                /// </summary>
                /// <param name="memberMap">成员位图</param>
                public void Xor(memberMap memberMap)
                {
                    map ^= memberMap.map;
                }
                /// <summary>
                /// 成员并集运算,忽略默认成员
                /// </summary>
                /// <param name="memberMap">成员位图</param>
                public void Or(memberMap memberMap)
                {
                    map |= memberMap.map;
                }
                /// <summary>
                /// 判断成员索引是否有效
                /// </summary>
                /// <param name="memberIndex">成员索引</param>
                /// <returns>成员索引是否有效</returns>
                public bool IsMember(int memberIndex)
                {
                    return map == 0 || (map & (1 << memberIndex)) != 0;
                }
                /// <summary>
                /// 判断成员是否有效
                /// </summary>
                /// <param name="member">成员</param>
                /// <returns>成员是否有效</returns>
                public bool IsMember(member member)
                {
                    return IsMember((int)member);
                }
                /// <summary>
                /// 序列化
                /// </summary>
                /// <param name="stream">数据流</param>
                public void Serialize(memoryStream stream)
                {
                    stream.Write(map);
                }
                /// <summary>
                /// 序列化
                /// </summary>
                /// <param name="stream">数据流</param>
                public void Serialize(System.IO.Stream stream)
                {
                    stream.Write(BitConverter.GetBytes(map), 0, sizeof(uint));
                }
                /// <summary>
                /// 反序列化
                /// </summary>
                /// <param name="data">数据</param>
                /// <returns>结束位置</returns>
                public unsafe byte* DeSerialize(byte* data)
                {
                    map = *(uint*)data;
                    return data + sizeof(uint);
                }
                /// <summary>
                /// 成员获取器
                /// </summary>
                /// <returns>成员获取器</returns>
                public fastCSharp.setup.cSharp.IMemberInfo MemberInfo
                {
                    get { return new memberInfo(); }
                }
            }


            /// <summary>
            /// 成员
            /// </summary>
            public enum member
            {
                [fastCSharp.setup.cSharp.member(Type = typeof(fastCSharp.setup.tcpRegister.registerState))]
                State = 0,
                [fastCSharp.setup.cSharp.member(Type = typeof(fastCSharp.setup.tcpRegister.service))]
                Service = 1,
            }
            /// <summary>
            /// 成员信息获取器
            /// </summary>
            private struct memberInfo : fastCSharp.setup.cSharp.IMemberInfo
            {
                /// <summary>
                /// 获取成员名称
                /// </summary>
                /// <param name="memberIndex">成员索引</param>
                /// <returns>成员名称</returns>
                public string GetName(int memberIndex)
                {
                    return ((member)memberIndex).ToString();
                }
                /// <summary>
                /// 获取成员类型
                /// </summary>
                /// <param name="memberIndex">成员索引</param>
                /// <returns>成员类型</returns>
                public Type GetType(int memberIndex)
                {
                    return fastCSharp.Enum<member, fastCSharp.setup.cSharp.member>.Array(memberIndex).Type;
                }
                /// <summary>
                /// 所有成员数量
                /// </summary>
                public int MemberCount
                {
                    get
                    {
                        return 1 + 1;
                    }
                }
            }
        }
    }
}namespace fastCSharp.setup
{
    public partial class tcpRegister
    {
        partial struct registerResult : fastCSharp.setup.cSharp.ICopy<fastCSharp.setup.tcpRegister.registerResult, fastCSharp.setup.tcpRegister.registerResult/**/.memberMap>
        {
            
            /// <summary>
            /// 成员复制
            /// </summary>
            /// <param name="value">被复制对象</param>
            /// <param name="memberMap">复制成员位图</param>
            public void CopyFrom(fastCSharp.setup.tcpRegister.registerResult value, fastCSharp.setup.tcpRegister.registerResult/**/.memberMap memberMap = default(fastCSharp.setup.tcpRegister.registerResult/**/.memberMap))
            {
                if (memberMap.IsDefault)
                {
                    this.State = value.State;
                    this.Service = value.Service;
                }
                else
                {
                    if (memberMap.IsMember(0)) this.State = value.State;
                    if (memberMap.IsMember(1)) this.Service = value.Service;
                }
            }
            /// <summary>
            /// 浅复制对象
            /// </summary>
            /// <returns>复制的对象</returns>
            public fastCSharp.setup.tcpRegister.registerResult CopyMember()
            {
                return (fastCSharp.setup.tcpRegister.registerResult)MemberwiseClone();
            }
        }
    }
}namespace fastCSharp.setup
{
    public partial class tcpRegister
    {
        partial struct registerResult : 
            fastCSharp.setup.cSharp.serialize.ISerialize<fastCSharp.setup.tcpRegister.registerResult/**/.memberMap>
        {
            /// <summary>
            /// 序列化
            /// </summary>
            unsafe class serializer : fastCSharp.setup.cSharp.serialize.dataSerializer
            {
                /// <summary>
                /// 序列化
                /// </summary>
                /// <param name="stream">序列化流</param>
                /// <param name="memberMap">成员位图接口</param>
                public serializer(memoryStream stream, fastCSharp.setup.cSharp.IMemberMap memberMap) : base(stream, memberMap) { }
                /// <summary>
                /// 序列化
                /// </summary>
                /// <param name="parentSerializer">序列化</param>
                /// <param name="memberMap">成员位图接口</param>
                public serializer(fastCSharp.setup.cSharp.serialize.dataSerializer parentSerializer)
                    : base(parentSerializer, default(fastCSharp.setup.tcpRegister.registerResult/**/.memberMap)) { }
                /// <summary>
                /// 对象序列化
                /// </summary>
                /// <param name="value">对象</param>
                public void Serialize(fastCSharp.setup.tcpRegister.registerResult value)
                {
                    {
                        versionMemerMap(0);
                        serialize(value);
                    }
                }
                /// <summary>
                /// 对象序列化
                /// </summary>
                /// <param name="value">对象</param>
                private void serialize(fastCSharp.setup.tcpRegister.registerResult value)
                {
                    memoryStream.unsafer unsafeStream = dataStream.Unsafer;
                    int length = memberMap.SerializeSize;
                    dataStream.PrepLength(length + 8);
                    fixed (byte* dataFixed = dataStream.Array)
                    {
                        write = dataFixed + dataStream.Length;
                        fixedMap nullMap = new fixedMap(write);
                        fastCSharp.unsafer.memory.Fill(write, (uint)0, length >> 2);
                        write += length;
                        if (memberMap.IsDefault)
                        {
                            {
                                *(int*)write = (int)(int)value.State;
                                write += sizeof(int);
                            }
                        }
                        else
                        {
                            if (memberMap.IsMember(0))
                            {
                            {
                                *(int*)write = (int)(int)value.State;
                                write += sizeof(int);
                            }
                            }
                            if (memberMap.IsMember(1))
                            {
                            }
                        }
                        unsafeStream.AddLength(((int)(write - dataFixed - dataStream.Length) + 3) & (int.MaxValue - 3));
                    }
                    if (memberMap.IsDefault)
                    {
                        iSerializeNotNull(value.Service);
                    }
                    else
                    {
                        if (memberMap.IsMember(1))
                        {
                        iSerializeNotNull(value.Service);
                        }
                    }
                }
            }
            /// <summary>
            /// 对象序列化
            /// </summary>
            /// <returns>序列化数据</returns>
            public byte[] Serialize()
            {
                using (memoryStream stream = new memoryStream())
                {
                    Serialize(stream, default(fastCSharp.setup.tcpRegister.registerResult/**/.memberMap));
                    return stream.ToArray();
                }
            }
            /// <summary>
            /// 对象序列化
            /// </summary>
            /// <param name="stream">数据流</param>
            public void Serialize(memoryStream stream)
            {
                Serialize(stream, default(fastCSharp.setup.tcpRegister.registerResult/**/.memberMap));
            }
            /// <summary>
            /// 对象序列化
            /// </summary>
            /// <param name="stream">数据流</param>
            /// <param name="memberMap">成员位图接口</param>
            public void Serialize(memoryStream stream, fastCSharp.setup.tcpRegister.registerResult/**/.memberMap memberMap)
            {
                serializer serializer = new serializer(stream, memberMap);
                serializer.Serialize(this);
                serializer.Finally();
            }
            /// <summary>
            /// 对象序列化
            /// </summary>
            /// <param name="serializer">对象序列化器</param>
            public void Serialize(fastCSharp.setup.cSharp.serialize.dataSerializer parentSerializer)
            {
                new serializer(parentSerializer).Serialize(this);
            }
            /// <summary>
            /// 对象反序列化
            /// </summary>
            unsafe class deSerializer : fastCSharp.setup.cSharp.serialize.deSerializer
            {
                /// <summary>
                /// 成员位图接口
                /// </summary>
                public fastCSharp.setup.tcpRegister.registerResult/**/.memberMap MemberMap;
                /// <summary>
                /// 对象反序列化
                /// </summary>
                /// <param name="data">序列化数据</param>
                public deSerializer(byte[] data) : base(data) { }
                /// <summary>
                /// 对象反序列化
                /// </summary>
                /// <param name="parentDeSerializer">对象反序列化器</param>
                public deSerializer(fastCSharp.setup.cSharp.serialize.deSerializer parentDeSerializer)
                    : base(parentDeSerializer) { }
                /// <summary>
                /// 反序列化
                /// </summary>
                /// <param name="value">反序列化目标对象</param>
                /// <param name="startIndex">数据起始位置</param>
                /// <returns>数据对象</returns>
                public fastCSharp.setup.tcpRegister.registerResult DeSerialize(fastCSharp.setup.tcpRegister.registerResult value, int startIndex)
                {
                    fixed (byte* dataFixed = data)
                    {
                        this.dataFixed = dataFixed;
                        dataStart = read = dataFixed + startIndex;
                        dataVersion = *(int*)read;
                        if (dataVersion != (int)fastCSharp.setup.cSharp.serializeVersion.serialize)
                        {
                            fastCSharp.log.Default.Throw("序列化格式版本号不匹配 fastCSharp.setup.cSharp.serializeVersion.serialize[" + ((int)fastCSharp.setup.cSharp.serializeVersion.serialize).toString() + "] != " + dataVersion.toString(), true, false);
                        }
                        dataVersion = *(int*)(read += sizeof(int));
                        {
                            versionMemberMap();
                            value = DeSerializeData(value);
                            checkEnd();
                            return value;
                        }
                    }
                }
                /// <summary>
                /// 版本号+成员位图接口
                /// </summary>
                protected override void versionMemberMap()
                {
                    if (dataVersion != 0)
                    {
                        fastCSharp.log.Default.Throw("序列化版本号错误 0 != " + dataVersion.toString(), true, false);
                    }
                    read = MemberMap.DeSerialize(read += sizeof(int));
                }
                /// <summary>
                /// 反序列化
                /// </summary>
                /// <param name="value">反序列化目标对象</param>
                /// <returns>数据对象</returns>
                public fastCSharp.setup.tcpRegister.registerResult DeSerialize(fastCSharp.setup.tcpRegister.registerResult value)
                {
                    dataVersion = *(int*)read;
                    versionMemberMap();
                    return DeSerializeData(value);
                }
                /// <summary>
                /// 反序列化
                /// </summary>
                /// <param name="value">反序列化目标对象</param>
                /// <returns>数据对象</returns>
                public fastCSharp.setup.tcpRegister.registerResult DeSerializeData(fastCSharp.setup.tcpRegister.registerResult value)
                {
                    fixedMap nullMap = new fixedMap(read);
                    read += MemberMap.SerializeSize;
                    if (MemberMap.IsDefault)
                    {
                        {
                            value.State = (fastCSharp.setup.tcpRegister.registerState)((int)*(int*)read);
                            read += sizeof(int);
                        }
                    }
                    else
                    {
                        if (MemberMap.IsMember(0))
                        {
                        {
                            value.State = (fastCSharp.setup.tcpRegister.registerState)((int)*(int*)read);
                            read += sizeof(int);
                        }
                        }
                        if (MemberMap.IsMember(1))
                        {
                        }
                    }
                    int length = (int)(read - nullMap.Map);
                    if ((length & 3) != 0) read += -length & 3;
                    if (MemberMap.IsDefault)
                    {
                        {
                            value.Service = iSerializeNotNull<fastCSharp.setup.tcpRegister.service>();
                        }
                    }
                    else
                    {
                        if (MemberMap.IsMember(1))
                        {
                        {
                            value.Service = iSerializeNotNull<fastCSharp.setup.tcpRegister.service>();
                        }
                        }
                    }
                    return value;
                }
            }
            /// <summary>
            /// 反序列化
            /// </summary>
            /// <param name="data">序列化数据</param>
            public bool DeSerialize(byte[] data)
            {
                return DeSerialize(data, 0, out deSerializer.OutEndIndex);
            }
            /// <summary>
            /// 反序列化
            /// </summary>
            /// <param name="data">序列化数据</param>
            /// <param name="startIndex">起始位置</param>
            /// <param name="endIndex">结束位置</param>
            public bool DeSerialize(byte[] data, int startIndex, out int endIndex)
            {
                deSerializer deSerializer = new deSerializer(data);
                fastCSharp.setup.tcpRegister.registerResult value = deSerializer.DeSerialize(this, startIndex);
                
                CopyFrom(value);
                endIndex = deSerializer.EndIndex;
                return endIndex <= data.Length;
            }
            /// <summary>
            /// 反序列化
            /// </summary>
            /// <param name="parentDeSerializer">对象反序列化器</param>
            public unsafe void DeSerialize(fastCSharp.setup.cSharp.serialize.deSerializer parentDeSerializer)
            {
                deSerializer deSerializer = new deSerializer(parentDeSerializer);
                
                fastCSharp.setup.tcpRegister.registerResult value = deSerializer.DeSerialize(this);
                
                CopyFrom(value);
                parentDeSerializer.SetRead(deSerializer);
            }
        }
    }
}namespace fastCSharp.setup
{
    public partial class tcpRegister
    {
        partial class pollResult
        {

            /// <summary>
            /// 成员位图
            /// </summary>
            public struct memberMap : fastCSharp.setup.cSharp.IMemberMap<memberMap>
            {
                /// <summary>
                /// 成员位图
                /// </summary>
                private uint map;
                /// <summary>
                /// 成员位图
                /// </summary>
                /// <param name="members">成员集合</param>
                public memberMap(params member[] members)
                {
                    map = 0;
                    foreach (member member in members) SetMember((int)member);
                }
                /// <summary>
                /// 成员位图
                /// </summary>
                /// <returns>成员位图</returns>
                public memberMap Copy()
                {
                    return new memberMap { map = map };
                }
                /// <summary>
                /// 是否默认全部成员有效
                /// </summary>
                public bool IsDefault
                {
                    get { return map == 0; }
                }
                /// <summary>
                /// 序列化字节长度
                /// </summary>
                public int SerializeSize
                {
                    get
                    {
                        return sizeof(uint);
                    }
                }
                /// <summary>
                /// 设置成员索引,忽略默认成员
                /// </summary>
                /// <param name="memberIndex">成员索引</param>
                public void SetMember(int memberIndex)
                {
                    map |= 1U << (int)memberIndex;
                }
                /// <summary>
                /// 清除成员索引,忽略默认成员
                /// </summary>
                /// <param name="memberIndex">成员索引</param>
                public void ClearMember(int memberIndex)
                {
                    map &= uint.MaxValue ^ (1U << (int)memberIndex);
                }
                /// <summary>
                /// 设置成员,忽略默认成员
                /// </summary>
                /// <param name="member">成员</param>
                public void SetMember(member member)
                {
                    SetMember((int)member);
                }
                /// <summary>
                /// 清除成员,忽略默认成员
                /// </summary>
                /// <param name="memberIndex">成员</param>
                public void ClearMember(member member)
                {
                    ClearMember((int)member);
                }
                /// <summary>
                /// 成员交集运算,忽略默认成员
                /// </summary>
                /// <param name="memberMap">成员位图</param>
                public void And(memberMap memberMap)
                {
                    map &= memberMap.map;
                }
                /// <summary>
                /// 成员异或运算,忽略默认成员
                /// </summary>
                /// <param name="memberMap">成员位图</param>
                public void Xor(memberMap memberMap)
                {
                    map ^= memberMap.map;
                }
                /// <summary>
                /// 成员并集运算,忽略默认成员
                /// </summary>
                /// <param name="memberMap">成员位图</param>
                public void Or(memberMap memberMap)
                {
                    map |= memberMap.map;
                }
                /// <summary>
                /// 判断成员索引是否有效
                /// </summary>
                /// <param name="memberIndex">成员索引</param>
                /// <returns>成员索引是否有效</returns>
                public bool IsMember(int memberIndex)
                {
                    return map == 0 || (map & (1 << memberIndex)) != 0;
                }
                /// <summary>
                /// 判断成员是否有效
                /// </summary>
                /// <param name="member">成员</param>
                /// <returns>成员是否有效</returns>
                public bool IsMember(member member)
                {
                    return IsMember((int)member);
                }
                /// <summary>
                /// 序列化
                /// </summary>
                /// <param name="stream">数据流</param>
                public void Serialize(memoryStream stream)
                {
                    stream.Write(map);
                }
                /// <summary>
                /// 序列化
                /// </summary>
                /// <param name="stream">数据流</param>
                public void Serialize(System.IO.Stream stream)
                {
                    stream.Write(BitConverter.GetBytes(map), 0, sizeof(uint));
                }
                /// <summary>
                /// 反序列化
                /// </summary>
                /// <param name="data">数据</param>
                /// <returns>结束位置</returns>
                public unsafe byte* DeSerialize(byte* data)
                {
                    map = *(uint*)data;
                    return data + sizeof(uint);
                }
                /// <summary>
                /// 成员获取器
                /// </summary>
                /// <returns>成员获取器</returns>
                public fastCSharp.setup.cSharp.IMemberInfo MemberInfo
                {
                    get { return new memberInfo(); }
                }
            }


            /// <summary>
            /// 成员
            /// </summary>
            public enum member
            {
                [fastCSharp.setup.cSharp.member(Type = typeof(fastCSharp.setup.tcpRegister.pollState))]
                State = 0,
                [fastCSharp.setup.cSharp.member(Type = typeof(fastCSharp.setup.tcpRegister.services[]))]
                Services = 1,
                [fastCSharp.setup.cSharp.member(Type = typeof(int))]
                Version = 2,
            }
            /// <summary>
            /// 成员信息获取器
            /// </summary>
            private struct memberInfo : fastCSharp.setup.cSharp.IMemberInfo
            {
                /// <summary>
                /// 获取成员名称
                /// </summary>
                /// <param name="memberIndex">成员索引</param>
                /// <returns>成员名称</returns>
                public string GetName(int memberIndex)
                {
                    return ((member)memberIndex).ToString();
                }
                /// <summary>
                /// 获取成员类型
                /// </summary>
                /// <param name="memberIndex">成员索引</param>
                /// <returns>成员类型</returns>
                public Type GetType(int memberIndex)
                {
                    return fastCSharp.Enum<member, fastCSharp.setup.cSharp.member>.Array(memberIndex).Type;
                }
                /// <summary>
                /// 所有成员数量
                /// </summary>
                public int MemberCount
                {
                    get
                    {
                        return 2 + 1;
                    }
                }
            }
        }
    }
}namespace fastCSharp.setup
{
    public partial class tcpRegister
    {
        partial class pollResult : fastCSharp.setup.cSharp.ICopy<fastCSharp.setup.tcpRegister.pollResult, fastCSharp.setup.tcpRegister.pollResult/**/.memberMap>
        {
            
            /// <summary>
            /// 成员复制
            /// </summary>
            /// <param name="value">被复制对象</param>
            /// <param name="memberMap">复制成员位图</param>
            public void CopyFrom(fastCSharp.setup.tcpRegister.pollResult value, fastCSharp.setup.tcpRegister.pollResult/**/.memberMap memberMap = default(fastCSharp.setup.tcpRegister.pollResult/**/.memberMap))
            {
                if (memberMap.IsDefault)
                {
                    this.State = value.State;
                    this.Services = value.Services;
                    this.Version = value.Version;
                }
                else
                {
                    if (memberMap.IsMember(0)) this.State = value.State;
                    if (memberMap.IsMember(1)) this.Services = value.Services;
                    if (memberMap.IsMember(2)) this.Version = value.Version;
                }
            }
            /// <summary>
            /// 浅复制对象
            /// </summary>
            /// <returns>复制的对象</returns>
            public fastCSharp.setup.tcpRegister.pollResult CopyMember()
            {
                return (fastCSharp.setup.tcpRegister.pollResult)MemberwiseClone();
            }
            /// <summary>
            /// 无参数构造函数调用
            /// </summary>
            private static fastCSharp.setup.tcpRegister.pollResult fastCSharpConstructor
            {
                get
                {
                    return new fastCSharp.setup.tcpRegister.pollResult();
                }
            }
        }
    }
}namespace fastCSharp.setup
{
    public partial class tcpRegister
    {
        partial class pollResult : 
            fastCSharp.setup.cSharp.serialize.ISerialize<fastCSharp.setup.tcpRegister.pollResult/**/.memberMap>
        {
            /// <summary>
            /// 序列化
            /// </summary>
            unsafe class serializer : fastCSharp.setup.cSharp.serialize.dataSerializer
            {
                /// <summary>
                /// 序列化
                /// </summary>
                /// <param name="stream">序列化流</param>
                /// <param name="memberMap">成员位图接口</param>
                public serializer(memoryStream stream, fastCSharp.setup.cSharp.IMemberMap memberMap) : base(stream, memberMap) { }
                /// <summary>
                /// 序列化
                /// </summary>
                /// <param name="parentSerializer">序列化</param>
                /// <param name="memberMap">成员位图接口</param>
                public serializer(fastCSharp.setup.cSharp.serialize.dataSerializer parentSerializer)
                    : base(parentSerializer, default(fastCSharp.setup.tcpRegister.pollResult/**/.memberMap)) { }
                /// <summary>
                /// 对象序列化
                /// </summary>
                /// <param name="value">对象</param>
                /// <param name="isPoint">是否记录历史指针</param>
                public void Serialize(fastCSharp.setup.tcpRegister.pollResult value, bool isPoint)
                {
                    if (value != null)
                    {
                        if (isPoint) points[value] = dataStream.Length - streamStartIndex;
                        versionMemerMap(0);
                        serialize(value);
                    }
                    else dataStream.Write(fastCSharp.setup.cSharp.serialize.NullValue);
                }
                /// <summary>
                /// 对象序列化
                /// </summary>
                /// <param name="value">对象</param>
                private void serialize(fastCSharp.setup.tcpRegister.pollResult value)
                {
                    memoryStream.unsafer unsafeStream = dataStream.Unsafer;
                    int length = memberMap.SerializeSize;
                    dataStream.PrepLength(length + 12);
                    fixed (byte* dataFixed = dataStream.Array)
                    {
                        write = dataFixed + dataStream.Length;
                        fixedMap nullMap = new fixedMap(write);
                        fastCSharp.unsafer.memory.Fill(write, (uint)0, length >> 2);
                        write += length;
                        if (memberMap.IsDefault)
                        {
                            {
                                *(int*)write = (int)(int)value.State;
                                write += sizeof(int);
                            }
                            if (value.Services == null) nullMap.Set(1);
                            {
                                *(int*)write = (int)value.Version;
                                write += sizeof(int);
                            }
                        }
                        else
                        {
                            if (memberMap.IsMember(0))
                            {
                            {
                                *(int*)write = (int)(int)value.State;
                                write += sizeof(int);
                            }
                            }
                            if (memberMap.IsMember(1))
                            {
                            if (value.Services == null) nullMap.Set(1);
                            }
                            if (memberMap.IsMember(2))
                            {
                            {
                                *(int*)write = (int)value.Version;
                                write += sizeof(int);
                            }
                            }
                        }
                        unsafeStream.AddLength(((int)(write - dataFixed - dataStream.Length) + 3) & (int.MaxValue - 3));
                    }
                    if (memberMap.IsDefault)
                    {
                        {
                            fastCSharp.setup.tcpRegister.services[] enumerable = value.Services;
                            if (checkPoint(enumerable))
                            {
                                fastCSharp.setup.tcpRegister.services[] array = enumerable;
                                iSerializeArrayNotNullNoPoint(array);

                            }
                        }
                    }
                    else
                    {
                        if (memberMap.IsMember(1))
                        {
                        {
                            fastCSharp.setup.tcpRegister.services[] enumerable = value.Services;
                            if (checkPoint(enumerable))
                            {
                                fastCSharp.setup.tcpRegister.services[] array = enumerable;
                                iSerializeArrayNotNullNoPoint(array);

                            }
                        }
                        }
                    }
                }
            }
            /// <summary>
            /// 对象序列化
            /// </summary>
            /// <returns>序列化数据</returns>
            public byte[] Serialize()
            {
                using (memoryStream stream = new memoryStream())
                {
                    Serialize(stream, default(fastCSharp.setup.tcpRegister.pollResult/**/.memberMap));
                    return stream.ToArray();
                }
            }
            /// <summary>
            /// 对象序列化
            /// </summary>
            /// <param name="stream">数据流</param>
            public void Serialize(memoryStream stream)
            {
                Serialize(stream, default(fastCSharp.setup.tcpRegister.pollResult/**/.memberMap));
            }
            /// <summary>
            /// 对象序列化
            /// </summary>
            /// <param name="stream">数据流</param>
            /// <param name="memberMap">成员位图接口</param>
            public void Serialize(memoryStream stream, fastCSharp.setup.tcpRegister.pollResult/**/.memberMap memberMap)
            {
                serializer serializer = new serializer(stream, memberMap);
                serializer.Serialize(this, true);
                serializer.Finally();
            }
            /// <summary>
            /// 对象序列化
            /// </summary>
            /// <param name="serializer">对象序列化器</param>
            public void Serialize(fastCSharp.setup.cSharp.serialize.dataSerializer parentSerializer)
            {
                new serializer(parentSerializer).Serialize(this, false);
            }
            /// <summary>
            /// 对象反序列化
            /// </summary>
            unsafe class deSerializer : fastCSharp.setup.cSharp.serialize.deSerializer
            {
                /// <summary>
                /// 成员位图接口
                /// </summary>
                public fastCSharp.setup.tcpRegister.pollResult/**/.memberMap MemberMap;
                /// <summary>
                /// 对象反序列化
                /// </summary>
                /// <param name="data">序列化数据</param>
                public deSerializer(byte[] data) : base(data) { }
                /// <summary>
                /// 对象反序列化
                /// </summary>
                /// <param name="parentDeSerializer">对象反序列化器</param>
                public deSerializer(fastCSharp.setup.cSharp.serialize.deSerializer parentDeSerializer)
                    : base(parentDeSerializer) { }
                /// <summary>
                /// 反序列化
                /// </summary>
                /// <param name="value">反序列化目标对象</param>
                /// <param name="startIndex">数据起始位置</param>
                /// <returns>数据对象</returns>
                public fastCSharp.setup.tcpRegister.pollResult DeSerialize(fastCSharp.setup.tcpRegister.pollResult value, int startIndex)
                {
                    fixed (byte* dataFixed = data)
                    {
                        this.dataFixed = dataFixed;
                        dataStart = read = dataFixed + startIndex;
                        dataVersion = *(int*)read;
                        if (dataVersion != (int)fastCSharp.setup.cSharp.serializeVersion.serialize)
                        {
                            fastCSharp.log.Default.Throw("序列化格式版本号不匹配 fastCSharp.setup.cSharp.serializeVersion.serialize[" + ((int)fastCSharp.setup.cSharp.serializeVersion.serialize).toString() + "] != " + dataVersion.toString(), true, false);
                        }
                        dataVersion = *(int*)(read += sizeof(int));
                        if (dataVersion != fastCSharp.setup.cSharp.serialize.NullValue)
                        {
                            versionMemberMap();
                            value = DeSerializeData(value);
                            checkEnd();
                            return value;
                        }
                    }
                    return default(fastCSharp.setup.tcpRegister.pollResult);
                }
                /// <summary>
                /// 版本号+成员位图接口
                /// </summary>
                protected override void versionMemberMap()
                {
                    if (dataVersion != 0)
                    {
                        fastCSharp.log.Default.Throw("序列化版本号错误 0 != " + dataVersion.toString(), true, false);
                    }
                    read = MemberMap.DeSerialize(read += sizeof(int));
                }
                /// <summary>
                /// 反序列化
                /// </summary>
                /// <param name="value">反序列化目标对象</param>
                /// <returns>数据对象</returns>
                public fastCSharp.setup.tcpRegister.pollResult DeSerialize(fastCSharp.setup.tcpRegister.pollResult value)
                {
                    dataVersion = *(int*)read;
                    versionMemberMap();
                    return DeSerializeData(value);
                }
                /// <summary>
                /// 反序列化
                /// </summary>
                /// <param name="value">反序列化目标对象</param>
                /// <returns>数据对象</returns>
                public fastCSharp.setup.tcpRegister.pollResult DeSerializeData(fastCSharp.setup.tcpRegister.pollResult value)
                {
                    fixedMap nullMap = new fixedMap(read);
                    read += MemberMap.SerializeSize;
                    if (MemberMap.IsDefault)
                    {
                        {
                            value.State = (fastCSharp.setup.tcpRegister.pollState)((int)*(int*)read);
                            read += sizeof(int);
                        }
                        if (nullMap.Get(1)) value.Services = default(fastCSharp.setup.tcpRegister.services[]);
                        {
                            value.Version = (*(int*)read);
                            read += sizeof(int);
                        }
                    }
                    else
                    {
                        if (MemberMap.IsMember(0))
                        {
                        {
                            value.State = (fastCSharp.setup.tcpRegister.pollState)((int)*(int*)read);
                            read += sizeof(int);
                        }
                        }
                        if (MemberMap.IsMember(1))
                        {
                        if (nullMap.Get(1)) value.Services = default(fastCSharp.setup.tcpRegister.services[]);
                        }
                        if (MemberMap.IsMember(2))
                        {
                        {
                            value.Version = (*(int*)read);
                            read += sizeof(int);
                        }
                        }
                    }
                    int length = (int)(read - nullMap.Map);
                    if ((length & 3) != 0) read += -length & 3;
                    if (MemberMap.IsDefault)
                    {
                        if (!nullMap.Get(1))
                        {
                            {
                                object reference = getPoint();
                                if (reference != null) value.Services = (fastCSharp.setup.tcpRegister.services[])reference;
                                else
                                {
                                    length = *(int*)read;
                                    fastCSharp.setup.tcpRegister.services[] enumerable = new fastCSharp.setup.tcpRegister.services[length];
                                    points.Add(-(int)(read - dataStart), enumerable);
                                    read += sizeof(int);
                                    fastCSharp.setup.tcpRegister.services[] array = new fastCSharp.setup.tcpRegister.services[length];
                                    iSerializeArrayNotNullNoPoint(array);

                                    Array.Copy(array, 0, enumerable, 0, array.Length);
                                    value.Services = enumerable;
                                }
                            }
                        }
                    }
                    else
                    {
                        if (MemberMap.IsMember(1))
                        {
                        if (!nullMap.Get(1))
                        {
                            {
                                object reference = getPoint();
                                if (reference != null) value.Services = (fastCSharp.setup.tcpRegister.services[])reference;
                                else
                                {
                                    length = *(int*)read;
                                    fastCSharp.setup.tcpRegister.services[] enumerable = new fastCSharp.setup.tcpRegister.services[length];
                                    points.Add(-(int)(read - dataStart), enumerable);
                                    read += sizeof(int);
                                    fastCSharp.setup.tcpRegister.services[] array = new fastCSharp.setup.tcpRegister.services[length];
                                    iSerializeArrayNotNullNoPoint(array);

                                    Array.Copy(array, 0, enumerable, 0, array.Length);
                                    value.Services = enumerable;
                                }
                            }
                        }
                        }
                    }
                    return value;
                }
            }
            /// <summary>
            /// 反序列化
            /// </summary>
            /// <param name="data">序列化数据</param>
            public bool DeSerialize(byte[] data)
            {
                return DeSerialize(data, 0, out deSerializer.OutEndIndex);
            }
            /// <summary>
            /// 反序列化
            /// </summary>
            /// <param name="data">序列化数据</param>
            /// <param name="startIndex">起始位置</param>
            /// <param name="endIndex">结束位置</param>
            public bool DeSerialize(byte[] data, int startIndex, out int endIndex)
            {
                deSerializer deSerializer = new deSerializer(data);
                fastCSharp.setup.tcpRegister.pollResult value = deSerializer.DeSerialize(this, startIndex);
                
                endIndex = deSerializer.EndIndex;
                return value != null && endIndex <= data.Length;
            }
            /// <summary>
            /// 反序列化
            /// </summary>
            /// <param name="parentDeSerializer">对象反序列化器</param>
            public unsafe void DeSerialize(fastCSharp.setup.cSharp.serialize.deSerializer parentDeSerializer)
            {
                deSerializer deSerializer = new deSerializer(parentDeSerializer);
                deSerializer.DeSerialize(this);
                
                parentDeSerializer.SetRead(deSerializer);
            }
        }
    }
}namespace fastCSharp.setup
{
    public partial class tcpRegister
    {
        partial struct service
        {

            /// <summary>
            /// 成员位图
            /// </summary>
            public struct memberMap : fastCSharp.setup.cSharp.IMemberMap<memberMap>
            {
                /// <summary>
                /// 成员位图
                /// </summary>
                private uint map;
                /// <summary>
                /// 成员位图
                /// </summary>
                /// <param name="members">成员集合</param>
                public memberMap(params member[] members)
                {
                    map = 0;
                    foreach (member member in members) SetMember((int)member);
                }
                /// <summary>
                /// 成员位图
                /// </summary>
                /// <returns>成员位图</returns>
                public memberMap Copy()
                {
                    return new memberMap { map = map };
                }
                /// <summary>
                /// 是否默认全部成员有效
                /// </summary>
                public bool IsDefault
                {
                    get { return map == 0; }
                }
                /// <summary>
                /// 序列化字节长度
                /// </summary>
                public int SerializeSize
                {
                    get
                    {
                        return sizeof(uint);
                    }
                }
                /// <summary>
                /// 设置成员索引,忽略默认成员
                /// </summary>
                /// <param name="memberIndex">成员索引</param>
                public void SetMember(int memberIndex)
                {
                    map |= 1U << (int)memberIndex;
                }
                /// <summary>
                /// 清除成员索引,忽略默认成员
                /// </summary>
                /// <param name="memberIndex">成员索引</param>
                public void ClearMember(int memberIndex)
                {
                    map &= uint.MaxValue ^ (1U << (int)memberIndex);
                }
                /// <summary>
                /// 设置成员,忽略默认成员
                /// </summary>
                /// <param name="member">成员</param>
                public void SetMember(member member)
                {
                    SetMember((int)member);
                }
                /// <summary>
                /// 清除成员,忽略默认成员
                /// </summary>
                /// <param name="memberIndex">成员</param>
                public void ClearMember(member member)
                {
                    ClearMember((int)member);
                }
                /// <summary>
                /// 成员交集运算,忽略默认成员
                /// </summary>
                /// <param name="memberMap">成员位图</param>
                public void And(memberMap memberMap)
                {
                    map &= memberMap.map;
                }
                /// <summary>
                /// 成员异或运算,忽略默认成员
                /// </summary>
                /// <param name="memberMap">成员位图</param>
                public void Xor(memberMap memberMap)
                {
                    map ^= memberMap.map;
                }
                /// <summary>
                /// 成员并集运算,忽略默认成员
                /// </summary>
                /// <param name="memberMap">成员位图</param>
                public void Or(memberMap memberMap)
                {
                    map |= memberMap.map;
                }
                /// <summary>
                /// 判断成员索引是否有效
                /// </summary>
                /// <param name="memberIndex">成员索引</param>
                /// <returns>成员索引是否有效</returns>
                public bool IsMember(int memberIndex)
                {
                    return map == 0 || (map & (1 << memberIndex)) != 0;
                }
                /// <summary>
                /// 判断成员是否有效
                /// </summary>
                /// <param name="member">成员</param>
                /// <returns>成员是否有效</returns>
                public bool IsMember(member member)
                {
                    return IsMember((int)member);
                }
                /// <summary>
                /// 序列化
                /// </summary>
                /// <param name="stream">数据流</param>
                public void Serialize(memoryStream stream)
                {
                    stream.Write(map);
                }
                /// <summary>
                /// 序列化
                /// </summary>
                /// <param name="stream">数据流</param>
                public void Serialize(System.IO.Stream stream)
                {
                    stream.Write(BitConverter.GetBytes(map), 0, sizeof(uint));
                }
                /// <summary>
                /// 反序列化
                /// </summary>
                /// <param name="data">数据</param>
                /// <returns>结束位置</returns>
                public unsafe byte* DeSerialize(byte* data)
                {
                    map = *(uint*)data;
                    return data + sizeof(uint);
                }
                /// <summary>
                /// 成员获取器
                /// </summary>
                /// <returns>成员获取器</returns>
                public fastCSharp.setup.cSharp.IMemberInfo MemberInfo
                {
                    get { return new memberInfo(); }
                }
            }


            /// <summary>
            /// 成员
            /// </summary>
            public enum member
            {
                [fastCSharp.setup.cSharp.member(Type = typeof(string))]
                Name = 0,
                [fastCSharp.setup.cSharp.member(Type = typeof(fastCSharp.setup.tcpRegister.host))]
                Host = 1,
                [fastCSharp.setup.cSharp.member(Type = typeof(bool))]
                IsSingle = 2,
            }
            /// <summary>
            /// 成员信息获取器
            /// </summary>
            private struct memberInfo : fastCSharp.setup.cSharp.IMemberInfo
            {
                /// <summary>
                /// 获取成员名称
                /// </summary>
                /// <param name="memberIndex">成员索引</param>
                /// <returns>成员名称</returns>
                public string GetName(int memberIndex)
                {
                    return ((member)memberIndex).ToString();
                }
                /// <summary>
                /// 获取成员类型
                /// </summary>
                /// <param name="memberIndex">成员索引</param>
                /// <returns>成员类型</returns>
                public Type GetType(int memberIndex)
                {
                    return fastCSharp.Enum<member, fastCSharp.setup.cSharp.member>.Array(memberIndex).Type;
                }
                /// <summary>
                /// 所有成员数量
                /// </summary>
                public int MemberCount
                {
                    get
                    {
                        return 2 + 1;
                    }
                }
            }
        }
    }
}namespace fastCSharp.setup
{
    public partial class tcpRegister
    {
        partial struct service : fastCSharp.setup.cSharp.ICopy<fastCSharp.setup.tcpRegister.service, fastCSharp.setup.tcpRegister.service/**/.memberMap>
        {
            
            /// <summary>
            /// 成员复制
            /// </summary>
            /// <param name="value">被复制对象</param>
            /// <param name="memberMap">复制成员位图</param>
            public void CopyFrom(fastCSharp.setup.tcpRegister.service value, fastCSharp.setup.tcpRegister.service/**/.memberMap memberMap = default(fastCSharp.setup.tcpRegister.service/**/.memberMap))
            {
                if (memberMap.IsDefault)
                {
                    this.Name = value.Name;
                    this.Host = value.Host;
                    this.IsSingle = value.IsSingle;
                }
                else
                {
                    if (memberMap.IsMember(0)) this.Name = value.Name;
                    if (memberMap.IsMember(1)) this.Host = value.Host;
                    if (memberMap.IsMember(2)) this.IsSingle = value.IsSingle;
                }
            }
            /// <summary>
            /// 浅复制对象
            /// </summary>
            /// <returns>复制的对象</returns>
            public fastCSharp.setup.tcpRegister.service CopyMember()
            {
                return (fastCSharp.setup.tcpRegister.service)MemberwiseClone();
            }
        }
    }
}namespace fastCSharp.setup
{
    public partial class tcpRegister
    {
        partial struct service : 
            fastCSharp.setup.cSharp.serialize.ISerialize<fastCSharp.setup.tcpRegister.service/**/.memberMap>
        {
            /// <summary>
            /// 序列化
            /// </summary>
            unsafe class serializer : fastCSharp.setup.cSharp.serialize.dataSerializer
            {
                /// <summary>
                /// 序列化
                /// </summary>
                /// <param name="stream">序列化流</param>
                /// <param name="memberMap">成员位图接口</param>
                public serializer(memoryStream stream, fastCSharp.setup.cSharp.IMemberMap memberMap) : base(stream, memberMap) { }
                /// <summary>
                /// 序列化
                /// </summary>
                /// <param name="parentSerializer">序列化</param>
                /// <param name="memberMap">成员位图接口</param>
                public serializer(fastCSharp.setup.cSharp.serialize.dataSerializer parentSerializer)
                    : base(parentSerializer, default(fastCSharp.setup.tcpRegister.service/**/.memberMap)) { }
                /// <summary>
                /// 对象序列化
                /// </summary>
                /// <param name="value">对象</param>
                public void Serialize(fastCSharp.setup.tcpRegister.service value)
                {
                    {
                        versionMemerMap(0);
                        serialize(value);
                    }
                }
                /// <summary>
                /// 对象序列化
                /// </summary>
                /// <param name="value">对象</param>
                private void serialize(fastCSharp.setup.tcpRegister.service value)
                {
                    memoryStream.unsafer unsafeStream = dataStream.Unsafer;
                    int length = memberMap.SerializeSize;
                    dataStream.PrepLength(length + 12);
                    fixed (byte* dataFixed = dataStream.Array)
                    {
                        write = dataFixed + dataStream.Length;
                        fixedMap nullMap = new fixedMap(write);
                        fastCSharp.unsafer.memory.Fill(write, (uint)0, length >> 2);
                        write += length;
                        if (memberMap.IsDefault)
                        {
                            if (value.Name == null) nullMap.Set(0);
                            {
                                *(bool*)write = (bool)value.IsSingle;
                                write += sizeof(bool);
                            }
                        }
                        else
                        {
                            if (memberMap.IsMember(0))
                            {
                            if (value.Name == null) nullMap.Set(0);
                            }
                            if (memberMap.IsMember(1))
                            {
                            }
                            if (memberMap.IsMember(2))
                            {
                            {
                                *(bool*)write = (bool)value.IsSingle;
                                write += sizeof(bool);
                            }
                            }
                        }
                        unsafeStream.AddLength(((int)(write - dataFixed - dataStream.Length) + 3) & (int.MaxValue - 3));
                    }
                    if (memberMap.IsDefault)
                    {
                        serializeString(value.Name);
                        iSerializeNotNull(value.Host);
                    }
                    else
                    {
                        if (memberMap.IsMember(0))
                        {
                        serializeString(value.Name);
                        }
                        if (memberMap.IsMember(1))
                        {
                        iSerializeNotNull(value.Host);
                        }
                    }
                }
            }
            /// <summary>
            /// 对象序列化
            /// </summary>
            /// <returns>序列化数据</returns>
            public byte[] Serialize()
            {
                using (memoryStream stream = new memoryStream())
                {
                    Serialize(stream, default(fastCSharp.setup.tcpRegister.service/**/.memberMap));
                    return stream.ToArray();
                }
            }
            /// <summary>
            /// 对象序列化
            /// </summary>
            /// <param name="stream">数据流</param>
            public void Serialize(memoryStream stream)
            {
                Serialize(stream, default(fastCSharp.setup.tcpRegister.service/**/.memberMap));
            }
            /// <summary>
            /// 对象序列化
            /// </summary>
            /// <param name="stream">数据流</param>
            /// <param name="memberMap">成员位图接口</param>
            public void Serialize(memoryStream stream, fastCSharp.setup.tcpRegister.service/**/.memberMap memberMap)
            {
                serializer serializer = new serializer(stream, memberMap);
                serializer.Serialize(this);
                serializer.Finally();
            }
            /// <summary>
            /// 对象序列化
            /// </summary>
            /// <param name="serializer">对象序列化器</param>
            public void Serialize(fastCSharp.setup.cSharp.serialize.dataSerializer parentSerializer)
            {
                new serializer(parentSerializer).Serialize(this);
            }
            /// <summary>
            /// 对象反序列化
            /// </summary>
            unsafe class deSerializer : fastCSharp.setup.cSharp.serialize.deSerializer
            {
                /// <summary>
                /// 成员位图接口
                /// </summary>
                public fastCSharp.setup.tcpRegister.service/**/.memberMap MemberMap;
                /// <summary>
                /// 对象反序列化
                /// </summary>
                /// <param name="data">序列化数据</param>
                public deSerializer(byte[] data) : base(data) { }
                /// <summary>
                /// 对象反序列化
                /// </summary>
                /// <param name="parentDeSerializer">对象反序列化器</param>
                public deSerializer(fastCSharp.setup.cSharp.serialize.deSerializer parentDeSerializer)
                    : base(parentDeSerializer) { }
                /// <summary>
                /// 反序列化
                /// </summary>
                /// <param name="value">反序列化目标对象</param>
                /// <param name="startIndex">数据起始位置</param>
                /// <returns>数据对象</returns>
                public fastCSharp.setup.tcpRegister.service DeSerialize(fastCSharp.setup.tcpRegister.service value, int startIndex)
                {
                    fixed (byte* dataFixed = data)
                    {
                        this.dataFixed = dataFixed;
                        dataStart = read = dataFixed + startIndex;
                        dataVersion = *(int*)read;
                        if (dataVersion != (int)fastCSharp.setup.cSharp.serializeVersion.serialize)
                        {
                            fastCSharp.log.Default.Throw("序列化格式版本号不匹配 fastCSharp.setup.cSharp.serializeVersion.serialize[" + ((int)fastCSharp.setup.cSharp.serializeVersion.serialize).toString() + "] != " + dataVersion.toString(), true, false);
                        }
                        dataVersion = *(int*)(read += sizeof(int));
                        {
                            versionMemberMap();
                            value = DeSerializeData(value);
                            checkEnd();
                            return value;
                        }
                    }
                }
                /// <summary>
                /// 版本号+成员位图接口
                /// </summary>
                protected override void versionMemberMap()
                {
                    if (dataVersion != 0)
                    {
                        fastCSharp.log.Default.Throw("序列化版本号错误 0 != " + dataVersion.toString(), true, false);
                    }
                    read = MemberMap.DeSerialize(read += sizeof(int));
                }
                /// <summary>
                /// 反序列化
                /// </summary>
                /// <param name="value">反序列化目标对象</param>
                /// <returns>数据对象</returns>
                public fastCSharp.setup.tcpRegister.service DeSerialize(fastCSharp.setup.tcpRegister.service value)
                {
                    dataVersion = *(int*)read;
                    versionMemberMap();
                    return DeSerializeData(value);
                }
                /// <summary>
                /// 反序列化
                /// </summary>
                /// <param name="value">反序列化目标对象</param>
                /// <returns>数据对象</returns>
                public fastCSharp.setup.tcpRegister.service DeSerializeData(fastCSharp.setup.tcpRegister.service value)
                {
                    fixedMap nullMap = new fixedMap(read);
                    read += MemberMap.SerializeSize;
                    if (MemberMap.IsDefault)
                    {
                        if (nullMap.Get(0)) value.Name = default(string);
                        {
                            value.IsSingle = (*(bool*)read);
                            read += sizeof(bool);
                        }
                    }
                    else
                    {
                        if (MemberMap.IsMember(0))
                        {
                        if (nullMap.Get(0)) value.Name = default(string);
                        }
                        if (MemberMap.IsMember(1))
                        {
                        }
                        if (MemberMap.IsMember(2))
                        {
                        {
                            value.IsSingle = (*(bool*)read);
                            read += sizeof(bool);
                        }
                        }
                    }
                    int length = (int)(read - nullMap.Map);
                    if ((length & 3) != 0) read += -length & 3;
                    if (MemberMap.IsDefault)
                    {
                        if (!nullMap.Get(0))
                        {
                            value.Name = getString();
                        }
                        {
                            value.Host = iSerializeNotNull<fastCSharp.setup.tcpRegister.host>();
                        }
                    }
                    else
                    {
                        if (MemberMap.IsMember(0))
                        {
                        if (!nullMap.Get(0))
                        {
                            value.Name = getString();
                        }
                        }
                        if (MemberMap.IsMember(1))
                        {
                        {
                            value.Host = iSerializeNotNull<fastCSharp.setup.tcpRegister.host>();
                        }
                        }
                    }
                    return value;
                }
            }
            /// <summary>
            /// 反序列化
            /// </summary>
            /// <param name="data">序列化数据</param>
            public bool DeSerialize(byte[] data)
            {
                return DeSerialize(data, 0, out deSerializer.OutEndIndex);
            }
            /// <summary>
            /// 反序列化
            /// </summary>
            /// <param name="data">序列化数据</param>
            /// <param name="startIndex">起始位置</param>
            /// <param name="endIndex">结束位置</param>
            public bool DeSerialize(byte[] data, int startIndex, out int endIndex)
            {
                deSerializer deSerializer = new deSerializer(data);
                fastCSharp.setup.tcpRegister.service value = deSerializer.DeSerialize(this, startIndex);
                
                CopyFrom(value);
                endIndex = deSerializer.EndIndex;
                return endIndex <= data.Length;
            }
            /// <summary>
            /// 反序列化
            /// </summary>
            /// <param name="parentDeSerializer">对象反序列化器</param>
            public unsafe void DeSerialize(fastCSharp.setup.cSharp.serialize.deSerializer parentDeSerializer)
            {
                deSerializer deSerializer = new deSerializer(parentDeSerializer);
                
                fastCSharp.setup.tcpRegister.service value = deSerializer.DeSerialize(this);
                
                CopyFrom(value);
                parentDeSerializer.SetRead(deSerializer);
            }
        }
    }
}namespace fastCSharp.setup
{
    public partial class tcpRegister
    {
        partial struct cache
        {

            /// <summary>
            /// 成员位图
            /// </summary>
            public struct memberMap : fastCSharp.setup.cSharp.IMemberMap<memberMap>
            {
                /// <summary>
                /// 成员位图
                /// </summary>
                private uint map;
                /// <summary>
                /// 成员位图
                /// </summary>
                /// <param name="members">成员集合</param>
                public memberMap(params member[] members)
                {
                    map = 0;
                    foreach (member member in members) SetMember((int)member);
                }
                /// <summary>
                /// 成员位图
                /// </summary>
                /// <returns>成员位图</returns>
                public memberMap Copy()
                {
                    return new memberMap { map = map };
                }
                /// <summary>
                /// 是否默认全部成员有效
                /// </summary>
                public bool IsDefault
                {
                    get { return map == 0; }
                }
                /// <summary>
                /// 序列化字节长度
                /// </summary>
                public int SerializeSize
                {
                    get
                    {
                        return sizeof(uint);
                    }
                }
                /// <summary>
                /// 设置成员索引,忽略默认成员
                /// </summary>
                /// <param name="memberIndex">成员索引</param>
                public void SetMember(int memberIndex)
                {
                    map |= 1U << (int)memberIndex;
                }
                /// <summary>
                /// 清除成员索引,忽略默认成员
                /// </summary>
                /// <param name="memberIndex">成员索引</param>
                public void ClearMember(int memberIndex)
                {
                    map &= uint.MaxValue ^ (1U << (int)memberIndex);
                }
                /// <summary>
                /// 设置成员,忽略默认成员
                /// </summary>
                /// <param name="member">成员</param>
                public void SetMember(member member)
                {
                    SetMember((int)member);
                }
                /// <summary>
                /// 清除成员,忽略默认成员
                /// </summary>
                /// <param name="memberIndex">成员</param>
                public void ClearMember(member member)
                {
                    ClearMember((int)member);
                }
                /// <summary>
                /// 成员交集运算,忽略默认成员
                /// </summary>
                /// <param name="memberMap">成员位图</param>
                public void And(memberMap memberMap)
                {
                    map &= memberMap.map;
                }
                /// <summary>
                /// 成员异或运算,忽略默认成员
                /// </summary>
                /// <param name="memberMap">成员位图</param>
                public void Xor(memberMap memberMap)
                {
                    map ^= memberMap.map;
                }
                /// <summary>
                /// 成员并集运算,忽略默认成员
                /// </summary>
                /// <param name="memberMap">成员位图</param>
                public void Or(memberMap memberMap)
                {
                    map |= memberMap.map;
                }
                /// <summary>
                /// 判断成员索引是否有效
                /// </summary>
                /// <param name="memberIndex">成员索引</param>
                /// <returns>成员索引是否有效</returns>
                public bool IsMember(int memberIndex)
                {
                    return map == 0 || (map & (1 << memberIndex)) != 0;
                }
                /// <summary>
                /// 判断成员是否有效
                /// </summary>
                /// <param name="member">成员</param>
                /// <returns>成员是否有效</returns>
                public bool IsMember(member member)
                {
                    return IsMember((int)member);
                }
                /// <summary>
                /// 序列化
                /// </summary>
                /// <param name="stream">数据流</param>
                public void Serialize(memoryStream stream)
                {
                    stream.Write(map);
                }
                /// <summary>
                /// 序列化
                /// </summary>
                /// <param name="stream">数据流</param>
                public void Serialize(System.IO.Stream stream)
                {
                    stream.Write(BitConverter.GetBytes(map), 0, sizeof(uint));
                }
                /// <summary>
                /// 反序列化
                /// </summary>
                /// <param name="data">数据</param>
                /// <returns>结束位置</returns>
                public unsafe byte* DeSerialize(byte* data)
                {
                    map = *(uint*)data;
                    return data + sizeof(uint);
                }
                /// <summary>
                /// 成员获取器
                /// </summary>
                /// <returns>成员获取器</returns>
                public fastCSharp.setup.cSharp.IMemberInfo MemberInfo
                {
                    get { return new memberInfo(); }
                }
            }


            /// <summary>
            /// 成员
            /// </summary>
            public enum member
            {
                [fastCSharp.setup.cSharp.member(Type = typeof(fastCSharp.setup.tcpRegister.services[]))]
                ServiceCache = 0,
                [fastCSharp.setup.cSharp.member(Type = typeof(fastCSharp.setup.tcpRegister.host[]))]
                HostClientsKey = 1,
                [fastCSharp.setup.cSharp.member(Type = typeof(fastCSharp.setup.tcpRegister.clientId[]))]
                HostClients = 2,
                [fastCSharp.setup.cSharp.member(Type = typeof(fastCSharp.setup.tcpRegister.host[]))]
                HostPorts = 3,
            }
            /// <summary>
            /// 成员信息获取器
            /// </summary>
            private struct memberInfo : fastCSharp.setup.cSharp.IMemberInfo
            {
                /// <summary>
                /// 获取成员名称
                /// </summary>
                /// <param name="memberIndex">成员索引</param>
                /// <returns>成员名称</returns>
                public string GetName(int memberIndex)
                {
                    return ((member)memberIndex).ToString();
                }
                /// <summary>
                /// 获取成员类型
                /// </summary>
                /// <param name="memberIndex">成员索引</param>
                /// <returns>成员类型</returns>
                public Type GetType(int memberIndex)
                {
                    return fastCSharp.Enum<member, fastCSharp.setup.cSharp.member>.Array(memberIndex).Type;
                }
                /// <summary>
                /// 所有成员数量
                /// </summary>
                public int MemberCount
                {
                    get
                    {
                        return 3 + 1;
                    }
                }
            }
        }
    }
}namespace fastCSharp.setup
{
    public partial class tcpRegister
    {
        partial struct cache : fastCSharp.setup.cSharp.ICopy<fastCSharp.setup.tcpRegister.cache, fastCSharp.setup.tcpRegister.cache/**/.memberMap>
        {
            
            /// <summary>
            /// 成员复制
            /// </summary>
            /// <param name="value">被复制对象</param>
            /// <param name="memberMap">复制成员位图</param>
            public void CopyFrom(fastCSharp.setup.tcpRegister.cache value, fastCSharp.setup.tcpRegister.cache/**/.memberMap memberMap = default(fastCSharp.setup.tcpRegister.cache/**/.memberMap))
            {
                if (memberMap.IsDefault)
                {
                    this.ServiceCache = value.ServiceCache;
                    this.HostClientsKey = value.HostClientsKey;
                    this.HostClients = value.HostClients;
                    this.HostPorts = value.HostPorts;
                }
                else
                {
                    if (memberMap.IsMember(0)) this.ServiceCache = value.ServiceCache;
                    if (memberMap.IsMember(1)) this.HostClientsKey = value.HostClientsKey;
                    if (memberMap.IsMember(2)) this.HostClients = value.HostClients;
                    if (memberMap.IsMember(3)) this.HostPorts = value.HostPorts;
                }
            }
            /// <summary>
            /// 浅复制对象
            /// </summary>
            /// <returns>复制的对象</returns>
            public fastCSharp.setup.tcpRegister.cache CopyMember()
            {
                return (fastCSharp.setup.tcpRegister.cache)MemberwiseClone();
            }
        }
    }
}namespace fastCSharp.setup
{
    public partial class tcpRegister
    {
        partial struct cache : 
            fastCSharp.setup.cSharp.serialize.ISerialize<fastCSharp.setup.tcpRegister.cache/**/.memberMap>
        {
            /// <summary>
            /// 序列化
            /// </summary>
            unsafe class serializer : fastCSharp.setup.cSharp.serialize.dataSerializer
            {
                /// <summary>
                /// 序列化
                /// </summary>
                /// <param name="stream">序列化流</param>
                /// <param name="memberMap">成员位图接口</param>
                public serializer(memoryStream stream, fastCSharp.setup.cSharp.IMemberMap memberMap) : base(stream, memberMap) { }
                /// <summary>
                /// 序列化
                /// </summary>
                /// <param name="parentSerializer">序列化</param>
                /// <param name="memberMap">成员位图接口</param>
                public serializer(fastCSharp.setup.cSharp.serialize.dataSerializer parentSerializer)
                    : base(parentSerializer, default(fastCSharp.setup.tcpRegister.cache/**/.memberMap)) { }
                /// <summary>
                /// 对象序列化
                /// </summary>
                /// <param name="value">对象</param>
                public void Serialize(fastCSharp.setup.tcpRegister.cache value)
                {
                    {
                        versionMemerMap(0);
                        serialize(value);
                    }
                }
                /// <summary>
                /// 对象序列化
                /// </summary>
                /// <param name="value">对象</param>
                private void serialize(fastCSharp.setup.tcpRegister.cache value)
                {
                    memoryStream.unsafer unsafeStream = dataStream.Unsafer;
                    int length = memberMap.SerializeSize;
                    dataStream.PrepLength(length + 16);
                    fixed (byte* dataFixed = dataStream.Array)
                    {
                        write = dataFixed + dataStream.Length;
                        fixedMap nullMap = new fixedMap(write);
                        fastCSharp.unsafer.memory.Fill(write, (uint)0, length >> 2);
                        write += length;
                        if (memberMap.IsDefault)
                        {
                            if (value.ServiceCache == null) nullMap.Set(0);
                            if (value.HostClients == null) nullMap.Set(2);
                            if (value.HostClientsKey == null) nullMap.Set(1);
                            if (value.HostPorts == null) nullMap.Set(3);
                        }
                        else
                        {
                            if (memberMap.IsMember(0))
                            {
                            if (value.ServiceCache == null) nullMap.Set(0);
                            }
                            if (memberMap.IsMember(2))
                            {
                            if (value.HostClients == null) nullMap.Set(2);
                            }
                            if (memberMap.IsMember(1))
                            {
                            if (value.HostClientsKey == null) nullMap.Set(1);
                            }
                            if (memberMap.IsMember(3))
                            {
                            if (value.HostPorts == null) nullMap.Set(3);
                            }
                        }
                        unsafeStream.AddLength(((int)(write - dataFixed - dataStream.Length) + 3) & (int.MaxValue - 3));
                    }
                    if (memberMap.IsDefault)
                    {
                        {
                            fastCSharp.setup.tcpRegister.services[] enumerable = value.ServiceCache;
                            if (checkPoint(enumerable))
                            {
                                fastCSharp.setup.tcpRegister.services[] array = enumerable;
                                iSerializeArrayNotNullNoPoint(array);

                            }
                        }
                        {
                            fastCSharp.setup.tcpRegister.clientId[] enumerable = value.HostClients;
                            if (checkPoint(enumerable))
                            {
                                fastCSharp.setup.tcpRegister.clientId[] array = enumerable;
                                iSerializeArrayNotNullNoPoint(array);

                            }
                        }
                        {
                            fastCSharp.setup.tcpRegister.host[] enumerable = value.HostClientsKey;
                            if (checkPoint(enumerable))
                            {
                                fastCSharp.setup.tcpRegister.host[] array = enumerable;
                                iSerializeArrayNotNullNoPoint(array);

                            }
                        }
                        {
                            fastCSharp.setup.tcpRegister.host[] enumerable = value.HostPorts;
                            if (checkPoint(enumerable))
                            {
                                fastCSharp.setup.tcpRegister.host[] array = enumerable;
                                iSerializeArrayNotNullNoPoint(array);

                            }
                        }
                    }
                    else
                    {
                        if (memberMap.IsMember(0))
                        {
                        {
                            fastCSharp.setup.tcpRegister.services[] enumerable = value.ServiceCache;
                            if (checkPoint(enumerable))
                            {
                                fastCSharp.setup.tcpRegister.services[] array = enumerable;
                                iSerializeArrayNotNullNoPoint(array);

                            }
                        }
                        }
                        if (memberMap.IsMember(2))
                        {
                        {
                            fastCSharp.setup.tcpRegister.clientId[] enumerable = value.HostClients;
                            if (checkPoint(enumerable))
                            {
                                fastCSharp.setup.tcpRegister.clientId[] array = enumerable;
                                iSerializeArrayNotNullNoPoint(array);

                            }
                        }
                        }
                        if (memberMap.IsMember(1))
                        {
                        {
                            fastCSharp.setup.tcpRegister.host[] enumerable = value.HostClientsKey;
                            if (checkPoint(enumerable))
                            {
                                fastCSharp.setup.tcpRegister.host[] array = enumerable;
                                iSerializeArrayNotNullNoPoint(array);

                            }
                        }
                        }
                        if (memberMap.IsMember(3))
                        {
                        {
                            fastCSharp.setup.tcpRegister.host[] enumerable = value.HostPorts;
                            if (checkPoint(enumerable))
                            {
                                fastCSharp.setup.tcpRegister.host[] array = enumerable;
                                iSerializeArrayNotNullNoPoint(array);

                            }
                        }
                        }
                    }
                }
            }
            /// <summary>
            /// 对象序列化
            /// </summary>
            /// <returns>序列化数据</returns>
            public byte[] Serialize()
            {
                using (memoryStream stream = new memoryStream())
                {
                    Serialize(stream, default(fastCSharp.setup.tcpRegister.cache/**/.memberMap));
                    return stream.ToArray();
                }
            }
            /// <summary>
            /// 对象序列化
            /// </summary>
            /// <param name="stream">数据流</param>
            public void Serialize(memoryStream stream)
            {
                Serialize(stream, default(fastCSharp.setup.tcpRegister.cache/**/.memberMap));
            }
            /// <summary>
            /// 对象序列化
            /// </summary>
            /// <param name="stream">数据流</param>
            /// <param name="memberMap">成员位图接口</param>
            public void Serialize(memoryStream stream, fastCSharp.setup.tcpRegister.cache/**/.memberMap memberMap)
            {
                serializer serializer = new serializer(stream, memberMap);
                serializer.Serialize(this);
                serializer.Finally();
            }
            /// <summary>
            /// 对象序列化
            /// </summary>
            /// <param name="serializer">对象序列化器</param>
            public void Serialize(fastCSharp.setup.cSharp.serialize.dataSerializer parentSerializer)
            {
                new serializer(parentSerializer).Serialize(this);
            }
            /// <summary>
            /// 对象反序列化
            /// </summary>
            unsafe class deSerializer : fastCSharp.setup.cSharp.serialize.deSerializer
            {
                /// <summary>
                /// 成员位图接口
                /// </summary>
                public fastCSharp.setup.tcpRegister.cache/**/.memberMap MemberMap;
                /// <summary>
                /// 对象反序列化
                /// </summary>
                /// <param name="data">序列化数据</param>
                public deSerializer(byte[] data) : base(data) { }
                /// <summary>
                /// 对象反序列化
                /// </summary>
                /// <param name="parentDeSerializer">对象反序列化器</param>
                public deSerializer(fastCSharp.setup.cSharp.serialize.deSerializer parentDeSerializer)
                    : base(parentDeSerializer) { }
                /// <summary>
                /// 反序列化
                /// </summary>
                /// <param name="value">反序列化目标对象</param>
                /// <param name="startIndex">数据起始位置</param>
                /// <returns>数据对象</returns>
                public fastCSharp.setup.tcpRegister.cache DeSerialize(fastCSharp.setup.tcpRegister.cache value, int startIndex)
                {
                    fixed (byte* dataFixed = data)
                    {
                        this.dataFixed = dataFixed;
                        dataStart = read = dataFixed + startIndex;
                        dataVersion = *(int*)read;
                        if (dataVersion != (int)fastCSharp.setup.cSharp.serializeVersion.serialize)
                        {
                            fastCSharp.log.Default.Throw("序列化格式版本号不匹配 fastCSharp.setup.cSharp.serializeVersion.serialize[" + ((int)fastCSharp.setup.cSharp.serializeVersion.serialize).toString() + "] != " + dataVersion.toString(), true, false);
                        }
                        dataVersion = *(int*)(read += sizeof(int));
                        {
                            versionMemberMap();
                            value = DeSerializeData(value);
                            checkEnd();
                            return value;
                        }
                    }
                }
                /// <summary>
                /// 版本号+成员位图接口
                /// </summary>
                protected override void versionMemberMap()
                {
                    if (dataVersion != 0)
                    {
                        fastCSharp.log.Default.Throw("序列化版本号错误 0 != " + dataVersion.toString(), true, false);
                    }
                    read = MemberMap.DeSerialize(read += sizeof(int));
                }
                /// <summary>
                /// 反序列化
                /// </summary>
                /// <param name="value">反序列化目标对象</param>
                /// <returns>数据对象</returns>
                public fastCSharp.setup.tcpRegister.cache DeSerialize(fastCSharp.setup.tcpRegister.cache value)
                {
                    dataVersion = *(int*)read;
                    versionMemberMap();
                    return DeSerializeData(value);
                }
                /// <summary>
                /// 反序列化
                /// </summary>
                /// <param name="value">反序列化目标对象</param>
                /// <returns>数据对象</returns>
                public fastCSharp.setup.tcpRegister.cache DeSerializeData(fastCSharp.setup.tcpRegister.cache value)
                {
                    fixedMap nullMap = new fixedMap(read);
                    read += MemberMap.SerializeSize;
                    if (MemberMap.IsDefault)
                    {
                        if (nullMap.Get(0)) value.ServiceCache = default(fastCSharp.setup.tcpRegister.services[]);
                        if (nullMap.Get(2)) value.HostClients = default(fastCSharp.setup.tcpRegister.clientId[]);
                        if (nullMap.Get(1)) value.HostClientsKey = default(fastCSharp.setup.tcpRegister.host[]);
                        if (nullMap.Get(3)) value.HostPorts = default(fastCSharp.setup.tcpRegister.host[]);
                    }
                    else
                    {
                        if (MemberMap.IsMember(0))
                        {
                        if (nullMap.Get(0)) value.ServiceCache = default(fastCSharp.setup.tcpRegister.services[]);
                        }
                        if (MemberMap.IsMember(2))
                        {
                        if (nullMap.Get(2)) value.HostClients = default(fastCSharp.setup.tcpRegister.clientId[]);
                        }
                        if (MemberMap.IsMember(1))
                        {
                        if (nullMap.Get(1)) value.HostClientsKey = default(fastCSharp.setup.tcpRegister.host[]);
                        }
                        if (MemberMap.IsMember(3))
                        {
                        if (nullMap.Get(3)) value.HostPorts = default(fastCSharp.setup.tcpRegister.host[]);
                        }
                    }
                    int length = (int)(read - nullMap.Map);
                    if ((length & 3) != 0) read += -length & 3;
                    if (MemberMap.IsDefault)
                    {
                        if (!nullMap.Get(0))
                        {
                            {
                                object reference = getPoint();
                                if (reference != null) value.ServiceCache = (fastCSharp.setup.tcpRegister.services[])reference;
                                else
                                {
                                    length = *(int*)read;
                                    fastCSharp.setup.tcpRegister.services[] enumerable = new fastCSharp.setup.tcpRegister.services[length];
                                    points.Add(-(int)(read - dataStart), enumerable);
                                    read += sizeof(int);
                                    fastCSharp.setup.tcpRegister.services[] array = new fastCSharp.setup.tcpRegister.services[length];
                                    iSerializeArrayNotNullNoPoint(array);

                                    Array.Copy(array, 0, enumerable, 0, array.Length);
                                    value.ServiceCache = enumerable;
                                }
                            }
                        }
                        if (!nullMap.Get(2))
                        {
                            {
                                object reference = getPoint();
                                if (reference != null) value.HostClients = (fastCSharp.setup.tcpRegister.clientId[])reference;
                                else
                                {
                                    length = *(int*)read;
                                    fastCSharp.setup.tcpRegister.clientId[] enumerable = new fastCSharp.setup.tcpRegister.clientId[length];
                                    points.Add(-(int)(read - dataStart), enumerable);
                                    read += sizeof(int);
                                    fastCSharp.setup.tcpRegister.clientId[] array = new fastCSharp.setup.tcpRegister.clientId[length];
                                    iSerializeArrayNotNullNoPoint(array);

                                    Array.Copy(array, 0, enumerable, 0, array.Length);
                                    value.HostClients = enumerable;
                                }
                            }
                        }
                        if (!nullMap.Get(1))
                        {
                            {
                                object reference = getPoint();
                                if (reference != null) value.HostClientsKey = (fastCSharp.setup.tcpRegister.host[])reference;
                                else
                                {
                                    length = *(int*)read;
                                    fastCSharp.setup.tcpRegister.host[] enumerable = new fastCSharp.setup.tcpRegister.host[length];
                                    points.Add(-(int)(read - dataStart), enumerable);
                                    read += sizeof(int);
                                    fastCSharp.setup.tcpRegister.host[] array = new fastCSharp.setup.tcpRegister.host[length];
                                    iSerializeArrayNotNullNoPoint(array);

                                    Array.Copy(array, 0, enumerable, 0, array.Length);
                                    value.HostClientsKey = enumerable;
                                }
                            }
                        }
                        if (!nullMap.Get(3))
                        {
                            {
                                object reference = getPoint();
                                if (reference != null) value.HostPorts = (fastCSharp.setup.tcpRegister.host[])reference;
                                else
                                {
                                    length = *(int*)read;
                                    fastCSharp.setup.tcpRegister.host[] enumerable = new fastCSharp.setup.tcpRegister.host[length];
                                    points.Add(-(int)(read - dataStart), enumerable);
                                    read += sizeof(int);
                                    fastCSharp.setup.tcpRegister.host[] array = new fastCSharp.setup.tcpRegister.host[length];
                                    iSerializeArrayNotNullNoPoint(array);

                                    Array.Copy(array, 0, enumerable, 0, array.Length);
                                    value.HostPorts = enumerable;
                                }
                            }
                        }
                    }
                    else
                    {
                        if (MemberMap.IsMember(0))
                        {
                        if (!nullMap.Get(0))
                        {
                            {
                                object reference = getPoint();
                                if (reference != null) value.ServiceCache = (fastCSharp.setup.tcpRegister.services[])reference;
                                else
                                {
                                    length = *(int*)read;
                                    fastCSharp.setup.tcpRegister.services[] enumerable = new fastCSharp.setup.tcpRegister.services[length];
                                    points.Add(-(int)(read - dataStart), enumerable);
                                    read += sizeof(int);
                                    fastCSharp.setup.tcpRegister.services[] array = new fastCSharp.setup.tcpRegister.services[length];
                                    iSerializeArrayNotNullNoPoint(array);

                                    Array.Copy(array, 0, enumerable, 0, array.Length);
                                    value.ServiceCache = enumerable;
                                }
                            }
                        }
                        }
                        if (MemberMap.IsMember(2))
                        {
                        if (!nullMap.Get(2))
                        {
                            {
                                object reference = getPoint();
                                if (reference != null) value.HostClients = (fastCSharp.setup.tcpRegister.clientId[])reference;
                                else
                                {
                                    length = *(int*)read;
                                    fastCSharp.setup.tcpRegister.clientId[] enumerable = new fastCSharp.setup.tcpRegister.clientId[length];
                                    points.Add(-(int)(read - dataStart), enumerable);
                                    read += sizeof(int);
                                    fastCSharp.setup.tcpRegister.clientId[] array = new fastCSharp.setup.tcpRegister.clientId[length];
                                    iSerializeArrayNotNullNoPoint(array);

                                    Array.Copy(array, 0, enumerable, 0, array.Length);
                                    value.HostClients = enumerable;
                                }
                            }
                        }
                        }
                        if (MemberMap.IsMember(1))
                        {
                        if (!nullMap.Get(1))
                        {
                            {
                                object reference = getPoint();
                                if (reference != null) value.HostClientsKey = (fastCSharp.setup.tcpRegister.host[])reference;
                                else
                                {
                                    length = *(int*)read;
                                    fastCSharp.setup.tcpRegister.host[] enumerable = new fastCSharp.setup.tcpRegister.host[length];
                                    points.Add(-(int)(read - dataStart), enumerable);
                                    read += sizeof(int);
                                    fastCSharp.setup.tcpRegister.host[] array = new fastCSharp.setup.tcpRegister.host[length];
                                    iSerializeArrayNotNullNoPoint(array);

                                    Array.Copy(array, 0, enumerable, 0, array.Length);
                                    value.HostClientsKey = enumerable;
                                }
                            }
                        }
                        }
                        if (MemberMap.IsMember(3))
                        {
                        if (!nullMap.Get(3))
                        {
                            {
                                object reference = getPoint();
                                if (reference != null) value.HostPorts = (fastCSharp.setup.tcpRegister.host[])reference;
                                else
                                {
                                    length = *(int*)read;
                                    fastCSharp.setup.tcpRegister.host[] enumerable = new fastCSharp.setup.tcpRegister.host[length];
                                    points.Add(-(int)(read - dataStart), enumerable);
                                    read += sizeof(int);
                                    fastCSharp.setup.tcpRegister.host[] array = new fastCSharp.setup.tcpRegister.host[length];
                                    iSerializeArrayNotNullNoPoint(array);

                                    Array.Copy(array, 0, enumerable, 0, array.Length);
                                    value.HostPorts = enumerable;
                                }
                            }
                        }
                        }
                    }
                    return value;
                }
            }
            /// <summary>
            /// 反序列化
            /// </summary>
            /// <param name="data">序列化数据</param>
            public bool DeSerialize(byte[] data)
            {
                return DeSerialize(data, 0, out deSerializer.OutEndIndex);
            }
            /// <summary>
            /// 反序列化
            /// </summary>
            /// <param name="data">序列化数据</param>
            /// <param name="startIndex">起始位置</param>
            /// <param name="endIndex">结束位置</param>
            public bool DeSerialize(byte[] data, int startIndex, out int endIndex)
            {
                deSerializer deSerializer = new deSerializer(data);
                fastCSharp.setup.tcpRegister.cache value = deSerializer.DeSerialize(this, startIndex);
                
                CopyFrom(value);
                endIndex = deSerializer.EndIndex;
                return endIndex <= data.Length;
            }
            /// <summary>
            /// 反序列化
            /// </summary>
            /// <param name="parentDeSerializer">对象反序列化器</param>
            public unsafe void DeSerialize(fastCSharp.setup.cSharp.serialize.deSerializer parentDeSerializer)
            {
                deSerializer deSerializer = new deSerializer(parentDeSerializer);
                
                fastCSharp.setup.tcpRegister.cache value = deSerializer.DeSerialize(this);
                
                CopyFrom(value);
                parentDeSerializer.SetRead(deSerializer);
            }
        }
    }
}namespace fastCSharp.config
{

        public partial class pub : fastCSharp.setup.cSharp.ajax.IParseJson
        {
            /// <summary>
            /// JSON解析节点转换对象
            /// </summary>
            class jsonParser : fastCSharp.setup.cSharp.ajax.nodeParser
            {
                /// <summary>
                /// 解析对象
                /// </summary>
                /// <param name="value">目标对象</param>
                /// <returns>目标对象</returns>
                public fastCSharp.config.pub Parse(fastCSharp.config.pub value)
                {
                    if (dictionary != null)
                    {
                        fastCSharp.setup.cSharp.ajax.jsonNode node;
                        if (dictionary.TryGetValue(currentMemberName = "encoding", out node))
                        {
                            if (node.Type == fastCSharp.setup.cSharp.ajax.jsonNode.nodeType.Null) value.encoding = default(string);
                            else
                            {
                                value.encoding = node.String;








                            }
                        }
                        if (dictionary.TryGetValue(currentMemberName = "streamBufferLength", out node))
                        {
                            if (node.Type == fastCSharp.setup.cSharp.ajax.jsonNode.nodeType.Null) value.streamBufferLength = default(int);
                            else
                            {





                                if (node.Type == fastCSharp.setup.cSharp.ajax.jsonNode.nodeType.Int) value.streamBufferLength = (int)node.Int;
                                else
                                {
                                        if (!int/**/.TryParse(node.NumberString, out value.streamBufferLength))
                                        {
                                            fastCSharp.log.Default.Throw("int : " + currentMemberName + @" 转换失败
" + node.NumberString, true, false);
                                        }
                                }



                            }
                        }
                        if (dictionary.TryGetValue(currentMemberName = "pageSize", out node))
                        {
                            if (node.Type == fastCSharp.setup.cSharp.ajax.jsonNode.nodeType.Null) value.pageSize = default(int);
                            else
                            {





                                if (node.Type == fastCSharp.setup.cSharp.ajax.jsonNode.nodeType.Int) value.pageSize = (int)node.Int;
                                else
                                {
                                        if (!int/**/.TryParse(node.NumberString, out value.pageSize))
                                        {
                                            fastCSharp.log.Default.Throw("int : " + currentMemberName + @" 转换失败
" + node.NumberString, true, false);
                                        }
                                }



                            }
                        }
                        if (dictionary.TryGetValue(currentMemberName = "maxEnumArraySize", out node))
                        {
                            if (node.Type == fastCSharp.setup.cSharp.ajax.jsonNode.nodeType.Null) value.maxEnumArraySize = default(int);
                            else
                            {





                                if (node.Type == fastCSharp.setup.cSharp.ajax.jsonNode.nodeType.Int) value.maxEnumArraySize = (int)node.Int;
                                else
                                {
                                        if (!int/**/.TryParse(node.NumberString, out value.maxEnumArraySize))
                                        {
                                            fastCSharp.log.Default.Throw("int : " + currentMemberName + @" 转换失败
" + node.NumberString, true, false);
                                        }
                                }



                            }
                        }
                        if (dictionary.TryGetValue(currentMemberName = "taskThreadCount", out node))
                        {
                            if (node.Type == fastCSharp.setup.cSharp.ajax.jsonNode.nodeType.Null) value.taskThreadCount = default(int);
                            else
                            {





                                if (node.Type == fastCSharp.setup.cSharp.ajax.jsonNode.nodeType.Int) value.taskThreadCount = (int)node.Int;
                                else
                                {
                                        if (!int/**/.TryParse(node.NumberString, out value.taskThreadCount))
                                        {
                                            fastCSharp.log.Default.Throw("int : " + currentMemberName + @" 转换失败
" + node.NumberString, true, false);
                                        }
                                }



                            }
                        }
                        if (dictionary.TryGetValue(currentMemberName = "taskMaxThreadCount", out node))
                        {
                            if (node.Type == fastCSharp.setup.cSharp.ajax.jsonNode.nodeType.Null) value.taskMaxThreadCount = default(int);
                            else
                            {





                                if (node.Type == fastCSharp.setup.cSharp.ajax.jsonNode.nodeType.Int) value.taskMaxThreadCount = (int)node.Int;
                                else
                                {
                                        if (!int/**/.TryParse(node.NumberString, out value.taskMaxThreadCount))
                                        {
                                            fastCSharp.log.Default.Throw("int : " + currentMemberName + @" 转换失败
" + node.NumberString, true, false);
                                        }
                                }



                            }
                        }
                        if (dictionary.TryGetValue(currentMemberName = "lockCheckMinutes", out node))
                        {
                            if (node.Type == fastCSharp.setup.cSharp.ajax.jsonNode.nodeType.Null) value.lockCheckMinutes = default(int);
                            else
                            {





                                if (node.Type == fastCSharp.setup.cSharp.ajax.jsonNode.nodeType.Int) value.lockCheckMinutes = (int)node.Int;
                                else
                                {
                                        if (!int/**/.TryParse(node.NumberString, out value.lockCheckMinutes))
                                        {
                                            fastCSharp.log.Default.Throw("int : " + currentMemberName + @" 转换失败
" + node.NumberString, true, false);
                                        }
                                }



                            }
                        }
                        if (dictionary.TryGetValue(currentMemberName = "defaultThreadPoolStackSize", out node))
                        {
                            if (node.Type == fastCSharp.setup.cSharp.ajax.jsonNode.nodeType.Null) value.defaultThreadPoolStackSize = default(int);
                            else
                            {





                                if (node.Type == fastCSharp.setup.cSharp.ajax.jsonNode.nodeType.Int) value.defaultThreadPoolStackSize = (int)node.Int;
                                else
                                {
                                        if (!int/**/.TryParse(node.NumberString, out value.defaultThreadPoolStackSize))
                                        {
                                            fastCSharp.log.Default.Throw("int : " + currentMemberName + @" 转换失败
" + node.NumberString, true, false);
                                        }
                                }



                            }
                        }
                        if (dictionary.TryGetValue(currentMemberName = "tinyThreadPoolStackSize", out node))
                        {
                            if (node.Type == fastCSharp.setup.cSharp.ajax.jsonNode.nodeType.Null) value.tinyThreadPoolStackSize = default(int);
                            else
                            {





                                if (node.Type == fastCSharp.setup.cSharp.ajax.jsonNode.nodeType.Int) value.tinyThreadPoolStackSize = (int)node.Int;
                                else
                                {
                                        if (!int/**/.TryParse(node.NumberString, out value.tinyThreadPoolStackSize))
                                        {
                                            fastCSharp.log.Default.Throw("int : " + currentMemberName + @" 转换失败
" + node.NumberString, true, false);
                                        }
                                }



                            }
                        }
                        if (dictionary.TryGetValue(currentMemberName = "tinyThreadCount", out node))
                        {
                            if (node.Type == fastCSharp.setup.cSharp.ajax.jsonNode.nodeType.Null) value.tinyThreadCount = default(int);
                            else
                            {





                                if (node.Type == fastCSharp.setup.cSharp.ajax.jsonNode.nodeType.Int) value.tinyThreadCount = (int)node.Int;
                                else
                                {
                                        if (!int/**/.TryParse(node.NumberString, out value.tinyThreadCount))
                                        {
                                            fastCSharp.log.Default.Throw("int : " + currentMemberName + @" 转换失败
" + node.NumberString, true, false);
                                        }
                                }



                            }
                        }
                        if (dictionary.TryGetValue(currentMemberName = "WorkPath", out node))
                        {
                            if (node.Type == fastCSharp.setup.cSharp.ajax.jsonNode.nodeType.Null) value.WorkPath = default(string);
                            else
                            {
                                value.WorkPath = node.String;








                            }
                        }
                        if (dictionary.TryGetValue(currentMemberName = "LogPath", out node))
                        {
                            if (node.Type == fastCSharp.setup.cSharp.ajax.jsonNode.nodeType.Null) value.LogPath = default(string);
                            else
                            {
                                value.LogPath = node.String;








                            }
                        }
                        if (dictionary.TryGetValue(currentMemberName = "CachePath", out node))
                        {
                            if (node.Type == fastCSharp.setup.cSharp.ajax.jsonNode.nodeType.Null) value.CachePath = default(string);
                            else
                            {
                                value.CachePath = node.String;








                            }
                        }
                        if (dictionary.TryGetValue(currentMemberName = "IsDebug", out node))
                        {
                            if (node.Type == fastCSharp.setup.cSharp.ajax.jsonNode.nodeType.Null) value.IsDebug = default(bool);
                            else
                            {


                                value.IsDebug = node.Bool;






                            }
                        }
                        if (dictionary.TryGetValue(currentMemberName = "includeFile", out node))
                        {
                            if (node.Type == fastCSharp.setup.cSharp.ajax.jsonNode.nodeType.Null) value.includeFile = default(string[]);
                            else
                            {








                                {
                                    if (node.Type != fastCSharp.setup.cSharp.ajax.jsonNode.nodeType.List) fastCSharp.log.Default.Throw(currentMemberName + " 不可枚举", true, false);
                                    list<fastCSharp.setup.cSharp.ajax.jsonNode> nodes = node.List;
                                    string[] array = new string[nodes.Count];
                                    int arrayIndex = -1;
                                    foreach (fastCSharp.setup.cSharp.ajax.jsonNode arrayNode in nodes)
                                    {
                                        if (arrayNode.Type == fastCSharp.setup.cSharp.ajax.jsonNode.nodeType.Null) array[++arrayIndex] = default(string);
                                        else
                                        {
                                            array[++arrayIndex] = arrayNode.String;






                                        }
                                    }
                                    value.includeFile = array;

                                }
                            }
                        }
                    }
                    return value;
                }
            }
            /// <summary>
            /// JSON字符串转换成对象
            /// </summary>
            /// <param name="json">JSON字符串</param>
            public void FromJson(string json)
            {
                FromJson(new fastCSharp.setup.cSharp.ajax.jsonParser().Parse(json));
            }
            /// <summary>
            /// JSON字符串解析节点换成对象
            /// </summary>
            /// <param name="node">JSON字符串解析节点</param>
            public void FromJson(fastCSharp.setup.cSharp.ajax.jsonNode node)
            {
                jsonParser parser = new jsonParser { Node = node };
                parser.Parse(this);
                
            }
        }
}namespace fastCSharp.setup
{
        public partial class tcpRegister : fastCSharp.setup.cSharp.tcpServer.ITcpServer
        {
            internal static class tcpServer
            {
                public static fastCSharp.setup.tcpRegister.clientId register(fastCSharp.setup.tcpRegister _value_)
                {
                    
                    return _value_.register();
                }
                public static fastCSharp.setup.tcpRegister.services[] getServices(fastCSharp.setup.tcpRegister _value_, out int version)
                {
                    
                    return _value_.getServices(out version);
                }
                public static fastCSharp.setup.tcpRegister.registerResult register(fastCSharp.setup.tcpRegister _value_, fastCSharp.setup.tcpRegister.clientId client, fastCSharp.setup.tcpRegister.service service)
                {
                    
                    return _value_.register(client, service);
                }
                public static void poll(fastCSharp.setup.tcpRegister _value_, fastCSharp.setup.tcpRegister.clientId client, fastCSharp.action<fastCSharp.setup.cSharp.tcpBase.asynchronousReturn<fastCSharp.setup.tcpRegister.pollResult>> onRegisterChanged)
                {
                    _value_.poll(client, onRegisterChanged);
                }
                public static void removeRegister(fastCSharp.setup.tcpRegister _value_, fastCSharp.setup.tcpRegister.clientId client, string serviceName)
                {
                    _value_.removeRegister(client, serviceName);
                }
                public static void removeRegister(fastCSharp.setup.tcpRegister _value_, fastCSharp.setup.tcpRegister.clientId client)
                {
                    _value_.removeRegister(client);
                }
            }
        }
}
namespace fastCSharp.tcpServer
{

        /// <summary>
        /// TCP服务
        /// </summary>
        public class tcpRegister : fastCSharp.net.tcpServerAsynchronous
        {
            /// <summary>
            /// TCP服务目标对象
            /// </summary>
            private readonly fastCSharp.setup.tcpRegister _value_ = new fastCSharp.setup.tcpRegister();
            /// <summary>
            /// TCP调用服务端
            /// </summary>
            /// <param name="attribute">TCP调用服务器端配置信息</param>
            /// <param name="verify">TCP验证实例</param>
            public tcpRegister(fastCSharp.setup.cSharp.tcpServer attribute = null, fastCSharp.setup.cSharp.tcpBase.ITcpVerifyAsynchronous verify = null)
                : base(attribute ?? fastCSharp.setup.cSharp.tcpServer.GetConfig("tcpRegister", typeof(fastCSharp.setup.tcpRegister)), verify ?? new fastCSharp.setup.tcpRegister.verify())
            {
                _value_.SetTcpServer(this);
                list<keyValue<hashBytes, keyValue<action<socket, int>, bool>>>.unsafer onCommands = new list<keyValue<hashBytes, keyValue<action<socket, int>, bool>>>(6 + 1).Unsafer;
                onCommands.Add(new keyValue<hashBytes, keyValue<action<socket, int>, bool>>(closeCommandData, new keyValue<action<socket, int>, bool>(new action<socket, int>(close), false)));
                onCommands.Add(new keyValue<hashBytes, keyValue<action<socket, int>, bool>>(formatMethodKeyName("()register"), new keyValue<action<socket, int>, bool>(_m0, false)));
                onCommands.Add(new keyValue<hashBytes, keyValue<action<socket, int>, bool>>(formatMethodKeyName("(out int)getServices"), new keyValue<action<socket, int>, bool>(_m1, true)));
                onCommands.Add(new keyValue<hashBytes, keyValue<action<socket, int>, bool>>(formatMethodKeyName("(fastCSharp.setup.tcpRegister.clientId,fastCSharp.setup.tcpRegister.service)register"), new keyValue<action<socket, int>, bool>(_m2, true)));
                onCommands.Add(new keyValue<hashBytes, keyValue<action<socket, int>, bool>>(formatMethodKeyName("(fastCSharp.setup.tcpRegister.clientId,fastCSharp.action<fastCSharp.setup.cSharp.tcpBase.asynchronousReturn<fastCSharp.setup.tcpRegister.pollResult>>)poll"), new keyValue<action<socket, int>, bool>(_m3, true)));
                onCommands.Add(new keyValue<hashBytes, keyValue<action<socket, int>, bool>>(formatMethodKeyName("(fastCSharp.setup.tcpRegister.clientId,string)removeRegister"), new keyValue<action<socket, int>, bool>(_m4, true)));
                onCommands.Add(new keyValue<hashBytes, keyValue<action<socket, int>, bool>>(formatMethodKeyName("(fastCSharp.setup.tcpRegister.clientId)removeRegister"), new keyValue<action<socket, int>, bool>(_m5, true)));
                this.onCommands = new staticDictionary<hashBytes, keyValue<action<socket, int>, bool>>(onCommands.List);
            }
            internal class _o0 : fastCSharp.setup.cSharp.tcpBase.returnParameter<fastCSharp.setup.tcpRegister.clientId>, fastCSharp.setup.cSharp.serialize.ISerialize
            {
            /// <summary>
            /// 序列化
            /// </summary>
            unsafe class serializer : fastCSharp.setup.cSharp.serialize.dataSerializer
            {
                /// <summary>
                /// 序列化
                /// </summary>
                /// <param name="stream">序列化流</param>
                /// <param name="memberMap">成员位图接口</param>
                public serializer(memoryStream stream, fastCSharp.setup.cSharp.IMemberMap memberMap) : base(stream, memberMap) { }
                /// <summary>
                /// 序列化
                /// </summary>
                /// <param name="parentSerializer">序列化</param>
                /// <param name="memberMap">成员位图接口</param>
                public serializer(fastCSharp.setup.cSharp.serialize.dataSerializer parentSerializer)
                    : base(parentSerializer, default(_o0/**/.memberMap)) { }
                /// <summary>
                /// 对象序列化
                /// </summary>
                /// <param name="value">对象</param>
                /// <param name="isPoint">是否记录历史指针</param>
                public void Serialize(_o0 value, bool isPoint)
                {
                    if (value != null)
                    {
                        if (isPoint) points[value] = dataStream.Length - streamStartIndex;
                        versionMemerMap(0);
                        serialize(value);
                    }
                    else dataStream.Write(fastCSharp.setup.cSharp.serialize.NullValue);
                }
                /// <summary>
                /// 对象序列化
                /// </summary>
                /// <param name="value">对象</param>
                private void serialize(_o0 value)
                {
                    memoryStream.unsafer unsafeStream = dataStream.Unsafer;
                    int length = memberMap.SerializeSize;
                    dataStream.PrepLength(length + 4);
                    fixed (byte* dataFixed = dataStream.Array)
                    {
                        write = dataFixed + dataStream.Length;
                        fixedMap nullMap = new fixedMap(write);
                        fastCSharp.unsafer.memory.Fill(write, (uint)0, length >> 2);
                        write += length;
                        if (memberMap.IsDefault)
                        {
                        }
                        else
                        {
                            if (memberMap.IsMember(0))
                            {
                            }
                        }
                        unsafeStream.AddLength(((int)(write - dataFixed - dataStream.Length) + 3) & (int.MaxValue - 3));
                    }
                    if (memberMap.IsDefault)
                    {
                        iSerializeNotNull(value._Return_);
                    }
                    else
                    {
                        if (memberMap.IsMember(0))
                        {
                        iSerializeNotNull(value._Return_);
                        }
                    }
                }
            }
            /// <summary>
            /// 对象序列化
            /// </summary>
            /// <returns>序列化数据</returns>
            public byte[] Serialize()
            {
                using (memoryStream stream = new memoryStream())
                {
                    Serialize(stream, default(_o0/**/.memberMap));
                    return stream.ToArray();
                }
            }
            /// <summary>
            /// 对象序列化
            /// </summary>
            /// <param name="stream">数据流</param>
            public void Serialize(memoryStream stream)
            {
                Serialize(stream, default(_o0/**/.memberMap));
            }
            /// <summary>
            /// 对象序列化
            /// </summary>
            /// <param name="stream">数据流</param>
            /// <param name="memberMap">成员位图接口</param>
            public void Serialize(memoryStream stream, _o0/**/.memberMap memberMap)
            {
                serializer serializer = new serializer(stream, memberMap);
                serializer.Serialize(this, true);
                serializer.Finally();
            }
            /// <summary>
            /// 对象序列化
            /// </summary>
            /// <param name="serializer">对象序列化器</param>
            public void Serialize(fastCSharp.setup.cSharp.serialize.dataSerializer parentSerializer)
            {
                new serializer(parentSerializer).Serialize(this, false);
            }
            /// <summary>
            /// 对象反序列化
            /// </summary>
            unsafe class deSerializer : fastCSharp.setup.cSharp.serialize.deSerializer
            {
                /// <summary>
                /// 成员位图接口
                /// </summary>
                public _o0/**/.memberMap MemberMap;
                /// <summary>
                /// 对象反序列化
                /// </summary>
                /// <param name="data">序列化数据</param>
                public deSerializer(byte[] data) : base(data) { }
                /// <summary>
                /// 对象反序列化
                /// </summary>
                /// <param name="parentDeSerializer">对象反序列化器</param>
                public deSerializer(fastCSharp.setup.cSharp.serialize.deSerializer parentDeSerializer)
                    : base(parentDeSerializer) { }
                /// <summary>
                /// 反序列化
                /// </summary>
                /// <param name="value">反序列化目标对象</param>
                /// <param name="startIndex">数据起始位置</param>
                /// <returns>数据对象</returns>
                public _o0 DeSerialize(_o0 value, int startIndex)
                {
                    fixed (byte* dataFixed = data)
                    {
                        this.dataFixed = dataFixed;
                        dataStart = read = dataFixed + startIndex;
                        dataVersion = *(int*)read;
                        if (dataVersion != (int)fastCSharp.setup.cSharp.serializeVersion.serialize)
                        {
                            fastCSharp.log.Default.Throw("序列化格式版本号不匹配 fastCSharp.setup.cSharp.serializeVersion.serialize[" + ((int)fastCSharp.setup.cSharp.serializeVersion.serialize).toString() + "] != " + dataVersion.toString(), true, false);
                        }
                        dataVersion = *(int*)(read += sizeof(int));
                        if (dataVersion != fastCSharp.setup.cSharp.serialize.NullValue)
                        {
                            versionMemberMap();
                            value = DeSerializeData(value);
                            checkEnd();
                            return value;
                        }
                    }
                    return default(_o0);
                }
                /// <summary>
                /// 版本号+成员位图接口
                /// </summary>
                protected override void versionMemberMap()
                {
                    if (dataVersion != 0)
                    {
                        fastCSharp.log.Default.Throw("序列化版本号错误 0 != " + dataVersion.toString(), true, false);
                    }
                    read = MemberMap.DeSerialize(read += sizeof(int));
                }
                /// <summary>
                /// 反序列化
                /// </summary>
                /// <param name="value">反序列化目标对象</param>
                /// <returns>数据对象</returns>
                public _o0 DeSerialize(_o0 value)
                {
                    dataVersion = *(int*)read;
                    versionMemberMap();
                    return DeSerializeData(value);
                }
                /// <summary>
                /// 反序列化
                /// </summary>
                /// <param name="value">反序列化目标对象</param>
                /// <returns>数据对象</returns>
                public _o0 DeSerializeData(_o0 value)
                {
                    fixedMap nullMap = new fixedMap(read);
                    read += MemberMap.SerializeSize;
                    if (MemberMap.IsDefault)
                    {
                    }
                    else
                    {
                        if (MemberMap.IsMember(0))
                        {
                        }
                    }
                    int length = (int)(read - nullMap.Map);
                    if ((length & 3) != 0) read += -length & 3;
                    if (MemberMap.IsDefault)
                    {
                        {
                            value._Return_ = iSerializeNotNull<fastCSharp.setup.tcpRegister.clientId>();
                        }
                    }
                    else
                    {
                        if (MemberMap.IsMember(0))
                        {
                        {
                            value._Return_ = iSerializeNotNull<fastCSharp.setup.tcpRegister.clientId>();
                        }
                        }
                    }
                    return value;
                }
            }
            /// <summary>
            /// 反序列化
            /// </summary>
            /// <param name="data">序列化数据</param>
            public bool DeSerialize(byte[] data)
            {
                return DeSerialize(data, 0, out deSerializer.OutEndIndex);
            }
            /// <summary>
            /// 反序列化
            /// </summary>
            /// <param name="data">序列化数据</param>
            /// <param name="startIndex">起始位置</param>
            /// <param name="endIndex">结束位置</param>
            public bool DeSerialize(byte[] data, int startIndex, out int endIndex)
            {
                deSerializer deSerializer = new deSerializer(data);
                _o0 value = deSerializer.DeSerialize(this, startIndex);
                
                endIndex = deSerializer.EndIndex;
                return value != null && endIndex <= data.Length;
            }
            /// <summary>
            /// 反序列化
            /// </summary>
            /// <param name="parentDeSerializer">对象反序列化器</param>
            public unsafe void DeSerialize(fastCSharp.setup.cSharp.serialize.deSerializer parentDeSerializer)
            {
                deSerializer deSerializer = new deSerializer(parentDeSerializer);
                deSerializer.DeSerialize(this);
                
                parentDeSerializer.SetRead(deSerializer);
            }

            /// <summary>
            /// 成员位图
            /// </summary>
            public struct memberMap : fastCSharp.setup.cSharp.IMemberMap<memberMap>
            {
                /// <summary>
                /// 成员位图
                /// </summary>
                private uint map;
                /// <summary>
                /// 成员位图
                /// </summary>
                /// <param name="members">成员集合</param>
                public memberMap(params member[] members)
                {
                    map = 0;
                    foreach (member member in members) SetMember((int)member);
                }
                /// <summary>
                /// 成员位图
                /// </summary>
                /// <returns>成员位图</returns>
                public memberMap Copy()
                {
                    return new memberMap { map = map };
                }
                /// <summary>
                /// 是否默认全部成员有效
                /// </summary>
                public bool IsDefault
                {
                    get { return map == 0; }
                }
                /// <summary>
                /// 序列化字节长度
                /// </summary>
                public int SerializeSize
                {
                    get
                    {
                        return sizeof(uint);
                    }
                }
                /// <summary>
                /// 设置成员索引,忽略默认成员
                /// </summary>
                /// <param name="memberIndex">成员索引</param>
                public void SetMember(int memberIndex)
                {
                    map |= 1U << (int)memberIndex;
                }
                /// <summary>
                /// 清除成员索引,忽略默认成员
                /// </summary>
                /// <param name="memberIndex">成员索引</param>
                public void ClearMember(int memberIndex)
                {
                    map &= uint.MaxValue ^ (1U << (int)memberIndex);
                }
                /// <summary>
                /// 设置成员,忽略默认成员
                /// </summary>
                /// <param name="member">成员</param>
                public void SetMember(member member)
                {
                    SetMember((int)member);
                }
                /// <summary>
                /// 清除成员,忽略默认成员
                /// </summary>
                /// <param name="memberIndex">成员</param>
                public void ClearMember(member member)
                {
                    ClearMember((int)member);
                }
                /// <summary>
                /// 成员交集运算,忽略默认成员
                /// </summary>
                /// <param name="memberMap">成员位图</param>
                public void And(memberMap memberMap)
                {
                    map &= memberMap.map;
                }
                /// <summary>
                /// 成员异或运算,忽略默认成员
                /// </summary>
                /// <param name="memberMap">成员位图</param>
                public void Xor(memberMap memberMap)
                {
                    map ^= memberMap.map;
                }
                /// <summary>
                /// 成员并集运算,忽略默认成员
                /// </summary>
                /// <param name="memberMap">成员位图</param>
                public void Or(memberMap memberMap)
                {
                    map |= memberMap.map;
                }
                /// <summary>
                /// 判断成员索引是否有效
                /// </summary>
                /// <param name="memberIndex">成员索引</param>
                /// <returns>成员索引是否有效</returns>
                public bool IsMember(int memberIndex)
                {
                    return map == 0 || (map & (1 << memberIndex)) != 0;
                }
                /// <summary>
                /// 判断成员是否有效
                /// </summary>
                /// <param name="member">成员</param>
                /// <returns>成员是否有效</returns>
                public bool IsMember(member member)
                {
                    return IsMember((int)member);
                }
                /// <summary>
                /// 序列化
                /// </summary>
                /// <param name="stream">数据流</param>
                public void Serialize(memoryStream stream)
                {
                    stream.Write(map);
                }
                /// <summary>
                /// 序列化
                /// </summary>
                /// <param name="stream">数据流</param>
                public void Serialize(System.IO.Stream stream)
                {
                    stream.Write(BitConverter.GetBytes(map), 0, sizeof(uint));
                }
                /// <summary>
                /// 反序列化
                /// </summary>
                /// <param name="data">数据</param>
                /// <returns>结束位置</returns>
                public unsafe byte* DeSerialize(byte* data)
                {
                    map = *(uint*)data;
                    return data + sizeof(uint);
                }
                /// <summary>
                /// 成员获取器
                /// </summary>
                /// <returns>成员获取器</returns>
                public fastCSharp.setup.cSharp.IMemberInfo MemberInfo
                {
                    get { return new memberInfo(); }
                }
            }


            /// <summary>
            /// 成员
            /// </summary>
            public enum member
            {
                [fastCSharp.setup.cSharp.member(Type = typeof(fastCSharp.setup.tcpRegister.clientId))]
                _Return_ = 0,
            }
            /// <summary>
            /// 成员信息获取器
            /// </summary>
            private struct memberInfo : fastCSharp.setup.cSharp.IMemberInfo
            {
                /// <summary>
                /// 获取成员名称
                /// </summary>
                /// <param name="memberIndex">成员索引</param>
                /// <returns>成员名称</returns>
                public string GetName(int memberIndex)
                {
                    return ((member)memberIndex).ToString();
                }
                /// <summary>
                /// 获取成员类型
                /// </summary>
                /// <param name="memberIndex">成员索引</param>
                /// <returns>成员类型</returns>
                public Type GetType(int memberIndex)
                {
                    return fastCSharp.Enum<member, fastCSharp.setup.cSharp.member>.Array(memberIndex).Type;
                }
                /// <summary>
                /// 所有成员数量
                /// </summary>
                public int MemberCount
                {
                    get
                    {
                        return 0 + 1;
                    }
                }
            }
            }
            private void _m0(socket _socket_, int _identity_)
            {
                bool _isError_ = false;
                byte[] _data_ = null;
                try
                {

                    
                    fastCSharp.setup.tcpRegister.clientId _return_ = 
                    fastCSharp.setup.tcpRegister/**/.tcpServer.register(_value_);
                    _data_ = (new _o0
                    {
                        _Return_ = _return_
                    }).Serialize();
                }
                catch (Exception error)
                {
                    fastCSharp.log.Default.Add(error, null, true);
                    {
                        _isError_ = true;
                        send(_socket_, socket.Close, fastCSharp.net.tcpServer.status.Error, _identity_);
                    }
                }
                if (!_isError_)
                {
                    send(_socket_, receiveCommand, fastCSharp.net.tcpServer.status.Success, _identity_, _data_);
                }
            }
            [fastCSharp.setup.cSharp.serialize(IsIgnore = true, IsObject = true, IsInterface = true)]
            internal class _i1 : fastCSharp.setup.cSharp.serialize.ISerialize
            {
                public int version;
            /// <summary>
            /// 序列化
            /// </summary>
            unsafe class serializer : fastCSharp.setup.cSharp.serialize.dataSerializer
            {
                /// <summary>
                /// 序列化
                /// </summary>
                /// <param name="stream">序列化流</param>
                /// <param name="memberMap">成员位图接口</param>
                public serializer(memoryStream stream, fastCSharp.setup.cSharp.IMemberMap memberMap) : base(stream, memberMap) { }
                /// <summary>
                /// 序列化
                /// </summary>
                /// <param name="parentSerializer">序列化</param>
                /// <param name="memberMap">成员位图接口</param>
                public serializer(fastCSharp.setup.cSharp.serialize.dataSerializer parentSerializer)
                    : base(parentSerializer, default(_i1/**/.memberMap)) { }
                /// <summary>
                /// 对象序列化
                /// </summary>
                /// <param name="value">对象</param>
                /// <param name="isPoint">是否记录历史指针</param>
                public void Serialize(_i1 value, bool isPoint)
                {
                    if (value != null)
                    {
                        if (isPoint) points[value] = dataStream.Length - streamStartIndex;
                        versionMemerMap(0);
                        serialize(value);
                    }
                    else dataStream.Write(fastCSharp.setup.cSharp.serialize.NullValue);
                }
                /// <summary>
                /// 对象序列化
                /// </summary>
                /// <param name="value">对象</param>
                private void serialize(_i1 value)
                {
                    memoryStream.unsafer unsafeStream = dataStream.Unsafer;
                    int length = memberMap.SerializeSize;
                    dataStream.PrepLength(length + 4);
                    fixed (byte* dataFixed = dataStream.Array)
                    {
                        write = dataFixed + dataStream.Length;
                        fixedMap nullMap = new fixedMap(write);
                        fastCSharp.unsafer.memory.Fill(write, (uint)0, length >> 2);
                        write += length;
                        if (memberMap.IsDefault)
                        {
                            {
                                *(int*)write = (int)value.version;
                                write += sizeof(int);
                            }
                        }
                        else
                        {
                            if (memberMap.IsMember(0))
                            {
                            {
                                *(int*)write = (int)value.version;
                                write += sizeof(int);
                            }
                            }
                        }
                        unsafeStream.AddLength(((int)(write - dataFixed - dataStream.Length) + 3) & (int.MaxValue - 3));
                    }
                    if (memberMap.IsDefault)
                    {
                    }
                    else
                    {
                    }
                }
            }
            /// <summary>
            /// 对象序列化
            /// </summary>
            /// <returns>序列化数据</returns>
            public byte[] Serialize()
            {
                using (memoryStream stream = new memoryStream())
                {
                    Serialize(stream, default(_i1/**/.memberMap));
                    return stream.ToArray();
                }
            }
            /// <summary>
            /// 对象序列化
            /// </summary>
            /// <param name="stream">数据流</param>
            public void Serialize(memoryStream stream)
            {
                Serialize(stream, default(_i1/**/.memberMap));
            }
            /// <summary>
            /// 对象序列化
            /// </summary>
            /// <param name="stream">数据流</param>
            /// <param name="memberMap">成员位图接口</param>
            public void Serialize(memoryStream stream, _i1/**/.memberMap memberMap)
            {
                serializer serializer = new serializer(stream, memberMap);
                serializer.Serialize(this, true);
                serializer.Finally();
            }
            /// <summary>
            /// 对象序列化
            /// </summary>
            /// <param name="serializer">对象序列化器</param>
            public void Serialize(fastCSharp.setup.cSharp.serialize.dataSerializer parentSerializer)
            {
                new serializer(parentSerializer).Serialize(this, false);
            }
            /// <summary>
            /// 对象反序列化
            /// </summary>
            unsafe class deSerializer : fastCSharp.setup.cSharp.serialize.deSerializer
            {
                /// <summary>
                /// 成员位图接口
                /// </summary>
                public _i1/**/.memberMap MemberMap;
                /// <summary>
                /// 对象反序列化
                /// </summary>
                /// <param name="data">序列化数据</param>
                public deSerializer(byte[] data) : base(data) { }
                /// <summary>
                /// 对象反序列化
                /// </summary>
                /// <param name="parentDeSerializer">对象反序列化器</param>
                public deSerializer(fastCSharp.setup.cSharp.serialize.deSerializer parentDeSerializer)
                    : base(parentDeSerializer) { }
                /// <summary>
                /// 反序列化
                /// </summary>
                /// <param name="value">反序列化目标对象</param>
                /// <param name="startIndex">数据起始位置</param>
                /// <returns>数据对象</returns>
                public _i1 DeSerialize(_i1 value, int startIndex)
                {
                    fixed (byte* dataFixed = data)
                    {
                        this.dataFixed = dataFixed;
                        dataStart = read = dataFixed + startIndex;
                        dataVersion = *(int*)read;
                        if (dataVersion != (int)fastCSharp.setup.cSharp.serializeVersion.serialize)
                        {
                            fastCSharp.log.Default.Throw("序列化格式版本号不匹配 fastCSharp.setup.cSharp.serializeVersion.serialize[" + ((int)fastCSharp.setup.cSharp.serializeVersion.serialize).toString() + "] != " + dataVersion.toString(), true, false);
                        }
                        dataVersion = *(int*)(read += sizeof(int));
                        if (dataVersion != fastCSharp.setup.cSharp.serialize.NullValue)
                        {
                            versionMemberMap();
                            value = DeSerializeData(value);
                            checkEnd();
                            return value;
                        }
                    }
                    return default(_i1);
                }
                /// <summary>
                /// 版本号+成员位图接口
                /// </summary>
                protected override void versionMemberMap()
                {
                    if (dataVersion != 0)
                    {
                        fastCSharp.log.Default.Throw("序列化版本号错误 0 != " + dataVersion.toString(), true, false);
                    }
                    read = MemberMap.DeSerialize(read += sizeof(int));
                }
                /// <summary>
                /// 反序列化
                /// </summary>
                /// <param name="value">反序列化目标对象</param>
                /// <returns>数据对象</returns>
                public _i1 DeSerialize(_i1 value)
                {
                    dataVersion = *(int*)read;
                    versionMemberMap();
                    return DeSerializeData(value);
                }
                /// <summary>
                /// 反序列化
                /// </summary>
                /// <param name="value">反序列化目标对象</param>
                /// <returns>数据对象</returns>
                public _i1 DeSerializeData(_i1 value)
                {
                    fixedMap nullMap = new fixedMap(read);
                    read += MemberMap.SerializeSize;
                    if (MemberMap.IsDefault)
                    {
                        {
                            value.version = (*(int*)read);
                            read += sizeof(int);
                        }
                    }
                    else
                    {
                        if (MemberMap.IsMember(0))
                        {
                        {
                            value.version = (*(int*)read);
                            read += sizeof(int);
                        }
                        }
                    }
                    int length = (int)(read - nullMap.Map);
                    if ((length & 3) != 0) read += -length & 3;
                    if (MemberMap.IsDefault)
                    {
                    }
                    else
                    {
                    }
                    return value;
                }
            }
            /// <summary>
            /// 反序列化
            /// </summary>
            /// <param name="data">序列化数据</param>
            public bool DeSerialize(byte[] data)
            {
                return DeSerialize(data, 0, out deSerializer.OutEndIndex);
            }
            /// <summary>
            /// 反序列化
            /// </summary>
            /// <param name="data">序列化数据</param>
            /// <param name="startIndex">起始位置</param>
            /// <param name="endIndex">结束位置</param>
            public bool DeSerialize(byte[] data, int startIndex, out int endIndex)
            {
                deSerializer deSerializer = new deSerializer(data);
                _i1 value = deSerializer.DeSerialize(this, startIndex);
                
                endIndex = deSerializer.EndIndex;
                return value != null && endIndex <= data.Length;
            }
            /// <summary>
            /// 反序列化
            /// </summary>
            /// <param name="parentDeSerializer">对象反序列化器</param>
            public unsafe void DeSerialize(fastCSharp.setup.cSharp.serialize.deSerializer parentDeSerializer)
            {
                deSerializer deSerializer = new deSerializer(parentDeSerializer);
                deSerializer.DeSerialize(this);
                
                parentDeSerializer.SetRead(deSerializer);
            }

            /// <summary>
            /// 成员位图
            /// </summary>
            public struct memberMap : fastCSharp.setup.cSharp.IMemberMap<memberMap>
            {
                /// <summary>
                /// 成员位图
                /// </summary>
                private uint map;
                /// <summary>
                /// 成员位图
                /// </summary>
                /// <param name="members">成员集合</param>
                public memberMap(params member[] members)
                {
                    map = 0;
                    foreach (member member in members) SetMember((int)member);
                }
                /// <summary>
                /// 成员位图
                /// </summary>
                /// <returns>成员位图</returns>
                public memberMap Copy()
                {
                    return new memberMap { map = map };
                }
                /// <summary>
                /// 是否默认全部成员有效
                /// </summary>
                public bool IsDefault
                {
                    get { return map == 0; }
                }
                /// <summary>
                /// 序列化字节长度
                /// </summary>
                public int SerializeSize
                {
                    get
                    {
                        return sizeof(uint);
                    }
                }
                /// <summary>
                /// 设置成员索引,忽略默认成员
                /// </summary>
                /// <param name="memberIndex">成员索引</param>
                public void SetMember(int memberIndex)
                {
                    map |= 1U << (int)memberIndex;
                }
                /// <summary>
                /// 清除成员索引,忽略默认成员
                /// </summary>
                /// <param name="memberIndex">成员索引</param>
                public void ClearMember(int memberIndex)
                {
                    map &= uint.MaxValue ^ (1U << (int)memberIndex);
                }
                /// <summary>
                /// 设置成员,忽略默认成员
                /// </summary>
                /// <param name="member">成员</param>
                public void SetMember(member member)
                {
                    SetMember((int)member);
                }
                /// <summary>
                /// 清除成员,忽略默认成员
                /// </summary>
                /// <param name="memberIndex">成员</param>
                public void ClearMember(member member)
                {
                    ClearMember((int)member);
                }
                /// <summary>
                /// 成员交集运算,忽略默认成员
                /// </summary>
                /// <param name="memberMap">成员位图</param>
                public void And(memberMap memberMap)
                {
                    map &= memberMap.map;
                }
                /// <summary>
                /// 成员异或运算,忽略默认成员
                /// </summary>
                /// <param name="memberMap">成员位图</param>
                public void Xor(memberMap memberMap)
                {
                    map ^= memberMap.map;
                }
                /// <summary>
                /// 成员并集运算,忽略默认成员
                /// </summary>
                /// <param name="memberMap">成员位图</param>
                public void Or(memberMap memberMap)
                {
                    map |= memberMap.map;
                }
                /// <summary>
                /// 判断成员索引是否有效
                /// </summary>
                /// <param name="memberIndex">成员索引</param>
                /// <returns>成员索引是否有效</returns>
                public bool IsMember(int memberIndex)
                {
                    return map == 0 || (map & (1 << memberIndex)) != 0;
                }
                /// <summary>
                /// 判断成员是否有效
                /// </summary>
                /// <param name="member">成员</param>
                /// <returns>成员是否有效</returns>
                public bool IsMember(member member)
                {
                    return IsMember((int)member);
                }
                /// <summary>
                /// 序列化
                /// </summary>
                /// <param name="stream">数据流</param>
                public void Serialize(memoryStream stream)
                {
                    stream.Write(map);
                }
                /// <summary>
                /// 序列化
                /// </summary>
                /// <param name="stream">数据流</param>
                public void Serialize(System.IO.Stream stream)
                {
                    stream.Write(BitConverter.GetBytes(map), 0, sizeof(uint));
                }
                /// <summary>
                /// 反序列化
                /// </summary>
                /// <param name="data">数据</param>
                /// <returns>结束位置</returns>
                public unsafe byte* DeSerialize(byte* data)
                {
                    map = *(uint*)data;
                    return data + sizeof(uint);
                }
                /// <summary>
                /// 成员获取器
                /// </summary>
                /// <returns>成员获取器</returns>
                public fastCSharp.setup.cSharp.IMemberInfo MemberInfo
                {
                    get { return new memberInfo(); }
                }
            }


            /// <summary>
            /// 成员
            /// </summary>
            public enum member
            {
                [fastCSharp.setup.cSharp.member(Type = typeof(int))]
                version = 0,
            }
            /// <summary>
            /// 成员信息获取器
            /// </summary>
            private struct memberInfo : fastCSharp.setup.cSharp.IMemberInfo
            {
                /// <summary>
                /// 获取成员名称
                /// </summary>
                /// <param name="memberIndex">成员索引</param>
                /// <returns>成员名称</returns>
                public string GetName(int memberIndex)
                {
                    return ((member)memberIndex).ToString();
                }
                /// <summary>
                /// 获取成员类型
                /// </summary>
                /// <param name="memberIndex">成员索引</param>
                /// <returns>成员类型</returns>
                public Type GetType(int memberIndex)
                {
                    return fastCSharp.Enum<member, fastCSharp.setup.cSharp.member>.Array(memberIndex).Type;
                }
                /// <summary>
                /// 所有成员数量
                /// </summary>
                public int MemberCount
                {
                    get
                    {
                        return 0 + 1;
                    }
                }
            }
            }
            internal class _o1 : fastCSharp.setup.cSharp.tcpBase.returnParameter<fastCSharp.setup.tcpRegister.services[]>, fastCSharp.setup.cSharp.serialize.ISerialize
            {
                public int version;
            /// <summary>
            /// 序列化
            /// </summary>
            unsafe class serializer : fastCSharp.setup.cSharp.serialize.dataSerializer
            {
                /// <summary>
                /// 序列化
                /// </summary>
                /// <param name="stream">序列化流</param>
                /// <param name="memberMap">成员位图接口</param>
                public serializer(memoryStream stream, fastCSharp.setup.cSharp.IMemberMap memberMap) : base(stream, memberMap) { }
                /// <summary>
                /// 序列化
                /// </summary>
                /// <param name="parentSerializer">序列化</param>
                /// <param name="memberMap">成员位图接口</param>
                public serializer(fastCSharp.setup.cSharp.serialize.dataSerializer parentSerializer)
                    : base(parentSerializer, default(_o1/**/.memberMap)) { }
                /// <summary>
                /// 对象序列化
                /// </summary>
                /// <param name="value">对象</param>
                /// <param name="isPoint">是否记录历史指针</param>
                public void Serialize(_o1 value, bool isPoint)
                {
                    if (value != null)
                    {
                        if (isPoint) points[value] = dataStream.Length - streamStartIndex;
                        versionMemerMap(0);
                        serialize(value);
                    }
                    else dataStream.Write(fastCSharp.setup.cSharp.serialize.NullValue);
                }
                /// <summary>
                /// 对象序列化
                /// </summary>
                /// <param name="value">对象</param>
                private void serialize(_o1 value)
                {
                    memoryStream.unsafer unsafeStream = dataStream.Unsafer;
                    int length = memberMap.SerializeSize;
                    dataStream.PrepLength(length + 8);
                    fixed (byte* dataFixed = dataStream.Array)
                    {
                        write = dataFixed + dataStream.Length;
                        fixedMap nullMap = new fixedMap(write);
                        fastCSharp.unsafer.memory.Fill(write, (uint)0, length >> 2);
                        write += length;
                        if (memberMap.IsDefault)
                        {
                            if (value._Return_ == null) nullMap.Set(0);
                            {
                                *(int*)write = (int)value.version;
                                write += sizeof(int);
                            }
                        }
                        else
                        {
                            if (memberMap.IsMember(0))
                            {
                            if (value._Return_ == null) nullMap.Set(0);
                            }
                            if (memberMap.IsMember(1))
                            {
                            {
                                *(int*)write = (int)value.version;
                                write += sizeof(int);
                            }
                            }
                        }
                        unsafeStream.AddLength(((int)(write - dataFixed - dataStream.Length) + 3) & (int.MaxValue - 3));
                    }
                    if (memberMap.IsDefault)
                    {
                        {
                            fastCSharp.setup.tcpRegister.services[] enumerable = value._Return_;
                            if (checkPoint(enumerable))
                            {
                                fastCSharp.setup.tcpRegister.services[] array = enumerable;
                                iSerializeArrayNotNullNoPoint(array);

                            }
                        }
                    }
                    else
                    {
                        if (memberMap.IsMember(0))
                        {
                        {
                            fastCSharp.setup.tcpRegister.services[] enumerable = value._Return_;
                            if (checkPoint(enumerable))
                            {
                                fastCSharp.setup.tcpRegister.services[] array = enumerable;
                                iSerializeArrayNotNullNoPoint(array);

                            }
                        }
                        }
                    }
                }
            }
            /// <summary>
            /// 对象序列化
            /// </summary>
            /// <returns>序列化数据</returns>
            public byte[] Serialize()
            {
                using (memoryStream stream = new memoryStream())
                {
                    Serialize(stream, default(_o1/**/.memberMap));
                    return stream.ToArray();
                }
            }
            /// <summary>
            /// 对象序列化
            /// </summary>
            /// <param name="stream">数据流</param>
            public void Serialize(memoryStream stream)
            {
                Serialize(stream, default(_o1/**/.memberMap));
            }
            /// <summary>
            /// 对象序列化
            /// </summary>
            /// <param name="stream">数据流</param>
            /// <param name="memberMap">成员位图接口</param>
            public void Serialize(memoryStream stream, _o1/**/.memberMap memberMap)
            {
                serializer serializer = new serializer(stream, memberMap);
                serializer.Serialize(this, true);
                serializer.Finally();
            }
            /// <summary>
            /// 对象序列化
            /// </summary>
            /// <param name="serializer">对象序列化器</param>
            public void Serialize(fastCSharp.setup.cSharp.serialize.dataSerializer parentSerializer)
            {
                new serializer(parentSerializer).Serialize(this, false);
            }
            /// <summary>
            /// 对象反序列化
            /// </summary>
            unsafe class deSerializer : fastCSharp.setup.cSharp.serialize.deSerializer
            {
                /// <summary>
                /// 成员位图接口
                /// </summary>
                public _o1/**/.memberMap MemberMap;
                /// <summary>
                /// 对象反序列化
                /// </summary>
                /// <param name="data">序列化数据</param>
                public deSerializer(byte[] data) : base(data) { }
                /// <summary>
                /// 对象反序列化
                /// </summary>
                /// <param name="parentDeSerializer">对象反序列化器</param>
                public deSerializer(fastCSharp.setup.cSharp.serialize.deSerializer parentDeSerializer)
                    : base(parentDeSerializer) { }
                /// <summary>
                /// 反序列化
                /// </summary>
                /// <param name="value">反序列化目标对象</param>
                /// <param name="startIndex">数据起始位置</param>
                /// <returns>数据对象</returns>
                public _o1 DeSerialize(_o1 value, int startIndex)
                {
                    fixed (byte* dataFixed = data)
                    {
                        this.dataFixed = dataFixed;
                        dataStart = read = dataFixed + startIndex;
                        dataVersion = *(int*)read;
                        if (dataVersion != (int)fastCSharp.setup.cSharp.serializeVersion.serialize)
                        {
                            fastCSharp.log.Default.Throw("序列化格式版本号不匹配 fastCSharp.setup.cSharp.serializeVersion.serialize[" + ((int)fastCSharp.setup.cSharp.serializeVersion.serialize).toString() + "] != " + dataVersion.toString(), true, false);
                        }
                        dataVersion = *(int*)(read += sizeof(int));
                        if (dataVersion != fastCSharp.setup.cSharp.serialize.NullValue)
                        {
                            versionMemberMap();
                            value = DeSerializeData(value);
                            checkEnd();
                            return value;
                        }
                    }
                    return default(_o1);
                }
                /// <summary>
                /// 版本号+成员位图接口
                /// </summary>
                protected override void versionMemberMap()
                {
                    if (dataVersion != 0)
                    {
                        fastCSharp.log.Default.Throw("序列化版本号错误 0 != " + dataVersion.toString(), true, false);
                    }
                    read = MemberMap.DeSerialize(read += sizeof(int));
                }
                /// <summary>
                /// 反序列化
                /// </summary>
                /// <param name="value">反序列化目标对象</param>
                /// <returns>数据对象</returns>
                public _o1 DeSerialize(_o1 value)
                {
                    dataVersion = *(int*)read;
                    versionMemberMap();
                    return DeSerializeData(value);
                }
                /// <summary>
                /// 反序列化
                /// </summary>
                /// <param name="value">反序列化目标对象</param>
                /// <returns>数据对象</returns>
                public _o1 DeSerializeData(_o1 value)
                {
                    fixedMap nullMap = new fixedMap(read);
                    read += MemberMap.SerializeSize;
                    if (MemberMap.IsDefault)
                    {
                        if (nullMap.Get(0)) value._Return_ = default(fastCSharp.setup.tcpRegister.services[]);
                        {
                            value.version = (*(int*)read);
                            read += sizeof(int);
                        }
                    }
                    else
                    {
                        if (MemberMap.IsMember(0))
                        {
                        if (nullMap.Get(0)) value._Return_ = default(fastCSharp.setup.tcpRegister.services[]);
                        }
                        if (MemberMap.IsMember(1))
                        {
                        {
                            value.version = (*(int*)read);
                            read += sizeof(int);
                        }
                        }
                    }
                    int length = (int)(read - nullMap.Map);
                    if ((length & 3) != 0) read += -length & 3;
                    if (MemberMap.IsDefault)
                    {
                        if (!nullMap.Get(0))
                        {
                            {
                                object reference = getPoint();
                                if (reference != null) value._Return_ = (fastCSharp.setup.tcpRegister.services[])reference;
                                else
                                {
                                    length = *(int*)read;
                                    fastCSharp.setup.tcpRegister.services[] enumerable = new fastCSharp.setup.tcpRegister.services[length];
                                    points.Add(-(int)(read - dataStart), enumerable);
                                    read += sizeof(int);
                                    fastCSharp.setup.tcpRegister.services[] array = new fastCSharp.setup.tcpRegister.services[length];
                                    iSerializeArrayNotNullNoPoint(array);

                                    Array.Copy(array, 0, enumerable, 0, array.Length);
                                    value._Return_ = enumerable;
                                }
                            }
                        }
                    }
                    else
                    {
                        if (MemberMap.IsMember(0))
                        {
                        if (!nullMap.Get(0))
                        {
                            {
                                object reference = getPoint();
                                if (reference != null) value._Return_ = (fastCSharp.setup.tcpRegister.services[])reference;
                                else
                                {
                                    length = *(int*)read;
                                    fastCSharp.setup.tcpRegister.services[] enumerable = new fastCSharp.setup.tcpRegister.services[length];
                                    points.Add(-(int)(read - dataStart), enumerable);
                                    read += sizeof(int);
                                    fastCSharp.setup.tcpRegister.services[] array = new fastCSharp.setup.tcpRegister.services[length];
                                    iSerializeArrayNotNullNoPoint(array);

                                    Array.Copy(array, 0, enumerable, 0, array.Length);
                                    value._Return_ = enumerable;
                                }
                            }
                        }
                        }
                    }
                    return value;
                }
            }
            /// <summary>
            /// 反序列化
            /// </summary>
            /// <param name="data">序列化数据</param>
            public bool DeSerialize(byte[] data)
            {
                return DeSerialize(data, 0, out deSerializer.OutEndIndex);
            }
            /// <summary>
            /// 反序列化
            /// </summary>
            /// <param name="data">序列化数据</param>
            /// <param name="startIndex">起始位置</param>
            /// <param name="endIndex">结束位置</param>
            public bool DeSerialize(byte[] data, int startIndex, out int endIndex)
            {
                deSerializer deSerializer = new deSerializer(data);
                _o1 value = deSerializer.DeSerialize(this, startIndex);
                
                endIndex = deSerializer.EndIndex;
                return value != null && endIndex <= data.Length;
            }
            /// <summary>
            /// 反序列化
            /// </summary>
            /// <param name="parentDeSerializer">对象反序列化器</param>
            public unsafe void DeSerialize(fastCSharp.setup.cSharp.serialize.deSerializer parentDeSerializer)
            {
                deSerializer deSerializer = new deSerializer(parentDeSerializer);
                deSerializer.DeSerialize(this);
                
                parentDeSerializer.SetRead(deSerializer);
            }

            /// <summary>
            /// 成员位图
            /// </summary>
            public struct memberMap : fastCSharp.setup.cSharp.IMemberMap<memberMap>
            {
                /// <summary>
                /// 成员位图
                /// </summary>
                private uint map;
                /// <summary>
                /// 成员位图
                /// </summary>
                /// <param name="members">成员集合</param>
                public memberMap(params member[] members)
                {
                    map = 0;
                    foreach (member member in members) SetMember((int)member);
                }
                /// <summary>
                /// 成员位图
                /// </summary>
                /// <returns>成员位图</returns>
                public memberMap Copy()
                {
                    return new memberMap { map = map };
                }
                /// <summary>
                /// 是否默认全部成员有效
                /// </summary>
                public bool IsDefault
                {
                    get { return map == 0; }
                }
                /// <summary>
                /// 序列化字节长度
                /// </summary>
                public int SerializeSize
                {
                    get
                    {
                        return sizeof(uint);
                    }
                }
                /// <summary>
                /// 设置成员索引,忽略默认成员
                /// </summary>
                /// <param name="memberIndex">成员索引</param>
                public void SetMember(int memberIndex)
                {
                    map |= 1U << (int)memberIndex;
                }
                /// <summary>
                /// 清除成员索引,忽略默认成员
                /// </summary>
                /// <param name="memberIndex">成员索引</param>
                public void ClearMember(int memberIndex)
                {
                    map &= uint.MaxValue ^ (1U << (int)memberIndex);
                }
                /// <summary>
                /// 设置成员,忽略默认成员
                /// </summary>
                /// <param name="member">成员</param>
                public void SetMember(member member)
                {
                    SetMember((int)member);
                }
                /// <summary>
                /// 清除成员,忽略默认成员
                /// </summary>
                /// <param name="memberIndex">成员</param>
                public void ClearMember(member member)
                {
                    ClearMember((int)member);
                }
                /// <summary>
                /// 成员交集运算,忽略默认成员
                /// </summary>
                /// <param name="memberMap">成员位图</param>
                public void And(memberMap memberMap)
                {
                    map &= memberMap.map;
                }
                /// <summary>
                /// 成员异或运算,忽略默认成员
                /// </summary>
                /// <param name="memberMap">成员位图</param>
                public void Xor(memberMap memberMap)
                {
                    map ^= memberMap.map;
                }
                /// <summary>
                /// 成员并集运算,忽略默认成员
                /// </summary>
                /// <param name="memberMap">成员位图</param>
                public void Or(memberMap memberMap)
                {
                    map |= memberMap.map;
                }
                /// <summary>
                /// 判断成员索引是否有效
                /// </summary>
                /// <param name="memberIndex">成员索引</param>
                /// <returns>成员索引是否有效</returns>
                public bool IsMember(int memberIndex)
                {
                    return map == 0 || (map & (1 << memberIndex)) != 0;
                }
                /// <summary>
                /// 判断成员是否有效
                /// </summary>
                /// <param name="member">成员</param>
                /// <returns>成员是否有效</returns>
                public bool IsMember(member member)
                {
                    return IsMember((int)member);
                }
                /// <summary>
                /// 序列化
                /// </summary>
                /// <param name="stream">数据流</param>
                public void Serialize(memoryStream stream)
                {
                    stream.Write(map);
                }
                /// <summary>
                /// 序列化
                /// </summary>
                /// <param name="stream">数据流</param>
                public void Serialize(System.IO.Stream stream)
                {
                    stream.Write(BitConverter.GetBytes(map), 0, sizeof(uint));
                }
                /// <summary>
                /// 反序列化
                /// </summary>
                /// <param name="data">数据</param>
                /// <returns>结束位置</returns>
                public unsafe byte* DeSerialize(byte* data)
                {
                    map = *(uint*)data;
                    return data + sizeof(uint);
                }
                /// <summary>
                /// 成员获取器
                /// </summary>
                /// <returns>成员获取器</returns>
                public fastCSharp.setup.cSharp.IMemberInfo MemberInfo
                {
                    get { return new memberInfo(); }
                }
            }


            /// <summary>
            /// 成员
            /// </summary>
            public enum member
            {
                [fastCSharp.setup.cSharp.member(Type = typeof(fastCSharp.setup.tcpRegister.services[]))]
                _Return_ = 0,
                [fastCSharp.setup.cSharp.member(Type = typeof(int))]
                version = 1,
            }
            /// <summary>
            /// 成员信息获取器
            /// </summary>
            private struct memberInfo : fastCSharp.setup.cSharp.IMemberInfo
            {
                /// <summary>
                /// 获取成员名称
                /// </summary>
                /// <param name="memberIndex">成员索引</param>
                /// <returns>成员名称</returns>
                public string GetName(int memberIndex)
                {
                    return ((member)memberIndex).ToString();
                }
                /// <summary>
                /// 获取成员类型
                /// </summary>
                /// <param name="memberIndex">成员索引</param>
                /// <returns>成员类型</returns>
                public Type GetType(int memberIndex)
                {
                    return fastCSharp.Enum<member, fastCSharp.setup.cSharp.member>.Array(memberIndex).Type;
                }
                /// <summary>
                /// 所有成员数量
                /// </summary>
                public int MemberCount
                {
                    get
                    {
                        return 1 + 1;
                    }
                }
            }
            }
            private void _m1(socket _socket_, int _identity_)
            {
                bool _isError_ = false;
                byte[] _data_ = null;
                try
                {

                    _i1 _inputParameter_ = new _i1();
                    (_inputParameter_).DeSerialize(_socket_.CurrentData);
                    
                    fastCSharp.setup.tcpRegister.services[] _return_ = 
                    fastCSharp.setup.tcpRegister/**/.tcpServer.getServices(_value_, out _inputParameter_.version);
                    _data_ = (new _o1
                    {
                        version = _inputParameter_.version,
                        _Return_ = _return_
                    }).Serialize();
                }
                catch (Exception error)
                {
                    fastCSharp.log.Default.Add(error, null, true);
                    {
                        _isError_ = true;
                        send(_socket_, socket.Close, fastCSharp.net.tcpServer.status.Error, _identity_);
                    }
                }
                if (!_isError_)
                {
                    send(_socket_, receiveCommand, fastCSharp.net.tcpServer.status.Success, _identity_, _data_);
                }
            }
            [fastCSharp.setup.cSharp.serialize(IsIgnore = true, IsObject = true, IsInterface = true)]
            internal class _i2 : fastCSharp.setup.cSharp.serialize.ISerialize
            {
                public fastCSharp.setup.tcpRegister.clientId client;
                public fastCSharp.setup.tcpRegister.service service;
            /// <summary>
            /// 序列化
            /// </summary>
            unsafe class serializer : fastCSharp.setup.cSharp.serialize.dataSerializer
            {
                /// <summary>
                /// 序列化
                /// </summary>
                /// <param name="stream">序列化流</param>
                /// <param name="memberMap">成员位图接口</param>
                public serializer(memoryStream stream, fastCSharp.setup.cSharp.IMemberMap memberMap) : base(stream, memberMap) { }
                /// <summary>
                /// 序列化
                /// </summary>
                /// <param name="parentSerializer">序列化</param>
                /// <param name="memberMap">成员位图接口</param>
                public serializer(fastCSharp.setup.cSharp.serialize.dataSerializer parentSerializer)
                    : base(parentSerializer, default(_i2/**/.memberMap)) { }
                /// <summary>
                /// 对象序列化
                /// </summary>
                /// <param name="value">对象</param>
                /// <param name="isPoint">是否记录历史指针</param>
                public void Serialize(_i2 value, bool isPoint)
                {
                    if (value != null)
                    {
                        if (isPoint) points[value] = dataStream.Length - streamStartIndex;
                        versionMemerMap(0);
                        serialize(value);
                    }
                    else dataStream.Write(fastCSharp.setup.cSharp.serialize.NullValue);
                }
                /// <summary>
                /// 对象序列化
                /// </summary>
                /// <param name="value">对象</param>
                private void serialize(_i2 value)
                {
                    memoryStream.unsafer unsafeStream = dataStream.Unsafer;
                    int length = memberMap.SerializeSize;
                    dataStream.PrepLength(length + 8);
                    fixed (byte* dataFixed = dataStream.Array)
                    {
                        write = dataFixed + dataStream.Length;
                        fixedMap nullMap = new fixedMap(write);
                        fastCSharp.unsafer.memory.Fill(write, (uint)0, length >> 2);
                        write += length;
                        if (memberMap.IsDefault)
                        {
                        }
                        else
                        {
                            if (memberMap.IsMember(0))
                            {
                            }
                            if (memberMap.IsMember(1))
                            {
                            }
                        }
                        unsafeStream.AddLength(((int)(write - dataFixed - dataStream.Length) + 3) & (int.MaxValue - 3));
                    }
                    if (memberMap.IsDefault)
                    {
                        iSerializeNotNull(value.client);
                        iSerializeNotNull(value.service);
                    }
                    else
                    {
                        if (memberMap.IsMember(0))
                        {
                        iSerializeNotNull(value.client);
                        }
                        if (memberMap.IsMember(1))
                        {
                        iSerializeNotNull(value.service);
                        }
                    }
                }
            }
            /// <summary>
            /// 对象序列化
            /// </summary>
            /// <returns>序列化数据</returns>
            public byte[] Serialize()
            {
                using (memoryStream stream = new memoryStream())
                {
                    Serialize(stream, default(_i2/**/.memberMap));
                    return stream.ToArray();
                }
            }
            /// <summary>
            /// 对象序列化
            /// </summary>
            /// <param name="stream">数据流</param>
            public void Serialize(memoryStream stream)
            {
                Serialize(stream, default(_i2/**/.memberMap));
            }
            /// <summary>
            /// 对象序列化
            /// </summary>
            /// <param name="stream">数据流</param>
            /// <param name="memberMap">成员位图接口</param>
            public void Serialize(memoryStream stream, _i2/**/.memberMap memberMap)
            {
                serializer serializer = new serializer(stream, memberMap);
                serializer.Serialize(this, true);
                serializer.Finally();
            }
            /// <summary>
            /// 对象序列化
            /// </summary>
            /// <param name="serializer">对象序列化器</param>
            public void Serialize(fastCSharp.setup.cSharp.serialize.dataSerializer parentSerializer)
            {
                new serializer(parentSerializer).Serialize(this, false);
            }
            /// <summary>
            /// 对象反序列化
            /// </summary>
            unsafe class deSerializer : fastCSharp.setup.cSharp.serialize.deSerializer
            {
                /// <summary>
                /// 成员位图接口
                /// </summary>
                public _i2/**/.memberMap MemberMap;
                /// <summary>
                /// 对象反序列化
                /// </summary>
                /// <param name="data">序列化数据</param>
                public deSerializer(byte[] data) : base(data) { }
                /// <summary>
                /// 对象反序列化
                /// </summary>
                /// <param name="parentDeSerializer">对象反序列化器</param>
                public deSerializer(fastCSharp.setup.cSharp.serialize.deSerializer parentDeSerializer)
                    : base(parentDeSerializer) { }
                /// <summary>
                /// 反序列化
                /// </summary>
                /// <param name="value">反序列化目标对象</param>
                /// <param name="startIndex">数据起始位置</param>
                /// <returns>数据对象</returns>
                public _i2 DeSerialize(_i2 value, int startIndex)
                {
                    fixed (byte* dataFixed = data)
                    {
                        this.dataFixed = dataFixed;
                        dataStart = read = dataFixed + startIndex;
                        dataVersion = *(int*)read;
                        if (dataVersion != (int)fastCSharp.setup.cSharp.serializeVersion.serialize)
                        {
                            fastCSharp.log.Default.Throw("序列化格式版本号不匹配 fastCSharp.setup.cSharp.serializeVersion.serialize[" + ((int)fastCSharp.setup.cSharp.serializeVersion.serialize).toString() + "] != " + dataVersion.toString(), true, false);
                        }
                        dataVersion = *(int*)(read += sizeof(int));
                        if (dataVersion != fastCSharp.setup.cSharp.serialize.NullValue)
                        {
                            versionMemberMap();
                            value = DeSerializeData(value);
                            checkEnd();
                            return value;
                        }
                    }
                    return default(_i2);
                }
                /// <summary>
                /// 版本号+成员位图接口
                /// </summary>
                protected override void versionMemberMap()
                {
                    if (dataVersion != 0)
                    {
                        fastCSharp.log.Default.Throw("序列化版本号错误 0 != " + dataVersion.toString(), true, false);
                    }
                    read = MemberMap.DeSerialize(read += sizeof(int));
                }
                /// <summary>
                /// 反序列化
                /// </summary>
                /// <param name="value">反序列化目标对象</param>
                /// <returns>数据对象</returns>
                public _i2 DeSerialize(_i2 value)
                {
                    dataVersion = *(int*)read;
                    versionMemberMap();
                    return DeSerializeData(value);
                }
                /// <summary>
                /// 反序列化
                /// </summary>
                /// <param name="value">反序列化目标对象</param>
                /// <returns>数据对象</returns>
                public _i2 DeSerializeData(_i2 value)
                {
                    fixedMap nullMap = new fixedMap(read);
                    read += MemberMap.SerializeSize;
                    if (MemberMap.IsDefault)
                    {
                    }
                    else
                    {
                        if (MemberMap.IsMember(0))
                        {
                        }
                        if (MemberMap.IsMember(1))
                        {
                        }
                    }
                    int length = (int)(read - nullMap.Map);
                    if ((length & 3) != 0) read += -length & 3;
                    if (MemberMap.IsDefault)
                    {
                        {
                            value.client = iSerializeNotNull<fastCSharp.setup.tcpRegister.clientId>();
                        }
                        {
                            value.service = iSerializeNotNull<fastCSharp.setup.tcpRegister.service>();
                        }
                    }
                    else
                    {
                        if (MemberMap.IsMember(0))
                        {
                        {
                            value.client = iSerializeNotNull<fastCSharp.setup.tcpRegister.clientId>();
                        }
                        }
                        if (MemberMap.IsMember(1))
                        {
                        {
                            value.service = iSerializeNotNull<fastCSharp.setup.tcpRegister.service>();
                        }
                        }
                    }
                    return value;
                }
            }
            /// <summary>
            /// 反序列化
            /// </summary>
            /// <param name="data">序列化数据</param>
            public bool DeSerialize(byte[] data)
            {
                return DeSerialize(data, 0, out deSerializer.OutEndIndex);
            }
            /// <summary>
            /// 反序列化
            /// </summary>
            /// <param name="data">序列化数据</param>
            /// <param name="startIndex">起始位置</param>
            /// <param name="endIndex">结束位置</param>
            public bool DeSerialize(byte[] data, int startIndex, out int endIndex)
            {
                deSerializer deSerializer = new deSerializer(data);
                _i2 value = deSerializer.DeSerialize(this, startIndex);
                
                endIndex = deSerializer.EndIndex;
                return value != null && endIndex <= data.Length;
            }
            /// <summary>
            /// 反序列化
            /// </summary>
            /// <param name="parentDeSerializer">对象反序列化器</param>
            public unsafe void DeSerialize(fastCSharp.setup.cSharp.serialize.deSerializer parentDeSerializer)
            {
                deSerializer deSerializer = new deSerializer(parentDeSerializer);
                deSerializer.DeSerialize(this);
                
                parentDeSerializer.SetRead(deSerializer);
            }

            /// <summary>
            /// 成员位图
            /// </summary>
            public struct memberMap : fastCSharp.setup.cSharp.IMemberMap<memberMap>
            {
                /// <summary>
                /// 成员位图
                /// </summary>
                private uint map;
                /// <summary>
                /// 成员位图
                /// </summary>
                /// <param name="members">成员集合</param>
                public memberMap(params member[] members)
                {
                    map = 0;
                    foreach (member member in members) SetMember((int)member);
                }
                /// <summary>
                /// 成员位图
                /// </summary>
                /// <returns>成员位图</returns>
                public memberMap Copy()
                {
                    return new memberMap { map = map };
                }
                /// <summary>
                /// 是否默认全部成员有效
                /// </summary>
                public bool IsDefault
                {
                    get { return map == 0; }
                }
                /// <summary>
                /// 序列化字节长度
                /// </summary>
                public int SerializeSize
                {
                    get
                    {
                        return sizeof(uint);
                    }
                }
                /// <summary>
                /// 设置成员索引,忽略默认成员
                /// </summary>
                /// <param name="memberIndex">成员索引</param>
                public void SetMember(int memberIndex)
                {
                    map |= 1U << (int)memberIndex;
                }
                /// <summary>
                /// 清除成员索引,忽略默认成员
                /// </summary>
                /// <param name="memberIndex">成员索引</param>
                public void ClearMember(int memberIndex)
                {
                    map &= uint.MaxValue ^ (1U << (int)memberIndex);
                }
                /// <summary>
                /// 设置成员,忽略默认成员
                /// </summary>
                /// <param name="member">成员</param>
                public void SetMember(member member)
                {
                    SetMember((int)member);
                }
                /// <summary>
                /// 清除成员,忽略默认成员
                /// </summary>
                /// <param name="memberIndex">成员</param>
                public void ClearMember(member member)
                {
                    ClearMember((int)member);
                }
                /// <summary>
                /// 成员交集运算,忽略默认成员
                /// </summary>
                /// <param name="memberMap">成员位图</param>
                public void And(memberMap memberMap)
                {
                    map &= memberMap.map;
                }
                /// <summary>
                /// 成员异或运算,忽略默认成员
                /// </summary>
                /// <param name="memberMap">成员位图</param>
                public void Xor(memberMap memberMap)
                {
                    map ^= memberMap.map;
                }
                /// <summary>
                /// 成员并集运算,忽略默认成员
                /// </summary>
                /// <param name="memberMap">成员位图</param>
                public void Or(memberMap memberMap)
                {
                    map |= memberMap.map;
                }
                /// <summary>
                /// 判断成员索引是否有效
                /// </summary>
                /// <param name="memberIndex">成员索引</param>
                /// <returns>成员索引是否有效</returns>
                public bool IsMember(int memberIndex)
                {
                    return map == 0 || (map & (1 << memberIndex)) != 0;
                }
                /// <summary>
                /// 判断成员是否有效
                /// </summary>
                /// <param name="member">成员</param>
                /// <returns>成员是否有效</returns>
                public bool IsMember(member member)
                {
                    return IsMember((int)member);
                }
                /// <summary>
                /// 序列化
                /// </summary>
                /// <param name="stream">数据流</param>
                public void Serialize(memoryStream stream)
                {
                    stream.Write(map);
                }
                /// <summary>
                /// 序列化
                /// </summary>
                /// <param name="stream">数据流</param>
                public void Serialize(System.IO.Stream stream)
                {
                    stream.Write(BitConverter.GetBytes(map), 0, sizeof(uint));
                }
                /// <summary>
                /// 反序列化
                /// </summary>
                /// <param name="data">数据</param>
                /// <returns>结束位置</returns>
                public unsafe byte* DeSerialize(byte* data)
                {
                    map = *(uint*)data;
                    return data + sizeof(uint);
                }
                /// <summary>
                /// 成员获取器
                /// </summary>
                /// <returns>成员获取器</returns>
                public fastCSharp.setup.cSharp.IMemberInfo MemberInfo
                {
                    get { return new memberInfo(); }
                }
            }


            /// <summary>
            /// 成员
            /// </summary>
            public enum member
            {
                [fastCSharp.setup.cSharp.member(Type = typeof(fastCSharp.setup.tcpRegister.clientId))]
                client = 0,
                [fastCSharp.setup.cSharp.member(Type = typeof(fastCSharp.setup.tcpRegister.service))]
                service = 1,
            }
            /// <summary>
            /// 成员信息获取器
            /// </summary>
            private struct memberInfo : fastCSharp.setup.cSharp.IMemberInfo
            {
                /// <summary>
                /// 获取成员名称
                /// </summary>
                /// <param name="memberIndex">成员索引</param>
                /// <returns>成员名称</returns>
                public string GetName(int memberIndex)
                {
                    return ((member)memberIndex).ToString();
                }
                /// <summary>
                /// 获取成员类型
                /// </summary>
                /// <param name="memberIndex">成员索引</param>
                /// <returns>成员类型</returns>
                public Type GetType(int memberIndex)
                {
                    return fastCSharp.Enum<member, fastCSharp.setup.cSharp.member>.Array(memberIndex).Type;
                }
                /// <summary>
                /// 所有成员数量
                /// </summary>
                public int MemberCount
                {
                    get
                    {
                        return 1 + 1;
                    }
                }
            }
            }
            internal class _o2 : fastCSharp.setup.cSharp.tcpBase.returnParameter<fastCSharp.setup.tcpRegister.registerResult>, fastCSharp.setup.cSharp.serialize.ISerialize
            {
            /// <summary>
            /// 序列化
            /// </summary>
            unsafe class serializer : fastCSharp.setup.cSharp.serialize.dataSerializer
            {
                /// <summary>
                /// 序列化
                /// </summary>
                /// <param name="stream">序列化流</param>
                /// <param name="memberMap">成员位图接口</param>
                public serializer(memoryStream stream, fastCSharp.setup.cSharp.IMemberMap memberMap) : base(stream, memberMap) { }
                /// <summary>
                /// 序列化
                /// </summary>
                /// <param name="parentSerializer">序列化</param>
                /// <param name="memberMap">成员位图接口</param>
                public serializer(fastCSharp.setup.cSharp.serialize.dataSerializer parentSerializer)
                    : base(parentSerializer, default(_o2/**/.memberMap)) { }
                /// <summary>
                /// 对象序列化
                /// </summary>
                /// <param name="value">对象</param>
                /// <param name="isPoint">是否记录历史指针</param>
                public void Serialize(_o2 value, bool isPoint)
                {
                    if (value != null)
                    {
                        if (isPoint) points[value] = dataStream.Length - streamStartIndex;
                        versionMemerMap(0);
                        serialize(value);
                    }
                    else dataStream.Write(fastCSharp.setup.cSharp.serialize.NullValue);
                }
                /// <summary>
                /// 对象序列化
                /// </summary>
                /// <param name="value">对象</param>
                private void serialize(_o2 value)
                {
                    memoryStream.unsafer unsafeStream = dataStream.Unsafer;
                    int length = memberMap.SerializeSize;
                    dataStream.PrepLength(length + 4);
                    fixed (byte* dataFixed = dataStream.Array)
                    {
                        write = dataFixed + dataStream.Length;
                        fixedMap nullMap = new fixedMap(write);
                        fastCSharp.unsafer.memory.Fill(write, (uint)0, length >> 2);
                        write += length;
                        if (memberMap.IsDefault)
                        {
                        }
                        else
                        {
                            if (memberMap.IsMember(0))
                            {
                            }
                        }
                        unsafeStream.AddLength(((int)(write - dataFixed - dataStream.Length) + 3) & (int.MaxValue - 3));
                    }
                    if (memberMap.IsDefault)
                    {
                        iSerializeNotNull(value._Return_);
                    }
                    else
                    {
                        if (memberMap.IsMember(0))
                        {
                        iSerializeNotNull(value._Return_);
                        }
                    }
                }
            }
            /// <summary>
            /// 对象序列化
            /// </summary>
            /// <returns>序列化数据</returns>
            public byte[] Serialize()
            {
                using (memoryStream stream = new memoryStream())
                {
                    Serialize(stream, default(_o2/**/.memberMap));
                    return stream.ToArray();
                }
            }
            /// <summary>
            /// 对象序列化
            /// </summary>
            /// <param name="stream">数据流</param>
            public void Serialize(memoryStream stream)
            {
                Serialize(stream, default(_o2/**/.memberMap));
            }
            /// <summary>
            /// 对象序列化
            /// </summary>
            /// <param name="stream">数据流</param>
            /// <param name="memberMap">成员位图接口</param>
            public void Serialize(memoryStream stream, _o2/**/.memberMap memberMap)
            {
                serializer serializer = new serializer(stream, memberMap);
                serializer.Serialize(this, true);
                serializer.Finally();
            }
            /// <summary>
            /// 对象序列化
            /// </summary>
            /// <param name="serializer">对象序列化器</param>
            public void Serialize(fastCSharp.setup.cSharp.serialize.dataSerializer parentSerializer)
            {
                new serializer(parentSerializer).Serialize(this, false);
            }
            /// <summary>
            /// 对象反序列化
            /// </summary>
            unsafe class deSerializer : fastCSharp.setup.cSharp.serialize.deSerializer
            {
                /// <summary>
                /// 成员位图接口
                /// </summary>
                public _o2/**/.memberMap MemberMap;
                /// <summary>
                /// 对象反序列化
                /// </summary>
                /// <param name="data">序列化数据</param>
                public deSerializer(byte[] data) : base(data) { }
                /// <summary>
                /// 对象反序列化
                /// </summary>
                /// <param name="parentDeSerializer">对象反序列化器</param>
                public deSerializer(fastCSharp.setup.cSharp.serialize.deSerializer parentDeSerializer)
                    : base(parentDeSerializer) { }
                /// <summary>
                /// 反序列化
                /// </summary>
                /// <param name="value">反序列化目标对象</param>
                /// <param name="startIndex">数据起始位置</param>
                /// <returns>数据对象</returns>
                public _o2 DeSerialize(_o2 value, int startIndex)
                {
                    fixed (byte* dataFixed = data)
                    {
                        this.dataFixed = dataFixed;
                        dataStart = read = dataFixed + startIndex;
                        dataVersion = *(int*)read;
                        if (dataVersion != (int)fastCSharp.setup.cSharp.serializeVersion.serialize)
                        {
                            fastCSharp.log.Default.Throw("序列化格式版本号不匹配 fastCSharp.setup.cSharp.serializeVersion.serialize[" + ((int)fastCSharp.setup.cSharp.serializeVersion.serialize).toString() + "] != " + dataVersion.toString(), true, false);
                        }
                        dataVersion = *(int*)(read += sizeof(int));
                        if (dataVersion != fastCSharp.setup.cSharp.serialize.NullValue)
                        {
                            versionMemberMap();
                            value = DeSerializeData(value);
                            checkEnd();
                            return value;
                        }
                    }
                    return default(_o2);
                }
                /// <summary>
                /// 版本号+成员位图接口
                /// </summary>
                protected override void versionMemberMap()
                {
                    if (dataVersion != 0)
                    {
                        fastCSharp.log.Default.Throw("序列化版本号错误 0 != " + dataVersion.toString(), true, false);
                    }
                    read = MemberMap.DeSerialize(read += sizeof(int));
                }
                /// <summary>
                /// 反序列化
                /// </summary>
                /// <param name="value">反序列化目标对象</param>
                /// <returns>数据对象</returns>
                public _o2 DeSerialize(_o2 value)
                {
                    dataVersion = *(int*)read;
                    versionMemberMap();
                    return DeSerializeData(value);
                }
                /// <summary>
                /// 反序列化
                /// </summary>
                /// <param name="value">反序列化目标对象</param>
                /// <returns>数据对象</returns>
                public _o2 DeSerializeData(_o2 value)
                {
                    fixedMap nullMap = new fixedMap(read);
                    read += MemberMap.SerializeSize;
                    if (MemberMap.IsDefault)
                    {
                    }
                    else
                    {
                        if (MemberMap.IsMember(0))
                        {
                        }
                    }
                    int length = (int)(read - nullMap.Map);
                    if ((length & 3) != 0) read += -length & 3;
                    if (MemberMap.IsDefault)
                    {
                        {
                            value._Return_ = iSerializeNotNull<fastCSharp.setup.tcpRegister.registerResult>();
                        }
                    }
                    else
                    {
                        if (MemberMap.IsMember(0))
                        {
                        {
                            value._Return_ = iSerializeNotNull<fastCSharp.setup.tcpRegister.registerResult>();
                        }
                        }
                    }
                    return value;
                }
            }
            /// <summary>
            /// 反序列化
            /// </summary>
            /// <param name="data">序列化数据</param>
            public bool DeSerialize(byte[] data)
            {
                return DeSerialize(data, 0, out deSerializer.OutEndIndex);
            }
            /// <summary>
            /// 反序列化
            /// </summary>
            /// <param name="data">序列化数据</param>
            /// <param name="startIndex">起始位置</param>
            /// <param name="endIndex">结束位置</param>
            public bool DeSerialize(byte[] data, int startIndex, out int endIndex)
            {
                deSerializer deSerializer = new deSerializer(data);
                _o2 value = deSerializer.DeSerialize(this, startIndex);
                
                endIndex = deSerializer.EndIndex;
                return value != null && endIndex <= data.Length;
            }
            /// <summary>
            /// 反序列化
            /// </summary>
            /// <param name="parentDeSerializer">对象反序列化器</param>
            public unsafe void DeSerialize(fastCSharp.setup.cSharp.serialize.deSerializer parentDeSerializer)
            {
                deSerializer deSerializer = new deSerializer(parentDeSerializer);
                deSerializer.DeSerialize(this);
                
                parentDeSerializer.SetRead(deSerializer);
            }

            /// <summary>
            /// 成员位图
            /// </summary>
            public struct memberMap : fastCSharp.setup.cSharp.IMemberMap<memberMap>
            {
                /// <summary>
                /// 成员位图
                /// </summary>
                private uint map;
                /// <summary>
                /// 成员位图
                /// </summary>
                /// <param name="members">成员集合</param>
                public memberMap(params member[] members)
                {
                    map = 0;
                    foreach (member member in members) SetMember((int)member);
                }
                /// <summary>
                /// 成员位图
                /// </summary>
                /// <returns>成员位图</returns>
                public memberMap Copy()
                {
                    return new memberMap { map = map };
                }
                /// <summary>
                /// 是否默认全部成员有效
                /// </summary>
                public bool IsDefault
                {
                    get { return map == 0; }
                }
                /// <summary>
                /// 序列化字节长度
                /// </summary>
                public int SerializeSize
                {
                    get
                    {
                        return sizeof(uint);
                    }
                }
                /// <summary>
                /// 设置成员索引,忽略默认成员
                /// </summary>
                /// <param name="memberIndex">成员索引</param>
                public void SetMember(int memberIndex)
                {
                    map |= 1U << (int)memberIndex;
                }
                /// <summary>
                /// 清除成员索引,忽略默认成员
                /// </summary>
                /// <param name="memberIndex">成员索引</param>
                public void ClearMember(int memberIndex)
                {
                    map &= uint.MaxValue ^ (1U << (int)memberIndex);
                }
                /// <summary>
                /// 设置成员,忽略默认成员
                /// </summary>
                /// <param name="member">成员</param>
                public void SetMember(member member)
                {
                    SetMember((int)member);
                }
                /// <summary>
                /// 清除成员,忽略默认成员
                /// </summary>
                /// <param name="memberIndex">成员</param>
                public void ClearMember(member member)
                {
                    ClearMember((int)member);
                }
                /// <summary>
                /// 成员交集运算,忽略默认成员
                /// </summary>
                /// <param name="memberMap">成员位图</param>
                public void And(memberMap memberMap)
                {
                    map &= memberMap.map;
                }
                /// <summary>
                /// 成员异或运算,忽略默认成员
                /// </summary>
                /// <param name="memberMap">成员位图</param>
                public void Xor(memberMap memberMap)
                {
                    map ^= memberMap.map;
                }
                /// <summary>
                /// 成员并集运算,忽略默认成员
                /// </summary>
                /// <param name="memberMap">成员位图</param>
                public void Or(memberMap memberMap)
                {
                    map |= memberMap.map;
                }
                /// <summary>
                /// 判断成员索引是否有效
                /// </summary>
                /// <param name="memberIndex">成员索引</param>
                /// <returns>成员索引是否有效</returns>
                public bool IsMember(int memberIndex)
                {
                    return map == 0 || (map & (1 << memberIndex)) != 0;
                }
                /// <summary>
                /// 判断成员是否有效
                /// </summary>
                /// <param name="member">成员</param>
                /// <returns>成员是否有效</returns>
                public bool IsMember(member member)
                {
                    return IsMember((int)member);
                }
                /// <summary>
                /// 序列化
                /// </summary>
                /// <param name="stream">数据流</param>
                public void Serialize(memoryStream stream)
                {
                    stream.Write(map);
                }
                /// <summary>
                /// 序列化
                /// </summary>
                /// <param name="stream">数据流</param>
                public void Serialize(System.IO.Stream stream)
                {
                    stream.Write(BitConverter.GetBytes(map), 0, sizeof(uint));
                }
                /// <summary>
                /// 反序列化
                /// </summary>
                /// <param name="data">数据</param>
                /// <returns>结束位置</returns>
                public unsafe byte* DeSerialize(byte* data)
                {
                    map = *(uint*)data;
                    return data + sizeof(uint);
                }
                /// <summary>
                /// 成员获取器
                /// </summary>
                /// <returns>成员获取器</returns>
                public fastCSharp.setup.cSharp.IMemberInfo MemberInfo
                {
                    get { return new memberInfo(); }
                }
            }


            /// <summary>
            /// 成员
            /// </summary>
            public enum member
            {
                [fastCSharp.setup.cSharp.member(Type = typeof(fastCSharp.setup.tcpRegister.registerResult))]
                _Return_ = 0,
            }
            /// <summary>
            /// 成员信息获取器
            /// </summary>
            private struct memberInfo : fastCSharp.setup.cSharp.IMemberInfo
            {
                /// <summary>
                /// 获取成员名称
                /// </summary>
                /// <param name="memberIndex">成员索引</param>
                /// <returns>成员名称</returns>
                public string GetName(int memberIndex)
                {
                    return ((member)memberIndex).ToString();
                }
                /// <summary>
                /// 获取成员类型
                /// </summary>
                /// <param name="memberIndex">成员索引</param>
                /// <returns>成员类型</returns>
                public Type GetType(int memberIndex)
                {
                    return fastCSharp.Enum<member, fastCSharp.setup.cSharp.member>.Array(memberIndex).Type;
                }
                /// <summary>
                /// 所有成员数量
                /// </summary>
                public int MemberCount
                {
                    get
                    {
                        return 0 + 1;
                    }
                }
            }
            }
            private void _m2(socket _socket_, int _identity_)
            {
                bool _isError_ = false;
                byte[] _data_ = null;
                try
                {

                    _i2 _inputParameter_ = new _i2();
                    (_inputParameter_).DeSerialize(_socket_.CurrentData);
                    
                    fastCSharp.setup.tcpRegister.registerResult _return_ = 
                    fastCSharp.setup.tcpRegister/**/.tcpServer.register(_value_, _inputParameter_.client, _inputParameter_.service);
                    _data_ = (new _o2
                    {
                        _Return_ = _return_
                    }).Serialize();
                }
                catch (Exception error)
                {
                    fastCSharp.log.Default.Add(error, null, true);
                    {
                        _isError_ = true;
                        send(_socket_, socket.Close, fastCSharp.net.tcpServer.status.Error, _identity_);
                    }
                }
                if (!_isError_)
                {
                    send(_socket_, receiveCommand, fastCSharp.net.tcpServer.status.Success, _identity_, _data_);
                }
            }
            [fastCSharp.setup.cSharp.serialize(IsIgnore = true, IsObject = true, IsInterface = true)]
            internal class _i3 : fastCSharp.setup.cSharp.serialize.ISerialize
            {
                public fastCSharp.setup.tcpRegister.clientId client;
            /// <summary>
            /// 序列化
            /// </summary>
            unsafe class serializer : fastCSharp.setup.cSharp.serialize.dataSerializer
            {
                /// <summary>
                /// 序列化
                /// </summary>
                /// <param name="stream">序列化流</param>
                /// <param name="memberMap">成员位图接口</param>
                public serializer(memoryStream stream, fastCSharp.setup.cSharp.IMemberMap memberMap) : base(stream, memberMap) { }
                /// <summary>
                /// 序列化
                /// </summary>
                /// <param name="parentSerializer">序列化</param>
                /// <param name="memberMap">成员位图接口</param>
                public serializer(fastCSharp.setup.cSharp.serialize.dataSerializer parentSerializer)
                    : base(parentSerializer, default(_i3/**/.memberMap)) { }
                /// <summary>
                /// 对象序列化
                /// </summary>
                /// <param name="value">对象</param>
                /// <param name="isPoint">是否记录历史指针</param>
                public void Serialize(_i3 value, bool isPoint)
                {
                    if (value != null)
                    {
                        if (isPoint) points[value] = dataStream.Length - streamStartIndex;
                        versionMemerMap(0);
                        serialize(value);
                    }
                    else dataStream.Write(fastCSharp.setup.cSharp.serialize.NullValue);
                }
                /// <summary>
                /// 对象序列化
                /// </summary>
                /// <param name="value">对象</param>
                private void serialize(_i3 value)
                {
                    memoryStream.unsafer unsafeStream = dataStream.Unsafer;
                    int length = memberMap.SerializeSize;
                    dataStream.PrepLength(length + 4);
                    fixed (byte* dataFixed = dataStream.Array)
                    {
                        write = dataFixed + dataStream.Length;
                        fixedMap nullMap = new fixedMap(write);
                        fastCSharp.unsafer.memory.Fill(write, (uint)0, length >> 2);
                        write += length;
                        if (memberMap.IsDefault)
                        {
                        }
                        else
                        {
                            if (memberMap.IsMember(0))
                            {
                            }
                        }
                        unsafeStream.AddLength(((int)(write - dataFixed - dataStream.Length) + 3) & (int.MaxValue - 3));
                    }
                    if (memberMap.IsDefault)
                    {
                        iSerializeNotNull(value.client);
                    }
                    else
                    {
                        if (memberMap.IsMember(0))
                        {
                        iSerializeNotNull(value.client);
                        }
                    }
                }
            }
            /// <summary>
            /// 对象序列化
            /// </summary>
            /// <returns>序列化数据</returns>
            public byte[] Serialize()
            {
                using (memoryStream stream = new memoryStream())
                {
                    Serialize(stream, default(_i3/**/.memberMap));
                    return stream.ToArray();
                }
            }
            /// <summary>
            /// 对象序列化
            /// </summary>
            /// <param name="stream">数据流</param>
            public void Serialize(memoryStream stream)
            {
                Serialize(stream, default(_i3/**/.memberMap));
            }
            /// <summary>
            /// 对象序列化
            /// </summary>
            /// <param name="stream">数据流</param>
            /// <param name="memberMap">成员位图接口</param>
            public void Serialize(memoryStream stream, _i3/**/.memberMap memberMap)
            {
                serializer serializer = new serializer(stream, memberMap);
                serializer.Serialize(this, true);
                serializer.Finally();
            }
            /// <summary>
            /// 对象序列化
            /// </summary>
            /// <param name="serializer">对象序列化器</param>
            public void Serialize(fastCSharp.setup.cSharp.serialize.dataSerializer parentSerializer)
            {
                new serializer(parentSerializer).Serialize(this, false);
            }
            /// <summary>
            /// 对象反序列化
            /// </summary>
            unsafe class deSerializer : fastCSharp.setup.cSharp.serialize.deSerializer
            {
                /// <summary>
                /// 成员位图接口
                /// </summary>
                public _i3/**/.memberMap MemberMap;
                /// <summary>
                /// 对象反序列化
                /// </summary>
                /// <param name="data">序列化数据</param>
                public deSerializer(byte[] data) : base(data) { }
                /// <summary>
                /// 对象反序列化
                /// </summary>
                /// <param name="parentDeSerializer">对象反序列化器</param>
                public deSerializer(fastCSharp.setup.cSharp.serialize.deSerializer parentDeSerializer)
                    : base(parentDeSerializer) { }
                /// <summary>
                /// 反序列化
                /// </summary>
                /// <param name="value">反序列化目标对象</param>
                /// <param name="startIndex">数据起始位置</param>
                /// <returns>数据对象</returns>
                public _i3 DeSerialize(_i3 value, int startIndex)
                {
                    fixed (byte* dataFixed = data)
                    {
                        this.dataFixed = dataFixed;
                        dataStart = read = dataFixed + startIndex;
                        dataVersion = *(int*)read;
                        if (dataVersion != (int)fastCSharp.setup.cSharp.serializeVersion.serialize)
                        {
                            fastCSharp.log.Default.Throw("序列化格式版本号不匹配 fastCSharp.setup.cSharp.serializeVersion.serialize[" + ((int)fastCSharp.setup.cSharp.serializeVersion.serialize).toString() + "] != " + dataVersion.toString(), true, false);
                        }
                        dataVersion = *(int*)(read += sizeof(int));
                        if (dataVersion != fastCSharp.setup.cSharp.serialize.NullValue)
                        {
                            versionMemberMap();
                            value = DeSerializeData(value);
                            checkEnd();
                            return value;
                        }
                    }
                    return default(_i3);
                }
                /// <summary>
                /// 版本号+成员位图接口
                /// </summary>
                protected override void versionMemberMap()
                {
                    if (dataVersion != 0)
                    {
                        fastCSharp.log.Default.Throw("序列化版本号错误 0 != " + dataVersion.toString(), true, false);
                    }
                    read = MemberMap.DeSerialize(read += sizeof(int));
                }
                /// <summary>
                /// 反序列化
                /// </summary>
                /// <param name="value">反序列化目标对象</param>
                /// <returns>数据对象</returns>
                public _i3 DeSerialize(_i3 value)
                {
                    dataVersion = *(int*)read;
                    versionMemberMap();
                    return DeSerializeData(value);
                }
                /// <summary>
                /// 反序列化
                /// </summary>
                /// <param name="value">反序列化目标对象</param>
                /// <returns>数据对象</returns>
                public _i3 DeSerializeData(_i3 value)
                {
                    fixedMap nullMap = new fixedMap(read);
                    read += MemberMap.SerializeSize;
                    if (MemberMap.IsDefault)
                    {
                    }
                    else
                    {
                        if (MemberMap.IsMember(0))
                        {
                        }
                    }
                    int length = (int)(read - nullMap.Map);
                    if ((length & 3) != 0) read += -length & 3;
                    if (MemberMap.IsDefault)
                    {
                        {
                            value.client = iSerializeNotNull<fastCSharp.setup.tcpRegister.clientId>();
                        }
                    }
                    else
                    {
                        if (MemberMap.IsMember(0))
                        {
                        {
                            value.client = iSerializeNotNull<fastCSharp.setup.tcpRegister.clientId>();
                        }
                        }
                    }
                    return value;
                }
            }
            /// <summary>
            /// 反序列化
            /// </summary>
            /// <param name="data">序列化数据</param>
            public bool DeSerialize(byte[] data)
            {
                return DeSerialize(data, 0, out deSerializer.OutEndIndex);
            }
            /// <summary>
            /// 反序列化
            /// </summary>
            /// <param name="data">序列化数据</param>
            /// <param name="startIndex">起始位置</param>
            /// <param name="endIndex">结束位置</param>
            public bool DeSerialize(byte[] data, int startIndex, out int endIndex)
            {
                deSerializer deSerializer = new deSerializer(data);
                _i3 value = deSerializer.DeSerialize(this, startIndex);
                
                endIndex = deSerializer.EndIndex;
                return value != null && endIndex <= data.Length;
            }
            /// <summary>
            /// 反序列化
            /// </summary>
            /// <param name="parentDeSerializer">对象反序列化器</param>
            public unsafe void DeSerialize(fastCSharp.setup.cSharp.serialize.deSerializer parentDeSerializer)
            {
                deSerializer deSerializer = new deSerializer(parentDeSerializer);
                deSerializer.DeSerialize(this);
                
                parentDeSerializer.SetRead(deSerializer);
            }

            /// <summary>
            /// 成员位图
            /// </summary>
            public struct memberMap : fastCSharp.setup.cSharp.IMemberMap<memberMap>
            {
                /// <summary>
                /// 成员位图
                /// </summary>
                private uint map;
                /// <summary>
                /// 成员位图
                /// </summary>
                /// <param name="members">成员集合</param>
                public memberMap(params member[] members)
                {
                    map = 0;
                    foreach (member member in members) SetMember((int)member);
                }
                /// <summary>
                /// 成员位图
                /// </summary>
                /// <returns>成员位图</returns>
                public memberMap Copy()
                {
                    return new memberMap { map = map };
                }
                /// <summary>
                /// 是否默认全部成员有效
                /// </summary>
                public bool IsDefault
                {
                    get { return map == 0; }
                }
                /// <summary>
                /// 序列化字节长度
                /// </summary>
                public int SerializeSize
                {
                    get
                    {
                        return sizeof(uint);
                    }
                }
                /// <summary>
                /// 设置成员索引,忽略默认成员
                /// </summary>
                /// <param name="memberIndex">成员索引</param>
                public void SetMember(int memberIndex)
                {
                    map |= 1U << (int)memberIndex;
                }
                /// <summary>
                /// 清除成员索引,忽略默认成员
                /// </summary>
                /// <param name="memberIndex">成员索引</param>
                public void ClearMember(int memberIndex)
                {
                    map &= uint.MaxValue ^ (1U << (int)memberIndex);
                }
                /// <summary>
                /// 设置成员,忽略默认成员
                /// </summary>
                /// <param name="member">成员</param>
                public void SetMember(member member)
                {
                    SetMember((int)member);
                }
                /// <summary>
                /// 清除成员,忽略默认成员
                /// </summary>
                /// <param name="memberIndex">成员</param>
                public void ClearMember(member member)
                {
                    ClearMember((int)member);
                }
                /// <summary>
                /// 成员交集运算,忽略默认成员
                /// </summary>
                /// <param name="memberMap">成员位图</param>
                public void And(memberMap memberMap)
                {
                    map &= memberMap.map;
                }
                /// <summary>
                /// 成员异或运算,忽略默认成员
                /// </summary>
                /// <param name="memberMap">成员位图</param>
                public void Xor(memberMap memberMap)
                {
                    map ^= memberMap.map;
                }
                /// <summary>
                /// 成员并集运算,忽略默认成员
                /// </summary>
                /// <param name="memberMap">成员位图</param>
                public void Or(memberMap memberMap)
                {
                    map |= memberMap.map;
                }
                /// <summary>
                /// 判断成员索引是否有效
                /// </summary>
                /// <param name="memberIndex">成员索引</param>
                /// <returns>成员索引是否有效</returns>
                public bool IsMember(int memberIndex)
                {
                    return map == 0 || (map & (1 << memberIndex)) != 0;
                }
                /// <summary>
                /// 判断成员是否有效
                /// </summary>
                /// <param name="member">成员</param>
                /// <returns>成员是否有效</returns>
                public bool IsMember(member member)
                {
                    return IsMember((int)member);
                }
                /// <summary>
                /// 序列化
                /// </summary>
                /// <param name="stream">数据流</param>
                public void Serialize(memoryStream stream)
                {
                    stream.Write(map);
                }
                /// <summary>
                /// 序列化
                /// </summary>
                /// <param name="stream">数据流</param>
                public void Serialize(System.IO.Stream stream)
                {
                    stream.Write(BitConverter.GetBytes(map), 0, sizeof(uint));
                }
                /// <summary>
                /// 反序列化
                /// </summary>
                /// <param name="data">数据</param>
                /// <returns>结束位置</returns>
                public unsafe byte* DeSerialize(byte* data)
                {
                    map = *(uint*)data;
                    return data + sizeof(uint);
                }
                /// <summary>
                /// 成员获取器
                /// </summary>
                /// <returns>成员获取器</returns>
                public fastCSharp.setup.cSharp.IMemberInfo MemberInfo
                {
                    get { return new memberInfo(); }
                }
            }


            /// <summary>
            /// 成员
            /// </summary>
            public enum member
            {
                [fastCSharp.setup.cSharp.member(Type = typeof(fastCSharp.setup.tcpRegister.clientId))]
                client = 0,
            }
            /// <summary>
            /// 成员信息获取器
            /// </summary>
            private struct memberInfo : fastCSharp.setup.cSharp.IMemberInfo
            {
                /// <summary>
                /// 获取成员名称
                /// </summary>
                /// <param name="memberIndex">成员索引</param>
                /// <returns>成员名称</returns>
                public string GetName(int memberIndex)
                {
                    return ((member)memberIndex).ToString();
                }
                /// <summary>
                /// 获取成员类型
                /// </summary>
                /// <param name="memberIndex">成员索引</param>
                /// <returns>成员类型</returns>
                public Type GetType(int memberIndex)
                {
                    return fastCSharp.Enum<member, fastCSharp.setup.cSharp.member>.Array(memberIndex).Type;
                }
                /// <summary>
                /// 所有成员数量
                /// </summary>
                public int MemberCount
                {
                    get
                    {
                        return 0 + 1;
                    }
                }
            }
            }
            internal class _o3 : fastCSharp.setup.cSharp.tcpBase.returnParameter<fastCSharp.setup.tcpRegister.pollResult>, fastCSharp.setup.cSharp.serialize.ISerialize
            {
            /// <summary>
            /// 序列化
            /// </summary>
            unsafe class serializer : fastCSharp.setup.cSharp.serialize.dataSerializer
            {
                /// <summary>
                /// 序列化
                /// </summary>
                /// <param name="stream">序列化流</param>
                /// <param name="memberMap">成员位图接口</param>
                public serializer(memoryStream stream, fastCSharp.setup.cSharp.IMemberMap memberMap) : base(stream, memberMap) { }
                /// <summary>
                /// 序列化
                /// </summary>
                /// <param name="parentSerializer">序列化</param>
                /// <param name="memberMap">成员位图接口</param>
                public serializer(fastCSharp.setup.cSharp.serialize.dataSerializer parentSerializer)
                    : base(parentSerializer, default(_o3/**/.memberMap)) { }
                /// <summary>
                /// 对象序列化
                /// </summary>
                /// <param name="value">对象</param>
                /// <param name="isPoint">是否记录历史指针</param>
                public void Serialize(_o3 value, bool isPoint)
                {
                    if (value != null)
                    {
                        if (isPoint) points[value] = dataStream.Length - streamStartIndex;
                        versionMemerMap(0);
                        serialize(value);
                    }
                    else dataStream.Write(fastCSharp.setup.cSharp.serialize.NullValue);
                }
                /// <summary>
                /// 对象序列化
                /// </summary>
                /// <param name="value">对象</param>
                private void serialize(_o3 value)
                {
                    memoryStream.unsafer unsafeStream = dataStream.Unsafer;
                    int length = memberMap.SerializeSize;
                    dataStream.PrepLength(length + 4);
                    fixed (byte* dataFixed = dataStream.Array)
                    {
                        write = dataFixed + dataStream.Length;
                        fixedMap nullMap = new fixedMap(write);
                        fastCSharp.unsafer.memory.Fill(write, (uint)0, length >> 2);
                        write += length;
                        if (memberMap.IsDefault)
                        {
                            if (value._Return_ == null) nullMap.Set(0);
                        }
                        else
                        {
                            if (memberMap.IsMember(0))
                            {
                            if (value._Return_ == null) nullMap.Set(0);
                            }
                        }
                        unsafeStream.AddLength(((int)(write - dataFixed - dataStream.Length) + 3) & (int.MaxValue - 3));
                    }
                    if (memberMap.IsDefault)
                    {
                        iSerialize(value._Return_);
                    }
                    else
                    {
                        if (memberMap.IsMember(0))
                        {
                        iSerialize(value._Return_);
                        }
                    }
                }
            }
            /// <summary>
            /// 对象序列化
            /// </summary>
            /// <returns>序列化数据</returns>
            public byte[] Serialize()
            {
                using (memoryStream stream = new memoryStream())
                {
                    Serialize(stream, default(_o3/**/.memberMap));
                    return stream.ToArray();
                }
            }
            /// <summary>
            /// 对象序列化
            /// </summary>
            /// <param name="stream">数据流</param>
            public void Serialize(memoryStream stream)
            {
                Serialize(stream, default(_o3/**/.memberMap));
            }
            /// <summary>
            /// 对象序列化
            /// </summary>
            /// <param name="stream">数据流</param>
            /// <param name="memberMap">成员位图接口</param>
            public void Serialize(memoryStream stream, _o3/**/.memberMap memberMap)
            {
                serializer serializer = new serializer(stream, memberMap);
                serializer.Serialize(this, true);
                serializer.Finally();
            }
            /// <summary>
            /// 对象序列化
            /// </summary>
            /// <param name="serializer">对象序列化器</param>
            public void Serialize(fastCSharp.setup.cSharp.serialize.dataSerializer parentSerializer)
            {
                new serializer(parentSerializer).Serialize(this, false);
            }
            /// <summary>
            /// 对象反序列化
            /// </summary>
            unsafe class deSerializer : fastCSharp.setup.cSharp.serialize.deSerializer
            {
                /// <summary>
                /// 成员位图接口
                /// </summary>
                public _o3/**/.memberMap MemberMap;
                /// <summary>
                /// 对象反序列化
                /// </summary>
                /// <param name="data">序列化数据</param>
                public deSerializer(byte[] data) : base(data) { }
                /// <summary>
                /// 对象反序列化
                /// </summary>
                /// <param name="parentDeSerializer">对象反序列化器</param>
                public deSerializer(fastCSharp.setup.cSharp.serialize.deSerializer parentDeSerializer)
                    : base(parentDeSerializer) { }
                /// <summary>
                /// 反序列化
                /// </summary>
                /// <param name="value">反序列化目标对象</param>
                /// <param name="startIndex">数据起始位置</param>
                /// <returns>数据对象</returns>
                public _o3 DeSerialize(_o3 value, int startIndex)
                {
                    fixed (byte* dataFixed = data)
                    {
                        this.dataFixed = dataFixed;
                        dataStart = read = dataFixed + startIndex;
                        dataVersion = *(int*)read;
                        if (dataVersion != (int)fastCSharp.setup.cSharp.serializeVersion.serialize)
                        {
                            fastCSharp.log.Default.Throw("序列化格式版本号不匹配 fastCSharp.setup.cSharp.serializeVersion.serialize[" + ((int)fastCSharp.setup.cSharp.serializeVersion.serialize).toString() + "] != " + dataVersion.toString(), true, false);
                        }
                        dataVersion = *(int*)(read += sizeof(int));
                        if (dataVersion != fastCSharp.setup.cSharp.serialize.NullValue)
                        {
                            versionMemberMap();
                            value = DeSerializeData(value);
                            checkEnd();
                            return value;
                        }
                    }
                    return default(_o3);
                }
                /// <summary>
                /// 版本号+成员位图接口
                /// </summary>
                protected override void versionMemberMap()
                {
                    if (dataVersion != 0)
                    {
                        fastCSharp.log.Default.Throw("序列化版本号错误 0 != " + dataVersion.toString(), true, false);
                    }
                    read = MemberMap.DeSerialize(read += sizeof(int));
                }
                /// <summary>
                /// 反序列化
                /// </summary>
                /// <param name="value">反序列化目标对象</param>
                /// <returns>数据对象</returns>
                public _o3 DeSerialize(_o3 value)
                {
                    dataVersion = *(int*)read;
                    versionMemberMap();
                    return DeSerializeData(value);
                }
                /// <summary>
                /// 反序列化
                /// </summary>
                /// <param name="value">反序列化目标对象</param>
                /// <returns>数据对象</returns>
                public _o3 DeSerializeData(_o3 value)
                {
                    fixedMap nullMap = new fixedMap(read);
                    read += MemberMap.SerializeSize;
                    if (MemberMap.IsDefault)
                    {
                        if (nullMap.Get(0)) value._Return_ = default(fastCSharp.setup.tcpRegister.pollResult);
                    }
                    else
                    {
                        if (MemberMap.IsMember(0))
                        {
                        if (nullMap.Get(0)) value._Return_ = default(fastCSharp.setup.tcpRegister.pollResult);
                        }
                    }
                    int length = (int)(read - nullMap.Map);
                    if ((length & 3) != 0) read += -length & 3;
                    if (MemberMap.IsDefault)
                    {
                        if (!nullMap.Get(0))
                        {
                            value._Return_ = iSerialize(() => new fastCSharp.setup.tcpRegister.pollResult());
                        }
                    }
                    else
                    {
                        if (MemberMap.IsMember(0))
                        {
                        if (!nullMap.Get(0))
                        {
                            value._Return_ = iSerialize(() => new fastCSharp.setup.tcpRegister.pollResult());
                        }
                        }
                    }
                    return value;
                }
            }
            /// <summary>
            /// 反序列化
            /// </summary>
            /// <param name="data">序列化数据</param>
            public bool DeSerialize(byte[] data)
            {
                return DeSerialize(data, 0, out deSerializer.OutEndIndex);
            }
            /// <summary>
            /// 反序列化
            /// </summary>
            /// <param name="data">序列化数据</param>
            /// <param name="startIndex">起始位置</param>
            /// <param name="endIndex">结束位置</param>
            public bool DeSerialize(byte[] data, int startIndex, out int endIndex)
            {
                deSerializer deSerializer = new deSerializer(data);
                _o3 value = deSerializer.DeSerialize(this, startIndex);
                
                endIndex = deSerializer.EndIndex;
                return value != null && endIndex <= data.Length;
            }
            /// <summary>
            /// 反序列化
            /// </summary>
            /// <param name="parentDeSerializer">对象反序列化器</param>
            public unsafe void DeSerialize(fastCSharp.setup.cSharp.serialize.deSerializer parentDeSerializer)
            {
                deSerializer deSerializer = new deSerializer(parentDeSerializer);
                deSerializer.DeSerialize(this);
                
                parentDeSerializer.SetRead(deSerializer);
            }

            /// <summary>
            /// 成员位图
            /// </summary>
            public struct memberMap : fastCSharp.setup.cSharp.IMemberMap<memberMap>
            {
                /// <summary>
                /// 成员位图
                /// </summary>
                private uint map;
                /// <summary>
                /// 成员位图
                /// </summary>
                /// <param name="members">成员集合</param>
                public memberMap(params member[] members)
                {
                    map = 0;
                    foreach (member member in members) SetMember((int)member);
                }
                /// <summary>
                /// 成员位图
                /// </summary>
                /// <returns>成员位图</returns>
                public memberMap Copy()
                {
                    return new memberMap { map = map };
                }
                /// <summary>
                /// 是否默认全部成员有效
                /// </summary>
                public bool IsDefault
                {
                    get { return map == 0; }
                }
                /// <summary>
                /// 序列化字节长度
                /// </summary>
                public int SerializeSize
                {
                    get
                    {
                        return sizeof(uint);
                    }
                }
                /// <summary>
                /// 设置成员索引,忽略默认成员
                /// </summary>
                /// <param name="memberIndex">成员索引</param>
                public void SetMember(int memberIndex)
                {
                    map |= 1U << (int)memberIndex;
                }
                /// <summary>
                /// 清除成员索引,忽略默认成员
                /// </summary>
                /// <param name="memberIndex">成员索引</param>
                public void ClearMember(int memberIndex)
                {
                    map &= uint.MaxValue ^ (1U << (int)memberIndex);
                }
                /// <summary>
                /// 设置成员,忽略默认成员
                /// </summary>
                /// <param name="member">成员</param>
                public void SetMember(member member)
                {
                    SetMember((int)member);
                }
                /// <summary>
                /// 清除成员,忽略默认成员
                /// </summary>
                /// <param name="memberIndex">成员</param>
                public void ClearMember(member member)
                {
                    ClearMember((int)member);
                }
                /// <summary>
                /// 成员交集运算,忽略默认成员
                /// </summary>
                /// <param name="memberMap">成员位图</param>
                public void And(memberMap memberMap)
                {
                    map &= memberMap.map;
                }
                /// <summary>
                /// 成员异或运算,忽略默认成员
                /// </summary>
                /// <param name="memberMap">成员位图</param>
                public void Xor(memberMap memberMap)
                {
                    map ^= memberMap.map;
                }
                /// <summary>
                /// 成员并集运算,忽略默认成员
                /// </summary>
                /// <param name="memberMap">成员位图</param>
                public void Or(memberMap memberMap)
                {
                    map |= memberMap.map;
                }
                /// <summary>
                /// 判断成员索引是否有效
                /// </summary>
                /// <param name="memberIndex">成员索引</param>
                /// <returns>成员索引是否有效</returns>
                public bool IsMember(int memberIndex)
                {
                    return map == 0 || (map & (1 << memberIndex)) != 0;
                }
                /// <summary>
                /// 判断成员是否有效
                /// </summary>
                /// <param name="member">成员</param>
                /// <returns>成员是否有效</returns>
                public bool IsMember(member member)
                {
                    return IsMember((int)member);
                }
                /// <summary>
                /// 序列化
                /// </summary>
                /// <param name="stream">数据流</param>
                public void Serialize(memoryStream stream)
                {
                    stream.Write(map);
                }
                /// <summary>
                /// 序列化
                /// </summary>
                /// <param name="stream">数据流</param>
                public void Serialize(System.IO.Stream stream)
                {
                    stream.Write(BitConverter.GetBytes(map), 0, sizeof(uint));
                }
                /// <summary>
                /// 反序列化
                /// </summary>
                /// <param name="data">数据</param>
                /// <returns>结束位置</returns>
                public unsafe byte* DeSerialize(byte* data)
                {
                    map = *(uint*)data;
                    return data + sizeof(uint);
                }
                /// <summary>
                /// 成员获取器
                /// </summary>
                /// <returns>成员获取器</returns>
                public fastCSharp.setup.cSharp.IMemberInfo MemberInfo
                {
                    get { return new memberInfo(); }
                }
            }


            /// <summary>
            /// 成员
            /// </summary>
            public enum member
            {
                [fastCSharp.setup.cSharp.member(Type = typeof(fastCSharp.setup.tcpRegister.pollResult))]
                _Return_ = 0,
            }
            /// <summary>
            /// 成员信息获取器
            /// </summary>
            private struct memberInfo : fastCSharp.setup.cSharp.IMemberInfo
            {
                /// <summary>
                /// 获取成员名称
                /// </summary>
                /// <param name="memberIndex">成员索引</param>
                /// <returns>成员名称</returns>
                public string GetName(int memberIndex)
                {
                    return ((member)memberIndex).ToString();
                }
                /// <summary>
                /// 获取成员类型
                /// </summary>
                /// <param name="memberIndex">成员索引</param>
                /// <returns>成员类型</returns>
                public Type GetType(int memberIndex)
                {
                    return fastCSharp.Enum<member, fastCSharp.setup.cSharp.member>.Array(memberIndex).Type;
                }
                /// <summary>
                /// 所有成员数量
                /// </summary>
                public int MemberCount
                {
                    get
                    {
                        return 0 + 1;
                    }
                }
            }
            }
            private struct _a3
            {
                public tcpRegister Server;
                public socket Socket;
                public int Identity;
                public void Callback(fastCSharp.setup.cSharp.tcpBase.asynchronousReturn<fastCSharp.setup.tcpRegister.pollResult> returnValue)
                {
                    byte[] data = null;
                    if (returnValue.IsReturn)
                    {
                        try
                        {
                            data = (new _o3 { _Return_ = returnValue.Value }).Serialize();
                        }
                        catch (Exception error)
                        {
                            returnValue.IsReturn = false;
                            fastCSharp.log.Default.Add(error, null, true);
                        }
                    }
                    if (returnValue.IsReturn) Server.send(Socket, Server.receiveCommand, fastCSharp.net.tcpServer.status.Success, Identity, data);
                    else Server.send(Socket, socket.Close, fastCSharp.net.tcpServer.status.Error, Identity);
                }
            }
            private void _m3(socket _socket_, int _identity_)
            {
                bool _isAsync_ = false;
                try
                {
                    _i3 _inputParameter_ = new _i3();
                    (_inputParameter_).DeSerialize(_socket_.CurrentData);
                    _isAsync_ = true;
                    fastCSharp.setup.tcpRegister/**/.tcpServer.poll(_value_, _inputParameter_.client, new _a3 { Server = this, Socket = _socket_, Identity = _identity_ }.Callback);

                }
                catch (Exception error)
                {
                    fastCSharp.log.Default.Add(error, null, true);
                    if (!_isAsync_)
                    {
                        send(_socket_, socket.Close, fastCSharp.net.tcpServer.status.Error, _identity_);
                    }
                }
            }
            [fastCSharp.setup.cSharp.serialize(IsIgnore = true, IsObject = true, IsInterface = true)]
            internal class _i4 : fastCSharp.setup.cSharp.serialize.ISerialize
            {
                public fastCSharp.setup.tcpRegister.clientId client;
                public string serviceName;
            /// <summary>
            /// 序列化
            /// </summary>
            unsafe class serializer : fastCSharp.setup.cSharp.serialize.dataSerializer
            {
                /// <summary>
                /// 序列化
                /// </summary>
                /// <param name="stream">序列化流</param>
                /// <param name="memberMap">成员位图接口</param>
                public serializer(memoryStream stream, fastCSharp.setup.cSharp.IMemberMap memberMap) : base(stream, memberMap) { }
                /// <summary>
                /// 序列化
                /// </summary>
                /// <param name="parentSerializer">序列化</param>
                /// <param name="memberMap">成员位图接口</param>
                public serializer(fastCSharp.setup.cSharp.serialize.dataSerializer parentSerializer)
                    : base(parentSerializer, default(_i4/**/.memberMap)) { }
                /// <summary>
                /// 对象序列化
                /// </summary>
                /// <param name="value">对象</param>
                /// <param name="isPoint">是否记录历史指针</param>
                public void Serialize(_i4 value, bool isPoint)
                {
                    if (value != null)
                    {
                        if (isPoint) points[value] = dataStream.Length - streamStartIndex;
                        versionMemerMap(0);
                        serialize(value);
                    }
                    else dataStream.Write(fastCSharp.setup.cSharp.serialize.NullValue);
                }
                /// <summary>
                /// 对象序列化
                /// </summary>
                /// <param name="value">对象</param>
                private void serialize(_i4 value)
                {
                    memoryStream.unsafer unsafeStream = dataStream.Unsafer;
                    int length = memberMap.SerializeSize;
                    dataStream.PrepLength(length + 8);
                    fixed (byte* dataFixed = dataStream.Array)
                    {
                        write = dataFixed + dataStream.Length;
                        fixedMap nullMap = new fixedMap(write);
                        fastCSharp.unsafer.memory.Fill(write, (uint)0, length >> 2);
                        write += length;
                        if (memberMap.IsDefault)
                        {
                            if (value.serviceName == null) nullMap.Set(1);
                        }
                        else
                        {
                            if (memberMap.IsMember(0))
                            {
                            }
                            if (memberMap.IsMember(1))
                            {
                            if (value.serviceName == null) nullMap.Set(1);
                            }
                        }
                        unsafeStream.AddLength(((int)(write - dataFixed - dataStream.Length) + 3) & (int.MaxValue - 3));
                    }
                    if (memberMap.IsDefault)
                    {
                        iSerializeNotNull(value.client);
                        serializeString(value.serviceName);
                    }
                    else
                    {
                        if (memberMap.IsMember(0))
                        {
                        iSerializeNotNull(value.client);
                        }
                        if (memberMap.IsMember(1))
                        {
                        serializeString(value.serviceName);
                        }
                    }
                }
            }
            /// <summary>
            /// 对象序列化
            /// </summary>
            /// <returns>序列化数据</returns>
            public byte[] Serialize()
            {
                using (memoryStream stream = new memoryStream())
                {
                    Serialize(stream, default(_i4/**/.memberMap));
                    return stream.ToArray();
                }
            }
            /// <summary>
            /// 对象序列化
            /// </summary>
            /// <param name="stream">数据流</param>
            public void Serialize(memoryStream stream)
            {
                Serialize(stream, default(_i4/**/.memberMap));
            }
            /// <summary>
            /// 对象序列化
            /// </summary>
            /// <param name="stream">数据流</param>
            /// <param name="memberMap">成员位图接口</param>
            public void Serialize(memoryStream stream, _i4/**/.memberMap memberMap)
            {
                serializer serializer = new serializer(stream, memberMap);
                serializer.Serialize(this, true);
                serializer.Finally();
            }
            /// <summary>
            /// 对象序列化
            /// </summary>
            /// <param name="serializer">对象序列化器</param>
            public void Serialize(fastCSharp.setup.cSharp.serialize.dataSerializer parentSerializer)
            {
                new serializer(parentSerializer).Serialize(this, false);
            }
            /// <summary>
            /// 对象反序列化
            /// </summary>
            unsafe class deSerializer : fastCSharp.setup.cSharp.serialize.deSerializer
            {
                /// <summary>
                /// 成员位图接口
                /// </summary>
                public _i4/**/.memberMap MemberMap;
                /// <summary>
                /// 对象反序列化
                /// </summary>
                /// <param name="data">序列化数据</param>
                public deSerializer(byte[] data) : base(data) { }
                /// <summary>
                /// 对象反序列化
                /// </summary>
                /// <param name="parentDeSerializer">对象反序列化器</param>
                public deSerializer(fastCSharp.setup.cSharp.serialize.deSerializer parentDeSerializer)
                    : base(parentDeSerializer) { }
                /// <summary>
                /// 反序列化
                /// </summary>
                /// <param name="value">反序列化目标对象</param>
                /// <param name="startIndex">数据起始位置</param>
                /// <returns>数据对象</returns>
                public _i4 DeSerialize(_i4 value, int startIndex)
                {
                    fixed (byte* dataFixed = data)
                    {
                        this.dataFixed = dataFixed;
                        dataStart = read = dataFixed + startIndex;
                        dataVersion = *(int*)read;
                        if (dataVersion != (int)fastCSharp.setup.cSharp.serializeVersion.serialize)
                        {
                            fastCSharp.log.Default.Throw("序列化格式版本号不匹配 fastCSharp.setup.cSharp.serializeVersion.serialize[" + ((int)fastCSharp.setup.cSharp.serializeVersion.serialize).toString() + "] != " + dataVersion.toString(), true, false);
                        }
                        dataVersion = *(int*)(read += sizeof(int));
                        if (dataVersion != fastCSharp.setup.cSharp.serialize.NullValue)
                        {
                            versionMemberMap();
                            value = DeSerializeData(value);
                            checkEnd();
                            return value;
                        }
                    }
                    return default(_i4);
                }
                /// <summary>
                /// 版本号+成员位图接口
                /// </summary>
                protected override void versionMemberMap()
                {
                    if (dataVersion != 0)
                    {
                        fastCSharp.log.Default.Throw("序列化版本号错误 0 != " + dataVersion.toString(), true, false);
                    }
                    read = MemberMap.DeSerialize(read += sizeof(int));
                }
                /// <summary>
                /// 反序列化
                /// </summary>
                /// <param name="value">反序列化目标对象</param>
                /// <returns>数据对象</returns>
                public _i4 DeSerialize(_i4 value)
                {
                    dataVersion = *(int*)read;
                    versionMemberMap();
                    return DeSerializeData(value);
                }
                /// <summary>
                /// 反序列化
                /// </summary>
                /// <param name="value">反序列化目标对象</param>
                /// <returns>数据对象</returns>
                public _i4 DeSerializeData(_i4 value)
                {
                    fixedMap nullMap = new fixedMap(read);
                    read += MemberMap.SerializeSize;
                    if (MemberMap.IsDefault)
                    {
                        if (nullMap.Get(1)) value.serviceName = default(string);
                    }
                    else
                    {
                        if (MemberMap.IsMember(0))
                        {
                        }
                        if (MemberMap.IsMember(1))
                        {
                        if (nullMap.Get(1)) value.serviceName = default(string);
                        }
                    }
                    int length = (int)(read - nullMap.Map);
                    if ((length & 3) != 0) read += -length & 3;
                    if (MemberMap.IsDefault)
                    {
                        {
                            value.client = iSerializeNotNull<fastCSharp.setup.tcpRegister.clientId>();
                        }
                        if (!nullMap.Get(1))
                        {
                            value.serviceName = getString();
                        }
                    }
                    else
                    {
                        if (MemberMap.IsMember(0))
                        {
                        {
                            value.client = iSerializeNotNull<fastCSharp.setup.tcpRegister.clientId>();
                        }
                        }
                        if (MemberMap.IsMember(1))
                        {
                        if (!nullMap.Get(1))
                        {
                            value.serviceName = getString();
                        }
                        }
                    }
                    return value;
                }
            }
            /// <summary>
            /// 反序列化
            /// </summary>
            /// <param name="data">序列化数据</param>
            public bool DeSerialize(byte[] data)
            {
                return DeSerialize(data, 0, out deSerializer.OutEndIndex);
            }
            /// <summary>
            /// 反序列化
            /// </summary>
            /// <param name="data">序列化数据</param>
            /// <param name="startIndex">起始位置</param>
            /// <param name="endIndex">结束位置</param>
            public bool DeSerialize(byte[] data, int startIndex, out int endIndex)
            {
                deSerializer deSerializer = new deSerializer(data);
                _i4 value = deSerializer.DeSerialize(this, startIndex);
                
                endIndex = deSerializer.EndIndex;
                return value != null && endIndex <= data.Length;
            }
            /// <summary>
            /// 反序列化
            /// </summary>
            /// <param name="parentDeSerializer">对象反序列化器</param>
            public unsafe void DeSerialize(fastCSharp.setup.cSharp.serialize.deSerializer parentDeSerializer)
            {
                deSerializer deSerializer = new deSerializer(parentDeSerializer);
                deSerializer.DeSerialize(this);
                
                parentDeSerializer.SetRead(deSerializer);
            }

            /// <summary>
            /// 成员位图
            /// </summary>
            public struct memberMap : fastCSharp.setup.cSharp.IMemberMap<memberMap>
            {
                /// <summary>
                /// 成员位图
                /// </summary>
                private uint map;
                /// <summary>
                /// 成员位图
                /// </summary>
                /// <param name="members">成员集合</param>
                public memberMap(params member[] members)
                {
                    map = 0;
                    foreach (member member in members) SetMember((int)member);
                }
                /// <summary>
                /// 成员位图
                /// </summary>
                /// <returns>成员位图</returns>
                public memberMap Copy()
                {
                    return new memberMap { map = map };
                }
                /// <summary>
                /// 是否默认全部成员有效
                /// </summary>
                public bool IsDefault
                {
                    get { return map == 0; }
                }
                /// <summary>
                /// 序列化字节长度
                /// </summary>
                public int SerializeSize
                {
                    get
                    {
                        return sizeof(uint);
                    }
                }
                /// <summary>
                /// 设置成员索引,忽略默认成员
                /// </summary>
                /// <param name="memberIndex">成员索引</param>
                public void SetMember(int memberIndex)
                {
                    map |= 1U << (int)memberIndex;
                }
                /// <summary>
                /// 清除成员索引,忽略默认成员
                /// </summary>
                /// <param name="memberIndex">成员索引</param>
                public void ClearMember(int memberIndex)
                {
                    map &= uint.MaxValue ^ (1U << (int)memberIndex);
                }
                /// <summary>
                /// 设置成员,忽略默认成员
                /// </summary>
                /// <param name="member">成员</param>
                public void SetMember(member member)
                {
                    SetMember((int)member);
                }
                /// <summary>
                /// 清除成员,忽略默认成员
                /// </summary>
                /// <param name="memberIndex">成员</param>
                public void ClearMember(member member)
                {
                    ClearMember((int)member);
                }
                /// <summary>
                /// 成员交集运算,忽略默认成员
                /// </summary>
                /// <param name="memberMap">成员位图</param>
                public void And(memberMap memberMap)
                {
                    map &= memberMap.map;
                }
                /// <summary>
                /// 成员异或运算,忽略默认成员
                /// </summary>
                /// <param name="memberMap">成员位图</param>
                public void Xor(memberMap memberMap)
                {
                    map ^= memberMap.map;
                }
                /// <summary>
                /// 成员并集运算,忽略默认成员
                /// </summary>
                /// <param name="memberMap">成员位图</param>
                public void Or(memberMap memberMap)
                {
                    map |= memberMap.map;
                }
                /// <summary>
                /// 判断成员索引是否有效
                /// </summary>
                /// <param name="memberIndex">成员索引</param>
                /// <returns>成员索引是否有效</returns>
                public bool IsMember(int memberIndex)
                {
                    return map == 0 || (map & (1 << memberIndex)) != 0;
                }
                /// <summary>
                /// 判断成员是否有效
                /// </summary>
                /// <param name="member">成员</param>
                /// <returns>成员是否有效</returns>
                public bool IsMember(member member)
                {
                    return IsMember((int)member);
                }
                /// <summary>
                /// 序列化
                /// </summary>
                /// <param name="stream">数据流</param>
                public void Serialize(memoryStream stream)
                {
                    stream.Write(map);
                }
                /// <summary>
                /// 序列化
                /// </summary>
                /// <param name="stream">数据流</param>
                public void Serialize(System.IO.Stream stream)
                {
                    stream.Write(BitConverter.GetBytes(map), 0, sizeof(uint));
                }
                /// <summary>
                /// 反序列化
                /// </summary>
                /// <param name="data">数据</param>
                /// <returns>结束位置</returns>
                public unsafe byte* DeSerialize(byte* data)
                {
                    map = *(uint*)data;
                    return data + sizeof(uint);
                }
                /// <summary>
                /// 成员获取器
                /// </summary>
                /// <returns>成员获取器</returns>
                public fastCSharp.setup.cSharp.IMemberInfo MemberInfo
                {
                    get { return new memberInfo(); }
                }
            }


            /// <summary>
            /// 成员
            /// </summary>
            public enum member
            {
                [fastCSharp.setup.cSharp.member(Type = typeof(fastCSharp.setup.tcpRegister.clientId))]
                client = 0,
                [fastCSharp.setup.cSharp.member(Type = typeof(string))]
                serviceName = 1,
            }
            /// <summary>
            /// 成员信息获取器
            /// </summary>
            private struct memberInfo : fastCSharp.setup.cSharp.IMemberInfo
            {
                /// <summary>
                /// 获取成员名称
                /// </summary>
                /// <param name="memberIndex">成员索引</param>
                /// <returns>成员名称</returns>
                public string GetName(int memberIndex)
                {
                    return ((member)memberIndex).ToString();
                }
                /// <summary>
                /// 获取成员类型
                /// </summary>
                /// <param name="memberIndex">成员索引</param>
                /// <returns>成员类型</returns>
                public Type GetType(int memberIndex)
                {
                    return fastCSharp.Enum<member, fastCSharp.setup.cSharp.member>.Array(memberIndex).Type;
                }
                /// <summary>
                /// 所有成员数量
                /// </summary>
                public int MemberCount
                {
                    get
                    {
                        return 1 + 1;
                    }
                }
            }
            }
            private void _m4(socket _socket_, int _identity_)
            {
                bool _isError_ = false;
                try
                {

                    _i4 _inputParameter_ = new _i4();
                    (_inputParameter_).DeSerialize(_socket_.CurrentData);
                    
                    fastCSharp.setup.tcpRegister/**/.tcpServer.removeRegister(_value_, _inputParameter_.client, _inputParameter_.serviceName);
                }
                catch (Exception error)
                {
                    fastCSharp.log.Default.Add(error, null, true);
                    {
                        _isError_ = true;
                        send(_socket_, socket.Close, fastCSharp.net.tcpServer.status.Error, _identity_);
                    }
                }
                if (!_isError_)
                {
                    send(_socket_, receiveCommand, fastCSharp.net.tcpServer.status.Success, _identity_);
                }
            }
            [fastCSharp.setup.cSharp.serialize(IsIgnore = true, IsObject = true, IsInterface = true)]
            internal class _i5 : fastCSharp.setup.cSharp.serialize.ISerialize
            {
                public fastCSharp.setup.tcpRegister.clientId client;
            /// <summary>
            /// 序列化
            /// </summary>
            unsafe class serializer : fastCSharp.setup.cSharp.serialize.dataSerializer
            {
                /// <summary>
                /// 序列化
                /// </summary>
                /// <param name="stream">序列化流</param>
                /// <param name="memberMap">成员位图接口</param>
                public serializer(memoryStream stream, fastCSharp.setup.cSharp.IMemberMap memberMap) : base(stream, memberMap) { }
                /// <summary>
                /// 序列化
                /// </summary>
                /// <param name="parentSerializer">序列化</param>
                /// <param name="memberMap">成员位图接口</param>
                public serializer(fastCSharp.setup.cSharp.serialize.dataSerializer parentSerializer)
                    : base(parentSerializer, default(_i5/**/.memberMap)) { }
                /// <summary>
                /// 对象序列化
                /// </summary>
                /// <param name="value">对象</param>
                /// <param name="isPoint">是否记录历史指针</param>
                public void Serialize(_i5 value, bool isPoint)
                {
                    if (value != null)
                    {
                        if (isPoint) points[value] = dataStream.Length - streamStartIndex;
                        versionMemerMap(0);
                        serialize(value);
                    }
                    else dataStream.Write(fastCSharp.setup.cSharp.serialize.NullValue);
                }
                /// <summary>
                /// 对象序列化
                /// </summary>
                /// <param name="value">对象</param>
                private void serialize(_i5 value)
                {
                    memoryStream.unsafer unsafeStream = dataStream.Unsafer;
                    int length = memberMap.SerializeSize;
                    dataStream.PrepLength(length + 4);
                    fixed (byte* dataFixed = dataStream.Array)
                    {
                        write = dataFixed + dataStream.Length;
                        fixedMap nullMap = new fixedMap(write);
                        fastCSharp.unsafer.memory.Fill(write, (uint)0, length >> 2);
                        write += length;
                        if (memberMap.IsDefault)
                        {
                        }
                        else
                        {
                            if (memberMap.IsMember(0))
                            {
                            }
                        }
                        unsafeStream.AddLength(((int)(write - dataFixed - dataStream.Length) + 3) & (int.MaxValue - 3));
                    }
                    if (memberMap.IsDefault)
                    {
                        iSerializeNotNull(value.client);
                    }
                    else
                    {
                        if (memberMap.IsMember(0))
                        {
                        iSerializeNotNull(value.client);
                        }
                    }
                }
            }
            /// <summary>
            /// 对象序列化
            /// </summary>
            /// <returns>序列化数据</returns>
            public byte[] Serialize()
            {
                using (memoryStream stream = new memoryStream())
                {
                    Serialize(stream, default(_i5/**/.memberMap));
                    return stream.ToArray();
                }
            }
            /// <summary>
            /// 对象序列化
            /// </summary>
            /// <param name="stream">数据流</param>
            public void Serialize(memoryStream stream)
            {
                Serialize(stream, default(_i5/**/.memberMap));
            }
            /// <summary>
            /// 对象序列化
            /// </summary>
            /// <param name="stream">数据流</param>
            /// <param name="memberMap">成员位图接口</param>
            public void Serialize(memoryStream stream, _i5/**/.memberMap memberMap)
            {
                serializer serializer = new serializer(stream, memberMap);
                serializer.Serialize(this, true);
                serializer.Finally();
            }
            /// <summary>
            /// 对象序列化
            /// </summary>
            /// <param name="serializer">对象序列化器</param>
            public void Serialize(fastCSharp.setup.cSharp.serialize.dataSerializer parentSerializer)
            {
                new serializer(parentSerializer).Serialize(this, false);
            }
            /// <summary>
            /// 对象反序列化
            /// </summary>
            unsafe class deSerializer : fastCSharp.setup.cSharp.serialize.deSerializer
            {
                /// <summary>
                /// 成员位图接口
                /// </summary>
                public _i5/**/.memberMap MemberMap;
                /// <summary>
                /// 对象反序列化
                /// </summary>
                /// <param name="data">序列化数据</param>
                public deSerializer(byte[] data) : base(data) { }
                /// <summary>
                /// 对象反序列化
                /// </summary>
                /// <param name="parentDeSerializer">对象反序列化器</param>
                public deSerializer(fastCSharp.setup.cSharp.serialize.deSerializer parentDeSerializer)
                    : base(parentDeSerializer) { }
                /// <summary>
                /// 反序列化
                /// </summary>
                /// <param name="value">反序列化目标对象</param>
                /// <param name="startIndex">数据起始位置</param>
                /// <returns>数据对象</returns>
                public _i5 DeSerialize(_i5 value, int startIndex)
                {
                    fixed (byte* dataFixed = data)
                    {
                        this.dataFixed = dataFixed;
                        dataStart = read = dataFixed + startIndex;
                        dataVersion = *(int*)read;
                        if (dataVersion != (int)fastCSharp.setup.cSharp.serializeVersion.serialize)
                        {
                            fastCSharp.log.Default.Throw("序列化格式版本号不匹配 fastCSharp.setup.cSharp.serializeVersion.serialize[" + ((int)fastCSharp.setup.cSharp.serializeVersion.serialize).toString() + "] != " + dataVersion.toString(), true, false);
                        }
                        dataVersion = *(int*)(read += sizeof(int));
                        if (dataVersion != fastCSharp.setup.cSharp.serialize.NullValue)
                        {
                            versionMemberMap();
                            value = DeSerializeData(value);
                            checkEnd();
                            return value;
                        }
                    }
                    return default(_i5);
                }
                /// <summary>
                /// 版本号+成员位图接口
                /// </summary>
                protected override void versionMemberMap()
                {
                    if (dataVersion != 0)
                    {
                        fastCSharp.log.Default.Throw("序列化版本号错误 0 != " + dataVersion.toString(), true, false);
                    }
                    read = MemberMap.DeSerialize(read += sizeof(int));
                }
                /// <summary>
                /// 反序列化
                /// </summary>
                /// <param name="value">反序列化目标对象</param>
                /// <returns>数据对象</returns>
                public _i5 DeSerialize(_i5 value)
                {
                    dataVersion = *(int*)read;
                    versionMemberMap();
                    return DeSerializeData(value);
                }
                /// <summary>
                /// 反序列化
                /// </summary>
                /// <param name="value">反序列化目标对象</param>
                /// <returns>数据对象</returns>
                public _i5 DeSerializeData(_i5 value)
                {
                    fixedMap nullMap = new fixedMap(read);
                    read += MemberMap.SerializeSize;
                    if (MemberMap.IsDefault)
                    {
                    }
                    else
                    {
                        if (MemberMap.IsMember(0))
                        {
                        }
                    }
                    int length = (int)(read - nullMap.Map);
                    if ((length & 3) != 0) read += -length & 3;
                    if (MemberMap.IsDefault)
                    {
                        {
                            value.client = iSerializeNotNull<fastCSharp.setup.tcpRegister.clientId>();
                        }
                    }
                    else
                    {
                        if (MemberMap.IsMember(0))
                        {
                        {
                            value.client = iSerializeNotNull<fastCSharp.setup.tcpRegister.clientId>();
                        }
                        }
                    }
                    return value;
                }
            }
            /// <summary>
            /// 反序列化
            /// </summary>
            /// <param name="data">序列化数据</param>
            public bool DeSerialize(byte[] data)
            {
                return DeSerialize(data, 0, out deSerializer.OutEndIndex);
            }
            /// <summary>
            /// 反序列化
            /// </summary>
            /// <param name="data">序列化数据</param>
            /// <param name="startIndex">起始位置</param>
            /// <param name="endIndex">结束位置</param>
            public bool DeSerialize(byte[] data, int startIndex, out int endIndex)
            {
                deSerializer deSerializer = new deSerializer(data);
                _i5 value = deSerializer.DeSerialize(this, startIndex);
                
                endIndex = deSerializer.EndIndex;
                return value != null && endIndex <= data.Length;
            }
            /// <summary>
            /// 反序列化
            /// </summary>
            /// <param name="parentDeSerializer">对象反序列化器</param>
            public unsafe void DeSerialize(fastCSharp.setup.cSharp.serialize.deSerializer parentDeSerializer)
            {
                deSerializer deSerializer = new deSerializer(parentDeSerializer);
                deSerializer.DeSerialize(this);
                
                parentDeSerializer.SetRead(deSerializer);
            }

            /// <summary>
            /// 成员位图
            /// </summary>
            public struct memberMap : fastCSharp.setup.cSharp.IMemberMap<memberMap>
            {
                /// <summary>
                /// 成员位图
                /// </summary>
                private uint map;
                /// <summary>
                /// 成员位图
                /// </summary>
                /// <param name="members">成员集合</param>
                public memberMap(params member[] members)
                {
                    map = 0;
                    foreach (member member in members) SetMember((int)member);
                }
                /// <summary>
                /// 成员位图
                /// </summary>
                /// <returns>成员位图</returns>
                public memberMap Copy()
                {
                    return new memberMap { map = map };
                }
                /// <summary>
                /// 是否默认全部成员有效
                /// </summary>
                public bool IsDefault
                {
                    get { return map == 0; }
                }
                /// <summary>
                /// 序列化字节长度
                /// </summary>
                public int SerializeSize
                {
                    get
                    {
                        return sizeof(uint);
                    }
                }
                /// <summary>
                /// 设置成员索引,忽略默认成员
                /// </summary>
                /// <param name="memberIndex">成员索引</param>
                public void SetMember(int memberIndex)
                {
                    map |= 1U << (int)memberIndex;
                }
                /// <summary>
                /// 清除成员索引,忽略默认成员
                /// </summary>
                /// <param name="memberIndex">成员索引</param>
                public void ClearMember(int memberIndex)
                {
                    map &= uint.MaxValue ^ (1U << (int)memberIndex);
                }
                /// <summary>
                /// 设置成员,忽略默认成员
                /// </summary>
                /// <param name="member">成员</param>
                public void SetMember(member member)
                {
                    SetMember((int)member);
                }
                /// <summary>
                /// 清除成员,忽略默认成员
                /// </summary>
                /// <param name="memberIndex">成员</param>
                public void ClearMember(member member)
                {
                    ClearMember((int)member);
                }
                /// <summary>
                /// 成员交集运算,忽略默认成员
                /// </summary>
                /// <param name="memberMap">成员位图</param>
                public void And(memberMap memberMap)
                {
                    map &= memberMap.map;
                }
                /// <summary>
                /// 成员异或运算,忽略默认成员
                /// </summary>
                /// <param name="memberMap">成员位图</param>
                public void Xor(memberMap memberMap)
                {
                    map ^= memberMap.map;
                }
                /// <summary>
                /// 成员并集运算,忽略默认成员
                /// </summary>
                /// <param name="memberMap">成员位图</param>
                public void Or(memberMap memberMap)
                {
                    map |= memberMap.map;
                }
                /// <summary>
                /// 判断成员索引是否有效
                /// </summary>
                /// <param name="memberIndex">成员索引</param>
                /// <returns>成员索引是否有效</returns>
                public bool IsMember(int memberIndex)
                {
                    return map == 0 || (map & (1 << memberIndex)) != 0;
                }
                /// <summary>
                /// 判断成员是否有效
                /// </summary>
                /// <param name="member">成员</param>
                /// <returns>成员是否有效</returns>
                public bool IsMember(member member)
                {
                    return IsMember((int)member);
                }
                /// <summary>
                /// 序列化
                /// </summary>
                /// <param name="stream">数据流</param>
                public void Serialize(memoryStream stream)
                {
                    stream.Write(map);
                }
                /// <summary>
                /// 序列化
                /// </summary>
                /// <param name="stream">数据流</param>
                public void Serialize(System.IO.Stream stream)
                {
                    stream.Write(BitConverter.GetBytes(map), 0, sizeof(uint));
                }
                /// <summary>
                /// 反序列化
                /// </summary>
                /// <param name="data">数据</param>
                /// <returns>结束位置</returns>
                public unsafe byte* DeSerialize(byte* data)
                {
                    map = *(uint*)data;
                    return data + sizeof(uint);
                }
                /// <summary>
                /// 成员获取器
                /// </summary>
                /// <returns>成员获取器</returns>
                public fastCSharp.setup.cSharp.IMemberInfo MemberInfo
                {
                    get { return new memberInfo(); }
                }
            }


            /// <summary>
            /// 成员
            /// </summary>
            public enum member
            {
                [fastCSharp.setup.cSharp.member(Type = typeof(fastCSharp.setup.tcpRegister.clientId))]
                client = 0,
            }
            /// <summary>
            /// 成员信息获取器
            /// </summary>
            private struct memberInfo : fastCSharp.setup.cSharp.IMemberInfo
            {
                /// <summary>
                /// 获取成员名称
                /// </summary>
                /// <param name="memberIndex">成员索引</param>
                /// <returns>成员名称</returns>
                public string GetName(int memberIndex)
                {
                    return ((member)memberIndex).ToString();
                }
                /// <summary>
                /// 获取成员类型
                /// </summary>
                /// <param name="memberIndex">成员索引</param>
                /// <returns>成员类型</returns>
                public Type GetType(int memberIndex)
                {
                    return fastCSharp.Enum<member, fastCSharp.setup.cSharp.member>.Array(memberIndex).Type;
                }
                /// <summary>
                /// 所有成员数量
                /// </summary>
                public int MemberCount
                {
                    get
                    {
                        return 0 + 1;
                    }
                }
            }
            }
            private void _m5(socket _socket_, int _identity_)
            {
                bool _isError_ = false;
                try
                {

                    _i5 _inputParameter_ = new _i5();
                    (_inputParameter_).DeSerialize(_socket_.CurrentData);
                    
                    fastCSharp.setup.tcpRegister/**/.tcpServer.removeRegister(_value_, _inputParameter_.client);
                }
                catch (Exception error)
                {
                    fastCSharp.log.Default.Add(error, null, true);
                    {
                        _isError_ = true;
                        send(_socket_, socket.Close, fastCSharp.net.tcpServer.status.Error, _identity_);
                    }
                }
                if (!_isError_)
                {
                    send(_socket_, receiveCommand, fastCSharp.net.tcpServer.status.Success, _identity_);
                }
            }
        }
}
namespace fastCSharp.tcpClient
{

        public class tcpRegister: IDisposable
        {
            /// <summary>
            /// TCP调用客户端
            /// </summary>
            private fastCSharp.net.tcpClient _tcpClient_;
            /// <summary>
            /// TCP调用客户端是否已启动
            /// </summary>
            public bool _IsClientStart_
            {
                get
                {
                    return _tcpClient_ != null && _tcpClient_.IsStart;
                }
            }
            /// <summary>
            /// TCP调用客户端
            /// </summary>
            /// <param name="attribute">TCP调用服务器端配置信息</param>
            /// <param name="verify">TCP验证实例</param>
            /// <param name="isStart">是否启动连接</param>
            public tcpRegister(fastCSharp.setup.cSharp.tcpServer attribute = null, fastCSharp.setup.cSharp.tcpBase.ITcpVerifyClient verify = null, bool isStart = true)
            {
                _tcpClient_ = new fastCSharp.net.tcpClient(attribute ?? fastCSharp.setup.cSharp.tcpServer.GetConfig("tcpRegister", typeof(fastCSharp.setup.tcpRegister)), verify ?? new fastCSharp.setup.tcpRegister.verify(), isStart);
            }
            /// <summary>
            /// 释放资源
            /// </summary>
            public void Dispose()
            {
                if (_tcpClient_ != null)
                {
                    _tcpClient_.Dispose();
                    _tcpClient_ = null;
                }
            }


            private static readonly byte[] _c0 = fastCSharp.setup.cSharp.tcpBase.GetMethodKeyNameCommand("()register");
            public fastCSharp.setup.tcpRegister.clientId register()
            {
                
                fastCSharp.tcpServer/**/.tcpRegister/**/._o0 _outputParameter_ = new fastCSharp.tcpServer/**/.tcpRegister/**/._o0();
                if (_tcpClient_.Get<fastCSharp.tcpServer/**/.tcpRegister/**/._o0>(_c0, _outputParameter_))
                {
                    return _outputParameter_._Return_;
                }
                throw new Exception();
            }
            private static readonly byte[] _c1 = fastCSharp.setup.cSharp.tcpBase.GetMethodKeyNameCommand("(out int)getServices");
            public fastCSharp.setup.tcpRegister.services[] getServices(out int version)
            {
                
                fastCSharp.tcpServer/**/.tcpRegister/**/._i1 _inputParameter_ = new fastCSharp.tcpServer/**/.tcpRegister/**/._i1
                {
                };
                
                fastCSharp.tcpServer/**/.tcpRegister/**/._o1 _outputParameter_ = new fastCSharp.tcpServer/**/.tcpRegister/**/._o1();
                if (_tcpClient_.Get<fastCSharp.tcpServer/**/.tcpRegister/**/._i1, fastCSharp.tcpServer/**/.tcpRegister/**/._o1>(_c1, _inputParameter_, _outputParameter_))
                {
                    version = _outputParameter_.version;
                    return _outputParameter_._Return_;
                }
                throw new Exception();
            }
            private static readonly byte[] _c2 = fastCSharp.setup.cSharp.tcpBase.GetMethodKeyNameCommand("(fastCSharp.setup.tcpRegister.clientId,fastCSharp.setup.tcpRegister.service)register");
            public fastCSharp.setup.tcpRegister.registerResult register(fastCSharp.setup.tcpRegister.clientId client, fastCSharp.setup.tcpRegister.service service)
            {
                
                fastCSharp.tcpServer/**/.tcpRegister/**/._i2 _inputParameter_ = new fastCSharp.tcpServer/**/.tcpRegister/**/._i2
                {
                    client = client,
                    service = service,
                };
                
                fastCSharp.tcpServer/**/.tcpRegister/**/._o2 _outputParameter_ = new fastCSharp.tcpServer/**/.tcpRegister/**/._o2();
                if (_tcpClient_.Get<fastCSharp.tcpServer/**/.tcpRegister/**/._i2, fastCSharp.tcpServer/**/.tcpRegister/**/._o2>(_c2, _inputParameter_, _outputParameter_))
                {
                    return _outputParameter_._Return_;
                }
                throw new Exception();
            }
            private static readonly byte[] _c3 = fastCSharp.setup.cSharp.tcpBase.GetMethodKeyNameCommand("(fastCSharp.setup.tcpRegister.clientId,fastCSharp.action<fastCSharp.setup.cSharp.tcpBase.asynchronousReturn<fastCSharp.setup.tcpRegister.pollResult>>)poll");
            public void poll(action<fastCSharp.setup.cSharp.tcpBase.asynchronousReturn<fastCSharp.setup.tcpRegister.pollResult>> _onReturn_, fastCSharp.setup.tcpRegister.clientId client)
            {
                bool _isCall_ = false;
                try
                {
                    fastCSharp.net.tcpClient _client_ = _tcpClient_;
                    if (_client_ != null)
                    {
                        
                        fastCSharp.tcpServer/**/.tcpRegister/**/._i3 _inputParameter_ = new fastCSharp.tcpServer/**/.tcpRegister/**/._i3
                        {
                            client = client,
                        };
                        
                        fastCSharp.tcpServer/**/.tcpRegister/**/._o3 _outputParameter_ = new fastCSharp.tcpServer/**/.tcpRegister/**/._o3();
                        _isCall_ = true;
                        _client_.Get<fastCSharp.tcpServer/**/.tcpRegister/**/._i3, fastCSharp.tcpServer/**/.tcpRegister/**/._o3>(new fastCSharp.setup.cSharp.tcpBase.asyncReturn<fastCSharp.setup.tcpRegister.pollResult, fastCSharp.tcpServer/**/.tcpRegister/**/._o3> { OnReturn = _onReturn_ }.CallOnReturn, _c3, _inputParameter_, _outputParameter_);
                    }
                }
                catch (Exception _error_)
                {
                    fastCSharp.log.Default.Add(_error_, null, false);
                }
                finally
                {
                    if (!_isCall_) _onReturn_(new fastCSharp.setup.cSharp.tcpBase.asynchronousReturn<fastCSharp.setup.tcpRegister.pollResult>{ IsReturn = false });
                }
            }
            private static readonly byte[] _c4 = fastCSharp.setup.cSharp.tcpBase.GetMethodKeyNameCommand("(fastCSharp.setup.tcpRegister.clientId,string)removeRegister");
            public void removeRegister(fastCSharp.setup.tcpRegister.clientId client, string serviceName)
            {
                
                fastCSharp.tcpServer/**/.tcpRegister/**/._i4 _inputParameter_ = new fastCSharp.tcpServer/**/.tcpRegister/**/._i4
                {
                    client = client,
                    serviceName = serviceName,
                };
                if (_tcpClient_.Call<fastCSharp.tcpServer/**/.tcpRegister/**/._i4>(_c4, _inputParameter_)) return;
                throw new Exception();
            }
            private static readonly byte[] _c5 = fastCSharp.setup.cSharp.tcpBase.GetMethodKeyNameCommand("(fastCSharp.setup.tcpRegister.clientId)removeRegister");
            public void removeRegister(fastCSharp.setup.tcpRegister.clientId client)
            {
                
                fastCSharp.tcpServer/**/.tcpRegister/**/._i5 _inputParameter_ = new fastCSharp.tcpServer/**/.tcpRegister/**/._i5
                {
                    client = client,
                };
                if (_tcpClient_.Call<fastCSharp.tcpServer/**/.tcpRegister/**/._i5>(_c5, _inputParameter_)) return;
                throw new Exception();
            }
        }
}